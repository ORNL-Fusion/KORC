var tipuesearch = {"pages":[{"title":" KORC-Full Orbit ","text":"KORC-Full Orbit Hi, my name is Matt Beidler. This is documentation for the Kinetic Orbit Runaway electrons Code\n(KORC), developed at Oak Ridge National Laboratory and written\nprimarily by Leopoldo Carbajal. Mark Cianciosa, Diego\ndel-Castillo-Negrete and I are currently the primary developers. The\npresent version of the code follows relativistic electrons in general\nelectric and magnetic fields under the full Lorentz force, collisions,\nand radiation losses. The present version of the code is compiled and executed on the KNL\nnodes of the Cori supercomputer at NERSC. Note This documentation is presently under development. Please check\nback regularly for updates. Todo Future plans for development More physically realistic initial distribution function Implement a guiding-center approximation Port to multiple computing platforms Porting to GPU architectures Coupling with extended-MHD codes to self-consistently evolve \nEM fields and RE distribution functions Developer Info Matt Beidler R&D Associate at ORNL","tags":"home","loc":"index.html"},{"title":"special_fun_subroutines.f90 – KORC-Full Orbit","text":"Contents Functions chebev_s chebev_v Subroutines beschb_s beschb_v Source Code special_fun_subroutines.f90 Source Code FUNCTION chebev_s ( a , b , c , x ) USE nrtype ; USE nrutil , ONLY : nrerror IMPLICIT NONE REAL ( SP ), INTENT ( IN ) :: a , b , x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ) :: chebev_s INTEGER ( I4B ) :: j , m REAL ( SP ) :: d , dd , sv , y , y2 if (( x - a ) * ( x - b ) > 0.0 ) call nrerror ( 'x not in range in chebev_s' ) m = size ( c ) d = 0.0 dd = 0.0 y = ( 2.0_sp * x - a - b ) / ( b - a ) y2 = 2.0_sp * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev_s = y * d - dd + 0.5_sp * c ( 1 ) END FUNCTION chebev_s FUNCTION chebev_v ( a , b , c , x ) USE nrtype ; USE nrutil , ONLY : nrerror IMPLICIT NONE REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c , x REAL ( SP ), DIMENSION ( size ( x )) :: chebev_v INTEGER ( I4B ) :: j , m REAL ( SP ), DIMENSION ( size ( x )) :: d , dd , sv , y , y2 if ( any (( x - a ) * ( x - b ) > 0.0 )) call nrerror ( 'x not in range in chebev_v' ) m = size ( c ) d = 0.0 dd = 0.0 y = ( 2.0_sp * x - a - b ) / ( b - a ) y2 = 2.0_sp * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev_v = y * d - dd + 0.5_sp * c ( 1 ) END FUNCTION chebev_v SUBROUTINE beschb_s ( x , gam1 , gam2 , gampl , gammi ) USE nrtype USE nr , ONLY : chebev IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: x REAL ( DP ), INTENT ( OUT ) :: gam1 , gam2 , gampl , gammi INTEGER ( I4B ), PARAMETER :: NUSE1 = 5 , NUSE2 = 5 REAL ( SP ) :: xx REAL ( SP ), DIMENSION ( 7 ) :: c1 = ( /- 1.142022680371168_sp ,& 6.5165112670737e-3_sp , 3.087090173086e-4_sp , - 3.4706269649e-6_sp ,& 6.9437664e-9_sp , 3.67795e-11_sp , - 1.356e-13_sp / ) REAL ( SP ), DIMENSION ( 8 ) :: c2 = ( / 1.843740587300905_sp ,& - 7.68528408447867e-2_sp , 1.2719271366546e-3_sp ,& - 4.9717367042e-6_sp , - 3.31261198e-8_sp , 2.423096e-10_sp ,& - 1.702e-13_sp , - 1.49e-15_sp / ) xx = 8.0_dp * x * x - 1.0_dp gam1 = chebev ( - 1.0_sp , 1.0_sp , c1 ( 1 : NUSE1 ), xx ) gam2 = chebev ( - 1.0_sp , 1.0_sp , c2 ( 1 : NUSE2 ), xx ) gampl = gam2 - x * gam1 gammi = gam2 + x * gam1 END SUBROUTINE beschb_s SUBROUTINE beschb_v ( x , gam1 , gam2 , gampl , gammi ) USE nrtype USE nr , ONLY : chebev IMPLICIT NONE REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: gam1 , gam2 , gampl , gammi INTEGER ( I4B ), PARAMETER :: NUSE1 = 5 , NUSE2 = 5 REAL ( SP ), DIMENSION ( size ( x )) :: xx REAL ( SP ), DIMENSION ( 7 ) :: c1 = ( /- 1.142022680371168_sp ,& 6.5165112670737e-3_sp , 3.087090173086e-4_sp , - 3.4706269649e-6_sp ,& 6.9437664e-9_sp , 3.67795e-11_sp , - 1.356e-13_sp / ) REAL ( SP ), DIMENSION ( 8 ) :: c2 = ( / 1.843740587300905_sp ,& - 7.68528408447867e-2_sp , 1.2719271366546e-3_sp ,& - 4.9717367042e-6_sp , - 3.31261198e-8_sp , 2.423096e-10_sp ,& - 1.702e-13_sp , - 1.49e-15_sp / ) xx = 8.0_dp * x * x - 1.0_dp gam1 = chebev ( - 1.0_sp , 1.0_sp , c1 ( 1 : NUSE1 ), xx ) gam2 = chebev ( - 1.0_sp , 1.0_sp , c2 ( 1 : NUSE2 ), xx ) gampl = gam2 - x * gam1 gammi = gam2 + x * gam1 END SUBROUTINE beschb_v","tags":"","loc":"sourcefile/special_fun_subroutines.f90.html"},{"title":"korc_HDF5.f90 – KORC-Full Orbit","text":"Note KORC module containing subroutines to read and write data in HDF5\n files. This module contains interfaces to use the HDF5 library in a more friendly\n way. This module is intended to help developers to create new I/O\n subroutines without having to deal with the sometimes cumbersome details\n of the HDF5 API. Contents Modules korc_HDF5 Source Code korc_HDF5.f90 Source Code !! @note KORC module containing subroutines to read and write data in HDF5 !! files. @endnote !! This module contains interfaces to use the HDF5 library in a more friendly !! way. This module is intended to help developers to create new I/O !! subroutines without having to deal with the sometimes cumbersome details !! of the HDF5 API. module korc_HDF5 use korc_hpc use korc_types use korc_constants use HDF5 IMPLICIT NONE INTEGER ( HID_T ), PRIVATE :: KORC_HDF5_REAL !! HDF5 real precision data type to be used in the simulation. INTEGER ( SIZE_T ), PRIVATE :: rp_hdf5 !! Size of the HDF5 real precision data type used in the simulation. INTERFACE load_from_hdf5 !! @note Fortran interface to subroutines loading a real or integer !! value from HDF5 files. @endnote module procedure iload_from_hdf5 , rload_from_hdf5 END INTERFACE load_from_hdf5 INTERFACE load_array_from_hdf5 !! @note Fortran interface to subroutines loading 2-D and 3-D arrays !! of real values from HDF5 files. module procedure rload_1d_array_from_hdf5 , rload_3d_array_from_hdf5 , rload_2d_array_from_hdf5 END INTERFACE load_array_from_hdf5 INTERFACE save_to_hdf5 !! @note Fortran interface to subroutines saving real or integer !! values to HDF5 files. module procedure i1save_to_hdf5 , i2save_to_hdf5 , i4save_to_hdf5 , i8save_to_hdf5 , rsave_to_hdf5 END INTERFACE save_to_hdf5 !! @note Fortran interface to subroutines saving real and integer !! values to HDF5 files. INTERFACE save_1d_array_to_hdf5 module procedure isave_1d_array_to_hdf5 , rsave_1d_array_to_hdf5 END INTERFACE save_1d_array_to_hdf5 !! @note Fortran interface to subroutines saving 2-D arrays of real values to HDF5 files. !! @todo To code the corresponding subroutines for saving integer 2-D arrays. INTERFACE save_2d_array_to_hdf5 module procedure rsave_2d_array_to_hdf5 END INTERFACE save_2d_array_to_hdf5 !! @note Fortran interface to subroutines saving 3-D arrays of real values to HDF5 files. !! @todo To include the corresponding subroutines for saving arrays of integers. INTERFACE save_3d_array_to_hdf5 module procedure rsave_3d_array_to_hdf5 END INTERFACE save_3d_array_to_hdf5 !! @note Fortran interface to subroutines saving 1-D, 2-D or 3-D arrays of real values to HDF5 files. !! @todo To include the corresponding subroutines for saving arrays of integers. INTERFACE save_array_to_hdf5 module procedure isave_1d_array_to_hdf5 , rsave_1d_array_to_hdf5 , rsave_2d_array_to_hdf5 , rsave_3d_array_to_hdf5 END INTERFACE save_array_to_hdf5 PRIVATE :: rsave_to_hdf5 ,& isave_1d_array_to_hdf5 ,& rsave_1d_array_to_hdf5 ,& rsave_2d_array_to_hdf5 ,& iload_from_hdf5 ,& rload_from_hdf5 ,& rload_1d_array_from_hdf5 ,& rload_3d_array_from_hdf5 ,& rload_2d_array_from_hdf5 ,& i1save_to_hdf5 ,& i2save_to_hdf5 ,& i4save_to_hdf5 ,& i8save_to_hdf5 PUBLIC :: initialize_HDF5 ,& finalize_HDF5 ,& save_simulation_parameters ,& save_to_hdf5 ,& save_1d_array_to_hdf5 ,& save_2d_array_to_hdf5 ,& load_from_hdf5 ,& load_array_from_hdf5 ,& save_string_parameter ,& load_time_stepping_params ,& load_prev_time ,& load_prev_iter ,& save_restart_variables ,& load_particles_ic CONTAINS !! @note Initialization of HDF5 library. !! !! @param h5error HDF5 error status. subroutine initialize_HDF5 () INTEGER :: h5error ! Error flag call h5open_f ( h5error ) #ifdef HDF5_DOUBLE_PRESICION call h5tcopy_f ( H5T_NATIVE_DOUBLE , KORC_HDF5_REAL , h5error ) #elif HDF5_SINGLE_PRESICION call h5tcopy_f ( H5T_NATIVE_REAL , KORC_HDF5_REAL , h5error ) #endif call h5tget_size_f ( KORC_HDF5_REAL , rp_hdf5 , h5error ) end subroutine initialize_HDF5 !! @note Finalization of HDF5 library. !! !! @param h5error HDF5 error status. subroutine finalize_HDF5 () INTEGER :: h5error ! Error flag call h5close_f ( h5error ) end subroutine finalize_HDF5 !! @note Subroutine to load an integer datum from an HDF5 file. !! !! @todo Implement the reading of the attribute of idatum. !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[out] idatum Integer datum read from HDF5 file. !! @param[out] attr Attribute of datum read from HDF5 file. !! @param aname Name of idatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param h5error HDF5 error status. subroutine iload_from_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER , INTENT ( OUT ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( OUT ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: h5error ! * * * Read datum from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: iload_from_hdf5 & --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_INTEGER , idatum , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: iload_from_hdf5 & --> h5dread_f\")' ) end if call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: iload_from_hdf5 & --> h5dclose_f\")' ) end if if ( PRESENT ( attr )) then ! * * * Read attribute from file * * * ! * * * Read attribute from file * * * end if ! * * * Read datum from file * * * end subroutine iload_from_hdf5 !! @note Subroutine to load a real datum from an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[out] rdatum Real datum read from HDF5 file and casted to !! KORC's real precision type. !! @param[out] attr Attribute of datum read from HDF5 file. !! @param raw_datum Datum read from HDF5 file. !! @param aname Name of rdatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param h5error HDF5 error status. !! @todo Implement the reading of the attribute of rdatum. subroutine rload_from_hdf5 ( h5file_id , dset , rdatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), INTENT ( OUT ) :: rdatum REAL :: raw_datum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( OUT ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: h5error ! * * * Read datum from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 & --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_datum , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 & --> h5dread_f\")' ) end if rdatum = REAL ( raw_datum , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 & --> h5dclose_f\")' ) end if if ( PRESENT ( attr )) then ! * * * Read attribute from file * * * ! * * * Read attribute from file * * * end if ! * * * Read datum from file * * * end subroutine rload_from_hdf5 !! @note Subroutine to load a 1-D array of reals from an HDF5 file. !! @details The dimension of the 1-D array rdata is determined by the !! input-output array rdata. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[out] rdata 1-D array of real values read from HDF5 file and !! casted to KORC's real precision type. !! @param[out] attr 1-D array of attributes of rdata. !! @param raw_data 1-D array read from HDF5 file. !! @param aname Name of rdata attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param h5error HDF5 error status. !! @todo Implement the reading of the attributes of rdata. subroutine rload_1d_array_from_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: rdata REAL , DIMENSION (:), ALLOCATABLE :: raw_data CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: attr CHARACTER ( MAX_STRING_LENGTH ) :: aname INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims INTEGER :: h5error dims = ( / shape ( rdata ) / ) ALLOCATE ( raw_data ( dims ( 1 )) ) ! * * * Read data from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_data , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dread_f\")' ) end if rdata = REAL ( raw_data , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dclose_f\")' ) end if DEALLOCATE ( raw_data ) if ( PRESENT ( attr )) then ! * * * Read data attribute(s) from file * * * end if ! * * * Read data from file * * * end subroutine rload_1d_array_from_hdf5 !! @note Subroutine to load a 2-D array of reals from an HDF5 file. !! @details The dimensions of the 2-D array rdata is determined by the input-output array rdata. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[out] rdata 2-D array of real values read from HDF5 file and casted to KORC's real precision type. !! @param[out] attr 2-D array of attributes of rdata. !! @param raw_data 2-D array read from HDF5 file. !! @param aname Name of rdata attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param h5error HDF5 error status. !! @todo Implement the reading of the attributes of rdata. subroutine rload_2d_array_from_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: rdata REAL , DIMENSION (:,:), ALLOCATABLE :: raw_data CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( MAX_STRING_LENGTH ) :: aname INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 2 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 2 ) :: adims INTEGER :: h5error dims = shape ( rdata ) ALLOCATE ( raw_data ( dims ( 1 ), dims ( 2 )) ) ! * * * Read data from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_data , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dread_f\")' ) end if rdata = REAL ( raw_data , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dclose_f\")' ) end if DEALLOCATE ( raw_data ) if ( PRESENT ( attr )) then ! * * * Read data attribute(s) from file * * * end if ! * * * Read data from file * * * end subroutine rload_2d_array_from_hdf5 !! @note Subroutine to load a 3-D array of reals from an HDF5 file. !! @details The dimensions of the 3-D array rdata is determined by the input-output array rdata. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[out] rdata 3-D array of real values read from HDF5 file and casted to KORC's real precision type. !! @param[out] attr 3-D array of attributes of rdata. !! @param raw_data 3-D array read from HDF5 file. !! @param aname Name of rdata attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param h5error HDF5 error status. !! @todo Implement the reading of the attributes of rdata. subroutine rload_3d_array_from_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE , INTENT ( INOUT ) :: rdata REAL , DIMENSION (:,:,:), ALLOCATABLE :: raw_data CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( MAX_STRING_LENGTH ) :: aname INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 3 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 3 ) :: adims INTEGER :: h5error dims = shape ( rdata ) ALLOCATE ( raw_data ( dims ( 1 ), dims ( 2 ), dims ( 3 )) ) ! * * * Read data from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_data , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dread_f\")' ) end if rdata = REAL ( raw_data , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dclose_f\")' ) end if DEALLOCATE ( raw_data ) if ( PRESENT ( attr )) then ! * * * Read data attribute(s) from file * * * end if ! * * * Read data from file * * * end subroutine rload_3d_array_from_hdf5 !! @note Subroutine to write a 1 byte (8 bits) integer to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[in] idatum Integer datum read from HDF5 file. !! @param[in] attr Attribute of datum read from HDF5 file. !! @param aname Name of idatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param rank Number of dimensions of idatum's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of idatum attribute's name. !! @param h5error HDF5 error status. subroutine i1save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 1 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , INT ( idatum , idef ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i1save_to_hdf5 !! @note Subroutine to write a 2 byte (16 bits) integer to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[in] idatum Integer datum read from HDF5 file. !! @param[in] attr Attribute of datum read from HDF5 file. !! @param aname Name of idatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param rank Number of dimensions of idatum's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of idatum attribute's name. !! @param h5error HDF5 error status. subroutine i2save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 2 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , INT ( idatum , idef ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i2save_to_hdf5 !! @note Subroutine to write a 4 byte (32 bits) integer to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[in] idatum Integer datum read from HDF5 file. !! @param[in] attr Attribute of datum read from HDF5 file. !! @param aname Name of idatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param rank Number of dimensions of idatum's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of idatum attribute's name. !! @param h5error HDF5 error status. subroutine i4save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 4 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , INT ( idatum , idef ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i4save_to_hdf5 !! @note Subroutine to write a 8 byte (64 bits) integer to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[in] idatum Integer datum read from HDF5 file. !! @param[in] attr Attribute of datum read from HDF5 file. !! @param aname Name of idatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data read from HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param rank Number of dimensions of idatum's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of idatum attribute's name. !! @param h5error HDF5 error status. subroutine i8save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 8 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_DOUBLE , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_DOUBLE , REAL ( idatum , 8 ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i8save_to_hdf5 !! @note Subroutine to write a 1-D array of integer values to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[in] idata Data written to HDF5 file. !! @param[in] attr Attributes of data written to HDF5 file. !! @param aname Name of idata attributes. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 data space identifier. !! @param aspace_id HDF5 data's attribute space identifier. !! @param attr_id HDF5 data's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data writen to HDF5 file. !! @param adims Dimensions of data's attributes written to HDF5 file. !! @param rank Number of dimensions of idata's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of idata attribute's name. !! @param h5error HDF5 error status. !! @param rr Rank iterator. !! @param dd Dimension iterator. !! @bug When using a 1-D array of attributes, only the first attribute is saved. subroutine isave_1d_array_to_hdf5 ( h5file_id , dset , idata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER , DIMENSION (:), INTENT ( IN ) :: idata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: attrlen INTEGER ( SIZE_T ) :: tmplen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( idata )) ALLOCATE ( dims ( rank )) dims = shape ( idata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , idata , dims , h5error ) if ( PRESENT ( attr )) then arank = size ( shape ( attr )) ALLOCATE ( adims ( arank )) adims = shape ( attr ) ! * * * Write attribute of data to file * * * tmplen = 0 attrlen = 0 do rr = 1_idef , arank do dd = 1_idef , adims ( rr ) tmplen = LEN_TRIM ( attr ( dd )) if ( tmplen . GT . attrlen ) then attrlen = tmplen end if end do end do call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * DEALLOCATE ( adims ) end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine isave_1d_array_to_hdf5 !! @note Subroutine to write a real to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the datum. !! @param[in] rdatum Real datum written to HDF5 file. !! @param[in] attr Attribute of datum written to HDF5 file. !! @param aname Name of rdatum attribute. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 datum space identifier. !! @param aspace_id HDF5 datum's attribute space identifier. !! @param attr_id HDF5 datum's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data written to HDF5 file. !! @param adims Dimensions of data's attributes read from HDF5 file. !! @param rank Number of dimensions of rdatum's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of rdatum attribute's name. !! @param h5error HDF5 error status. subroutine rsave_to_hdf5 ( h5file_id , dset , rdatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), INTENT ( IN ) :: rdatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdatum , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdatum , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine rsave_to_hdf5 !! @note Subroutine to write a 1-D array of real values to an HDF5 file. !! !! @bug When using a 1-D array of attributes, only the first attribute is saved. !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[in] rdata Data written to HDF5 file. !! @param[in] attr Attributes of data written to HDF5 file. !! @param aname Name of rdata attributes. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 data space identifier. !! @param aspace_id HDF5 data's attribute space identifier. !! @param attr_id HDF5 data's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data writen to HDF5 file. !! @param adims Dimensions of data's attributes written to HDF5 file. !! @param rank Number of dimensions of rdata's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param tmplen Temporary length of rdata attribute's name. !! @param attrlen Lenght of rdata attribute's name. !! @param h5error HDF5 error status. !! @param rr Rank iterator. !! @param dd Dimension iterator. subroutine rsave_1d_array_to_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:), INTENT ( IN ) :: rdata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: tmplen INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( rdata )) ALLOCATE ( dims ( rank )) dims = shape ( rdata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdata , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdata , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then arank = size ( shape ( attr )) ALLOCATE ( adims ( arank )) adims = shape ( attr ) ! * * * Write attribute of data to file * * * tmplen = 0 attrlen = 0 do rr = 1_idef , arank do dd = 1_idef , adims ( rr ) tmplen = LEN_TRIM ( attr ( dd )) if ( tmplen . GT . attrlen ) then attrlen = tmplen end if end do end do call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * DEALLOCATE ( adims ) end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine rsave_1d_array_to_hdf5 !! @note Subroutine to write a 2-D array of real values to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[in] rdata Data written to HDF5 file. !! @param[in] attr Attributes of data written to HDF5 file. !! @param aname Name of rdata attributes. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 data space identifier. !! @param aspace_id HDF5 data's attribute space identifier. !! @param attr_id HDF5 data's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data writen to HDF5 file. !! @param adims Dimensions of data's attributes written to HDF5 file. !! @param rank Number of dimensions of rdata's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of rdata attribute's name. !! @param h5error HDF5 error status. !! @param rr Rank iterator. !! @param dd Dimension iterator. !! @todo Implement the writting of attributes to HDF5 file. subroutine rsave_2d_array_to_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:), INTENT ( IN ) :: rdata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( rdata )) ALLOCATE ( dims ( rank )) dims = shape ( rdata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdata , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdata , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine rsave_2d_array_to_hdf5 !! @note Subroutine to write a 3-D array of real values to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the data. !! @param[in] rdata Data written to HDF5 file. !! @param[in] attr Attributes of data written to HDF5 file. !! @param aname Name of rdata attributes. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 data space identifier. !! @param aspace_id HDF5 data's attribute space identifier. !! @param attr_id HDF5 data's attribute identifier. !! @param atype_id Native HDF5 attribute type. !! @param dims Dimensions of data writen to HDF5 file. !! @param adims Dimensions of data's attributes written to HDF5 file. !! @param rank Number of dimensions of rdata's dataspace. !! @param arank Number of dimensions of attr's dataspace. !! @param attrlen Lenght of rdata attribute's name. !! @param h5error HDF5 error status. !! @param rr Rank iterator. !! @param dd Dimension iterator. !! @todo Implement the writting of attributes to HDF5 file. subroutine rsave_3d_array_to_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:,:), INTENT ( IN ) :: rdata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( rdata )) ALLOCATE ( dims ( rank )) dims = shape ( rdata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdata , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdata , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine rsave_3d_array_to_hdf5 !! @note Subroutine to write an array of strings to an HDF5 file. !! !! @param[in] h5file_id HDF5 file identifier. !! @param[in] dset String containing the name of the array of strings. !! @param[in] string_array Array of characters containing the strings to be written to HDF5 file. !! @param dset_id HDF5 data set identifier. !! @param dspace_id HDF5 data space identifier. !! @param dims Number of strings to be written to file. !! @param data_dims Dimensions of data written to HDF5 file. This is equal to (Maximum length of KORC string)x(Number of strings). !! @param str_len Size of strings to be written to file without blank spaces. !! @param string_type Native HDF5 string type. !! @param h5error HDF5 error status. subroutine save_string_parameter ( h5file_id , dset , string_array ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), INTENT ( IN ) :: string_array INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 2 ) :: data_dims INTEGER ( SIZE_T ), DIMENSION (:), ALLOCATABLE :: str_len INTEGER ( HID_T ) :: string_type INTEGER :: h5error ALLOCATE ( str_len ( SIZE ( string_array ))) dims = ( / SIZE ( string_array ) / ) data_dims = ( / MAX_STRING_LENGTH , SIZE ( string_array ) / ) str_len = ( / LEN_TRIM ( string_array ) / ) call h5tcopy_f ( H5T_STRING , string_type , h5error ) call h5tset_strpad_f ( string_type , H5T_STR_SPACEPAD_F , h5error ) call h5screate_simple_f ( 1 , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), string_type , dspace_id , dset_id , h5error ) call h5dwrite_vl_f ( dset_id , string_type , string_array , data_dims , str_len , h5error , dspace_id ) call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) DEALLOCATE ( str_len ) end subroutine save_string_parameter subroutine save_simulation_parameters ( params , spp , F , P ) !! @note Subroutine to save to a HDF5 file all the relevant simulation !! parameters. @endnote !! This subroutine saves to the HDF5 file \"<a>simulation_parameters.h5</a>\" !! all the relevant simulation parameters of KORC, most of them being part !! of the input file, but also including some derived quantities from the !! input parameters. This file is intended to facilitate the !! post-processing of KORC data using any software that supports !! the HDF5 software. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !!Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. See [[korc_types]] !! and [[korc_fields]]. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !!  HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims !! Dimensions of data saved to HDF5 file. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rdata !! 1-D array of real data to be saved to HDF5 file. INTEGER , DIMENSION (:), ALLOCATABLE :: idata !! 1-D array of integer data to be saved to HDF5 file. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array !! An 1-D array with attributes of 1-D real or integer arrays that are !! passed to KORC interfaces of HDF5 I/O subroutines. CHARACTER ( MAX_STRING_LENGTH ) :: attr !!  A single attributes of real or integer data that is passed to KORC !! interfaces of HDF5 I/O subroutines. INTEGER :: h5error !! HDF5 error status. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. REAL ( rp ) :: units !! Temporary variable used to add physical units to KORC parameters. ! * * * Error handling * * * ! call h5eset_auto_f ( params % HDF5_error_handling , h5error ) ! Turn off: 0_idef. Turn on: 1_idef if (. NOT .( params % restart )) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Saving simulations parameters\")' ) end if if ( SIZE ( params % outputs_list ). GT . 1_idef ) then write ( tmp_str , '(I18)' ) params % mpi_params % rank filename = TRIM ( params % path_to_outputs ) // \"file_\" & // TRIM ( ADJUSTL ( tmp_str )) // \".h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simulation_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) ! Simulation parameters group gname = \"simulation\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( 1 )) ALLOCATE ( idata ( 1 )) dset = TRIM ( gname ) // \"/field_model\" call save_string_parameter ( h5file_id , dset ,( / params % field_model / )) dset = TRIM ( gname ) // \"/profile_model\" call save_string_parameter ( h5file_id , dset ,( / params % profile_model / )) dset = TRIM ( gname ) // \"/simulation_time\" attr = \"Total aimed simulation time in seconds\" call save_to_hdf5 ( h5file_id , dset , params % simulation_time * & params % cpp % time , attr ) dset = TRIM ( gname ) // \"/snapshot_frequency\" attr = \"Time between snapshots in seconds\" call save_to_hdf5 ( h5file_id , dset , params % snapshot_frequency * & params % cpp % time , attr ) dset = TRIM ( gname ) // \"/dt\" attr = \"Time step in secs\" call save_to_hdf5 ( h5file_id , dset , params % dt * params % cpp % time , attr ) dset = TRIM ( gname ) // \"/t_steps\" attr_array ( 1 ) = \"Number of time steps\" idata = params % t_steps call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/num_omp_threads\" attr = \"Number of omp threads\" call save_to_hdf5 ( h5file_id , dset , params % num_omp_threads , attr ) dset = TRIM ( gname ) // \"/output_cadence\" attr_array ( 1 ) = \"Cadence of output files\" idata = params % output_cadence call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/HDF5_error_handling\" attr_array ( 1 ) = \"Error handling option: 0=OFF, 1=ON\" idata = params % HDF5_error_handling call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/restart_output_cadence\" attr_array ( 1 ) = \"Cadence of output files\" idata = params % restart_output_cadence call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/num_snapshots\" attr_array ( 1 ) = \"Number of outputs for each variable\" idata = params % num_snapshots call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/num_species\" attr = \"Number of particle species\" call save_to_hdf5 ( h5file_id , dset , params % num_species , attr ) dset = TRIM ( gname ) // \"/nmpi\" attr = \"Number of mpi processes\" call save_to_hdf5 ( h5file_id , dset , params % mpi_params % nmpi , attr ) dset = TRIM ( gname ) // \"/minimum_particle_energy\" attr = \"Minimum energy of simulated particles in eV\" call save_to_hdf5 ( h5file_id , dset , params % minimum_particle_energy * & params % cpp % energy / C_E , attr ) dset = TRIM ( gname ) // \"/minimum_particle_g\" attr = \"Minimum relativistic factor gamma of simulated particles\" call save_to_hdf5 ( h5file_id , dset , params % minimum_particle_g , attr ) dset = TRIM ( gname ) // \"/radiation\" attr = \"Radiation losses included in simulation\" if ( params % radiation ) then call save_to_hdf5 ( h5file_id , dset , 1_idef , attr ) else call save_to_hdf5 ( h5file_id , dset , 0_idef , attr ) end if dset = TRIM ( gname ) // \"/collisions\" attr = \"Collisions included in simulation\" if ( params % collisions ) then call save_to_hdf5 ( h5file_id , dset , 1_idef , attr ) else call save_to_hdf5 ( h5file_id , dset , 0_idef , attr ) end if dset = TRIM ( gname ) // \"/outputs_list\" call save_string_parameter ( h5file_id , dset , params % outputs_list ) dset = TRIM ( gname ) // \"/orbit_model\" call save_string_parameter ( h5file_id , dset ,( / params % orbit_model / )) dset = TRIM ( gname ) // \"/field_eval\" call save_string_parameter ( h5file_id , dset ,( / params % field_eval / )) DEALLOCATE ( idata ) DEALLOCATE ( attr_array ) call h5gclose_f ( group_id , h5error ) ! Plasma species group gname = \"species\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( params % num_species )) dset = TRIM ( gname ) // \"/spatial_distribution\" call save_string_parameter ( h5file_id , dset , spp % spatial_distribution ) dset = TRIM ( gname ) // \"/energy_distribution\" call save_string_parameter ( h5file_id , dset , spp % energy_distribution ) dset = TRIM ( gname ) // \"/pitch_distribution\" call save_string_parameter ( h5file_id , dset , spp % pitch_distribution ) dset = TRIM ( gname ) // \"/ppp\" attr_array ( 1 ) = \"Particles per (mpi) process\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % ppp , attr_array ) dset = TRIM ( gname ) // \"/q\" attr_array ( 1 ) = \"Electric charge\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % q * & params % cpp % charge , attr_array ) dset = TRIM ( gname ) // \"/m\" attr_array ( 1 ) = \"Species mass in kg\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % m * & params % cpp % mass , attr_array ) dset = TRIM ( gname ) // \"/Eo\" attr_array ( 1 ) = \"Initial (average) energy in eV\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % Eo * & params % cpp % energy / C_E , attr_array ) dset = TRIM ( gname ) // \"/go\" attr_array ( 1 ) = \"Initial relativistic g factor.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % go , attr_array ) dset = TRIM ( gname ) // \"/etao\" attr_array ( 1 ) = \"Initial pitch angle in degrees\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % etao , attr_array ) dset = TRIM ( gname ) // \"/wc\" attr_array ( 1 ) = \"Average relativistic cyclotron frequency in Hz\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % wc_r / & params % cpp % time , attr_array ) dset = TRIM ( gname ) // \"/Ro\" attr_array ( 1 ) = \"Initial radial position of population\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % Ro * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/PHIo\" attr_array ( 1 ) = \"Azimuthal angle in degrees.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % PHIo * & 18 0.0_rp / C_PI , attr_array ) dset = TRIM ( gname ) // \"/Zo\" attr_array ( 1 ) = \"Initial Z position of population\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % Zo * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ri\" attr_array ( 1 ) = \"Inner radius of initial spatial distribution\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % r_inner * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ro\" attr_array ( 1 ) = \"Outter radius of initial spatial distribution\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % r_outter * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/falloff_rate\" attr_array ( 1 ) = \"Falloff of gaussian or exponential radial & profile in m\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % falloff_rate / & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/shear_factor\" attr_array ( 1 ) = \"Shear factor (in case ELLIPTIC-TORUS  & spatial distribution is used.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % shear_factor , & attr_array ) dset = TRIM ( gname ) // \"/sigmaR\" attr_array ( 1 ) = \"Variance of first dimension of 2D spatial & distribution.\" call save_1d_array_to_hdf5 ( h5file_id , dset , & spp % sigmaR * params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/sigmaZ\" attr_array ( 1 ) = \"Variance of second dimension of 2D spatial & distribution.\" call save_1d_array_to_hdf5 ( h5file_id , dset , & spp % sigmaZ * params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/theta_gauss\" attr_array ( 1 ) = \"Angle of rotation of 2D spatial distribution.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % theta_gauss , attr_array ) dset = TRIM ( gname ) // \"/psi_max\" attr_array ( 1 ) = \"Indicator function level of the argument of & the 2D gaussian exponential.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % psi_max , attr_array ) dset = TRIM ( gname ) // \"/dth\" attr_array ( 1 ) = \"Variance of sampling normal variate for pitch angle.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dth , attr_array ) dset = TRIM ( gname ) // \"/dgam\" attr_array ( 1 ) = \"Variance of sampling normal variate for gamma.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dgam , attr_array ) dset = TRIM ( gname ) // \"/dR\" attr_array ( 1 ) = \"Variance of sampling normal variate for R.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dR * params % cpp % length , & attr_array ) dset = TRIM ( gname ) // \"/dZ\" attr_array ( 1 ) = \"Variance of sampling normal variate for Z.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dZ * params % cpp % length , & attr_array ) call h5gclose_f ( group_id , h5error ) DEALLOCATE ( attr_array ) ! Plasma profiles group !          if (params%collisions) then gname = \"profiles\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/density_profile\" call save_string_parameter ( h5file_id , dset ,( / P % ne_profile / )) dset = TRIM ( gname ) // \"/temperature_profile\" call save_string_parameter ( h5file_id , dset ,( / P % Te_profile / )) dset = TRIM ( gname ) // \"/Zeff_profile\" call save_string_parameter ( h5file_id , dset ,( / P % Zeff_profile / )) dset = TRIM ( gname ) // \"/neo\" attr = \"Density at the magnetic axis (m&#94;-3)\" call save_to_hdf5 ( h5file_id , dset , P % neo * params % cpp % density , attr ) dset = TRIM ( gname ) // \"/Teo\" attr = \"Temperature at the magnetic axis (eV)\" call save_to_hdf5 ( h5file_id , dset , P % Teo * & params % cpp % temperature / C_E , attr ) dset = TRIM ( gname ) // \"/Zeffo\" attr = \"Zeff at the magnetic axis\" call save_to_hdf5 ( h5file_id , dset , P % Zeffo , attr ) if ( TRIM ( params % profile_model ) . EQ . 'ANALYTICAL' ) then dset = TRIM ( gname ) // \"/n_ne\" attr = \"Exponent of tanh(x)&#94;n for density profile\" call save_to_hdf5 ( h5file_id , dset , P % n_ne , attr ) dset = TRIM ( gname ) // \"/a_ne\" attr = \"Coefficients f=ao+a1*r+a2*r&#94;2+a3*r&#94;3.  & a_ne=[a0,a1,a2,a3]\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % a_ne ) dset = TRIM ( gname ) // \"/n_Te\" attr = \"Exponent of tanh(x)&#94;n for density profile\" call save_to_hdf5 ( h5file_id , dset , P % n_Te , attr ) dset = TRIM ( gname ) // \"/a_Te\" attr = \"Coefficients f=ao+a1*r+a2*r&#94;2+a3*r&#94;3.  & a_Te=[a0,a1,a2,a3]\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % a_Te ) dset = TRIM ( gname ) // \"/n_Zeff\" attr = \"Exponent of tanh(x)&#94;n for Zeff profile\" call save_to_hdf5 ( h5file_id , dset , P % n_Zeff , attr ) dset = TRIM ( gname ) // \"/a_Zeff\" attr = \"Coefficients f=ao+a1*r+a2*r&#94;2+a3*r&#94;3.  & a_Zeff=[a0,a1,a2,a3]\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % a_Zeff ) if ( params % field_eval . EQ . 'interp' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the profile (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Radial position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % R * params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % PHI , attr_array ) end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Z position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % Z * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ne\" units = params % cpp % density call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % ne_2D ) dset = TRIM ( gname ) // \"/Te\" units = params % cpp % temperature call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % Te_2D ) dset = TRIM ( gname ) // \"/Zeff\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & P % Zeff_2D ) DEALLOCATE ( attr_array ) end if else if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the profiles (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Grid nodes of profiles along the & radial position\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % X % R * & params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Grid nodes of profiles along the & azimuthal position\" call save_1d_array_to_hdf5 ( h5file_id , dset , & P % X % PHI , attr_array ) end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Grid nodes of profiles along the Z position\" call save_1d_array_to_hdf5 ( h5file_id , dset , & P % X % Z * params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ne\" units = params % cpp % density call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % ne_2D ) dset = TRIM ( gname ) // \"/Te\" units = params % cpp % temperature call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % Te_2D ) dset = TRIM ( gname ) // \"/Zeff\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & P % Zeff_2D ) DEALLOCATE ( attr_array ) else if ( params % profile_model . EQ . 'UNIFORM' ) then ! Something end if call h5gclose_f ( group_id , h5error ) !end if ! Electromagnetic fields group gname = \"fields\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) if ( TRIM ( params % field_model ( 1 : 10 )) . EQ . 'ANALYTICAL' ) then dset = TRIM ( gname ) // \"/Bo\" attr = \"Toroidal field at the magnetic axis in T\" call save_to_hdf5 ( h5file_id , dset , F % Bo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/current_direction\" call save_string_parameter ( h5file_id , dset , & ( / F % AB % current_direction / )) dset = TRIM ( gname ) // \"/a\" attr = \"Minor radius in m\" call save_to_hdf5 ( h5file_id , dset , F % AB % a * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Ro\" attr = \"Magnetic axis radial position\" call save_to_hdf5 ( h5file_id , dset , F % Ro * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Zo\" attr = \"Magnetic axis vertical position\" call save_to_hdf5 ( h5file_id , dset , F % Zo * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/qa\" attr = \"Safety factor at minor radius\" call save_to_hdf5 ( h5file_id , dset , F % AB % qa , attr ) dset = TRIM ( gname ) // \"/qo\" attr = \"Safety factor at the magnetic axis\" call save_to_hdf5 ( h5file_id , dset , F % AB % qo , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Parameter lamda in m\" call save_to_hdf5 ( h5file_id , dset , F % AB % lambda * & params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Bpo\" attr = \"Poloidal magnetic field in T\" call save_to_hdf5 ( h5file_id , dset , F % AB % Bpo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/Eo\" attr = \"Electric field at the magnetic axis in V/m\" call save_to_hdf5 ( h5file_id , dset , F % Eo * params % cpp % Eo , attr ) if ( params % SC_E ) then dset = TRIM ( gname ) // \"/dt_E_SC\" attr = \"Time step for self-consistent E calculation\" call save_to_hdf5 ( h5file_id , dset , F % dt_E_SC , attr ) dset = TRIM ( gname ) // \"/Ip_exp\" attr = \"Scaling for self-consistent current density\" call save_to_hdf5 ( h5file_id , dset , F % Ip_exp , attr ) dset = TRIM ( gname ) // \"/Ip0\" attr = \"Total RE current normalization\" call save_to_hdf5 ( h5file_id , dset , F % Ip0 , attr ) ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/r_1D\" attr_array ( 1 ) = \"1D minor radial mesh for & self-consistent fields\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % r_1D , attr_array ) DEALLOCATE ( attr_array ) end if if ( params % field_eval . EQ . 'interp' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the magnetic  & field (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Radial position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % R * params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % PHI , attr_array ) end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Z position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % Z * & params % cpp % length , attr_array ) if ( ALLOCATED ( F % PSIp )) then dset = TRIM ( gname ) // \"/psi_p\" units = params % cpp % Bo * params % cpp % length ** 2 call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % PSIp ) end if if ( params % field_model ( 12 : 13 ). eq . '2D' ) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % Z ) if ( ALLOCATED ( F % FLAG2D )) then dset = TRIM ( gname ) // \"/Flag\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & F % FLAG2D ) end if if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % Z ) end if else if ( params % field_model ( 12 : 13 ). eq . '3D' ) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % Z ) if ( ALLOCATED ( F % FLAG3D )) then dset = TRIM ( gname ) // \"/Flag\" call rsave_3d_array_to_hdf5 ( h5file_id , dset , & F % FLAG3D ) end if if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % Z ) end if end if DEALLOCATE ( attr_array ) end if else if ( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the magnetic  & field (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Radial position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % R * params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then if ( F % Dim2x1t ) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % PHI * params % cpp % time , attr_array ) else dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % PHI , attr_array ) end if end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Z position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % Z * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Toroidal field at the magnetic axis in T\" call save_to_hdf5 ( h5file_id , dset , F % Bo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/Eo\" attr = \"Electric field at the magnetic axis in V/m\" call save_to_hdf5 ( h5file_id , dset , F % Eo * params % cpp % Eo , attr ) dset = TRIM ( gname ) // \"/E_dyn\" attr = \"Magnitude of dynamic E\" call save_to_hdf5 ( h5file_id , dset , F % E_dyn * params % cpp % Eo , attr ) dset = TRIM ( gname ) // \"/E_pulse\" attr = \"Magnitude of dynamic E\" call save_to_hdf5 ( h5file_id , dset , F % E_pulse * params % cpp % time , attr ) dset = TRIM ( gname ) // \"/E_width\" attr = \"Magnitude of dynamic E\" call save_to_hdf5 ( h5file_id , dset , F % E_width * params % cpp % time , attr ) dset = TRIM ( gname ) // \"/Ro\" attr = \"Radial position of magnetic axis\" call save_to_hdf5 ( h5file_id , dset , F % Ro * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Zo\" attr = \"Radial position of magnetic axis\" call save_to_hdf5 ( h5file_id , dset , F % Zo * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Axisymmetric\" attr = \"Radial position of magnetic axis\" if ( F % axisymmetric_fields ) then call save_to_hdf5 ( h5file_id , dset , 1_idef , attr ) else call save_to_hdf5 ( h5file_id , dset , 0_idef , attr ) end if if ( ALLOCATED ( F % PSIp )) then dset = TRIM ( gname ) // \"/psi_p\" units = params % cpp % Bo * params % cpp % length ** 2 call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % PSIp ) end if if ( ALLOCATED ( F % E_3D % R )) then dset = TRIM ( gname ) // \"/ER3D\" units = params % cpp % Eo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % E_3D % R ) end if if ( ALLOCATED ( F % E_3D % PHI )) then dset = TRIM ( gname ) // \"/EPHI3D\" units = params % cpp % Eo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % E_3D % PHI ) end if if ( ALLOCATED ( F % PSIp3D )) then dset = TRIM ( gname ) // \"/psi_p3D\" units = params % cpp % Bo * params % cpp % length ** 2 call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % PSIp3D ) end if if ( ALLOCATED ( F % FLAG2D )) then dset = TRIM ( gname ) // \"/Flag2D\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & F % FLAG2D ) end if if ( ALLOCATED ( F % FLAG3D )) then dset = TRIM ( gname ) // \"/Flag3D\" call rsave_3d_array_to_hdf5 ( h5file_id , dset , & F % FLAG3D ) end if if ( params % SC_E ) then dset = TRIM ( gname ) // \"/dt_E_SC\" attr = \"Time step for self-consistent E calculation\" call save_to_hdf5 ( h5file_id , dset , F % dt_E_SC , attr ) dset = TRIM ( gname ) // \"/Ip_exp\" attr = \"Scaling for self-consistent current density\" call save_to_hdf5 ( h5file_id , dset , F % Ip_exp , attr ) dset = TRIM ( gname ) // \"/Ip0\" attr = \"Total RE current normalization\" call save_to_hdf5 ( h5file_id , dset , F % Ip0 , attr ) dset = TRIM ( gname ) // \"/PSIP_1D\" attr_array ( 1 ) = \"1D minor radial mesh for & self-consistent fields\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % PSIP_1D , attr_array ) end if if ( F % axisymmetric_fields . and . & . not .( params % field_model ( 10 : 12 ). eq . 'PSI' )) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % Z ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % Z ) end if else if ((. not . F % axisymmetric_fields ). and . & . not .( params % field_model ( 10 : 12 ). eq . 'PSI' )) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % Z ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % Z ) end if end if DEALLOCATE ( attr_array ) else if ( params % field_model . EQ . 'UNIFORM' ) then dset = TRIM ( gname ) // \"/Bo\" attr = \"Magnetic field in T\" call save_to_hdf5 ( h5file_id , dset , F % Bo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/Eo\" attr = \"Electric field in V/m\" call save_to_hdf5 ( h5file_id , dset , F % Eo * params % cpp % Eo , attr ) end if call h5gclose_f ( group_id , h5error ) ! Characteristic scales gname = \"scales\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/t\" attr = \"Characteristic time in secs\" call save_to_hdf5 ( h5file_id , dset , params % cpp % time , attr ) dset = TRIM ( gname ) // \"/m\" attr = \"Characteristic mass in kg\" call save_to_hdf5 ( h5file_id , dset , params % cpp % mass , attr ) dset = TRIM ( gname ) // \"/q\" attr = \"Characteristic charge in Coulombs\" call save_to_hdf5 ( h5file_id , dset , params % cpp % charge , attr ) dset = TRIM ( gname ) // \"/l\" attr = \"Characteristic length in m\" call save_to_hdf5 ( h5file_id , dset , params % cpp % length , attr ) dset = TRIM ( gname ) // \"/v\" attr = \"Characteristic velocity in m\" call save_to_hdf5 ( h5file_id , dset , params % cpp % velocity , attr ) dset = TRIM ( gname ) // \"/K\" attr = \"Characteristic kinetic energy in J\" call save_to_hdf5 ( h5file_id , dset , params % cpp % energy , attr ) dset = TRIM ( gname ) // \"/n\" attr = \"Characteristic plasma density in m&#94;-3\" call save_to_hdf5 ( h5file_id , dset , params % cpp % density , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Characteristic electric field in V/m\" call save_to_hdf5 ( h5file_id , dset , params % cpp % Eo , attr ) dset = TRIM ( gname ) // \"/B\" attr = \"Characteristic magnetic field in T\" call save_to_hdf5 ( h5file_id , dset , params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/P\" attr = \"Characteristic pressure in Pa\" call save_to_hdf5 ( h5file_id , dset , params % cpp % pressure , attr ) dset = TRIM ( gname ) // \"/T\" attr = \"Characteristic plasma temperature in J\" call save_to_hdf5 ( h5file_id , dset , params % cpp % temperature , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if end if end subroutine save_simulation_parameters subroutine save_simulation_outputs ( params , spp , F ) !! @note Subroutine that saves the electrons' variables specified in !! params::outputs_list to HDF5 files. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information !! of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: subgname !! String containing the subgroup name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HID_T ) :: subgroup_id !! HDF5 subgroup identifier. INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims !! Dimensions of data saved to HDF5 file. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rdata !! 1-D array of real data to be saved to HDF5 file. INTEGER , DIMENSION (:), ALLOCATABLE :: idata !!1-D array of integer data to be saved to HDF5 file. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array !! An 1-D array with attributes of 1-D real or integer arrays that are !! passed to KORC interfaces of HDF5 I/O subroutines. CHARACTER ( MAX_STRING_LENGTH ) :: attr !! A single attributes of real or integer data that is passed to KORC !! interfaces of HDF5 I/O subroutines. INTEGER :: h5error !!HDF5 error status. CHARACTER ( 19 ) :: tmp_str !!Temporary string used to manipulate various strings. REAL ( rp ) :: units !! Temporary variable used to add physical units to electrons' variables. INTEGER :: ss !! Electron species iterator. INTEGER :: jj !! Iterator for reading all the entried of params::outputs_list. LOGICAL :: object_exists !! Flag determining if a certain dataset is already present in !! the HDF5 output files. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: YY !! Temporary variable get proper units on vars%Y(1,:) and vars%Y(3,:), which !! are lengths, while keeping vars%Y(2,:), which is an angle if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Saving snapshot: \",I15)' ) & params % it / ( params % t_skip ) !write(output_unit_write,*) 'it',params%it,'t_skip',params%t_skip,'t_SC',params%t_it_SC end if if ( SIZE ( params % outputs_list ). GT . 1_idef ) then write ( tmp_str , '(I18)' ) params % mpi_params % rank filename = TRIM ( params % path_to_outputs ) // \"file_\" & // TRIM ( ADJUSTL ( tmp_str )) // \".h5\" call h5fopen_f ( TRIM ( filename ), H5F_ACC_RDWR_F , h5file_id , h5error ) ! Create group 'it' write ( tmp_str , '(I18)' ) params % it gname = TRIM ( ADJUSTL ( tmp_str )) call h5lexists_f ( h5file_id , TRIM ( gname ), object_exists , h5error ) if (. NOT . object_exists ) then ! Check if group does exist. call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/time\" attr = \"Simulation time in secs\" call save_to_hdf5 ( h5file_id , dset , params % init_time * params % cpp % time & + REAL ( params % it , rp ) * params % dt * params % cpp % time , attr ) do ss = 1_idef , params % num_species write ( tmp_str , '(I18)' ) ss subgname = \"spp_\" // TRIM ( ADJUSTL ( tmp_str )) call h5gcreate_f ( group_id , TRIM ( subgname ), subgroup_id , h5error ) do jj = 1_idef , SIZE ( params % outputs_list ) SELECT CASE ( TRIM ( params % outputs_list ( jj ))) CASE ( 'X' ) dset = \"X\" units = params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % X ) CASE ( 'Y' ) dset = \"Y\" units = params % cpp % length YY = spp ( ss )% vars % Y YY (:, 1 ) = units * YY (:, 1 ) YY (:, 3 ) = units * YY (:, 3 ) call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & YY ) DEALLOCATE ( YY ) CASE ( 'V' ) dset = \"V\" if ( params % orbit_model ( 1 : 2 ). eq . 'FO' ) then units = params % cpp % velocity call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % V ) else if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then YY = spp ( ss )% vars % V YY (:, 1 ) = YY (:, 1 ) * params % cpp % mass * params % cpp % velocity YY (:, 2 ) = YY (:, 2 ) * params % cpp % mass * & ( params % cpp % velocity ) ** 2 / params % cpp % Bo call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & YY ) DEALLOCATE ( YY ) end if CASE ( 'RHS' ) dset = \"RHS\" YY = spp ( ss )% vars % RHS units = params % cpp % length / params % cpp % time YY (:, 1 ) = YY (:, 1 ) * units YY (:, 2 ) = YY (:, 2 ) * units YY (:, 3 ) = YY (:, 3 ) * units units = params % cpp % mass * params % cpp % velocity / params % cpp % time YY (:, 4 ) = YY (:, 4 ) * units YY (:, 5 ) = YY (:, 5 ) * params % cpp % mass * & ( params % cpp % velocity ) ** 2 / params % cpp % Bo / params % cpp % time call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & YY ) DEALLOCATE ( YY ) CASE ( 'Rgc' ) dset = \"Rgc\" units = params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Rgc ) CASE ( 'g' ) dset = \"g\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % g ) CASE ( 'eta' ) dset = \"eta\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % eta ) CASE ( 'mu' ) dset = \"mu\" units = params % cpp % mass * params % cpp % velocity ** 2 / params % cpp % Bo call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % mu ) CASE ( 'Prad' ) dset = \"Prad\" units = params % cpp % mass * ( params % cpp % velocity ** 3 ) / & params % cpp % length call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Prad ) CASE ( 'Pin' ) dset = \"Pin\" units = params % cpp % mass * ( params % cpp % velocity ** 3 ) / & params % cpp % length call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Pin ) CASE ( 'flagCon' ) dset = \"flagCon\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & INT ( spp ( ss )% vars % flagCon , idef )) CASE ( 'flagCol' ) dset = \"flagCol\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & INT ( spp ( ss )% vars % flagCol , idef )) CASE ( 'B' ) dset = \"B\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % B ) CASE ( 'gradB' ) if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then dset = \"gradB\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % gradB ) end if CASE ( 'curlb' ) if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then dset = \"curlb\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % curlb ) end if CASE ( 'E' ) dset = \"E\" units = params % cpp % Eo call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % E ) CASE ( 'PSIp' ) dset = \"PSIp\" if (. not . params % field_model . eq . 'M3D_C1' ) then units = params % cpp % Bo * params % cpp % length ** 2 else units = 1._rp end if call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % PSI_P ) CASE ( 'AUX' ) dset = \"AUX\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % AUX ) CASE ( 'ne' ) dset = \"ne\" units = params % cpp % density call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % ne ) CASE ( 'Te' ) dset = \"Te\" units = params % cpp % temperature call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Te / C_E ) CASE ( 'Zeff' ) dset = \"Zeff\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % Zeff ) CASE ( 'J_SC' ) dset = \"J_SC\" if ( params % SC_E ) then call save_1d_array_to_hdf5 ( subgroup_id , dset , & F % J1_SC_1D % PHI ) end if CASE ( 'A_SC' ) dset = \"A_SC\" if ( params % SC_E ) then call save_1d_array_to_hdf5 ( subgroup_id , dset , & F % A1_SC_1D % PHI ) end if CASE ( 'E_SC' ) dset = \"E_SC\" units = params % cpp % Eo if ( params % SC_E ) then call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * F % E_SC_1D % PHI ) end if CASE DEFAULT END SELECT end do call h5gclose_f ( subgroup_id , h5error ) end do call h5gclose_f ( group_id , h5error ) end if ! Check if group does exist. call h5fclose_f ( h5file_id , h5error ) end if end subroutine save_simulation_outputs subroutine save_restart_variables ( params , spp , F ) !! @note Subroutine that saves all the variables that KORC needs for !! restarting a simulation. These variables are saved to \"restart_file.h5\". TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! params Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: spp !! An instance of KORC's derived type SPECIES containing !! all the information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION (:), ALLOCATABLE :: send_buffer_rp , receive_buffer_rp !! Temporary buffer to be used by MPI to gather different electrons' !! variables. !! Temporary buffer to be used by MPI to gather different electrons' !! variables. INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: send_buffer_is , receive_buffer_is !! Temporary buffer to be used by MPI to gather different electrons' !! variables. !! Temporary buffer to be used by MPI to gather different electrons' !! variables. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: X REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: V REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J0_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J1_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J2_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J3_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: E_SC INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: flagCon , flagCol CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HID_T ) :: subgroup_id !! HDF5 subgroup identifier. INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims !!  Dimensions of data saved to HDF5 file. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rdata !! 1-D array of real data to be saved to HDF5 file. INTEGER , DIMENSION (:), ALLOCATABLE :: idata !! 1-D array of integer data to be saved to HDF5 file. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array !! An 1-D array with attributes of 1-D real or integer arrays that !! are passed to KORC interfaces of HDF5 I/O subroutines. CHARACTER ( MAX_STRING_LENGTH ) :: attr !! A single attributes of real or integer data that is passed to KORC !! interfaces of HDF5 I/O subroutines. INTEGER :: h5error !! HDF5 error status. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. REAL ( rp ) :: units !! Temporary variable used to add physical units to restart variables. INTEGER :: ss , jj !! Electron species iterator. !! Iterator for reading all the entried of params::outputs_list. INTEGER :: mpierr !! MPI error status. INTEGER :: numel_send , numel_receive !! Variable used by MPI to count the amount of data sent by each MPI !! procces. !! Variable used by MPI to count the amount of data received by the main !! MPI procces. !    if ( MODULO(params%it,params%restart_output_cadence) .EQ. 0_ip ) then if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , '(\"Saving restart: \",I15)' ) & params % it / ( params % t_skip * params % t_it_SC ) filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) dset = \"it\" attr = \"Iteration\" call save_to_hdf5 ( h5file_id , dset , params % it , attr ) dset = \"time\" attr = \"Current simulation time in secs\" call save_to_hdf5 ( h5file_id , dset , params % init_time * params % cpp % time & + REAL ( params % it , rp ) * params % dt * params % cpp % time , attr ) dset = \"simulation_time\" attr = \"Total simulation time in secs\" call save_to_hdf5 ( h5file_id , dset , params % simulation_time * & params % cpp % time , attr ) dset = \"snapshot_frequency\" attr = \"Snapshot frequency in secs\" call save_to_hdf5 ( h5file_id , dset , params % snapshot_frequency * & params % cpp % time , attr ) dset = \"dt\" attr = \"Time step in secs\" call save_to_hdf5 ( h5file_id , dset , params % dt * params % cpp % time , attr ) dset = \"t_steps\" attr = \"Time steps in simulation\" call save_to_hdf5 ( h5file_id , dset , params % t_steps , attr ) dset = \"output_cadence\" attr = \"Output cadence\" call save_to_hdf5 ( h5file_id , dset , params % output_cadence , attr ) dset = \"restart_output_cadence\" attr = \"Restart output cadence\" call save_to_hdf5 ( h5file_id , dset , params % restart_output_cadence , attr ) dset = \"num_snapshots\" attr = \"Number of snapshots in time for saving simulation variables\" call save_to_hdf5 ( h5file_id , dset , params % num_snapshots , attr ) if ( F % ReInterp_2x1t ) then dset = \"ind_2x1t\" attr = \"ReInterp_2x1t iteration\" call save_to_hdf5 ( h5file_id , dset , F % ind_2x1t , attr ) end if end if do ss = 1_idef , params % num_species numel_send = 3_idef * spp ( ss )% ppp numel_receive = 3_idef * spp ( ss )% ppp * params % mpi_params % nmpi if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( X ( spp ( ss )% ppp * params % mpi_params % nmpi , 3 )) ALLOCATE ( V ( spp ( ss )% ppp * params % mpi_params % nmpi , 3 )) ALLOCATE ( g ( spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( flagCon ( spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( flagCol ( spp ( ss )% ppp * params % mpi_params % nmpi )) end if ALLOCATE ( send_buffer_rp ( numel_send )) ALLOCATE ( receive_buffer_rp ( numel_receive )) if ( params % orbit_model ( 1 : 2 ). EQ . 'FO' ) then send_buffer_rp = RESHAPE ( spp ( ss )% vars % X ,( / numel_send / )) else if ( params % orbit_model ( 1 : 2 ). EQ . 'GC' ) then send_buffer_rp = RESHAPE ( spp ( ss )% vars % Y ,( / numel_send / )) end if receive_buffer_rp = 0.0_rp CALL MPI_GATHER ( send_buffer_rp , numel_send , MPI_REAL8 , & receive_buffer_rp , numel_send , MPI_REAL8 , 0 , MPI_COMM_WORLD , & mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then X = RESHAPE ( receive_buffer_rp ,( / spp ( ss )% ppp * & params % mpi_params % nmpi , 3 / )) end if send_buffer_rp = RESHAPE ( spp ( ss )% vars % V ,( / numel_send / )) receive_buffer_rp = 0.0_rp CALL MPI_GATHER ( send_buffer_rp , numel_send , MPI_REAL8 , & receive_buffer_rp , numel_send , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then V = RESHAPE ( receive_buffer_rp ,( / spp ( ss )% ppp * & params % mpi_params % nmpi , 3 / )) end if DEALLOCATE ( send_buffer_rp ) DEALLOCATE ( receive_buffer_rp ) numel_send = spp ( ss )% ppp numel_receive = spp ( ss )% ppp * params % mpi_params % nmpi ALLOCATE ( send_buffer_is ( numel_send )) ALLOCATE ( receive_buffer_is ( numel_receive )) send_buffer_is = spp ( ss )% vars % flagCon receive_buffer_is = 0_is CALL MPI_GATHER ( send_buffer_is , numel_send , MPI_INTEGER1 , & receive_buffer_is , numel_send ,& MPI_INTEGER1 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then flagCon = receive_buffer_is end if send_buffer_is = spp ( ss )% vars % flagCol receive_buffer_is = 0_is CALL MPI_GATHER ( send_buffer_is , numel_send , MPI_INTEGER1 , & receive_buffer_is , numel_send ,& MPI_INTEGER1 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then flagCol = receive_buffer_is end if DEALLOCATE ( send_buffer_is ) DEALLOCATE ( receive_buffer_is ) ALLOCATE ( send_buffer_rp ( numel_send )) ALLOCATE ( receive_buffer_rp ( numel_receive )) send_buffer_rp = spp ( ss )% vars % g receive_buffer_rp = 0_rp CALL MPI_GATHER ( send_buffer_rp , numel_send , MPI_REAL8 , & receive_buffer_rp , numel_send ,& MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then g = receive_buffer_rp end if DEALLOCATE ( send_buffer_rp ) DEALLOCATE ( receive_buffer_rp ) if ( params % mpi_params % rank . EQ . 0_idef ) then write ( tmp_str , '(I18)' ) ss subgname = \"spp_\" // TRIM ( ADJUSTL ( tmp_str )) call h5gcreate_f ( h5file_id , TRIM ( subgname ), group_id , h5error ) dset = \"X\" call rsave_2d_array_to_hdf5 ( group_id , dset , X ) dset = \"V\" call rsave_2d_array_to_hdf5 ( group_id , dset , V ) dset = \"flagCon\" call save_1d_array_to_hdf5 ( group_id , dset , INT ( flagCon , idef )) dset = \"flagCol\" call save_1d_array_to_hdf5 ( group_id , dset , INT ( flagCol , idef )) dset = \"g\" call save_1d_array_to_hdf5 ( group_id , dset , g ) if ( params % SC_E ) then ALLOCATE ( J0_SC ( F % dim_1D )) ALLOCATE ( J1_SC ( F % dim_1D )) ALLOCATE ( J2_SC ( F % dim_1D )) ALLOCATE ( J3_SC ( F % dim_1D )) ALLOCATE ( E_SC ( F % dim_1D )) J0_SC = F % J1_SC_1D % PHI / F % Ip0 J1_SC = F % J1_SC_1D % PHI J2_SC = F % J2_SC_1D % PHI J3_SC = F % J3_SC_1D % PHI E_SC = F % E_SC_1D % PHI dset = \"J0_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J0_SC ) dset = \"J1_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J1_SC ) dset = \"J2_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J2_SC ) dset = \"J3_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J3_SC ) dset = \"E_SC\" call save_1d_array_to_hdf5 ( group_id , dset , E_SC ) DEALLOCATE ( J0_SC ) DEALLOCATE ( J1_SC ) DEALLOCATE ( J2_SC ) DEALLOCATE ( J3_SC ) DEALLOCATE ( E_SC ) end if call h5gclose_f ( group_id , h5error ) end if if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( X ) DEALLOCATE ( V ) DEALLOCATE ( g ) DEALLOCATE ( flagCon ) DEALLOCATE ( flagCol ) end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then call h5fclose_f ( h5file_id , h5error ) end if !    end if end subroutine save_restart_variables ! * * * * * * * * * * * * * * * * * * * * * * * * * ! ! * * * SUBROUTINES FOR RESTARTING SIMULATION * * * ! ! * * * * * * * * * * * * * * * * * * * * * * * * * ! subroutine load_time_stepping_params ( params ) !! @note Subroutine that loads KORC parameters that control the time !! stepping in [[main]]. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. REAL ( KIND = 8 ) :: real_number !! A temporary real number. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !!  MPI error status. INTEGER :: ss !! Electron species iterator. if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) end if dset = \"/it\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % ito = INT ( real_number , ip ) + 1_ip dset = \"/dt\" call load_from_hdf5 ( h5file_id , dset , params % dt ) dset = \"/t_steps\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % t_steps = INT ( real_number , ip ) dset = \"/simulation_time\" call load_from_hdf5 ( h5file_id , dset , params % simulation_time ) dset = \"/snapshot_frequency\" call load_from_hdf5 ( h5file_id , dset , params % snapshot_frequency ) dset = \"/output_cadence\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % output_cadence = INT ( real_number , ip ) dset = \"/restart_output_cadence\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % restart_output_cadence = INT ( real_number , ip ) dset = \"/num_snapshots\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % num_snapshots = INT ( real_number , ip ) call h5fclose_f ( h5file_id , h5error ) end if CALL MPI_BCAST ( params % ito , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % dt , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % t_steps , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % simulation_time , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % snapshot_frequency , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , & mpierr ) CALL MPI_BCAST ( params % output_cadence , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % restart_output_cadence , 1 , MPI_INTEGER8 , 0 , & MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % num_snapshots , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) end subroutine load_time_stepping_params subroutine load_prev_time ( params ) !! @note Subroutine that loads KORC parameters that control the time !! stepping in [[main]]. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. REAL ( KIND = 8 ) :: real_number !! A temporary real number. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !!  MPI error status. INTEGER :: ss !! Electron species iterator. if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) end if dset = \"/time\" call load_from_hdf5 ( h5file_id , dset , params % init_time ) call h5fclose_f ( h5file_id , h5error ) end if CALL MPI_BCAST ( params % init_time , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) end subroutine load_prev_time subroutine load_prev_iter ( params ) !! @note Subroutine that loads KORC parameters that control the time !! stepping in [[main]]. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. REAL ( KIND = 8 ) :: real_number !! A temporary real number. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !!  MPI error status. INTEGER :: ss !! Electron species iterator. if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) end if dset = \"/ind_2x1t\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % prev_iter_2x1t = INT ( real_number , ip ) call h5fclose_f ( h5file_id , h5error ) end if CALL MPI_BCAST ( params % prev_iter_2x1t , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) end subroutine load_prev_iter subroutine load_particles_ic ( params , spp , F ) !! @note Subroutine that loads all the electrons' data from !! \"restart_file.h5\" to restart a simulation. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the !! information of different electron species. See korc_types.f90. TYPE ( FIELDS ), INTENT ( INOUT ) :: F REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X_send_buffer !! Temporary buffer used by MPI for scattering the electrons' position !! to different MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X_receive_buffer !! Temporary buffer used by MPI for scattering the electrons' position !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V_send_buffer !! Temporary buffer used by MPI for scattering the electrons' velocity !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V_receive_buffer !! Temporary buffer used by MPI for scattering the electrons' velocity !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: AUX_send_buffer !!  Temporary buffer used by MPI to scatter various electrons' variables !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: AUX_receive_buffer !! Temporary buffer used by MPI to scatter various electrons' variables !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC0_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC1_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC2_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC3_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ESC_buffer CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !! Electron species iterator. INTEGER :: ss !! MPI error status. do ss = 1_idef , params % num_species ALLOCATE ( X_send_buffer ( 3 * spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( X_receive_buffer ( 3 * spp ( ss )% ppp )) ALLOCATE ( V_send_buffer ( 3 * spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( V_receive_buffer ( 3 * spp ( ss )% ppp )) ALLOCATE ( AUX_send_buffer ( spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( AUX_receive_buffer ( spp ( ss )% ppp )) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/X\" call load_array_from_hdf5 ( h5file_id , dset , X_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if X_receive_buffer = 0.0_rp CALL MPI_SCATTER ( X_send_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , & X_receive_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % orbit_model ( 1 : 2 ). EQ . 'FO' ) then spp ( ss )% vars % X = RESHAPE ( X_receive_buffer ,( / spp ( ss )% ppp , 3 / )) else if ( params % orbit_model ( 1 : 2 ). EQ . 'GC' ) then spp ( ss )% vars % Y = RESHAPE ( X_receive_buffer ,( / spp ( ss )% ppp , 3 / )) spp ( ss )% vars % Y (:, 2 ) = modulo ( spp ( ss )% vars % Y (:, 2 ), 2 * C_PI ) end if if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/V\" call load_array_from_hdf5 ( h5file_id , dset , V_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if V_receive_buffer = 0.0_rp CALL MPI_SCATTER ( V_send_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , & V_receive_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % V = RESHAPE ( V_receive_buffer ,( / spp ( ss )% ppp , 3 / )) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/flagCon\" call load_array_from_hdf5 ( h5file_id , dset , AUX_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if AUX_receive_buffer = 0.0_rp CALL MPI_SCATTER ( AUX_send_buffer , spp ( ss )% ppp , MPI_REAL8 , & AUX_receive_buffer , spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % flagCon = INT ( AUX_receive_buffer , is ) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/flagCol\" call load_array_from_hdf5 ( h5file_id , dset , AUX_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if AUX_receive_buffer = 0.0_rp CALL MPI_SCATTER ( AUX_send_buffer , spp ( ss )% ppp , MPI_REAL8 , & AUX_receive_buffer , spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % flagCol = INT ( AUX_receive_buffer , is ) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/g\" call load_array_from_hdf5 ( h5file_id , dset , AUX_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if AUX_receive_buffer = 0.0_rp CALL MPI_SCATTER ( AUX_send_buffer , spp ( ss )% ppp , MPI_REAL8 , & AUX_receive_buffer , spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % g = AUX_receive_buffer if ( params % SC_E ) then ALLOCATE ( JSC0_buffer ( F % dim_1D )) ALLOCATE ( JSC1_buffer ( F % dim_1D )) ALLOCATE ( JSC2_buffer ( F % dim_1D )) ALLOCATE ( JSC3_buffer ( F % dim_1D )) ALLOCATE ( ESC_buffer ( F % dim_1D )) filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J0_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC0_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J1_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC1_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J2_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC2_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J3_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC3_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/E_SC\" call load_array_from_hdf5 ( h5file_id , dset , ESC_buffer ) call h5fclose_f ( h5file_id , h5error ) F % J0_SC_1D % PHI = JSC0_buffer F % J1_SC_1D % PHI = JSC1_buffer F % J2_SC_1D % PHI = JSC2_buffer F % J3_SC_1D % PHI = JSC3_buffer F % E_SC_1D % PHI = ESC_buffer / params % cpp % Eo DEALLOCATE ( JSC0_buffer ) DEALLOCATE ( JSC1_buffer ) DEALLOCATE ( JSC2_buffer ) DEALLOCATE ( JSC3_buffer ) DEALLOCATE ( ESC_buffer ) end if DEALLOCATE ( X_send_buffer ) DEALLOCATE ( X_receive_buffer ) DEALLOCATE ( V_send_buffer ) DEALLOCATE ( V_receive_buffer ) DEALLOCATE ( AUX_send_buffer ) DEALLOCATE ( AUX_receive_buffer ) end do if ( params % orbit_model ( 1 : 2 ). EQ . 'GC' ) then params % GC_coords = . TRUE . end if end subroutine load_particles_ic end module korc_HDF5","tags":"","loc":"sourcefile/korc_hdf5.f90.html"},{"title":"korc_simple_equilibrium_pdf.f90 – KORC-Full Orbit","text":"Contents Modules korc_simple_equilibrium_pdf Source Code korc_simple_equilibrium_pdf.f90 Source Code MODULE korc_simple_equilibrium_pdf USE korc_types USE korc_constants USE korc_HDF5 USE korc_hpc USE special_functions USE korc_input IMPLICIT NONE TYPE , PRIVATE :: PARAMS REAL ( rp ) :: E ! Parallel electric field normalized using the critical electric field REAL ( rp ) :: Zeff ! Effective atomic number of impurities REAL ( rp ) :: max_pitch_angle ! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle ! Minimum pitch angle of sampled PDF in degrees REAL ( rp ) :: po ! Momentum of sampled PDF in units of mc REAL ( rp ) :: Bo REAL ( rp ) :: lambda END TYPE PARAMS TYPE ( PARAMS ), PRIVATE :: pdf_params REAL ( rp ), PRIVATE , PARAMETER :: xo = ( C_ME * C_C ** 2 / C_E ) / 1.0E6 REAL ( rp ), PRIVATE , PARAMETER :: Tol = 1.0E-5_rp REAL ( rp ), PRIVATE , PARAMETER :: minmax_buffer_size = 1 0.0_rp PUBLIC :: get_equilibrium_distribution PRIVATE :: initialize_params ,& save_params ,& sample_distribution ,& deg2rad ,& rad2deg ,& fRE ,& random_norm ,& PR ,& P_integral ,& IntK ,& IntBesselK CONTAINS SUBROUTINE get_equilibrium_distribution ( params , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( IN ) :: go REAL ( rp ), INTENT ( OUT ) :: etao call initialize_params ( params , go ) call save_params ( params ) call sample_distribution ( params , eta , etao ) END SUBROUTINE get_equilibrium_distribution SUBROUTINE initialize_params ( params , go ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: go !REAL(rp) :: max_pitch_angle !REAL(rp) :: min_pitch_angle !REAL(rp) :: Zeff !REAL(rp) :: E !REAL(rp) :: Bo !REAL(rp) :: lambda !NAMELIST /SimpleEquilibriumPDF/ max_pitch_angle,min_pitch_angle,Zeff,E,Bo,lambda !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=SimpleEquilibriumPDF) !close(default_unit_open) pdf_params % max_pitch_angle = max_pitch_angle_simple pdf_params % min_pitch_angle = min_pitch_angle_simple pdf_params % Zeff = Zeff_simple pdf_params % E = E_simple pdf_params % Bo = Bo_simple pdf_params % lambda = lambda_simple pdf_params % po = sqrt ( go ** 2 - 1.0_rp ) END SUBROUTINE initialize_params FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad FUNCTION rad2deg ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: rad2deg rad2deg = 18 0.0_rp * x / C_PI END FUNCTION rad2deg FUNCTION fRE ( eta , p ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRE REAL ( rp ) :: A A = ( 2.0_rp * pdf_params % E / ( pdf_params % Zeff + 1.0_rp )) * ( p ** 2 / SQRT ( p ** 2.0_rp + 1.0_rp )) fRE = 0.5_rp * A * EXP ( A * COS ( deg2rad ( eta ))) / SINH ( A ) !\tfRE = fRE*PR(eta,p,pdf_params%Bo,pdf_params%lambda) END FUNCTION fRE FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = SQRT ( - 2.0_rp * LOG ( 1.0_rp - rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm FUNCTION IntK ( v , x ) IMPLICIT NONE REAL ( rp ) :: IntK REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: x IntK = ( C_PI / SQRT ( 2.0_rp )) * ( 1.0_rp - 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp )) * ERFC ( SQRT ( x ))& + 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp ) * SQRT ( 0.5_rp * C_PI / x ) * EXP ( - x ) END FUNCTION IntK FUNCTION besselk ( v , x ) IMPLICIT NONE REAL ( rp ) :: besselk REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ), INTENT ( IN ) :: v REAL ( 4 ) :: ri , rk , rip , rkp call bessik ( REAL ( x , 4 ), REAL ( v , 4 ), ri , rk , rip , rkp ) besselk = REAL ( rk , rp ) END FUNCTION besselk FUNCTION IntBesselK ( a , b ) REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ) :: IntBesselK REAL ( rp ) :: Iold REAL ( rp ) :: Inew REAL ( rp ) :: rerr REAL ( rp ) :: sum_f REAL ( rp ) :: v , h , z INTEGER :: ii , jj , npoints LOGICAL :: flag v = 5.0_rp / 3.0_rp h = b - a sum_f = 0.5 * ( besselk ( v , a ) + besselk ( v , b )) Iold = 0.0_rp Inew = sum_f * h ii = 1_idef flag = . TRUE . do while ( flag ) Iold = Inew ii = ii + 1_idef npoints = 2_idef ** ( ii - 2_idef ) h = 0.5_rp * ( b - a ) / REAL ( npoints , rp ) sum_f = 0.0_rp do jj = 1_idef , npoints z = a + h + 2.0_rp * ( REAL ( jj , rp ) - 1.0_rp ) * h sum_f = sum_f + besselk ( v , z ) end do Inew = 0.5_rp * Iold + sum_f * h rerr = ABS (( Inew - Iold ) / Iold ) flag = . NOT .( rerr . LT . Tol ) end do IntBesselK = Inew END FUNCTION IntBesselK SUBROUTINE P_integral ( z , P ) REAL ( rp ), INTENT ( OUT ) :: P REAL ( rp ), INTENT ( IN ) :: z REAL ( rp ) :: a P = 0.0_rp IF ( z . LT . 0.5_rp ) THEN a = ( 2.16_rp / 2.0_rp ** ( 2.0_rp / 3.0_rp )) * z ** ( 1.0_rp / 3.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE IF (( z . GE . 0.5_rp ). AND .( z . LT . 2.5_rp )) THEN a = 0.72_rp * ( z + 1.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE P = IntK ( 5.0_rp / 3.0_rp , z ) END IF END SUBROUTINE P_integral FUNCTION PR ( eta , p , Bo , l ) REAL ( rp ), INTENT ( IN ) :: eta ! in radians REAL ( rp ), INTENT ( IN ) :: p ! dimensionless (in units of mc) REAL ( rp ), INTENT ( IN ) :: Bo REAL ( rp ), INTENT ( IN ) :: l REAL ( rp ) :: PR REAL ( rp ) :: g REAL ( rp ) :: v REAL ( rp ) :: k REAL ( rp ) :: lc REAL ( rp ) :: z REAL ( rp ) :: Pi g = SQRT ( p ** 2 + 1.0_rp ) v = C_C * SQRT ( 1.0_rp - 1.0_rp / g ** 2 ) k = C_E * Bo * SIN ( deg2rad ( eta )) / ( g * C_ME * v ) lc = ( 4.0_rp * C_PI / 3.0_rp ) / ( k * g ** 3 ) ! Critical wavelength z = lc / l call P_integral ( z , Pi ) PR = ( C_C * C_E ** 2 ) * Pi / ( SQRT ( 3.0_rp ) * C_E0 * g ** 2 * l ** 3 ) END FUNCTION PR SUBROUTINE sample_distribution ( params , eta , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: etao REAL ( rp ) :: go_root REAL ( rp ) :: etao_root REAL ( rp ) :: eta_buffer , eta_test REAL ( rp ) :: ratio , rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax , min_pitch_angle , max_pitch_angle REAL ( rp ) :: deta LOGICAL :: leta INTEGER :: num_accepted INTEGER :: ii , jj , ppp , nsamples INTEGER :: mpierr ppp = SIZE ( eta ) nsamples = ppp * params % mpi_params % nmpi deta = ( pdf_params % max_pitch_angle - pdf_params % min_pitch_angle ) / 10 0.0_rp if ( pdf_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = pdf_params % min_pitch_angle end if do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax end if end do !\twrite(output_unit_write,*) min_pitch_angle,max_pitch_angle if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes !* * * Transient * * *! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_buffer = pdf_params % min_pitch_angle + ( pdf_params % max_pitch_angle - pdf_params % min_pitch_angle ) * rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . pdf_params % max_pitch_angle ). OR .( ABS ( eta_test ) . LT . pdf_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) end do ratio = fRE ( eta_test , pdf_params % po ) / fRE ( eta_buffer , pdf_params % po ) if ( ratio . GE . 1.0_rp ) then eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then eta_buffer = eta_test ii = ii + 1_idef end if end if end do !* * * Transient * * *! eta_tmp ( 1 ) = eta_buffer call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR .( ABS ( eta_test ) . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) end do ratio = fRE ( eta_test , pdf_params % po ) / fRE ( eta_tmp ( ii - 1 ), pdf_params % po ) if ( ratio . GE . 1.0_rp ) then eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) leta = ( eta_tmp ( ii ). LE . pdf_params % max_pitch_angle ). AND .( eta_tmp ( ii ). GE . pdf_params % min_pitch_angle ) if ( leta ) then num_accepted = num_accepted + 1_idef eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do end do etao = SUM ( eta_samples ) / nsamples end if CALL MPI_SCATTER ( eta_samples , ppp , MPI_REAL8 , eta , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( etao , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( eta_samples ) DEALLOCATE ( eta_tmp ) end if END SUBROUTINE sample_distribution SUBROUTINE save_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simple_equilibrium_pdf.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Zeff , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % E , attr ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Characteristic magnetic field in T (in case of using PR)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Bo , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Characteristic wavelength in m (in case of using PR)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % lambda , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_params END MODULE korc_simple_equilibrium_pdf","tags":"","loc":"sourcefile/korc_simple_equilibrium_pdf.f90.html"},{"title":"korc_collisions.f90 – KORC-Full Orbit","text":"Contents Modules korc_collisions Source Code korc_collisions.f90 Source Code module korc_collisions use korc_types use korc_constants use korc_HDF5 use korc_interp use korc_profiles use korc_fields use korc_input #ifdef PARALLEL_RANDOM use korc_random #endif IMPLICIT NONE CHARACTER ( LEN =* ), PRIVATE , PARAMETER :: MODEL1 = 'SINGLE_SPECIES' CHARACTER ( LEN =* ), PRIVATE , PARAMETER :: MODEL2 = 'MULTIPLE_SPECIES' REAL ( rp ), PRIVATE , PARAMETER :: infinity = HUGE ( 1.0_rp ) TYPE , PRIVATE :: PARAMS_MS INTEGER :: num_impurity_species REAL ( rp ) :: Te ! Background electron temperature in eV REAL ( rp ) :: ne ! Background electron density in 1/m&#94;3 REAL ( rp ) :: nH ! Background proton density in 1/m&#94;3 REAL ( rp ) :: nef ! Free electron density in 1/m&#94;3 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: neb ! Bound electron density in 1/m&#94;3 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zi ! Atomic number of (majority) background ions REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zo ! Full nuclear charge of each impurity: Z=1 for D, Z=10 for Ne REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zj ! Atomic number of each impurity: Z=1 for D, Z=10 for Ne REAL ( rp ), DIMENSION (:), ALLOCATABLE :: nz ! Impurity densities REAL ( rp ), DIMENSION (:), ALLOCATABLE :: IZj , aZj ! Ionization energy of impurity in eV REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Ee_IZj ! me*c&#94;2/IZj dimensionless parameter REAL ( rp ) :: rD ! Debye length REAL ( rp ) :: re ! Classical electron radius REAL ( rp ), DIMENSION ( 11 ) :: aNe = ( / 11 1._rp , 10 0._rp , 9 0._rp , 8 0._rp , & 7 1._rp , 6 2._rp , 5 2._rp , 4 0._rp , 2 4._rp , 2 3._rp , 0._rp / ) REAL ( rp ), DIMENSION ( 19 ) :: aAr = ( / 9 6._rp , 9 0._rp , 8 4._rp , 7 8._rp , 7 2._rp , & 6 5._rp , 5 9._rp , 5 3._rp , 4 7._rp , 4 4._rp , 4 1._rp , 3 8._rp , 2 5._rp , 3 2._rp , & 2 7._rp , 2 1._rp , 1 3._rp , 1 3._rp , 0._rp / ) REAL ( rp ), DIMENSION ( 11 ) :: INe = ( / 13 7.2_rp , 16 5.2_rp , 19 6.9_rp , 23 5.2_rp , & 28 2.8_rp , 35 2.6_rp , 47 5.0_rp , 69 6.8_rp , 140 9.2_rp , 149 8.4_rp , huge ( 1._rp ) / ) REAL ( rp ), DIMENSION ( 19 ) :: IAr = ( / 18 8.5_rp , 21 9.4_rp , 25 3.8_rp , 29 3.4_rp , & 33 9.1_rp , 39 4.5_rp , 46 3.4_rp , 56 8.0_rp , 72 8.0_rp , 79 5.9_rp , 87 9.8_rp , & 98 9.9_rp , 113 8.1_rp , 136 9.5_rp , 179 1.2_rp , 249 7.0_rp , 467 7.2_rp , & 483 8.2_rp , huge ( 1._rp ) / ) END TYPE PARAMS_MS TYPE , PRIVATE :: PARAMS_SS REAL ( rp ) :: Te ! Electron temperature REAL ( rp ) :: Ti ! Ion temperature REAL ( rp ) :: ne ! Background electron density REAL ( rp ) :: Zeff ! Effective atomic number of ions REAL ( rp ) :: rD ! Debye radius REAL ( rp ) :: re ! Classical electron radius REAL ( rp ) :: CoulombLogee , CoulombLogei ! Coulomb logarithm REAL ( rp ) :: CLog1 , CLog2 , CLog0_1 , CLog0_2 REAL ( rp ) :: VTe ! Thermal velocity of background electrons REAL ( rp ) :: VTeo REAL ( rp ) :: delta ! delta parameter REAL ( rp ) :: deltao REAL ( rp ) :: Gammac ! Collisional Gamma factor REAL ( rp ) :: Gammaco ! Collisional gamma factor normalized for SDE for dp REAL ( rp ) :: Tau ! Collisional time of relativistic particles REAL ( rp ) :: Tauc ! Collisional time of thermal particles REAL ( rp ) :: taur ! radiation timescale REAL ( rp ) :: Ec ! Critical electric field REAL ( rp ) :: ED ! Dreicer electric field REAL ( rp ) :: dTau ! Subcycling time step in collisional time units (Tau) INTEGER ( ip ) :: subcycling_iterations REAL ( rp ), DIMENSION ( 3 ) :: x = ( / 1.0_rp , 0.0_rp , 0.0_rp / ) REAL ( rp ), DIMENSION ( 3 ) :: y = ( / 0.0_rp , 1.0_rp , 0.0_rp / ) REAL ( rp ), DIMENSION ( 3 ) :: z = ( / 0.0_rp , 0.0_rp , 1.0_rp / ) TYPE ( PROFILES ) :: P REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: rnd_num INTEGER :: rnd_num_count INTEGER :: rnd_dim = 40000000_idef END TYPE PARAMS_SS TYPE ( PARAMS_MS ), PRIVATE :: cparams_ms TYPE ( PARAMS_SS ), PRIVATE :: cparams_ss PUBLIC :: initialize_collision_params ,& normalize_collisions_params ,& collision_force ,& deallocate_collisions_params ,& save_collision_params ,& include_CoulombCollisions_GC_p ,& include_CoulombCollisions_FO_p ,& check_collisions_params ,& define_collisions_time_step PRIVATE :: load_params_ms ,& load_params_ss ,& normalize_params_ms ,& normalize_params_ss ,& save_params_ms ,& save_params_ss ,& deallocate_params_ms ,& cross ,& CA ,& CB_ee ,& CB_ei ,& CF ,& fun ,& nu_S ,& nu_par ,& nu_D ,& Gammac_wu ,& CLog_wu ,& VTe_wu ,& Gammacee ,& CLog ,& VTe ,& CA_SD ,& CB_ee_SD ,& CB_ei_SD ,& CF_SD ,& delta ,& unitVectorsC ,& unitVectors_p contains ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! ! * SUBROUTINES FOR INITIALIZING COLLISIONS PARAMS * ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! subroutine load_params_ms ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) \t\t\t\t:: Te ! Background electron temperature in eV !REAL(rp) \t\t\t\t:: ne ! Background electron density in 1/m&#94;3 !INTEGER \t\t\t\t:: num_impurity_species !REAL(rp), DIMENSION(10) \t\t:: Zo ! Full nuclear charge of each impurity: Z=1 for D, Z=10 for Ne !REAL(rp), DIMENSION(10) \t\t:: Zj ! Atomic number of each impurity: Z=1 for D, Z=10 for Ne !REAL(rp), DIMENSION(10) \t\t:: nz ! Impurity densities !REAL(rp), DIMENSION(10) \t\t:: IZj ! Ionization energy of impurity in eV !REAL(rp), DIMENSION(10) \t\t:: aZj INTEGER :: i !NAMELIST /CollisionParamsMultipleSpecies/ num_impurity_species,Te,ne, & !     Zo,Zj,nz,IZj !open(unit=output_unit_write,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(output_unit_write,nml=CollisionParamsMultipleSpecies) !close(output_unit_write) cparams_ms % num_impurity_species = num_impurity_species ALLOCATE ( cparams_ms % Zj ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % Zo ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % nz ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % neb ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % IZj ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % aZj ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % Ee_IZj ( cparams_ms % num_impurity_species )) cparams_ms % Te = Te_mult * C_E cparams_ms % ne = ne_mult cparams_ms % nH = ne_mult cparams_ms % Zj = Zj_mult ( 1 : cparams_ms % num_impurity_species ) cparams_ms % Zo = Zo_mult ( 1 : cparams_ms % num_impurity_species ) cparams_ms % nz = nz_mult ( 1 : cparams_ms % num_impurity_species ) do i = 1 , cparams_ms % num_impurity_species if ( int ( cparams_ms % Zo ( i )). eq . 10 ) then cparams_ms % IZj ( i ) = C_E * cparams_ms % INe ( int ( cparams_ms % Zj ( i ) + 1 )) cparams_ms % aZj ( i ) = cparams_ms % aNe ( int ( cparams_ms % Zj ( i ) + 1 )) else if ( int ( cparams_ms % Zo ( i )). eq . 18 ) then cparams_ms % IZj ( i ) = C_E * cparams_ms % IAr ( int ( cparams_ms % Zj ( i ) + 1 )) cparams_ms % aZj ( i ) = cparams_ms % aAr ( int ( cparams_ms % Zj ( i ) + 1 )) else if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Atomic number not defined!\")' ) end if exit end if end do cparams_ms % nef = ne_mult + sum ( cparams_ms % Zj * cparams_ms % nz ) cparams_ms % neb = ( cparams_ms % Zo - cparams_ms % Zj ) * cparams_ms % nz cparams_ms % rD = SQRT ( C_E0 * cparams_ms % Te / ( cparams_ms % ne * C_E ** 2 ) ) cparams_ms % re = C_RE cparams_ms % Ee_IZj = C_ME * C_C ** 2 / cparams_ms % IZj if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Number of impurity species: \",I16)' )& cparams_ms % num_impurity_species do i = 1 , cparams_ms % num_impurity_species if ( cparams_ms % Zo ( i ). eq . 10 ) then write ( output_unit_write , '(\"Ne with charge state: \",I16)' ) int ( cparams_ms % Zj ( i )) write ( output_unit_write , '(\"Mean excitation energy I (eV)\",E17.10)' ) & cparams_ms % IZj ( i ) / C_E write ( output_unit_write , '(\"Effective ion length scale a (a_0)\",E17.10)' ) & cparams_ms % aZj ( i ) else if ( cparams_ms % Zo ( i ). eq . 18 ) then write ( output_unit_write , '(\"Ar with charge state: \",I16)' ) int ( cparams_ms % Zj ( i )) write ( output_unit_write , '(\"Mean excitation energy I (eV)\",E17.10)' ) & cparams_ms % IZj ( i ) / C_E write ( output_unit_write , '(\"Effective ion length scale a (a_0)\",E17.10)' ) & cparams_ms % aZj ( i ) end if end do end if end subroutine load_params_ms subroutine load_params_ss ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) \t\t\t\t:: Te ! Electron temperature !REAL(rp) \t\t\t\t:: Ti ! Ion temperature !REAL(rp) \t\t\t\t:: ne ! Background electron density !REAL(rp) \t\t\t\t:: Zeff ! Effective atomic number of ions !REAL(rp) \t\t\t\t:: dTau ! Subcycling time step in collisional time units (Tau) !CHARACTER(MAX_STRING_LENGTH) \t:: ne_profile !CHARACTER(MAX_STRING_LENGTH) \t:: Te_profile !CHARACTER(MAX_STRING_LENGTH) \t:: Zeff_profile !CHARACTER(MAX_STRING_LENGTH) \t:: filename !REAL(rp) \t\t\t\t:: radius_profile !REAL(rp) \t\t\t\t:: neo !REAL(rp) \t\t\t\t:: Teo !REAL(rp) \t\t\t\t:: Zeffo !REAL(rp) \t\t\t\t:: n_ne !REAL(rp) \t\t\t\t:: n_Te !REAL(rp) \t\t\t\t:: n_Zeff !REAL(rp), DIMENSION(4) \t\t:: a_ne !REAL(rp), DIMENSION(4) \t\t:: a_Te !REAL(rp), DIMENSION(4) \t\t:: a_Zeff !LOGICAL \t\t\t\t:: axisymmetric !REAL(rp)  ::  n_REr0 !REAL(rp)  ::  n_tauion !REAL(rp)  ::  n_lamfront,psiN_0 !REAL(rp)  ::  n_lamback,n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf !NAMELIST /CollisionParamsSingleSpecies/ Te, Ti, ne, Zeff, dTau !NAMELIST /plasmaProfiles/ radius_profile,ne_profile,neo,n_ne,a_ne,& !     Te_profile,Teo,n_Te,a_Te,n_REr0,n_tauion,n_lamfront,n_lamback, & !     Zeff_profile,Zeffo,n_Zeff,a_Zeff,filename,axisymmetric, & !     n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf,psiN_0 !open(unit=output_unit_write,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(output_unit_write,nml=CollisionParamsSingleSpecies) !close(output_unit_write) cparams_ss % Te = Te_sing * C_E cparams_ss % Ti = Ti_sing * C_E cparams_ss % ne = ne_sing cparams_ss % Zeff = Zeff_sing cparams_ss % dTau = dTau_sing cparams_ss % rD = SQRT ( C_E0 * cparams_ss % Te / ( cparams_ss % ne * C_E ** 2 * ( 1.0_rp + & cparams_ss % Te / cparams_ss % Ti ))) cparams_ss % re = C_E ** 2 / ( 4.0_rp * C_PI * C_E0 * C_ME * C_C ** 2 ) cparams_ss % CoulombLogee = CLogee_wu ( params , cparams_ss % ne , cparams_ss % Te ) cparams_ss % CoulombLogei = CLogei_wu ( params , cparams_ss % ne , cparams_ss % Te ) cparams_ss % VTe = VTe_wu ( cparams_ss % Te ) cparams_ss % delta = cparams_ss % VTe / C_C cparams_ss % Gammaco = C_E ** 4 / ( 4.0_rp * C_PI * C_E0 ** 2 ) cparams_ss % Gammac = Gammac_wu ( params , cparams_ss % ne , cparams_ss % Te ) cparams_ss % Tauc = C_ME ** 2 * cparams_ss % VTe ** 3 / cparams_ss % Gammac cparams_ss % Tau = C_ME ** 2 * C_C ** 3 / cparams_ss % Gammac cparams_ss % Ec = C_ME * C_C / ( C_E * cparams_ss % Tau ) cparams_ss % ED = cparams_ss % ne * C_E ** 3 * cparams_ss % CoulombLogee / & ( 4.0_rp * C_PI * C_E0 ** 2 * cparams_ss % Te ) cparams_ss % taur = 6 * C_PI * C_E0 * ( C_ME * C_C ) ** 3 / ( C_E ** 4 * params % cpp % Bo ** 2 * & params % cpp % time ) !\tALLOCATE(cparams_ss%rnd_num(3,cparams_ss%rnd_dim)) !\tcall RANDOM_NUMBER(cparams_ss%rnd_num) cparams_ss % rnd_num_count = 1_idef !open(unit=output_unit_write,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(output_unit_write,nml=plasmaProfiles) !close(output_unit_write) cparams_ss % P % a = radius_profile cparams_ss % P % ne_profile = TRIM ( ne_profile ) cparams_ss % P % neo = neo cparams_ss % P % n_ne = n_ne cparams_ss % P % a_ne = a_ne cparams_ss % P % Te_profile = TRIM ( Te_profile ) cparams_ss % P % Teo = Teo * C_E cparams_ss % P % n_Te = n_Te cparams_ss % P % a_Te = a_Te cparams_ss % P % Zeff_profile = TRIM ( Zeff_profile ) cparams_ss % P % Zeffo = Zeffo cparams_ss % P % n_Zeff = n_Zeff cparams_ss % P % a_Zeff = a_Zeff end subroutine load_params_ss subroutine initialize_collision_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if ( params % collisions ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * * * INITIALIZING COLLISIONS * * * * * * *\")' ) end if SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) call load_params_ss ( params ) SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call load_params_ms ( params ) CASE ( 'HESSLOW' ) call load_params_ms ( params ) CASE ( 'ROSENBLUTH' ) call load_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call load_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end if end subroutine initialize_collision_params subroutine normalize_params_ms ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params cparams_ms % Te = cparams_ms % Te / params % cpp % temperature cparams_ms % ne = cparams_ms % ne / params % cpp % density cparams_ms % nH = cparams_ms % nH / params % cpp % density cparams_ms % nef = cparams_ms % nef / params % cpp % density cparams_ms % neb = cparams_ms % neb / params % cpp % density if ( ALLOCATED ( cparams_ms % nz )) cparams_ms % nz = cparams_ms % nz / & params % cpp % density if ( ALLOCATED ( cparams_ms % IZj )) cparams_ms % IZj = cparams_ms % IZj / & params % cpp % energy cparams_ms % rD = cparams_ms % rD / params % cpp % length cparams_ms % re = cparams_ms % re / params % cpp % length end subroutine normalize_params_ms subroutine normalize_params_ss ( params ) !! Calculate constant quantities used in various functions within !! this module TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params cparams_ss % Clog1 = - 1.15_rp * LOG10 ( 1.0E-6_rp * params % cpp % density ) cparams_ss % Clog2 = 2.3_rp * LOG10 ( params % cpp % temperature / C_E ) cparams_ss % Clog0_1 = - LOG ( 1.0E-20_rp * params % cpp % density ) / 2._rp cparams_ss % Clog0_2 = LOG ( 1.0E-3 * params % cpp % temperature / C_E ) cparams_ss % Gammaco = cparams_ss % Gammaco * params % cpp % density * & params % cpp % time / ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) cparams_ss % VTeo = SQRT ( params % cpp % temperature / C_ME ) / params % cpp % velocity cparams_ss % deltao = params % cpp % velocity / C_C cparams_ss % Te = cparams_ss % Te / params % cpp % temperature cparams_ss % Ti = cparams_ss % Ti / params % cpp % temperature cparams_ss % ne = cparams_ss % ne / params % cpp % density cparams_ss % rD = cparams_ss % rD / params % cpp % length cparams_ss % re = cparams_ss % re / params % cpp % length cparams_ss % VTe = cparams_ss % VTe / params % cpp % velocity cparams_ss % Gammac = cparams_ss % Gammac * params % cpp % time / & ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) cparams_ss % Tau = cparams_ss % Tau / params % cpp % time cparams_ss % Tauc = cparams_ss % Tauc / params % cpp % time cparams_ss % Ec = cparams_ss % Ec / params % cpp % Eo cparams_ss % ED = cparams_ss % ED / params % cpp % Eo cparams_ss % taur = cparams_ss % taur / params % cpp % time cparams_ss % P % a = cparams_ss % P % a / params % cpp % length cparams_ss % P % neo = cparams_ss % P % neo / params % cpp % density cparams_ss % P % Teo = cparams_ss % P % Teo / params % cpp % temperature end subroutine normalize_params_ss subroutine normalize_collisions_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if ( params % collisions ) then SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) call normalize_params_ss ( params ) SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call normalize_params_ms ( params ) CASE ( 'HESSLOW' ) call normalize_params_ms ( params ) CASE ( 'ROSENBLUTH' ) call normalize_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call normalize_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT end if end subroutine normalize_collisions_params subroutine collision_force ( spp , U , Fcoll ) !! For multiple-species collisions !! J. R. Martin-Solis et al. PoP 22, 092512 (2015) !! if (params%collisions .AND. (TRIM(params%collisions_model) .EQ. !! 'MULTIPLE_SPECIES')) then call collision_force(spp(ii),U_os,Fcoll) !!\tU_RC = U_RC + a*Fcoll/spp(ii)%q end if TYPE ( SPECIES ), INTENT ( IN ) :: spp REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: U REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: Fcoll REAL ( rp ), DIMENSION ( 3 ) :: V REAL ( rp ), DIMENSION ( 3 ) :: Fcolle REAL ( rp ), DIMENSION ( 3 ) :: Fcolli REAL ( rp ) :: gamma REAL ( rp ) :: tmp REAL ( rp ) :: ae REAL ( rp ) :: ai REAL ( rp ) :: Clog_ef REAL ( rp ) :: Clog_eb REAL ( rp ) :: Clog_eH REAL ( rp ) :: Clog_eZj REAL ( rp ) :: Clog_eZo INTEGER :: ppi gamma = SQRT ( 1.0_rp + DOT_PRODUCT ( U , U )) V = U / gamma tmp = ( gamma - 1.0_rp ) * SQRT ( gamma + 1.0_rp ) Clog_ef = log ( 0.5_rp * tmp * ( cparams_ms % rD / cparams_ms % re ) / gamma ) ae = cparams_ms % nef * Clog_ef do ppi = 1_idef , cparams_ms % num_impurity_species Clog_eb = log ( tmp * cparams_ms % Ee_IZj ( ppi )) ae = ae + cparams_ms % neb ( ppi ) * Clog_eb end do tmp = ( gamma ** 2 - 1.0_rp ) / gamma Clog_eH = log ( tmp * ( cparams_ms % rD / cparams_ms % re ) ) ai = cparams_ms % nH * Clog_eH do ppi = 1_idef , cparams_ms % num_impurity_species Clog_eZj = log ( cparams_ms % rD / ( cparams_ms % Zj ( ppi ) * & cparams_ms % re * cparams_ms % Ee_IZj ( ppi )) ) Clog_eZo = log ( tmp * cparams_ms % Ee_IZj ( ppi )) ai = ai + & cparams_ms % nz ( ppi ) * ( Clog_eZj * cparams_ms % Zj ( ppi ) ** 2 + & Clog_eZo * cparams_ms % Zo ( ppi ) ** 2 ) end do tmp = gamma * ( gamma + 1.0_rp ) / ( SQRT ( DOT_PRODUCT ( U , U )) ** 3 ) Fcolle = - 4.0_rp * C_PI * ae * spp % m * ( cparams_ms % re ** 2 ) * tmp * U tmp = gamma / ( SQRT ( DOT_PRODUCT ( U , U )) ** 3 ) Fcolli = - 4.0_rp * C_PI * ai * spp % m * ( cparams_ms % re ** 2 ) * tmp * U Fcoll = Fcolle + Fcolli end subroutine collision_force subroutine define_collisions_time_step ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( ip ) :: iterations REAL ( rp ) :: E REAL ( rp ) :: v REAL ( rp ) :: Tau REAL ( rp ), DIMENSION ( 3 ) :: nu REAL ( rp ) :: num_collisions_in_simulation if ( params % collisions ) then E = C_ME * C_C ** 2 + params % minimum_particle_energy * params % cpp % energy v = SQRT ( 1.0_rp - ( C_ME * C_C ** 2 / E ) ** 2 ) nu = ( / nu_S ( params , v ), nu_D ( params , v ), nu_par ( v ) / ) Tau = MINVAL ( 1.0_rp / nu ) !       write(output_unit_write,'(\"collision freqencies \",F25.12)') nu cparams_ss % subcycling_iterations = FLOOR ( cparams_ss % dTau * Tau / & params % dt , ip ) + 1_ip num_collisions_in_simulation = params % simulation_time / Tau if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * SUBCYCLING FOR  & COLLISIONS * * * * * * * * * * *\")' ) write ( output_unit_write , '(\"Slowing down freqency (CF): \",E17.10)' ) & nu ( 1 ) / params % cpp % time write ( output_unit_write , '(\"Pitch angle scattering freqency (CB): \",E17.10)' ) & nu ( 2 ) / params % cpp % time write ( output_unit_write , '(\"Speed diffusion freqency (CA): \",E17.10)' ) & nu ( 3 ) / params % cpp % time write ( output_unit_write , '(\"The shorter collisional time in the simulations  & is: \",E17.10,\" s\")' ) Tau * params % cpp % time write ( output_unit_write , '(\"Number of KORC iterations per collision: \",I16)' ) & cparams_ss % subcycling_iterations write ( output_unit_write , '(\"Number of collisions in simulated time: \",E17.10)' ) & num_collisions_in_simulation write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * & * * * * * * * * * * * * * * *\",/)' ) end if end if end subroutine define_collisions_time_step ! * * * * * * * * * * * *  * * * * * * * * * * * * * * * * * * * ! ! * FUNCTIONS OF COLLISION OPERATOR FOR SINGLE-SPECIES PLASMAS * ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * * * * * * * ! ! *_wu functions have physical units! function VTe_wu ( Te ) REAL ( rp ), INTENT ( IN ) :: Te !! In Joules REAL ( rp ) :: VTe_wu VTe_wu = SQRT ( 2.0_rp * Te / C_ME ) end function VTe_wu function VTe ( Te ) !! Dimensionless temperature REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: VTe VTe = SQRT ( 2.0_rp * Te ) * cparams_ss % VTeo end function VTe function Gammac_wu ( params , ne , Te ) !! With units TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: Gammac_wu Gammac_wu = ne * CLogee_wu ( params , ne , Te ) * cparams_ss % Gammaco end function Gammac_wu function Gammacee ( v , ne , Te ) !! Dimensionless ne and Te REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: Gammacee Gammacee = ne * CLogee ( v , ne , Te ) * cparams_ss % Gammaco end function Gammacee function CLog_wu ( ne , Te ) !! With units REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLog_wu CLog_wu = 2 5.3_rp - 1.15_rp * LOG10 ( 1E-6_rp * ne ) + 2.3_rp * LOG10 ( Te / C_E ) end function CLog_wu function CLog0_wu ( ne , Te ) !! With units REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLog0_wu CLog0_wu = 1 4.9_rp - LOG ( 1E-20_rp * ne ) / 2._rp + LOG ( 1E-3_rp * Te / C_E ) end function CLog0_wu function CLogee_wu ( params , ne , Te ) !! With units TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogee_wu REAL ( rp ) :: k = 5._rp CLogee_wu = CLog0_wu ( ne , Te ) + & log ( 1 + ( 2 * ( params % minimum_particle_g - 1 ) / & ( VTe_wu ( Te ) / C_C ) ** 2 ) ** ( k / 2._rp )) / k end function CLogee_wu function CLogei_wu ( params , ne , Te ) !! With units TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogei_wu REAL ( rp ) :: k = 5._rp REAL ( rp ) :: p p = sqrt ( params % minimum_particle_g ** 2 - 1 ) CLogei_wu = CLog0_wu ( ne , Te ) + & log ( 1 + ( 2 * p / ( VTe_wu ( Te ) / C_C )) ** k ) / k end function CLogei_wu function CLog ( ne , Te ) ! Dimensionless ne and Te REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CLog CLog = 2 5.3_rp - 1.15_rp * LOG10 ( ne ) + 2.3_rp * LOG10 ( Te ) + & cparams_ss % CLog1 + cparams_ss % CLog2 end function CLog function CLog0 ( ne , Te ) ! Dimensionless ne and Te REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CLog0 CLog0 = 1 4.9_rp - LOG ( ne ) / 2._rp + LOG ( Te ) + & cparams_ss % CLog0_1 + cparams_ss % CLog0_2 end function CLog0 function CLogee ( v , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogee REAL ( rp ) :: k = 5._rp REAL ( rp ) :: gam gam = 1 / sqrt ( 1 - v ** 2 ) CLogee = CLog0 ( ne , Te ) + & log ( 1 + ( 2 * ( gam - 1 ) / VTe ( Te ) ** 2 ) ** ( k / 2._rp )) / k !    write(output_unit_write,*) gam,CLogee end function CLogee function CLogei ( v , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogei REAL ( rp ) :: k = 5._rp REAL ( rp ) :: gam , p gam = 1 / sqrt ( 1 - v ** 2 ) p = gam * v CLogei = CLog0 ( ne , Te ) + log ( 1 + ( 2 * p / VTe ( Te )) ** k ) / k end function CLogei function delta ( Te ) REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: delta delta = VTe ( Te ) * cparams_ss % deltao end function delta function psi ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: psi psi = 0.5_rp * ( ERF ( x ) - 2.0_rp * x * EXP ( - x ** 2 ) / SQRT ( C_PI )) / x ** 2 end function psi function CA ( v ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CA REAL ( rp ) :: x x = v / cparams_ss % VTe CA = cparams_ss % Gammac * psi ( x ) / v end function CA function CA_SD ( v , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CA_SD REAL ( rp ) :: x !   write(6,*) ne,Te x = v / VTe ( Te ) CA_SD = Gammacee ( v , ne , Te ) * psi ( x ) / v !    write(output_unit_write,'(\"ne, \"E17.10)') ne !    write(output_unit_write,'(\"Te, \"E17.10)') Te !    write(output_unit_write,'(\"x, \"E17.10)') x !    write(output_unit_write,'(\"psi, \"E17.10)') psi(x) !    write(output_unit_write,'(\"Gammac, \"E17.10)') Gammac(ne,Te) end function CA_SD function dCA_SD ( v , me , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: me REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: dCA_SD REAL ( rp ) :: x real ( rp ) :: gam gam = 1 / sqrt ( 1 - v ** 2 ) x = v / VTe ( Te ) dCA_SD = Gammacee ( v , ne , Te ) * (( 2 * ( gam * v ) ** 2 - 1 ) * psi ( x ) + & 2.0_rp * x * EXP ( - x ** 2 ) / SQRT ( C_PI )) / ( gam ** 3 * me * v ** 2 ) end function dCA_SD function CF ( params , v ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CF REAL ( rp ) :: CF_temp REAL ( rp ) :: x INTEGER :: i REAL ( rp ) :: k = 5._rp x = v / cparams_ss % VTe CF = cparams_ss % Gammac * psi ( x ) / cparams_ss % Te if ( params % bound_electron_model . eq . 'HESSLOW' ) then CF_temp = CF do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / & CLogee ( v , cparams_ss % ne , cparams_ss % Te ) * & ( log ( 1 + h_j ( i , v ) ** k ) / k - v ** 2 ) end do CF = CF_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CF_temp = CF do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CF = CF_temp end if end function CF function CF_SD ( params , v , ne , Te ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CF_SD REAL ( rp ) :: CF_temp REAL ( rp ) :: x INTEGER :: i REAL ( rp ) :: k = 5._rp x = v / VTe ( Te ) CF_SD = Gammacee ( v , ne , Te ) * psi ( x ) / Te if ( params % bound_electron_model . eq . 'HESSLOW' ) then CF_temp = CF_SD do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF_SD * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / & CLogee ( v , ne , Te ) * ( log ( 1 + h_j ( i , v ) ** k ) / k - v ** 2 ) end do CF_SD = CF_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CF_temp = CF_SD do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF_SD * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CF_SD = CF_temp end if end function CF_SD function CB_ee ( v ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CB_ee REAL ( rp ) :: x x = v / cparams_ss % VTe CB_ee = ( 0.5_rp * cparams_ss % Gammac / v ) * ( ERF ( x ) - & psi ( x ) + 0.5_rp * cparams_ss % delta ** 4 * x ** 2 ) end function CB_ee function CB_ei ( params , v ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CB_ei REAL ( rp ) :: CB_ei_temp REAL ( rp ) :: x INTEGER :: i x = v / cparams_ss % VTe CB_ei = ( 0.5_rp * cparams_ss % Gammac / v ) * ( cparams_ss % Zeff * & CLogei ( v , cparams_ss % ne , cparams_ss % Te ) / & CLogee ( v , cparams_ss % ne , cparams_ss % Te )) if ( params % bound_electron_model . eq . 'HESSLOW' ) then CB_ei_temp = CB_ei do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei * cparams_ms % nz ( i ) / ( cparams_ms % ne * & cparams_ss % Zeff * CLogei ( v , cparams_ss % ne , cparams_ss % Te )) * & g_j ( i , v ) end do CB_ei = CB_ei_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CB_ei_temp = CB_ei do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CB_ei = CB_ei_temp end if end function CB_ei function CB_ee_SD ( v , ne , Te , Zeff ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ), INTENT ( IN ) :: Zeff REAL ( rp ) :: CB_ee_SD REAL ( rp ) :: x x = v / VTe ( Te ) CB_ee_SD = ( 0.5_rp * Gammacee ( v , ne , Te ) / v ) * & ( ERF ( x ) - psi ( x ) + & 0.5_rp * delta ( Te ) ** 4 * x ** 2 ) end function CB_ee_SD function CB_ei_SD ( params , v , ne , Te , Zeff ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ), INTENT ( IN ) :: Zeff REAL ( rp ) :: CB_ei_SD REAL ( rp ) :: CB_ei_temp REAL ( rp ) :: x INTEGER :: i x = v / VTe ( Te ) CB_ei_SD = ( 0.5_rp * Gammacee ( v , ne , Te ) / v ) * & ( Zeff * CLogei ( v , ne , Te ) / CLogee ( v , ne , Te )) if ( params % bound_electron_model . eq . 'HESSLOW' ) then CB_ei_temp = CB_ei_SD do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei_SD * cparams_ms % nz ( i ) / ( cparams_ms % ne * & Zeff * CLogei ( v , ne , Te )) * g_j ( i , v ) end do CB_ei_SD = CB_ei_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CB_ei_temp = CB_ei_SD do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei_SD * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CB_ei_SD = CB_ei_temp end if end function CB_ei_SD function nu_S ( params , v ) ! Slowing down collision frequency TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v ! Normalised particle speed REAL ( rp ) :: nu_S REAL ( rp ) :: nu_S_temp REAL ( rp ) :: p p = v / SQRT ( 1.0_rp - v ** 2 ) nu_S = CF ( params , v ) / p end function nu_S function h_j ( i , v ) INTEGER , INTENT ( IN ) :: i REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: gam REAL ( rp ) :: p REAL ( rp ) :: h_j gam = 1 / sqrt ( 1 - v ** 2 ) p = v * gam h_j = p * sqrt ( gam - 1 ) / cparams_ms % IZj ( i ) end function h_j function g_j ( i , v ) INTEGER , INTENT ( IN ) :: i REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: gam REAL ( rp ) :: p REAL ( rp ) :: g_j gam = 1 / sqrt ( 1 - v ** 2 ) p = v * gam g_j = 2._rp / 3._rp * (( cparams_ms % Zo ( i ) ** 2 - cparams_ms % Zj ( i ) ** 2 ) * & log (( p * cparams_ms % aZj ( i )) ** ( 3._rp / 2._rp ) + 1 ) - & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) ** 2 * & ( p * cparams_ms % aZj ( i )) ** ( 3._rp / 2._rp ) / & (( p * cparams_ms % aZj ( i )) ** ( 3._rp / 2._rp ) + 1 )) !    write(output_unit_write,'(\"g_j: \",E17.10)') g_j end function g_j function nu_D ( params , v ) ! perpendicular diffusion (pitch angle scattering) collision frequency REAL ( rp ), INTENT ( IN ) :: v TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params ! Normalised particle speed REAL ( rp ) :: nu_D REAL ( rp ) :: p p = v / SQRT ( 1.0_rp - v ** 2 ) nu_D = 2.0_rp * ( CB_ee ( v ) + CB_ei ( params , v )) / p ** 2 end function nu_D function nu_par ( v ) ! parallel (speed diffusion) collision frequency REAL ( rp ), INTENT ( IN ) :: v ! Normalised particle speed REAL ( rp ) :: nu_par REAL ( rp ) :: p p = v / SQRT ( 1.0_rp - v ** 2 ) nu_par = 2.0_rp * CA ( v ) / p ** 2 end function nu_par function fun ( v ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: fun REAL ( rp ) :: x x = v / cparams_ss % VTe fun = 2.0_rp * ( 1.0_rp / x + x ) * EXP ( - x ** 2 ) / SQRT ( C_PI ) - ERF ( x ) / x ** 2 - psi ( v ) end function fun function cross ( a , b ) REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: a REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: b REAL ( rp ), DIMENSION ( 3 ) :: cross cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross subroutine unitVectorsC ( B , b1 , b2 , b3 ) REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: B REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: b1 REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: b2 REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: b3 b1 = B / SQRT ( DOT_PRODUCT ( B , B )) b2 = cross ( b1 ,( / 0.0_rp , 0.0_rp , 1.0_rp / )) b2 = b2 / SQRT ( DOT_PRODUCT ( b2 , b2 )) b3 = cross ( b1 , b2 ) b3 = b3 / SQRT ( DOT_PRODUCT ( b3 , b3 )) end subroutine unitVectorsC subroutine unitVectors_p ( pchunk , b_unit_X , b_unit_Y , b_unit_Z , b1_X , b1_Y , b1_Z , & b2_X , b2_Y , b2_Z , b3_X , b3_Y , b3_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: b1_X , b1_Y , b1_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: b2_X , b2_Y , b2_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: b3_X , b3_Y , b3_Z REAL ( rp ), DIMENSION ( pchunk ) :: b2mag , b3mag integer ( ip ) :: cc !$OMP SIMD !    !$OMP& aligned(b1_X,b1_Y,b1_Z,b_unit_X,b_unit_Y,b_unit_Z, & !    !$OMP& b2_X,b2_Y,b2_Z,b2mag,b3_X,b3_Y,b3_Z,b3mag) do cc = 1_idef , pchunk b1_X ( cc ) = b_unit_X ( cc ) b1_Y ( cc ) = b_unit_Y ( cc ) b1_Z ( cc ) = b_unit_Z ( cc ) b2_X ( cc ) = b1_Y ( cc ) b2_Y ( cc ) = - b1_X ( cc ) b2_Z ( cc ) = 0._rp b2mag ( cc ) = sqrt ( b2_X ( cc ) * b2_X ( cc ) + b2_Y ( cc ) * b2_Y ( cc ) + b2_Z ( cc ) * b2_Z ( cc )) b2_X ( cc ) = b2_X ( cc ) / b2mag ( cc ) b2_Y ( cc ) = b2_Y ( cc ) / b2mag ( cc ) b2_Z ( cc ) = b2_Z ( cc ) / b2mag ( cc ) b3_X ( cc ) = b1_Y ( cc ) * b2_Z ( cc ) - b1_Z ( cc ) * b2_Y ( cc ) b3_Y ( cc ) = b1_Z ( cc ) * b2_X ( cc ) - b1_X ( cc ) * b2_Z ( cc ) b3_Z ( cc ) = b1_X ( cc ) * b2_Y ( cc ) - b1_Y ( cc ) * b2_X ( cc ) b3mag ( cc ) = sqrt ( b3_X ( cc ) * b3_X ( cc ) + b3_Y ( cc ) * b3_Y ( cc ) + b3_Z ( cc ) * b3_Z ( cc )) b3_X ( cc ) = b3_X ( cc ) / b3mag ( cc ) b3_Y ( cc ) = b3_Y ( cc ) / b3mag ( cc ) b3_Z ( cc ) = b3_Z ( cc ) / b3mag ( cc ) end do !$OMP END SIMD end subroutine unitVectors_p subroutine check_collisions_params ( spp ) #ifdef PARALLEL_RANDOM USE omp_lib #endif TYPE ( SPECIES ), INTENT ( IN ) :: spp INTEGER aux aux = cparams_ss % rnd_num_count + 2_idef * INT ( spp % ppp , idef ) if ( aux . GE . cparams_ss % rnd_dim ) then #ifdef PARALLEL_RANDOM cparams_ss % rnd_num = get_random () #else call RANDOM_NUMBER ( cparams_ss % rnd_num ) #endif cparams_ss % rnd_num_count = 1_idef end if end subroutine check_collisions_params ! * * * * * * * * * * * *  * * * * * * * * * * * * * * * * * * * ! ! * FUNCTIONS OF COLLISION OPERATOR FOR SINGLE-SPECIES PLASMAS * ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * * * * * * * ! subroutine include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , me , P , F , flagCon , flagCol , PSIp ) !! This subroutine performs a Stochastic collision process consistent !! with the Fokker-Planck model for relativitic electron colliding with !! a thermal (Maxwellian) plasma. The collision operator is in spherical !! coordinates of the form found in Papp et al., NF (2011). CA !! corresponds to the parallel (speed diffusion) process, CF corresponds !! to a slowing down (momentum loss) process, and CB corresponds to a !! perpendicular diffusion process. Ordering of the processes are !!  \\sqrt{CB}\\gg CB \\gg CF \\sim \\sqrt{CA} \\gg CA, !! and only the dominant terms are kept. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: X_X , X_Y , X_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCol INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon REAL ( rp ), INTENT ( IN ) :: me INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b1_X , b1_Y , b1_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b2_X , b2_Y , b2_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b3_X , b3_Y , b3_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk , 3 ) :: dW !! 3D Weiner process REAL ( rp ), DIMENSION ( params % pchunk , 3 ) :: rnd1 REAL ( rp ) :: dt , time REAL ( rp ), DIMENSION ( params % pchunk ) :: um REAL ( rp ), DIMENSION ( params % pchunk ) :: dpm REAL ( rp ), DIMENSION ( params % pchunk ) :: vm REAL ( rp ), DIMENSION ( params % pchunk ) :: pm REAL ( rp ), DIMENSION ( params % pchunk ) :: Ub_X , Ub_Y , Ub_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: xi REAL ( rp ), DIMENSION ( params % pchunk ) :: dxi REAL ( rp ), DIMENSION ( params % pchunk ) :: phi REAL ( rp ), DIMENSION ( params % pchunk ) :: dphi !! speed of particle REAL ( rp ), DIMENSION ( params % pchunk ) :: CAL REAL ( rp ), DIMENSION ( params % pchunk ) :: dCAL REAL ( rp ), DIMENSION ( params % pchunk ) :: CFL REAL ( rp ), DIMENSION ( params % pchunk ) :: CBL integer :: cc , pchunk pchunk = params % pchunk if ( MODULO ( params % it + tt , cparams_ss % subcycling_iterations ) . EQ . 0_ip ) then dt = REAL ( cparams_ss % subcycling_iterations , rp ) * params % dt time = params % init_time + ( params % it - 1 + tt ) * params % dt ! subcylcling iterations a fraction of fastest collision frequency, ! where fraction set by dTau in namelist &CollisionParamsSingleSpecies call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) if ( params % profile_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then call analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) else  if ( params % profile_model ( 1 : 8 ). eq . 'EXTERNAL' ) then call interp_FOcollision_p ( pchunk , Y_R , Y_PHI , Y_Z , ne , Te , Zeff , flagCon ) end if !$OMP SIMD !       !$OMP& aligned(um,pm,vm,U_X,U_Y,U_Z,Bmag,B_X,B_Y,B_Z, & !       !$OMP& b_unit_X,b_unit_Y,b_unit_Z,xi) do cc = 1_idef , pchunk um ( cc ) = SQRT ( U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) pm ( cc ) = me * um ( cc ) vm ( cc ) = um ( cc ) / SQRT ( 1.0_rp + um ( cc ) * um ( cc )) ! um is gamma times v, this solves for v Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) xi ( cc ) = ( U_X ( cc ) * b_unit_X ( cc ) + U_Y ( cc ) * b_unit_Y ( cc ) + & U_Z ( cc ) * b_unit_Z ( cc )) / um ( cc ) ! pitch angle in b_unit reference frame end do !$OMP END SIMD !       write(output_unit_write,'(\"vm: \",E17.10)') vm !       write(output_unit_write,'(\"xi: \",E17.10)') xi call unitVectors_p ( pchunk , b_unit_X , b_unit_Y , b_unit_Z , b1_X , b1_Y , b1_Z , & b2_X , b2_Y , b2_Z , b3_X , b3_Y , b3_Z ) ! b1=b_unit, (b1,b2,b3) is right-handed !$OMP SIMD !       !$OMP& aligned(phi,U_X,U_Y,U_Z,b3_X,b3_Y,b3_Z,b2_X,b2_Y,b2_Z) do cc = 1_idef , pchunk phi ( cc ) = atan2 (( U_X ( cc ) * b3_X ( cc ) + U_Y ( cc ) * b3_Y ( cc ) + & U_Z ( cc ) * b3_Z ( cc )), & ( U_X ( cc ) * b2_X ( cc ) + U_Y ( cc ) * b2_Y ( cc ) + U_Z ( cc ) * b2_Z ( cc ))) ! azimuthal angle in b_unit refernce frame end do !$OMP END SIMD !       write(output_unit_write,'(\"phi: \",E17.10)') phi !$OMP SIMD !       !$OMP& aligned(rnd1,dW,CAL,dCAL,CFL,CBL,vm,ne,Te,Zeff,dpm, & !       !$OMP& flagCon,flagCol,dxi,xi,pm,dphi,um,Ub_X,Ub_Y,Ub_Z,U_X,U_Y,U_Z, & !       !$OMP& b1_X,b1_Y,b1_Z,b2_X,b2_Y,b2_Z,b3_X,b3_Y,b3_Z) do cc = 1_idef , pchunk #ifdef PARALLEL_RANDOM ! uses C library to generate normal_distribution random variables, ! preserving parallelization where Fortran random number generator ! does not rnd1 ( cc , 1 ) = get_random () rnd1 ( cc , 2 ) = get_random () rnd1 ( cc , 3 ) = get_random () #else call RANDOM_NUMBER ( rnd1 ) #endif dW ( cc , 1 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 1 )) dW ( cc , 2 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 2 )) dW ( cc , 3 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 3 )) ! 3D Weiner process CAL ( cc ) = CA_SD ( vm ( cc ), ne ( cc ), Te ( cc )) dCAL ( cc ) = dCA_SD ( vm ( cc ), me , ne ( cc ), Te ( cc )) CFL ( cc ) = CF_SD ( params , vm ( cc ), ne ( cc ), Te ( cc )) CBL ( cc ) = ( CB_ee_SD ( vm ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc )) + & CB_ei_SD ( params , vm ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc ))) dpm ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - CFL ( cc ) + dCAL ( cc )) * dt + & sqrt ( 2.0_rp * CAL ( cc )) * dW ( cc , 1 )) dxi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & ( - 2 * xi ( cc ) * CBL ( cc ) / ( pm ( cc ) * pm ( cc )) * dt - & sqrt ( 2.0_rp * CBL ( cc ) * ( 1 - xi ( cc ) * xi ( cc ))) / pm ( cc ) * dW ( cc , 2 )) dphi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & ( sqrt ( 2 * CBL ( cc )) / ( pm ( cc ) * & sqrt ( 1 - xi ( cc ) * xi ( cc ))) * dW ( cc , 3 )) pm ( cc ) = pm ( cc ) + dpm ( cc ) xi ( cc ) = xi ( cc ) + dxi ( cc ) phi ( cc ) = phi ( cc ) + dphi ( cc ) !          if (pm(cc)<0) pm(cc)=-pm(cc) ! Keep xi between [-1,1] if ( xi ( cc ) > 1 ) then xi ( cc ) = 1 - mod ( xi ( cc ), 1._rp ) else if ( xi ( cc ) <- 1 ) then xi ( cc ) =- 1 - mod ( xi ( cc ), - 1._rp ) endif ! Keep phi between [0,pi] !          if (phi(cc)>C_PI) then !             phi(cc)=C_PI-mod(phi(cc),C_PI) !          else if (phi(cc)<0) then !             phi(cc)=mod(-phi(cc),C_PI) !          endif um ( cc ) = pm ( cc ) / me Ub_X ( cc ) = um ( cc ) * xi ( cc ) Ub_Y ( cc ) = um ( cc ) * sqrt ( 1 - xi ( cc ) * xi ( cc )) * cos ( phi ( cc )) Ub_Z ( cc ) = um ( cc ) * sqrt ( 1 - xi ( cc ) * xi ( cc )) * sin ( phi ( cc )) U_X ( cc ) = Ub_X ( cc ) * b1_X ( cc ) + Ub_Y ( cc ) * b2_X ( cc ) + Ub_Z ( cc ) * b3_X ( cc ) U_Y ( cc ) = Ub_X ( cc ) * b1_Y ( cc ) + Ub_Y ( cc ) * b2_Y ( cc ) + Ub_Z ( cc ) * b3_Y ( cc ) U_Z ( cc ) = Ub_X ( cc ) * b1_Z ( cc ) + Ub_Y ( cc ) * b2_Z ( cc ) + Ub_Z ( cc ) * b3_Z ( cc ) end do !$OMP END SIMD !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"CA: \",E17.10)') CAL(1) !          write(output_unit_write,'(\"dCA: \",E17.10)') dCAL(1) !          write(output_unit_write,'(\"CF \",E17.10)') CFL(1) !          write(output_unit_write,'(\"CB: \",E17.10)') CBL(1) !       end if do cc = 1_idef , pchunk if ( pm ( cc ). lt . 0 ) then write ( output_unit_write , '(\"Momentum less than zero\")' ) stop end if end do end if end subroutine include_CoulombCollisions_FO_p subroutine include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & Ppll , Pmu , me , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Ppll REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Pmu REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI , ne , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCol INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon REAL ( rp ), INTENT ( IN ) :: me REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: dW REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: rnd1 REAL ( rp ) :: dt , time REAL ( rp ), DIMENSION ( params % pchunk ) :: pm REAL ( rp ), DIMENSION ( params % pchunk ) :: dp REAL ( rp ), DIMENSION ( params % pchunk ) :: xi REAL ( rp ), DIMENSION ( params % pchunk ) :: dxi REAL ( rp ), DIMENSION ( params % pchunk ) :: v , gam !! speed of particle REAL ( rp ), DIMENSION ( params % pchunk ) :: CAL REAL ( rp ) , DIMENSION ( params % pchunk ) :: dCAL REAL ( rp ), DIMENSION ( params % pchunk ) :: CFL REAL ( rp ), DIMENSION ( params % pchunk ) :: CBL REAL ( rp ), DIMENSION ( params % pchunk ) :: SC_p , SC_mu , BREM_p REAL ( rp ) :: kappa integer :: cc , pchunk integer ( ip ), INTENT ( IN ) :: tt pchunk = params % pchunk if ( MODULO ( params % it + tt , cparams_ss % subcycling_iterations ) . EQ . 0_ip ) then dt = REAL ( cparams_ss % subcycling_iterations , rp ) * params % dt time = params % init_time + ( params % it - 1 + tt ) * params % dt if ( params % field_eval . eq . 'eqn' ) then call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) else if ( params % field_eval . eq . 'interp' ) then if ( F % axisymmetric_fields ) then if ( F % Bflux ) then if (. not . params % SC_E ) then call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) end if else if ( F % ReInterp_2x1t ) then call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else if ( F % Bflux3D ) then call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp , time ) else if ( F % dBfield ) then call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon ) end if else if ( F % dBfield ) then call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon ) end if endif call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) end if if ( params % profile_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then call analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) else if ( params % profile_model ( 1 : 8 ). eq . 'EXTERNAL' ) then call interp_FOcollision_p ( pchunk , Y_R , Y_PHI , Y_Z , ne , Te , Zeff , flagCon ) end if if (. not . params % FokPlan ) E_PHI = 0._rp !$OMP SIMD !       !$OMP& aligned (pm,xi,v,Ppll,Bmag,Pmu) do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Transform p_pll,mu to P,eta pm ( cc ) = SQRT ( Ppll ( cc ) * Ppll ( cc ) + 2 * me * Bmag ( cc ) * Pmu ( cc )) xi ( cc ) = Ppll ( cc ) / pm ( cc ) gam ( cc ) = sqrt ( 1 + pm ( cc ) * pm ( cc )) v ( cc ) = pm ( cc ) / gam ( cc ) ! normalized speed (v_K=v_P/c) end do !$OMP END SIMD !       write(output_unit_write,'(\"ne: \"E17.10)') ne !       write(output_unit_write,'(\"Te: \"E17.10)') Te !       write(output_unit_write,'(\"Bmag: \"E17.10)') Bmag !       write(output_unit_write,'(\"v: \",E17.10)') v !       write(output_unit_write,'(\"xi: \",E17.10)') xi !       write(output_unit_write,'(\"size(E_PHI_GC): \",I16)') size(E_PHI) !$OMP SIMD !       !$OMP& aligned(rnd1,dW,CAL,dCAL,CFL,CBL,v,ne,Te,Zeff,dp, & !       !$OMP& flagCon,flagCol,dxi,xi,pm,Ppll,Pmu,Bmag) do cc = 1_idef , pchunk #ifdef PARALLEL_RANDOM rnd1 ( cc , 1 ) = get_random () rnd1 ( cc , 2 ) = get_random () !       rnd1(:,1) = get_random_mkl() !       rnd1(:,2) = get_random_mkl() #else call RANDOM_NUMBER ( rnd1 ) #endif dW ( cc , 1 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 1 )) dW ( cc , 2 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 2 )) !          write(output_unit_write,'(\"dW1: \",E17.10)') dW(cc,1) !          write(output_unit_write,'(\"dW2: \",E17.10)') dW(cc,2) CAL ( cc ) = CA_SD ( v ( cc ), ne ( cc ), Te ( cc )) dCAL ( cc ) = dCA_SD ( v ( cc ), me , ne ( cc ), Te ( cc )) CFL ( cc ) = CF_SD ( params , v ( cc ), ne ( cc ), Te ( cc )) CBL ( cc ) = ( CB_ee_SD ( v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc )) + & CB_ei_SD ( params , v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc ))) dp ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - CFL ( cc ) + dCAL ( cc ) + E_PHI ( cc ) * xi ( cc )) * dt + & sqrt ( 2.0_rp * CAL ( cc )) * dW ( cc , 1 )) dxi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - 2 * xi ( cc ) * CBL ( cc ) / ( pm ( cc ) * pm ( cc )) + & E_PHI ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / pm ( cc )) * dt - & sqrt ( 2.0_rp * CBL ( cc ) * ( 1 - xi ( cc ) * xi ( cc ))) / pm ( cc ) * dW ( cc , 2 )) !          write(output_unit_write,'(\"dp: \",E17.10)') dp(cc) !          write(output_unit_write,'(\"dxi: \",E17.10)') dxi(cc) end do !$OMP END SIMD if ( params % FokPlan . and . params % radiation ) then if ( params % GC_rad_model . eq . 'SDE' ) then !$OMP SIMD do cc = 1_idef , pchunk SC_p ( cc ) =- gam ( cc ) * pm ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & ( cparams_ss % taur / Bmag ( cc ) ** 2 ) SC_mu ( cc ) = xi ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & (( cparams_ss % taur / Bmag ( cc ) ** 2 ) * gam ( cc )) kappa = 2._rp * C_PI * C_RE ** 2._rp * C_ME * C_C ** 2._rp BREM_p ( cc ) =- 2._rp * ne ( cc ) * kappa * Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * & C_a / C_PI * ( gam ( cc ) - 1._rp ) * ( log ( 2._rp * gam ( cc )) - 1._rp / 3._rp ) dp ( cc ) = dp ( cc ) + ( SC_p ( cc ) + BREM_p ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) dxi ( cc ) = dxi ( cc ) + ( SC_mu ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) end do !$OMP END SIMD end if end if !$OMP SIMD do cc = 1_idef , pchunk pm ( cc ) = pm ( cc ) + dp ( cc ) xi ( cc ) = xi ( cc ) + dxi ( cc ) !          if (pm(cc)<0) pm(cc)=-pm(cc) ! Keep xi between [-1,1] if ( xi ( cc ) > 1 ) then !             write(output_unit_write,'(\"High xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) xi ( cc ) = 1 - mod ( xi ( cc ), 1._rp ) else if ( xi ( cc ) <- 1 ) then xi ( cc ) =- 1 - mod ( xi ( cc ), - 1._rp ) !             write(output_unit_write,'(\"Low xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) endif ! Transform P,xi to p_pll,mu Ppll ( cc ) = pm ( cc ) * xi ( cc ) Pmu ( cc ) = ( pm ( cc ) * pm ( cc ) - Ppll ( cc ) * Ppll ( cc )) / ( 2 * me * Bmag ( cc )) end do !$OMP END SIMD !       write(output_unit_write,'(\"rnd1: \",E17.10)') rnd1 !       write(output_unit_write,'(\"flag: \",I16)') flag !       write(output_unit_write,'(\"CA: \",E17.10)') CAL !       write(output_unit_write,'(\"dCA: \",E17.10)') dCAL !       write(output_unit_write,'(\"CF \",E17.10)') CFL !       write(output_unit_write,'(\"CB: \",E17.10)') CBL !       write(output_unit_write,'(\"dp: \",E17.10)') dp !       write(output_unit_write,'(\"dxi: \",E17.10)') dxi !       write(output_unit_write,'(\"Ppll: \",E17.10)') Ppll !      write(output_unit_write,'(\"Pmu: \",E17.10)') Pmu !       write(output_unit_write,'(\"E_PHI_COL: \",E17.10)') E_PHI do cc = 1_idef , pchunk if (( pm ( cc ). lt . 1._rp ). and . flagCol ( cc ). eq . 1_ip ) then !             write(output_unit_write,'(\"Momentum less than zero\")') !             stop !             write(output_unit_write,'(\"Particle not tracked at: \",E17.10,\" & !                  & with xi: \",E17.10)') time*params%cpp%time, xi(cc) flagCol ( cc ) = 0_ip end if end do !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"dp_rad: \",E17.10)') & !               -gam(1)*pm(1)*(1-xi(1)*xi(1))/ & !               (cparams_ss%taur/Bmag(1)**2)*dt !          write(output_unit_write,'(\"dxi_rad: \",E17.10)') & !               xi(1)*(1-xi(1)*xi(1))/ & !               ((cparams_ss%taur/Bmag(1)**2)*gam(1))*dt !       end if !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"CA: \",E17.10)') CAL(1) !          write(output_unit_write,'(\"dCA: \",E17.10)') dCAL(1) !          write(output_unit_write,'(\"CF \",E17.10)') CFL(1) !          write(output_unit_write,'(\"CB: \",E17.10)') CBL(1) !       end if end if end subroutine include_CoulombCollisions_GC_p subroutine include_CoulombCollisions_GCm3dc1_p ( tt , params , Y_R , Y_PHI , Y_Z , & Ppll , Pmu , me , flagCon , flagCol , F , P , E_PHI , ne , Te , PSIp , hint ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Ppll REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Pmu REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_PHI , PSIp , E_PHI0 REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: ne , Te REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCol INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint REAL ( rp ), INTENT ( IN ) :: me REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: dW REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: rnd1 REAL ( rp ) :: dt , time REAL ( rp ), DIMENSION ( params % pchunk ) :: pm REAL ( rp ), DIMENSION ( params % pchunk ) :: dp REAL ( rp ), DIMENSION ( params % pchunk ) :: xi REAL ( rp ), DIMENSION ( params % pchunk ) :: dxi REAL ( rp ), DIMENSION ( params % pchunk ) :: v , gam !! speed of particle REAL ( rp ), DIMENSION ( params % pchunk ) :: CAL REAL ( rp ) , DIMENSION ( params % pchunk ) :: dCAL REAL ( rp ), DIMENSION ( params % pchunk ) :: CFL REAL ( rp ), DIMENSION ( params % pchunk ) :: CBL REAL ( rp ), DIMENSION ( params % pchunk ) :: SC_p , SC_mu , BREM_p REAL ( rp ) :: kappa integer :: cc , pchunk integer ( ip ), INTENT ( IN ) :: tt pchunk = params % pchunk if ( MODULO ( params % it + tt , cparams_ss % subcycling_iterations ) . EQ . 0_ip ) then dt = REAL ( cparams_ss % subcycling_iterations , rp ) * params % dt time = params % init_time + ( params % it - 1 + tt ) * params % dt call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call get_m3d_c1_profile_p ( params , P , Y_R , Y_PHI , Y_Z , & ne , Te , flagCon , hint ) !$OMP SIMD !       !$OMP& aligned (pm,xi,v,Ppll,Bmag,Pmu) do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Transform p_pll,mu to P,eta pm ( cc ) = SQRT ( Ppll ( cc ) * Ppll ( cc ) + 2 * me * Bmag ( cc ) * Pmu ( cc )) xi ( cc ) = Ppll ( cc ) / pm ( cc ) gam ( cc ) = sqrt ( 1 + pm ( cc ) * pm ( cc )) v ( cc ) = pm ( cc ) / gam ( cc ) ! normalized speed (v_K=v_P/c) Zeff ( cc ) = 1._rp E_PHI0 ( cc ) = E_PHI ( cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) E_PHI = 0._rp !       write(output_unit_write,'(\"ne: \"E17.10)') ne !       write(output_unit_write,'(\"Te: \"E17.10)') Te !       write(output_unit_write,'(\"Bmag: \"E17.10)') Bmag !       write(output_unit_write,'(\"v: \",E17.10)') v !       write(output_unit_write,'(\"xi: \",E17.10)') xi !       write(output_unit_write,'(\"size(E_PHI_GC): \",I16)') size(E_PHI) !$OMP SIMD !       !$OMP& aligned(rnd1,dW,CAL,dCAL,CFL,CBL,v,ne,Te,Zeff,dp, & !       !$OMP& flagCon,flagCol,dxi,xi,pm,Ppll,Pmu,Bmag) do cc = 1_idef , pchunk #ifdef PARALLEL_RANDOM rnd1 ( cc , 1 ) = get_random () rnd1 ( cc , 2 ) = get_random () !       rnd1(:,1) = get_random_mkl() !       rnd1(:,2) = get_random_mkl() #else call RANDOM_NUMBER ( rnd1 ) #endif dW ( cc , 1 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 1 )) dW ( cc , 2 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 2 )) !          write(output_unit_write,'(\"dW1: \",E17.10)') dW(cc,1) !          write(output_unit_write,'(\"dW2: \",E17.10)') dW(cc,2) CAL ( cc ) = CA_SD ( v ( cc ), ne ( cc ), Te ( cc )) dCAL ( cc ) = dCA_SD ( v ( cc ), me , ne ( cc ), Te ( cc )) CFL ( cc ) = CF_SD ( params , v ( cc ), ne ( cc ), Te ( cc )) CBL ( cc ) = ( CB_ee_SD ( v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc )) + & CB_ei_SD ( params , v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc ))) dp ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - CFL ( cc ) + dCAL ( cc ) + E_PHI ( cc ) * xi ( cc )) * dt + & sqrt ( 2.0_rp * CAL ( cc )) * dW ( cc , 1 )) dxi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - 2 * xi ( cc ) * CBL ( cc ) / ( pm ( cc ) * pm ( cc )) + & E_PHI ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / pm ( cc )) * dt - & sqrt ( 2.0_rp * CBL ( cc ) * ( 1 - xi ( cc ) * xi ( cc ))) / pm ( cc ) * dW ( cc , 2 )) !          write(output_unit_write,'(\"dp: \",E17.10)') dp(cc) !          write(output_unit_write,'(\"dxi: \",E17.10)') dxi(cc) end do !$OMP END SIMD if ( params % FokPlan . and . params % radiation ) then if ( params % GC_rad_model . eq . 'SDE' ) then !$OMP SIMD do cc = 1_idef , pchunk SC_p ( cc ) =- gam ( cc ) * pm ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & ( cparams_ss % taur / Bmag ( cc ) ** 2 ) SC_mu ( cc ) = xi ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & (( cparams_ss % taur / Bmag ( cc ) ** 2 ) * gam ( cc )) kappa = 2._rp * C_PI * C_RE ** 2._rp * C_ME * C_C ** 2._rp BREM_p ( cc ) =- 2._rp * ne ( cc ) * kappa * Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * & C_a / C_PI * ( gam ( cc ) - 1._rp ) * ( log ( 2._rp * gam ( cc )) - 1._rp / 3._rp ) dp ( cc ) = dp ( cc ) + ( SC_p ( cc ) + BREM_p ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) dxi ( cc ) = dxi ( cc ) + ( SC_mu ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) end do !$OMP END SIMD end if end if !$OMP SIMD do cc = 1_idef , pchunk pm ( cc ) = pm ( cc ) + dp ( cc ) xi ( cc ) = xi ( cc ) + dxi ( cc ) !          if (pm(cc)<0) pm(cc)=-pm(cc) ! Keep xi between [-1,1] if ( xi ( cc ) > 1 ) then !             write(output_unit_write,'(\"High xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) xi ( cc ) = 1 - mod ( xi ( cc ), 1._rp ) else if ( xi ( cc ) <- 1 ) then xi ( cc ) =- 1 - mod ( xi ( cc ), - 1._rp ) !             write(output_unit_write,'(\"Low xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) endif ! Transform P,xi to p_pll,mu Ppll ( cc ) = pm ( cc ) * xi ( cc ) Pmu ( cc ) = ( pm ( cc ) * pm ( cc ) - Ppll ( cc ) * Ppll ( cc )) / ( 2 * me * Bmag ( cc )) end do !$OMP END SIMD !       write(output_unit_write,'(\"rnd1: \",E17.10)') rnd1 !       write(output_unit_write,'(\"flag: \",I16)') flag !       write(output_unit_write,'(\"CA: \",E17.10)') CAL !       write(output_unit_write,'(\"dCA: \",E17.10)') dCAL !       write(output_unit_write,'(\"CF \",E17.10)') CFL !       write(output_unit_write,'(\"CB: \",E17.10)') CBL !       write(output_unit_write,'(\"dp: \",E17.10)') dp !       write(output_unit_write,'(\"dxi: \",E17.10)') dxi !       write(output_unit_write,'(\"Ppll: \",E17.10)') Ppll !      write(output_unit_write,'(\"Pmu: \",E17.10)') Pmu !       write(output_unit_write,'(\"E_PHI_COL: \",E17.10)') E_PHI do cc = 1_idef , pchunk if (( pm ( cc ). lt . 1._rp ). and . flagCol ( cc ). eq . 1_ip ) then !             write(output_unit_write,'(\"Momentum less than zero\")') !             stop !             write(output_unit_write,'(\"Particle not tracked at: \",E17.10,\" & !                  & with xi: \",E17.10)') time*params%cpp%time, xi(cc) flagCol ( cc ) = 0_ip end if end do !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"dp_rad: \",E17.10)') & !               -gam(1)*pm(1)*(1-xi(1)*xi(1))/ & !               (cparams_ss%taur/Bmag(1)**2)*dt !          write(output_unit_write,'(\"dxi_rad: \",E17.10)') & !               xi(1)*(1-xi(1)*xi(1))/ & !               ((cparams_ss%taur/Bmag(1)**2)*gam(1))*dt !       end if !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"CA: \",E17.10)') CAL(1) !          write(output_unit_write,'(\"dCA: \",E17.10)') dCAL(1) !          write(output_unit_write,'(\"CF \",E17.10)') CFL(1) !          write(output_unit_write,'(\"CB: \",E17.10)') CBL(1) !       end if if (. not . params % FokPlan ) E_PHI = E_PHI0 end if end subroutine include_CoulombCollisions_GCm3dc1_p subroutine save_params_ms ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simulation_parameters.h5\" call h5fopen_f ( TRIM ( filename ), H5F_ACC_RDWR_F , h5file_id , h5error ) gname = \"collisions_ms\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( cparams_ms % num_impurity_species )) dset = TRIM ( gname ) // \"/model\" call save_string_parameter ( h5file_id , dset ,( / params % collisions_model / )) dset = TRIM ( gname ) // \"/num_impurity_species\" attr = \"Number of impurity species\" call save_to_hdf5 ( h5file_id , dset , cparams_ms % num_impurity_species , attr ) dset = TRIM ( gname ) // \"/Te\" attr = \"Background electron temperature in eV\" units = params % cpp % temperature / C_E call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % Te , attr ) dset = TRIM ( gname ) // \"/ne\" attr = \"Background electron density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % ne , attr ) dset = TRIM ( gname ) // \"/nH\" attr = \"Background proton density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % nH , attr ) dset = TRIM ( gname ) // \"/nef\" attr = \"Free electron density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % nef , attr ) dset = TRIM ( gname ) // \"/neb\" attr_array ( 1 ) = \"Bound electron density per impurity in m&#94;-3\" units = params % cpp % density call save_1d_array_to_hdf5 ( h5file_id , dset , units * cparams_ms % neb , & attr_array ) dset = TRIM ( gname ) // \"/Zo\" attr_array ( 1 ) = \"Full nuclear charge of impurities\" call save_1d_array_to_hdf5 ( h5file_id , dset , cparams_ms % Zo , attr_array ) dset = TRIM ( gname ) // \"/Zj\" attr_array ( 1 ) = \"Average charge state of impurities\" call save_1d_array_to_hdf5 ( h5file_id , dset , cparams_ms % Zj , attr_array ) dset = TRIM ( gname ) // \"/nz\" attr_array ( 1 ) = \"Density of impurities in m&#94;-3\" units = params % cpp % density call save_1d_array_to_hdf5 ( h5file_id , dset , units * cparams_ms % nz , attr_array ) dset = TRIM ( gname ) // \"/IZj\" attr_array ( 1 ) = \" Ionization energy of impurities in eV\" units = params % cpp % energy / C_E call save_1d_array_to_hdf5 ( h5file_id , dset , units * cparams_ms % IZj , & attr_array ) dset = TRIM ( gname ) // \"/rD\" attr = \"Debye length in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % rD , attr ) dset = TRIM ( gname ) // \"/re\" attr = \"Classical electron radius in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % re , attr ) DEALLOCATE ( attr_array ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if end subroutine save_params_ms subroutine save_params_ss ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simulation_parameters.h5\" call h5fopen_f ( TRIM ( filename ), H5F_ACC_RDWR_F , h5file_id , h5error ) gname = \"collisions_ss\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( cparams_ms % num_impurity_species )) dset = TRIM ( gname ) // \"/collisions_model\" call save_string_parameter ( h5file_id , dset ,( / params % collisions_model / )) dset = TRIM ( gname ) // \"/Te\" attr = \"Background electron temperature in eV\" units = params % cpp % temperature / C_E call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Te , attr ) dset = TRIM ( gname ) // \"/Ti\" attr = \"Background ion temperature in eV\" units = params % cpp % temperature / C_E call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Ti , attr ) dset = TRIM ( gname ) // \"/ne\" attr = \"Background electron density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % ne , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective nuclear charge of impurities\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % Zeff , attr ) dset = TRIM ( gname ) // \"/rD\" attr = \"Debye length in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % rD , attr ) dset = TRIM ( gname ) // \"/re\" attr = \"Classical electron radius in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % re , attr ) dset = TRIM ( gname ) // \"/Clogee\" attr = \"Coulomb logarithm\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % CoulombLogee , attr ) dset = TRIM ( gname ) // \"/Clogei\" attr = \"Coulomb logarithm\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % CoulombLogei , attr ) dset = TRIM ( gname ) // \"/VTe\" attr = \"Background electron temperature\" units = params % cpp % velocity call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % VTe , attr ) dset = TRIM ( gname ) // \"/delta\" attr = \"Delta parameter VTe/C\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % delta , attr ) dset = TRIM ( gname ) // \"/Gamma\" attr = \"Gamma coefficient\" units = ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) / params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Gammac , attr ) dset = TRIM ( gname ) // \"/Tau\" attr = \"Relativistic collisional time in s\" units = params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Tau , attr ) dset = TRIM ( gname ) // \"/Tauc\" attr = \"Thermal collisional time in s\" units = params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Tauc , attr ) dset = TRIM ( gname ) // \"/dTau\" attr = \"Subcycling time step in s\" units = params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % dTau * & cparams_ss % Tau , attr ) dset = TRIM ( gname ) // \"/subcycling_iterations\" attr = \"KORC iterations per collision\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % subcycling_iterations , attr ) dset = TRIM ( gname ) // \"/Ec\" attr = \"Critical electric field\" units = params % cpp % Eo call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Ec , attr ) dset = TRIM ( gname ) // \"/ED\" attr = \"Dreicer electric field\" units = params % cpp % Eo call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % ED , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if end subroutine save_params_ss subroutine save_collision_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if (. NOT .( params % restart . OR . params % proceed )) then if ( params % collisions ) then SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) call save_params_ss ( params ) SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call save_params_ms ( params ) CASE ( 'HESSLOW' ) call save_params_ms ( params ) CASE ( 'ROSENBLUTH' ) call save_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call save_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT end if end if end subroutine save_collision_params subroutine deallocate_params_ms () if ( ALLOCATED ( cparams_ms % Zj )) DEALLOCATE ( cparams_ms % Zj ) if ( ALLOCATED ( cparams_ms % Zo )) DEALLOCATE ( cparams_ms % Zo ) if ( ALLOCATED ( cparams_ms % nz )) DEALLOCATE ( cparams_ms % nz ) if ( ALLOCATED ( cparams_ms % neb )) DEALLOCATE ( cparams_ms % neb ) if ( ALLOCATED ( cparams_ms % IZj )) DEALLOCATE ( cparams_ms % IZj ) if ( ALLOCATED ( cparams_ms % Zj )) DEALLOCATE ( cparams_ms % Ee_IZj ) end subroutine deallocate_params_ms subroutine deallocate_collisions_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if ( params % collisions ) then SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) !\t\t\t\twrite(output_unit_write,'(\"Something to be done\")') SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call deallocate_params_ms () CASE ( 'HESSLOW' ) call deallocate_params_ms () CASE ( 'ROSENBLUTH' ) call deallocate_params_ms () CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call deallocate_params_ms () CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT end if end subroutine deallocate_collisions_params end module korc_collisions","tags":"","loc":"sourcefile/korc_collisions.f90.html"},{"title":"special_fun_modules.f90 – KORC-Full Orbit","text":"Contents Modules nrtype nrutil nr special_functions Source Code special_fun_modules.f90 Source Code !> @brief Module containing types used in the modules of the Numerical Recipes book software. !! @details For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". MODULE nrtype INTEGER , PARAMETER :: I4B = SELECTED_INT_KIND ( 9 ) INTEGER , PARAMETER :: I2B = SELECTED_INT_KIND ( 4 ) INTEGER , PARAMETER :: I1B = SELECTED_INT_KIND ( 2 ) INTEGER , PARAMETER :: SP = KIND ( 1.0 ) INTEGER , PARAMETER :: DP = KIND ( 1.0D0 ) INTEGER , PARAMETER :: SPC = KIND (( 1.0 , 1.0 )) INTEGER , PARAMETER :: DPC = KIND (( 1.0D0 , 1.0D0 )) INTEGER , PARAMETER :: LGT = KIND (. true .) REAL ( SP ), PARAMETER :: PI = 3.141592653589793238462643383279502884197_sp REAL ( SP ), PARAMETER :: PIO2 = 1.57079632679489661923132169163975144209858_sp REAL ( SP ), PARAMETER :: TWOPI = 6.283185307179586476925286766559005768394_sp REAL ( SP ), PARAMETER :: SQRT2 = 1.41421356237309504880168872420969807856967_sp REAL ( SP ), PARAMETER :: EULER = 0.5772156649015328606065120900824024310422_sp REAL ( DP ), PARAMETER :: PI_D = 3.141592653589793238462643383279502884197_dp REAL ( DP ), PARAMETER :: PIO2_D = 1.57079632679489661923132169163975144209858_dp REAL ( DP ), PARAMETER :: TWOPI_D = 6.283185307179586476925286766559005768394_dp TYPE sprs2_sp INTEGER ( I4B ) :: n , len REAL ( SP ), DIMENSION (:), POINTER :: val INTEGER ( I4B ), DIMENSION (:), POINTER :: irow INTEGER ( I4B ), DIMENSION (:), POINTER :: jcol END TYPE sprs2_sp TYPE sprs2_dp INTEGER ( I4B ) :: n , len REAL ( DP ), DIMENSION (:), POINTER :: val INTEGER ( I4B ), DIMENSION (:), POINTER :: irow INTEGER ( I4B ), DIMENSION (:), POINTER :: jcol END TYPE sprs2_dp ! This is to suppress the ranlib \"has no symbols\" message integer , private :: private_dummy END MODULE nrtype !> @brief Module containing interfaces used in the modules of the Numerical Recipes book software. !! @details For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". MODULE nrutil USE nrtype IMPLICIT NONE INTEGER ( I4B ), PARAMETER :: NPAR_ARTH = 16 , NPAR2_ARTH = 8 INTEGER ( I4B ), PARAMETER :: NPAR_GEOP = 4 , NPAR2_GEOP = 2 INTEGER ( I4B ), PARAMETER :: NPAR_CUMSUM = 16 INTEGER ( I4B ), PARAMETER :: NPAR_CUMPROD = 8 INTEGER ( I4B ), PARAMETER :: NPAR_POLY = 8 INTEGER ( I4B ), PARAMETER :: NPAR_POLYTERM = 8 INTERFACE array_copy MODULE PROCEDURE array_copy_r , array_copy_d , array_copy_i END INTERFACE INTERFACE swap MODULE PROCEDURE swap_i , swap_r , swap_rv , swap_c , & swap_cv , swap_cm , swap_z , swap_zv , swap_zm , & masked_swap_rs , masked_swap_rv , masked_swap_rm END INTERFACE INTERFACE reallocate MODULE PROCEDURE reallocate_rv , reallocate_rm ,& reallocate_iv , reallocate_im , reallocate_hv END INTERFACE INTERFACE imaxloc MODULE PROCEDURE imaxloc_r , imaxloc_i END INTERFACE INTERFACE assert MODULE PROCEDURE assert1 , assert2 , assert3 , assert4 , assert_v END INTERFACE INTERFACE assert_eq MODULE PROCEDURE assert_eq2 , assert_eq3 , assert_eq4 , assert_eqn END INTERFACE INTERFACE arth MODULE PROCEDURE arth_r , arth_d , arth_i END INTERFACE INTERFACE geop MODULE PROCEDURE geop_r , geop_d , geop_i , geop_c , geop_dv END INTERFACE INTERFACE cumsum MODULE PROCEDURE cumsum_r , cumsum_i END INTERFACE INTERFACE poly MODULE PROCEDURE poly_rr , poly_rrv , poly_dd , poly_ddv ,& poly_rc , poly_cc , poly_msk_rrv , poly_msk_ddv END INTERFACE INTERFACE poly_term MODULE PROCEDURE poly_term_rr , poly_term_cc END INTERFACE INTERFACE outerprod MODULE PROCEDURE outerprod_r , outerprod_d END INTERFACE INTERFACE outerdiff MODULE PROCEDURE outerdiff_r , outerdiff_d , outerdiff_i END INTERFACE INTERFACE scatter_add MODULE PROCEDURE scatter_add_r , scatter_add_d END INTERFACE INTERFACE scatter_max MODULE PROCEDURE scatter_max_r , scatter_max_d END INTERFACE INTERFACE diagadd MODULE PROCEDURE diagadd_rv , diagadd_r END INTERFACE INTERFACE diagmult MODULE PROCEDURE diagmult_rv , diagmult_r END INTERFACE INTERFACE get_diag MODULE PROCEDURE get_diag_rv , get_diag_dv END INTERFACE INTERFACE put_diag MODULE PROCEDURE put_diag_rv , put_diag_r END INTERFACE CONTAINS !BL SUBROUTINE array_copy_r ( src , dest , n_copied , n_not_copied ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: src REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dest INTEGER ( I4B ), INTENT ( OUT ) :: n_copied , n_not_copied n_copied = min ( size ( src ), size ( dest )) n_not_copied = size ( src ) - n_copied dest ( 1 : n_copied ) = src ( 1 : n_copied ) END SUBROUTINE array_copy_r !BL SUBROUTINE array_copy_d ( src , dest , n_copied , n_not_copied ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: src REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: dest INTEGER ( I4B ), INTENT ( OUT ) :: n_copied , n_not_copied n_copied = min ( size ( src ), size ( dest )) n_not_copied = size ( src ) - n_copied dest ( 1 : n_copied ) = src ( 1 : n_copied ) END SUBROUTINE array_copy_d !BL SUBROUTINE array_copy_i ( src , dest , n_copied , n_not_copied ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: src INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: dest INTEGER ( I4B ), INTENT ( OUT ) :: n_copied , n_not_copied n_copied = min ( size ( src ), size ( dest )) n_not_copied = size ( src ) - n_copied dest ( 1 : n_copied ) = src ( 1 : n_copied ) END SUBROUTINE array_copy_i !BL !BL SUBROUTINE swap_i ( a , b ) INTEGER ( I4B ), INTENT ( INOUT ) :: a , b INTEGER ( I4B ) :: dum dum = a a = b b = dum END SUBROUTINE swap_i !BL SUBROUTINE swap_r ( a , b ) REAL ( SP ), INTENT ( INOUT ) :: a , b REAL ( SP ) :: dum dum = a a = b b = dum END SUBROUTINE swap_r !BL SUBROUTINE swap_rv ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a , b REAL ( SP ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_rv !BL SUBROUTINE swap_c ( a , b ) COMPLEX ( SPC ), INTENT ( INOUT ) :: a , b COMPLEX ( SPC ) :: dum dum = a a = b b = dum END SUBROUTINE swap_c !BL SUBROUTINE swap_cv ( a , b ) COMPLEX ( SPC ), DIMENSION (:), INTENT ( INOUT ) :: a , b COMPLEX ( SPC ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cv !BL SUBROUTINE swap_cm ( a , b ) COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b COMPLEX ( SPC ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cm !BL SUBROUTINE swap_z ( a , b ) COMPLEX ( DPC ), INTENT ( INOUT ) :: a , b COMPLEX ( DPC ) :: dum dum = a a = b b = dum END SUBROUTINE swap_z !BL SUBROUTINE swap_zv ( a , b ) COMPLEX ( DPC ), DIMENSION (:), INTENT ( INOUT ) :: a , b COMPLEX ( DPC ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_zv !BL SUBROUTINE swap_zm ( a , b ) COMPLEX ( DPC ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b COMPLEX ( DPC ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: dum dum = a a = b b = dum END SUBROUTINE swap_zm !BL SUBROUTINE masked_swap_rs ( a , b , mask ) REAL ( SP ), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), INTENT ( IN ) :: mask REAL ( SP ) :: swp if ( mask ) then swp = a a = b b = swp end if END SUBROUTINE masked_swap_rs !BL SUBROUTINE masked_swap_rv ( a , b , mask ) REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( SP ), DIMENSION ( size ( a )) :: swp where ( mask ) swp = a a = b b = swp end where END SUBROUTINE masked_swap_rv !BL SUBROUTINE masked_swap_rm ( a , b , mask ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:,:), INTENT ( IN ) :: mask REAL ( SP ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: swp where ( mask ) swp = a a = b b = swp end where END SUBROUTINE masked_swap_rm !BL !BL FUNCTION reallocate_rv ( p , n ) REAL ( SP ), DIMENSION (:), POINTER :: p , reallocate_rv INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ) :: nold , ierr allocate ( reallocate_rv ( n ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_rv: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p ) reallocate_rv ( 1 : min ( nold , n )) = p ( 1 : min ( nold , n )) deallocate ( p ) END FUNCTION reallocate_rv !BL FUNCTION reallocate_iv ( p , n ) INTEGER ( I4B ), DIMENSION (:), POINTER :: p , reallocate_iv INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ) :: nold , ierr allocate ( reallocate_iv ( n ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_iv: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p ) reallocate_iv ( 1 : min ( nold , n )) = p ( 1 : min ( nold , n )) deallocate ( p ) END FUNCTION reallocate_iv !BL FUNCTION reallocate_hv ( p , n ) CHARACTER ( 1 ), DIMENSION (:), POINTER :: p , reallocate_hv INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ) :: nold , ierr allocate ( reallocate_hv ( n ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_hv: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p ) reallocate_hv ( 1 : min ( nold , n )) = p ( 1 : min ( nold , n )) deallocate ( p ) END FUNCTION reallocate_hv !BL FUNCTION reallocate_rm ( p , n , m ) REAL ( SP ), DIMENSION (:,:), POINTER :: p , reallocate_rm INTEGER ( I4B ), INTENT ( IN ) :: n , m INTEGER ( I4B ) :: nold , mold , ierr allocate ( reallocate_rm ( n , m ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_rm: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p , 1 ) mold = size ( p , 2 ) reallocate_rm ( 1 : min ( nold , n ), 1 : min ( mold , m )) = & p ( 1 : min ( nold , n ), 1 : min ( mold , m )) deallocate ( p ) END FUNCTION reallocate_rm !BL FUNCTION reallocate_im ( p , n , m ) INTEGER ( I4B ), DIMENSION (:,:), POINTER :: p , reallocate_im INTEGER ( I4B ), INTENT ( IN ) :: n , m INTEGER ( I4B ) :: nold , mold , ierr allocate ( reallocate_im ( n , m ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_im: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p , 1 ) mold = size ( p , 2 ) reallocate_im ( 1 : min ( nold , n ), 1 : min ( mold , m )) = & p ( 1 : min ( nold , n ), 1 : min ( mold , m )) deallocate ( p ) END FUNCTION reallocate_im !BL FUNCTION ifirstloc ( mask ) LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask INTEGER ( I4B ) :: ifirstloc INTEGER ( I4B ), DIMENSION ( 1 ) :: loc loc = maxloc ( merge ( 1 , 0 , mask )) ifirstloc = loc ( 1 ) if (. not . mask ( ifirstloc )) ifirstloc = size ( mask ) + 1 END FUNCTION ifirstloc !BL FUNCTION imaxloc_r ( arr ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ) :: imaxloc_r INTEGER ( I4B ), DIMENSION ( 1 ) :: imax imax = maxloc ( arr (:)) imaxloc_r = imax ( 1 ) END FUNCTION imaxloc_r !BL FUNCTION imaxloc_i ( iarr ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: iarr INTEGER ( I4B ), DIMENSION ( 1 ) :: imax INTEGER ( I4B ) :: imaxloc_i imax = maxloc ( iarr (:)) imaxloc_i = imax ( 1 ) END FUNCTION imaxloc_i !BL FUNCTION iminloc ( arr ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION ( 1 ) :: imin INTEGER ( I4B ) :: iminloc imin = minloc ( arr (:)) iminloc = imin ( 1 ) END FUNCTION iminloc !BL SUBROUTINE assert1 ( n1 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 if (. not . n1 ) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert1' end if END SUBROUTINE assert1 !BL SUBROUTINE assert2 ( n1 , n2 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 if (. not . ( n1 . and . n2 )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert2' end if END SUBROUTINE assert2 !BL SUBROUTINE assert3 ( n1 , n2 , n3 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 , n3 if (. not . ( n1 . and . n2 . and . n3 )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert3' end if END SUBROUTINE assert3 !BL SUBROUTINE assert4 ( n1 , n2 , n3 , n4 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 , n3 , n4 if (. not . ( n1 . and . n2 . and . n3 . and . n4 )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert4' end if END SUBROUTINE assert4 !BL SUBROUTINE assert_v ( n , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , DIMENSION (:), INTENT ( IN ) :: n if (. not . all ( n )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert_v' end if END SUBROUTINE assert_v !BL FUNCTION assert_eq2 ( n1 , n2 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 INTEGER :: assert_eq2 if ( n1 == n2 ) then assert_eq2 = n1 else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eq2' end if END FUNCTION assert_eq2 !BL FUNCTION assert_eq3 ( n1 , n2 , n3 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 , n3 INTEGER :: assert_eq3 if ( n1 == n2 . and . n2 == n3 ) then assert_eq3 = n1 else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eq3' end if END FUNCTION assert_eq3 !BL FUNCTION assert_eq4 ( n1 , n2 , n3 , n4 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 , n3 , n4 INTEGER :: assert_eq4 if ( n1 == n2 . and . n2 == n3 . and . n3 == n4 ) then assert_eq4 = n1 else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eq4' end if END FUNCTION assert_eq4 !BL FUNCTION assert_eqn ( nn , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , DIMENSION (:), INTENT ( IN ) :: nn INTEGER :: assert_eqn if ( all ( nn ( 2 :) == nn ( 1 ))) then assert_eqn = nn ( 1 ) else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eqn' end if END FUNCTION assert_eqn !BL SUBROUTINE nrerror ( string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string write ( * , * ) 'nrerror: ' , string STOP 'program terminated by nrerror' END SUBROUTINE nrerror !BL FUNCTION arth_r ( first , increment , n ) REAL ( SP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: arth_r INTEGER ( I4B ) :: k , k2 REAL ( SP ) :: temp if ( n > 0 ) arth_r ( 1 ) = first if ( n <= NPAR_ARTH ) then do k = 2 , n arth_r ( k ) = arth_r ( k - 1 ) + increment end do else do k = 2 , NPAR2_ARTH arth_r ( k ) = arth_r ( k - 1 ) + increment end do temp = increment * NPAR2_ARTH k = NPAR2_ARTH do if ( k >= n ) exit k2 = k + k arth_r ( k + 1 : min ( k2 , n )) = temp + arth_r ( 1 : min ( k , n - k )) temp = temp + temp k = k2 end do end if END FUNCTION arth_r !BL FUNCTION arth_d ( first , increment , n ) REAL ( DP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( n ) :: arth_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp if ( n > 0 ) arth_d ( 1 ) = first if ( n <= NPAR_ARTH ) then do k = 2 , n arth_d ( k ) = arth_d ( k - 1 ) + increment end do else do k = 2 , NPAR2_ARTH arth_d ( k ) = arth_d ( k - 1 ) + increment end do temp = increment * NPAR2_ARTH k = NPAR2_ARTH do if ( k >= n ) exit k2 = k + k arth_d ( k + 1 : min ( k2 , n )) = temp + arth_d ( 1 : min ( k , n - k )) temp = temp + temp k = k2 end do end if END FUNCTION arth_d !BL FUNCTION arth_i ( first , increment , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , increment , n INTEGER ( I4B ), DIMENSION ( n ) :: arth_i INTEGER ( I4B ) :: k , k2 , temp if ( n > 0 ) arth_i ( 1 ) = first if ( n <= NPAR_ARTH ) then do k = 2 , n arth_i ( k ) = arth_i ( k - 1 ) + increment end do else do k = 2 , NPAR2_ARTH arth_i ( k ) = arth_i ( k - 1 ) + increment end do temp = increment * NPAR2_ARTH k = NPAR2_ARTH do if ( k >= n ) exit k2 = k + k arth_i ( k + 1 : min ( k2 , n )) = temp + arth_i ( 1 : min ( k , n - k )) temp = temp + temp k = k2 end do end if END FUNCTION arth_i !BL !BL FUNCTION geop_r ( first , factor , n ) REAL ( SP ), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: geop_r INTEGER ( I4B ) :: k , k2 REAL ( SP ) :: temp if ( n > 0 ) geop_r ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_r ( k ) = geop_r ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_r ( k ) = geop_r ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_r ( k + 1 : min ( k2 , n )) = temp * geop_r ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_r !BL FUNCTION geop_d ( first , factor , n ) REAL ( DP ), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( n ) :: geop_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp if ( n > 0 ) geop_d ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_d ( k ) = geop_d ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_d ( k ) = geop_d ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_d ( k + 1 : min ( k2 , n )) = temp * geop_d ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_d !BL FUNCTION geop_i ( first , factor , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , factor , n INTEGER ( I4B ), DIMENSION ( n ) :: geop_i INTEGER ( I4B ) :: k , k2 , temp if ( n > 0 ) geop_i ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_i ( k ) = geop_i ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_i ( k ) = geop_i ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_i ( k + 1 : min ( k2 , n )) = temp * geop_i ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_i !BL FUNCTION geop_c ( first , factor , n ) COMPLEX ( SP ), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n COMPLEX ( SP ), DIMENSION ( n ) :: geop_c INTEGER ( I4B ) :: k , k2 COMPLEX ( SP ) :: temp if ( n > 0 ) geop_c ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_c ( k ) = geop_c ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_c ( k ) = geop_c ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_c ( k + 1 : min ( k2 , n )) = temp * geop_c ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_c !BL FUNCTION geop_dv ( first , factor , n ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( size ( first ), n ) :: geop_dv INTEGER ( I4B ) :: k , k2 REAL ( DP ), DIMENSION ( size ( first )) :: temp if ( n > 0 ) geop_dv (:, 1 ) = first (:) if ( n <= NPAR_GEOP ) then do k = 2 , n geop_dv (:, k ) = geop_dv (:, k - 1 ) * factor (:) end do else do k = 2 , NPAR2_GEOP geop_dv (:, k ) = geop_dv (:, k - 1 ) * factor (:) end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_dv (:, k + 1 : min ( k2 , n )) = geop_dv (:, 1 : min ( k , n - k )) * & spread ( temp , 2 , size ( geop_dv (:, 1 : min ( k , n - k )), 2 )) temp = temp * temp k = k2 end do end if END FUNCTION geop_dv !BL !BL RECURSIVE FUNCTION cumsum_r ( arr , seed ) RESULT ( ans ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr REAL ( SP ), OPTIONAL , INTENT ( IN ) :: seed REAL ( SP ), DIMENSION ( size ( arr )) :: ans INTEGER ( I4B ) :: n , j REAL ( SP ) :: sd n = size ( arr ) if ( n == 0_i4b ) RETURN sd = 0.0_sp if ( present ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) + sd if ( n < NPAR_CUMSUM ) then do j = 2 , n ans ( j ) = ans ( j - 1 ) + arr ( j ) end do else ans ( 2 : n : 2 ) = cumsum_r ( arr ( 2 : n : 2 ) + arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) + arr ( 3 : n : 2 ) end if END FUNCTION cumsum_r !BL RECURSIVE FUNCTION cumsum_i ( arr , seed ) RESULT ( ans ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: seed INTEGER ( I4B ), DIMENSION ( size ( arr )) :: ans INTEGER ( I4B ) :: n , j , sd n = size ( arr ) if ( n == 0_i4b ) RETURN sd = 0_i4b if ( present ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) + sd if ( n < NPAR_CUMSUM ) then do j = 2 , n ans ( j ) = ans ( j - 1 ) + arr ( j ) end do else ans ( 2 : n : 2 ) = cumsum_i ( arr ( 2 : n : 2 ) + arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) + arr ( 3 : n : 2 ) end if END FUNCTION cumsum_i !BL !BL RECURSIVE FUNCTION cumprod ( arr , seed ) RESULT ( ans ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr REAL ( SP ), OPTIONAL , INTENT ( IN ) :: seed REAL ( SP ), DIMENSION ( size ( arr )) :: ans INTEGER ( I4B ) :: n , j REAL ( SP ) :: sd n = size ( arr ) if ( n == 0_i4b ) RETURN sd = 1.0_sp if ( present ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) * sd if ( n < NPAR_CUMPROD ) then do j = 2 , n ans ( j ) = ans ( j - 1 ) * arr ( j ) end do else ans ( 2 : n : 2 ) = cumprod ( arr ( 2 : n : 2 ) * arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) * arr ( 3 : n : 2 ) end if END FUNCTION cumprod !BL !BL FUNCTION poly_rr ( x , coeffs ) REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs REAL ( SP ) :: poly_rr REAL ( SP ) :: pow REAL ( SP ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_rr = 0.0_sp else if ( n < NPAR_POLY ) then poly_rr = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_rr = x * poly_rr + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_sp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_rr = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_rr !BL FUNCTION poly_dd ( x , coeffs ) REAL ( DP ), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: coeffs REAL ( DP ) :: poly_dd REAL ( DP ) :: pow REAL ( DP ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_dd = 0.0_dp else if ( n < NPAR_POLY ) then poly_dd = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_dd = x * poly_dd + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_dp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_dd = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_dd !BL FUNCTION poly_rc ( x , coeffs ) COMPLEX ( SPC ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs COMPLEX ( SPC ) :: poly_rc COMPLEX ( SPC ) :: pow COMPLEX ( SPC ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_rc = 0.0_sp else if ( n < NPAR_POLY ) then poly_rc = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_rc = x * poly_rc + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_sp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_rc = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_rc !BL FUNCTION poly_cc ( x , coeffs ) COMPLEX ( SPC ), INTENT ( IN ) :: x COMPLEX ( SPC ), DIMENSION (:), INTENT ( IN ) :: coeffs COMPLEX ( SPC ) :: poly_cc COMPLEX ( SPC ) :: pow COMPLEX ( SPC ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_cc = 0.0_sp else if ( n < NPAR_POLY ) then poly_cc = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_cc = x * poly_cc + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_sp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_cc = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_cc !BL FUNCTION poly_rrv ( x , coeffs ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x REAL ( SP ), DIMENSION ( size ( x )) :: poly_rrv INTEGER ( I4B ) :: i , n , m m = size ( coeffs ) n = size ( x ) if ( m <= 0 ) then poly_rrv = 0.0_sp else if ( m < n . or . m < NPAR_POLY ) then poly_rrv = coeffs ( m ) do i = m - 1 , 1 , - 1 poly_rrv = x * poly_rrv + coeffs ( i ) end do else do i = 1 , n poly_rrv ( i ) = poly_rr ( x ( i ), coeffs ) end do end if END FUNCTION poly_rrv !BL FUNCTION poly_ddv ( x , coeffs ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x REAL ( DP ), DIMENSION ( size ( x )) :: poly_ddv INTEGER ( I4B ) :: i , n , m m = size ( coeffs ) n = size ( x ) if ( m <= 0 ) then poly_ddv = 0.0_dp else if ( m < n . or . m < NPAR_POLY ) then poly_ddv = coeffs ( m ) do i = m - 1 , 1 , - 1 poly_ddv = x * poly_ddv + coeffs ( i ) end do else do i = 1 , n poly_ddv ( i ) = poly_dd ( x ( i ), coeffs ) end do end if END FUNCTION poly_ddv !BL FUNCTION poly_msk_rrv ( x , coeffs , mask ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( SP ), DIMENSION ( size ( x )) :: poly_msk_rrv poly_msk_rrv = unpack ( poly_rrv ( pack ( x , mask ), coeffs ), mask , 0.0_sp ) END FUNCTION poly_msk_rrv !BL FUNCTION poly_msk_ddv ( x , coeffs , mask ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( DP ), DIMENSION ( size ( x )) :: poly_msk_ddv poly_msk_ddv = unpack ( poly_ddv ( pack ( x , mask ), coeffs ), mask , 0.0_dp ) END FUNCTION poly_msk_ddv !BL !BL RECURSIVE FUNCTION poly_term_rr ( a , b ) RESULT ( u ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a REAL ( SP ), INTENT ( IN ) :: b REAL ( SP ), DIMENSION ( size ( a )) :: u INTEGER ( I4B ) :: n , j n = size ( a ) if ( n <= 0 ) RETURN u ( 1 ) = a ( 1 ) if ( n < NPAR_POLYTERM ) then do j = 2 , n u ( j ) = a ( j ) + b * u ( j - 1 ) end do else u ( 2 : n : 2 ) = poly_term_rr ( a ( 2 : n : 2 ) + a ( 1 : n - 1 : 2 ) * b , b * b ) u ( 3 : n : 2 ) = a ( 3 : n : 2 ) + b * u ( 2 : n - 1 : 2 ) end if END FUNCTION poly_term_rr !BL RECURSIVE FUNCTION poly_term_cc ( a , b ) RESULT ( u ) COMPLEX ( SPC ), DIMENSION (:), INTENT ( IN ) :: a COMPLEX ( SPC ), INTENT ( IN ) :: b COMPLEX ( SPC ), DIMENSION ( size ( a )) :: u INTEGER ( I4B ) :: n , j n = size ( a ) if ( n <= 0 ) RETURN u ( 1 ) = a ( 1 ) if ( n < NPAR_POLYTERM ) then do j = 2 , n u ( j ) = a ( j ) + b * u ( j - 1 ) end do else u ( 2 : n : 2 ) = poly_term_cc ( a ( 2 : n : 2 ) + a ( 1 : n - 1 : 2 ) * b , b * b ) u ( 3 : n : 2 ) = a ( 3 : n : 2 ) + b * u ( 2 : n - 1 : 2 ) end if END FUNCTION poly_term_cc !BL !BL FUNCTION zroots_unity ( n , nn ) INTEGER ( I4B ), INTENT ( IN ) :: n , nn COMPLEX ( SPC ), DIMENSION ( nn ) :: zroots_unity INTEGER ( I4B ) :: k REAL ( SP ) :: theta zroots_unity ( 1 ) = 1.0 theta = TWOPI / n k = 1 do if ( k >= nn ) exit zroots_unity ( k + 1 ) = cmplx ( cos ( k * theta ), sin ( k * theta ), SPC ) zroots_unity ( k + 2 : min ( 2 * k , nn )) = zroots_unity ( k + 1 ) * & zroots_unity ( 2 : min ( k , nn - k )) k = 2 * k end do END FUNCTION zroots_unity !BL FUNCTION outerprod_r ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerprod_r outerprod_r = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerprod_r !BL FUNCTION outerprod_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( size ( a ), size ( b )) :: outerprod_d outerprod_d = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerprod_d !BL FUNCTION outerdiv ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerdiv outerdiv = spread ( a , dim = 2 , ncopies = size ( b )) / & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiv !BL FUNCTION outersum ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outersum outersum = spread ( a , dim = 2 , ncopies = size ( b )) + & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outersum !BL FUNCTION outerdiff_r ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerdiff_r outerdiff_r = spread ( a , dim = 2 , ncopies = size ( b )) - & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiff_r !BL FUNCTION outerdiff_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( size ( a ), size ( b )) :: outerdiff_d outerdiff_d = spread ( a , dim = 2 , ncopies = size ( b )) - & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiff_d !BL FUNCTION outerdiff_i ( a , b ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: a , b INTEGER ( I4B ), DIMENSION ( size ( a ), size ( b )) :: outerdiff_i outerdiff_i = spread ( a , dim = 2 , ncopies = size ( b )) - & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiff_i !BL FUNCTION outerand ( a , b ) LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: a , b LOGICAL ( LGT ), DIMENSION ( size ( a ), size ( b )) :: outerand outerand = spread ( a , dim = 2 , ncopies = size ( b )) . and . & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerand !BL SUBROUTINE scatter_add_r ( dest , source , dest_index ) REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_add_r' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = dest ( i ) + source ( j ) end do END SUBROUTINE scatter_add_r SUBROUTINE scatter_add_d ( dest , source , dest_index ) REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_add_d' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = dest ( i ) + source ( j ) end do END SUBROUTINE scatter_add_d SUBROUTINE scatter_max_r ( dest , source , dest_index ) REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_max_r' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = max ( dest ( i ), source ( j )) end do END SUBROUTINE scatter_max_r SUBROUTINE scatter_max_d ( dest , source , dest_index ) REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_max_d' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = max ( dest ( i ), source ( j )) end do END SUBROUTINE scatter_max_d !BL SUBROUTINE diagadd_rv ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = assert_eq2 ( size ( diag ), min ( size ( mat , 1 ), size ( mat , 2 )), 'diagadd_rv' ) do j = 1 , n mat ( j , j ) = mat ( j , j ) + diag ( j ) end do END SUBROUTINE diagadd_rv !BL SUBROUTINE diagadd_r ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = min ( size ( mat , 1 ), size ( mat , 2 )) do j = 1 , n mat ( j , j ) = mat ( j , j ) + diag end do END SUBROUTINE diagadd_r !BL SUBROUTINE diagmult_rv ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = assert_eq2 ( size ( diag ), min ( size ( mat , 1 ), size ( mat , 2 )), 'diagmult_rv' ) do j = 1 , n mat ( j , j ) = mat ( j , j ) * diag ( j ) end do END SUBROUTINE diagmult_rv !BL SUBROUTINE diagmult_r ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = min ( size ( mat , 1 ), size ( mat , 2 )) do j = 1 , n mat ( j , j ) = mat ( j , j ) * diag end do END SUBROUTINE diagmult_r !BL FUNCTION get_diag_rv ( mat ) REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: mat REAL ( SP ), DIMENSION ( size ( mat , 1 )) :: get_diag_rv INTEGER ( I4B ) :: j j = assert_eq2 ( size ( mat , 1 ), size ( mat , 2 ), 'get_diag_rv' ) do j = 1 , size ( mat , 1 ) get_diag_rv ( j ) = mat ( j , j ) end do END FUNCTION get_diag_rv !BL FUNCTION get_diag_dv ( mat ) REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: mat REAL ( DP ), DIMENSION ( size ( mat , 1 )) :: get_diag_dv INTEGER ( I4B ) :: j j = assert_eq2 ( size ( mat , 1 ), size ( mat , 2 ), 'get_diag_dv' ) do j = 1 , size ( mat , 1 ) get_diag_dv ( j ) = mat ( j , j ) end do END FUNCTION get_diag_dv !BL SUBROUTINE put_diag_rv ( diagv , mat ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: diagv REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat INTEGER ( I4B ) :: j , n n = assert_eq2 ( size ( diagv ), min ( size ( mat , 1 ), size ( mat , 2 )), 'put_diag_rv' ) do j = 1 , n mat ( j , j ) = diagv ( j ) end do END SUBROUTINE put_diag_rv !BL SUBROUTINE put_diag_r ( scal , mat ) REAL ( SP ), INTENT ( IN ) :: scal REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat INTEGER ( I4B ) :: j , n n = min ( size ( mat , 1 ), size ( mat , 2 )) do j = 1 , n mat ( j , j ) = scal end do END SUBROUTINE put_diag_r !BL SUBROUTINE unit_matrix ( mat ) REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: mat INTEGER ( I4B ) :: i , n n = min ( size ( mat , 1 ), size ( mat , 2 )) mat (:,:) = 0.0_sp do i = 1 , n mat ( i , i ) = 1.0_sp end do END SUBROUTINE unit_matrix !BL FUNCTION upper_triangle ( j , k , extra ) INTEGER ( I4B ), INTENT ( IN ) :: j , k INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: extra LOGICAL ( LGT ), DIMENSION ( j , k ) :: upper_triangle INTEGER ( I4B ) :: n n = 0 if ( present ( extra )) n = extra upper_triangle = ( outerdiff ( arth_i ( 1 , 1 , j ), arth_i ( 1 , 1 , k )) < n ) END FUNCTION upper_triangle !BL FUNCTION lower_triangle ( j , k , extra ) INTEGER ( I4B ), INTENT ( IN ) :: j , k INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: extra LOGICAL ( LGT ), DIMENSION ( j , k ) :: lower_triangle INTEGER ( I4B ) :: n n = 0 if ( present ( extra )) n = extra lower_triangle = ( outerdiff ( arth_i ( 1 , 1 , j ), arth_i ( 1 , 1 , k )) > - n ) END FUNCTION lower_triangle !BL FUNCTION vabs ( v ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: v REAL ( SP ) :: vabs vabs = SQRT ( dot_product ( v , v )) END FUNCTION vabs !BL END MODULE nrutil !> @brief Module containing interfaces used in the modules of the Numerical Recipes book software. !! @details For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". MODULE nr INTERFACE SUBROUTINE airy ( x , ai , bi , aip , bip ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: ai , bi , aip , bip END SUBROUTINE airy END INTERFACE INTERFACE SUBROUTINE amebsa ( p , y , pb , yb , ftol , func , iter , temptr ) USE nrtype INTEGER ( I4B ), INTENT ( INOUT ) :: iter REAL ( SP ), INTENT ( INOUT ) :: yb REAL ( SP ), INTENT ( IN ) :: ftol , temptr REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y , pb REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: p INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE amebsa END INTERFACE INTERFACE SUBROUTINE amoeba ( p , y , ftol , func , iter ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: iter REAL ( SP ), INTENT ( IN ) :: ftol REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: p INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE amoeba END INTERFACE INTERFACE SUBROUTINE anneal ( x , y , iorder ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( INOUT ) :: iorder REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y END SUBROUTINE anneal END INTERFACE INTERFACE SUBROUTINE asolve ( b , x , itrnsp ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: b REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: x INTEGER ( I4B ), INTENT ( IN ) :: itrnsp END SUBROUTINE asolve END INTERFACE INTERFACE SUBROUTINE atimes ( x , r , itrnsp ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: r INTEGER ( I4B ), INTENT ( IN ) :: itrnsp END SUBROUTINE atimes END INTERFACE INTERFACE SUBROUTINE avevar ( data , ave , var ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data REAL ( SP ), INTENT ( OUT ) :: ave , var END SUBROUTINE avevar END INTERFACE INTERFACE SUBROUTINE balanc ( a ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a END SUBROUTINE balanc END INTERFACE INTERFACE SUBROUTINE banbks ( a , m1 , m2 , al , indx , b ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: m1 , m2 INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: indx REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a , al REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: b END SUBROUTINE banbks END INTERFACE INTERFACE SUBROUTINE bandec ( a , m1 , m2 , al , indx , d ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: m1 , m2 INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: indx REAL ( SP ), INTENT ( OUT ) :: d REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: al END SUBROUTINE bandec END INTERFACE INTERFACE SUBROUTINE banmul ( a , m1 , m2 , x , b ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: m1 , m2 REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: b REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a END SUBROUTINE banmul END INTERFACE INTERFACE SUBROUTINE bcucof ( y , y1 , y2 , y12 , d1 , d2 , c ) USE nrtype REAL ( SP ), INTENT ( IN ) :: d1 , d2 REAL ( SP ), DIMENSION ( 4 ), INTENT ( IN ) :: y , y1 , y2 , y12 REAL ( SP ), DIMENSION ( 4 , 4 ), INTENT ( OUT ) :: c END SUBROUTINE bcucof END INTERFACE INTERFACE SUBROUTINE bcuint ( y , y1 , y2 , y12 , x1l , x1u , x2l , x2u , x1 , x2 , ansy ,& ansy1 , ansy2 ) USE nrtype REAL ( SP ), DIMENSION ( 4 ), INTENT ( IN ) :: y , y1 , y2 , y12 REAL ( SP ), INTENT ( IN ) :: x1l , x1u , x2l , x2u , x1 , x2 REAL ( SP ), INTENT ( OUT ) :: ansy , ansy1 , ansy2 END SUBROUTINE bcuint END INTERFACE INTERFACE beschb SUBROUTINE beschb_s ( x , gam1 , gam2 , gampl , gammi ) USE nrtype REAL ( DP ), INTENT ( IN ) :: x REAL ( DP ), INTENT ( OUT ) :: gam1 , gam2 , gampl , gammi END SUBROUTINE beschb_s !BL SUBROUTINE beschb_v ( x , gam1 , gam2 , gampl , gammi ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: gam1 , gam2 , gampl , gammi END SUBROUTINE beschb_v END INTERFACE INTERFACE bessi FUNCTION bessi_s ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessi_s END FUNCTION bessi_s !BL FUNCTION bessi_v ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessi_v END FUNCTION bessi_v END INTERFACE INTERFACE bessi0 FUNCTION bessi0_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessi0_s END FUNCTION bessi0_s !BL FUNCTION bessi0_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessi0_v END FUNCTION bessi0_v END INTERFACE INTERFACE bessi1 FUNCTION bessi1_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessi1_s END FUNCTION bessi1_s !BL FUNCTION bessi1_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessi1_v END FUNCTION bessi1_v END INTERFACE INTERFACE SUBROUTINE bessik ( x , xnu , ri , rk , rip , rkp ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , xnu REAL ( SP ), INTENT ( OUT ) :: ri , rk , rip , rkp END SUBROUTINE bessik END INTERFACE INTERFACE bessj FUNCTION bessj_s ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessj_s END FUNCTION bessj_s !BL FUNCTION bessj_v ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessj_v END FUNCTION bessj_v END INTERFACE INTERFACE bessj0 FUNCTION bessj0_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessj0_s END FUNCTION bessj0_s !BL FUNCTION bessj0_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessj0_v END FUNCTION bessj0_v END INTERFACE INTERFACE bessj1 FUNCTION bessj1_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessj1_s END FUNCTION bessj1_s !BL FUNCTION bessj1_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessj1_v END FUNCTION bessj1_v END INTERFACE INTERFACE bessjy SUBROUTINE bessjy_s ( x , xnu , rj , ry , rjp , ryp ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , xnu REAL ( SP ), INTENT ( OUT ) :: rj , ry , rjp , ryp END SUBROUTINE bessjy_s !BL SUBROUTINE bessjy_v ( x , xnu , rj , ry , rjp , ryp ) USE nrtype REAL ( SP ), INTENT ( IN ) :: xnu REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: rj , rjp , ry , ryp END SUBROUTINE bessjy_v END INTERFACE INTERFACE bessk FUNCTION bessk_s ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessk_s END FUNCTION bessk_s !BL FUNCTION bessk_v ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessk_v END FUNCTION bessk_v END INTERFACE INTERFACE bessk0 FUNCTION bessk0_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessk0_s END FUNCTION bessk0_s !BL FUNCTION bessk0_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessk0_v END FUNCTION bessk0_v END INTERFACE INTERFACE bessk1 FUNCTION bessk1_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessk1_s END FUNCTION bessk1_s !BL FUNCTION bessk1_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessk1_v END FUNCTION bessk1_v END INTERFACE INTERFACE bessy FUNCTION bessy_s ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessy_s END FUNCTION bessy_s !BL FUNCTION bessy_v ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessy_v END FUNCTION bessy_v END INTERFACE INTERFACE bessy0 FUNCTION bessy0_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessy0_s END FUNCTION bessy0_s !BL FUNCTION bessy0_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessy0_v END FUNCTION bessy0_v END INTERFACE INTERFACE bessy1 FUNCTION bessy1_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: bessy1_s END FUNCTION bessy1_s !BL FUNCTION bessy1_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: bessy1_v END FUNCTION bessy1_v END INTERFACE INTERFACE beta FUNCTION beta_s ( z , w ) USE nrtype REAL ( SP ), INTENT ( IN ) :: z , w REAL ( SP ) :: beta_s END FUNCTION beta_s !BL FUNCTION beta_v ( z , w ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: z , w REAL ( SP ), DIMENSION ( size ( z )) :: beta_v END FUNCTION beta_v END INTERFACE INTERFACE betacf FUNCTION betacf_s ( a , b , x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b , x REAL ( SP ) :: betacf_s END FUNCTION betacf_s !BL FUNCTION betacf_v ( a , b , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b , x REAL ( SP ), DIMENSION ( size ( x )) :: betacf_v END FUNCTION betacf_v END INTERFACE INTERFACE betai FUNCTION betai_s ( a , b , x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b , x REAL ( SP ) :: betai_s END FUNCTION betai_s !BL FUNCTION betai_v ( a , b , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b , x REAL ( SP ), DIMENSION ( size ( a )) :: betai_v END FUNCTION betai_v END INTERFACE INTERFACE bico FUNCTION bico_s ( n , k ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n , k REAL ( SP ) :: bico_s END FUNCTION bico_s !BL FUNCTION bico_v ( n , k ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: n , k REAL ( SP ), DIMENSION ( size ( n )) :: bico_v END FUNCTION bico_v END INTERFACE INTERFACE FUNCTION bnldev ( pp , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: pp INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ) :: bnldev END FUNCTION bnldev END INTERFACE INTERFACE FUNCTION brent ( ax , bx , cx , func , tol , xmin ) USE nrtype REAL ( SP ), INTENT ( IN ) :: ax , bx , cx , tol REAL ( SP ), INTENT ( OUT ) :: xmin REAL ( SP ) :: brent INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION brent END INTERFACE INTERFACE SUBROUTINE broydn ( x , check ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: x LOGICAL ( LGT ), INTENT ( OUT ) :: check END SUBROUTINE broydn END INTERFACE INTERFACE SUBROUTINE bsstep ( y , dydx , x , htry , eps , yscal , hdid , hnext , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: dydx , yscal REAL ( SP ), INTENT ( INOUT ) :: x REAL ( SP ), INTENT ( IN ) :: htry , eps REAL ( SP ), INTENT ( OUT ) :: hdid , hnext INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE bsstep END INTERFACE INTERFACE SUBROUTINE caldat ( julian , mm , id , iyyy ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: julian INTEGER ( I4B ), INTENT ( OUT ) :: mm , id , iyyy END SUBROUTINE caldat END INTERFACE INTERFACE FUNCTION chder ( a , b , c ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ), DIMENSION ( size ( c )) :: chder END FUNCTION chder END INTERFACE INTERFACE chebev FUNCTION chebev_s ( a , b , c , x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b , x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ) :: chebev_s END FUNCTION chebev_s !BL FUNCTION chebev_v ( a , b , c , x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c , x REAL ( SP ), DIMENSION ( size ( x )) :: chebev_v END FUNCTION chebev_v END INTERFACE INTERFACE FUNCTION chebft ( a , b , n , func ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: chebft INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END FUNCTION chebft END INTERFACE INTERFACE FUNCTION chebpc ( c ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ), DIMENSION ( size ( c )) :: chebpc END FUNCTION chebpc END INTERFACE INTERFACE FUNCTION chint ( a , b , c ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ), DIMENSION ( size ( c )) :: chint END FUNCTION chint END INTERFACE INTERFACE SUBROUTINE choldc ( a , p ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: p END SUBROUTINE choldc END INTERFACE INTERFACE SUBROUTINE cholsl ( a , p , b , x ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: p , b REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: x END SUBROUTINE cholsl END INTERFACE INTERFACE SUBROUTINE chsone ( bins , ebins , knstrn , df , chsq , prob ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: knstrn REAL ( SP ), INTENT ( OUT ) :: df , chsq , prob REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: bins , ebins END SUBROUTINE chsone END INTERFACE INTERFACE SUBROUTINE chstwo ( bins1 , bins2 , knstrn , df , chsq , prob ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: knstrn REAL ( SP ), INTENT ( OUT ) :: df , chsq , prob REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: bins1 , bins2 END SUBROUTINE chstwo END INTERFACE INTERFACE SUBROUTINE cisi ( x , ci , si ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: ci , si END SUBROUTINE cisi END INTERFACE INTERFACE SUBROUTINE cntab1 ( nn , chisq , df , prob , cramrv , ccc ) USE nrtype INTEGER ( I4B ), DIMENSION (:,:), INTENT ( IN ) :: nn REAL ( SP ), INTENT ( OUT ) :: chisq , df , prob , cramrv , ccc END SUBROUTINE cntab1 END INTERFACE INTERFACE SUBROUTINE cntab2 ( nn , h , hx , hy , hygx , hxgy , uygx , uxgy , uxy ) USE nrtype INTEGER ( I4B ), DIMENSION (:,:), INTENT ( IN ) :: nn REAL ( SP ), INTENT ( OUT ) :: h , hx , hy , hygx , hxgy , uygx , uxgy , uxy END SUBROUTINE cntab2 END INTERFACE INTERFACE FUNCTION convlv ( data , respns , isign ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: respns INTEGER ( I4B ), INTENT ( IN ) :: isign REAL ( SP ), DIMENSION ( size ( data )) :: convlv END FUNCTION convlv END INTERFACE INTERFACE FUNCTION correl ( data1 , data2 ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 REAL ( SP ), DIMENSION ( size ( data1 )) :: correl END FUNCTION correl END INTERFACE INTERFACE SUBROUTINE cosft1 ( y ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y END SUBROUTINE cosft1 END INTERFACE INTERFACE SUBROUTINE cosft2 ( y , isign ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE cosft2 END INTERFACE INTERFACE SUBROUTINE covsrt ( covar , maska ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: covar LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: maska END SUBROUTINE covsrt END INTERFACE INTERFACE SUBROUTINE cyclic ( a , b , c , alpha , beta , r , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b , c , r REAL ( SP ), INTENT ( IN ) :: alpha , beta REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x END SUBROUTINE cyclic END INTERFACE INTERFACE SUBROUTINE daub4 ( a , isign ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE daub4 END INTERFACE INTERFACE dawson FUNCTION dawson_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: dawson_s END FUNCTION dawson_s !BL FUNCTION dawson_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: dawson_v END FUNCTION dawson_v END INTERFACE INTERFACE FUNCTION dbrent ( ax , bx , cx , func , dbrent_dfunc , tol , xmin ) USE nrtype REAL ( SP ), INTENT ( IN ) :: ax , bx , cx , tol REAL ( SP ), INTENT ( OUT ) :: xmin REAL ( SP ) :: dbrent INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func !BL FUNCTION dbrent_dfunc ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: dbrent_dfunc END FUNCTION dbrent_dfunc END INTERFACE END FUNCTION dbrent END INTERFACE INTERFACE SUBROUTINE ddpoly ( c , x , pd ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: pd END SUBROUTINE ddpoly END INTERFACE INTERFACE FUNCTION decchk ( string , ch ) USE nrtype CHARACTER ( 1 ), DIMENSION (:), INTENT ( IN ) :: string CHARACTER ( 1 ), INTENT ( OUT ) :: ch LOGICAL ( LGT ) :: decchk END FUNCTION decchk END INTERFACE INTERFACE SUBROUTINE dfpmin ( p , gtol , iter , fret , func , dfunc ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: iter REAL ( SP ), INTENT ( IN ) :: gtol REAL ( SP ), INTENT ( OUT ) :: fret REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: p INTERFACE FUNCTION func ( p ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: p REAL ( SP ) :: func END FUNCTION func !BL FUNCTION dfunc ( p ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: p REAL ( SP ), DIMENSION ( size ( p )) :: dfunc END FUNCTION dfunc END INTERFACE END SUBROUTINE dfpmin END INTERFACE INTERFACE FUNCTION dfridr ( func , x , h , err ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , h REAL ( SP ), INTENT ( OUT ) :: err REAL ( SP ) :: dfridr INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION dfridr END INTERFACE INTERFACE SUBROUTINE dftcor ( w , delta , a , b , endpts , corre , corim , corfac ) USE nrtype REAL ( SP ), INTENT ( IN ) :: w , delta , a , b REAL ( SP ), INTENT ( OUT ) :: corre , corim , corfac REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: endpts END SUBROUTINE dftcor END INTERFACE INTERFACE SUBROUTINE dftint ( func , a , b , w , cosint , sinint ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b , w REAL ( SP ), INTENT ( OUT ) :: cosint , sinint INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END SUBROUTINE dftint END INTERFACE INTERFACE SUBROUTINE difeq ( k , k1 , k2 , jsf , is1 , isf , indexv , s , y ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: is1 , isf , jsf , k , k1 , k2 INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: indexv REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: s REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: y END SUBROUTINE difeq END INTERFACE INTERFACE FUNCTION eclass ( lista , listb , n ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: lista , listb INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ), DIMENSION ( n ) :: eclass END FUNCTION eclass END INTERFACE INTERFACE FUNCTION eclazz ( equiv , n ) USE nrtype INTERFACE FUNCTION equiv ( i , j ) USE nrtype LOGICAL ( LGT ) :: equiv INTEGER ( I4B ), INTENT ( IN ) :: i , j END FUNCTION equiv END INTERFACE INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ), DIMENSION ( n ) :: eclazz END FUNCTION eclazz END INTERFACE INTERFACE FUNCTION ei ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: ei END FUNCTION ei END INTERFACE INTERFACE SUBROUTINE eigsrt ( d , v ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: d REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: v END SUBROUTINE eigsrt END INTERFACE INTERFACE elle FUNCTION elle_s ( phi , ak ) USE nrtype REAL ( SP ), INTENT ( IN ) :: phi , ak REAL ( SP ) :: elle_s END FUNCTION elle_s !BL FUNCTION elle_v ( phi , ak ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: phi , ak REAL ( SP ), DIMENSION ( size ( phi )) :: elle_v END FUNCTION elle_v END INTERFACE INTERFACE ellf FUNCTION ellf_s ( phi , ak ) USE nrtype REAL ( SP ), INTENT ( IN ) :: phi , ak REAL ( SP ) :: ellf_s END FUNCTION ellf_s !BL FUNCTION ellf_v ( phi , ak ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: phi , ak REAL ( SP ), DIMENSION ( size ( phi )) :: ellf_v END FUNCTION ellf_v END INTERFACE INTERFACE ellpi FUNCTION ellpi_s ( phi , en , ak ) USE nrtype REAL ( SP ), INTENT ( IN ) :: phi , en , ak REAL ( SP ) :: ellpi_s END FUNCTION ellpi_s !BL FUNCTION ellpi_v ( phi , en , ak ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: phi , en , ak REAL ( SP ), DIMENSION ( size ( phi )) :: ellpi_v END FUNCTION ellpi_v END INTERFACE INTERFACE SUBROUTINE elmhes ( a ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a END SUBROUTINE elmhes END INTERFACE INTERFACE erf FUNCTION erf_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: erf_s END FUNCTION erf_s !BL FUNCTION erf_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: erf_v END FUNCTION erf_v END INTERFACE INTERFACE erfc FUNCTION erfc_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: erfc_s END FUNCTION erfc_s !BL FUNCTION erfc_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: erfc_v END FUNCTION erfc_v END INTERFACE INTERFACE erfcc FUNCTION erfcc_s ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: erfcc_s END FUNCTION erfcc_s !BL FUNCTION erfcc_v ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: erfcc_v END FUNCTION erfcc_v END INTERFACE INTERFACE SUBROUTINE eulsum ( sum , term , jterm ) USE nrtype REAL ( SP ), INTENT ( INOUT ) :: sum REAL ( SP ), INTENT ( IN ) :: term INTEGER ( I4B ), INTENT ( IN ) :: jterm END SUBROUTINE eulsum END INTERFACE INTERFACE FUNCTION evlmem ( fdt , d , xms ) USE nrtype REAL ( SP ), INTENT ( IN ) :: fdt , xms REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: d REAL ( SP ) :: evlmem END FUNCTION evlmem END INTERFACE INTERFACE expdev SUBROUTINE expdev_s ( harvest ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: harvest END SUBROUTINE expdev_s !BL SUBROUTINE expdev_v ( harvest ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: harvest END SUBROUTINE expdev_v END INTERFACE INTERFACE FUNCTION expint ( n , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: expint END FUNCTION expint END INTERFACE INTERFACE factln FUNCTION factln_s ( n ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ) :: factln_s END FUNCTION factln_s !BL FUNCTION factln_v ( n ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( size ( n )) :: factln_v END FUNCTION factln_v END INTERFACE INTERFACE factrl FUNCTION factrl_s ( n ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ) :: factrl_s END FUNCTION factrl_s !BL FUNCTION factrl_v ( n ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( size ( n )) :: factrl_v END FUNCTION factrl_v END INTERFACE INTERFACE SUBROUTINE fasper ( x , y , ofac , hifac , px , py , jmax , prob ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), INTENT ( IN ) :: ofac , hifac INTEGER ( I4B ), INTENT ( OUT ) :: jmax REAL ( SP ), INTENT ( OUT ) :: prob REAL ( SP ), DIMENSION (:), POINTER :: px , py END SUBROUTINE fasper END INTERFACE INTERFACE SUBROUTINE fdjac ( x , fvec , df ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: fvec REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: x REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: df END SUBROUTINE fdjac END INTERFACE INTERFACE SUBROUTINE fgauss ( x , a , y , dyda ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: y REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: dyda END SUBROUTINE fgauss END INTERFACE INTERFACE SUBROUTINE fit ( x , y , a , b , siga , sigb , chi2 , q , sig ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), INTENT ( OUT ) :: a , b , siga , sigb , chi2 , q REAL ( SP ), DIMENSION (:), OPTIONAL , INTENT ( IN ) :: sig END SUBROUTINE fit END INTERFACE INTERFACE SUBROUTINE fitexy ( x , y , sigx , sigy , a , b , siga , sigb , chi2 , q ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , sigx , sigy REAL ( SP ), INTENT ( OUT ) :: a , b , siga , sigb , chi2 , q END SUBROUTINE fitexy END INTERFACE INTERFACE SUBROUTINE fixrts ( d ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: d END SUBROUTINE fixrts END INTERFACE INTERFACE FUNCTION fleg ( x , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: fleg END FUNCTION fleg END INTERFACE INTERFACE SUBROUTINE flmoon ( n , nph , jd , frac ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n , nph INTEGER ( I4B ), INTENT ( OUT ) :: jd REAL ( SP ), INTENT ( OUT ) :: frac END SUBROUTINE flmoon END INTERFACE INTERFACE four1 SUBROUTINE four1_dp ( data , isign ) USE nrtype COMPLEX ( DPC ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four1_dp !BL SUBROUTINE four1_sp ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four1_sp END INTERFACE INTERFACE SUBROUTINE four1_alt ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four1_alt END INTERFACE INTERFACE SUBROUTINE four1_gather ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four1_gather END INTERFACE INTERFACE SUBROUTINE four2 ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four2 END INTERFACE INTERFACE SUBROUTINE four2_alt ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four2_alt END INTERFACE INTERFACE SUBROUTINE four3 ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four3 END INTERFACE INTERFACE SUBROUTINE four3_alt ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE four3_alt END INTERFACE INTERFACE SUBROUTINE fourcol ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE fourcol END INTERFACE INTERFACE SUBROUTINE fourcol_3d ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE fourcol_3d END INTERFACE INTERFACE SUBROUTINE fourn_gather ( data , nn , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: nn INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE fourn_gather END INTERFACE INTERFACE fourrow SUBROUTINE fourrow_dp ( data , isign ) USE nrtype COMPLEX ( DPC ), DIMENSION (:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE fourrow_dp !BL SUBROUTINE fourrow_sp ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE fourrow_sp END INTERFACE INTERFACE SUBROUTINE fourrow_3d ( data , isign ) USE nrtype COMPLEX ( SPC ), DIMENSION (:,:,:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE fourrow_3d END INTERFACE INTERFACE FUNCTION fpoly ( x , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: fpoly END FUNCTION fpoly END INTERFACE INTERFACE SUBROUTINE fred2 ( a , b , t , f , w , g , ak ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: t , f , w INTERFACE FUNCTION g ( t ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: t REAL ( SP ), DIMENSION ( size ( t )) :: g END FUNCTION g !BL FUNCTION ak ( t , s ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: t , s REAL ( SP ), DIMENSION ( size ( t ), size ( s )) :: ak END FUNCTION ak END INTERFACE END SUBROUTINE fred2 END INTERFACE INTERFACE FUNCTION fredin ( x , a , b , t , f , w , g , ak ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , t , f , w REAL ( SP ), DIMENSION ( size ( x )) :: fredin INTERFACE FUNCTION g ( t ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: t REAL ( SP ), DIMENSION ( size ( t )) :: g END FUNCTION g !BL FUNCTION ak ( t , s ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: t , s REAL ( SP ), DIMENSION ( size ( t ), size ( s )) :: ak END FUNCTION ak END INTERFACE END FUNCTION fredin END INTERFACE INTERFACE SUBROUTINE frenel ( x , s , c ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: s , c END SUBROUTINE frenel END INTERFACE INTERFACE SUBROUTINE frprmn ( p , ftol , iter , fret ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: iter REAL ( SP ), INTENT ( IN ) :: ftol REAL ( SP ), INTENT ( OUT ) :: fret REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: p END SUBROUTINE frprmn END INTERFACE INTERFACE SUBROUTINE ftest ( data1 , data2 , f , prob ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: f , prob REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 END SUBROUTINE ftest END INTERFACE INTERFACE FUNCTION gamdev ( ia ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: ia REAL ( SP ) :: gamdev END FUNCTION gamdev END INTERFACE INTERFACE gammln FUNCTION gammln_s ( xx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: xx REAL ( SP ) :: gammln_s END FUNCTION gammln_s !BL FUNCTION gammln_v ( xx ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xx REAL ( SP ), DIMENSION ( size ( xx )) :: gammln_v END FUNCTION gammln_v END INTERFACE INTERFACE gammp FUNCTION gammp_s ( a , x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , x REAL ( SP ) :: gammp_s END FUNCTION gammp_s !BL FUNCTION gammp_v ( a , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , x REAL ( SP ), DIMENSION ( size ( a )) :: gammp_v END FUNCTION gammp_v END INTERFACE INTERFACE gammq FUNCTION gammq_s ( a , x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , x REAL ( SP ) :: gammq_s END FUNCTION gammq_s !BL FUNCTION gammq_v ( a , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , x REAL ( SP ), DIMENSION ( size ( a )) :: gammq_v END FUNCTION gammq_v END INTERFACE INTERFACE gasdev SUBROUTINE gasdev_s ( harvest ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: harvest END SUBROUTINE gasdev_s !BL SUBROUTINE gasdev_v ( harvest ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: harvest END SUBROUTINE gasdev_v END INTERFACE INTERFACE SUBROUTINE gaucof ( a , b , amu0 , x , w ) USE nrtype REAL ( SP ), INTENT ( IN ) :: amu0 REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x , w END SUBROUTINE gaucof END INTERFACE INTERFACE SUBROUTINE gauher ( x , w ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x , w END SUBROUTINE gauher END INTERFACE INTERFACE SUBROUTINE gaujac ( x , w , alf , bet ) USE nrtype REAL ( SP ), INTENT ( IN ) :: alf , bet REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x , w END SUBROUTINE gaujac END INTERFACE INTERFACE SUBROUTINE gaulag ( x , w , alf ) USE nrtype REAL ( SP ), INTENT ( IN ) :: alf REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x , w END SUBROUTINE gaulag END INTERFACE INTERFACE SUBROUTINE gauleg ( x1 , x2 , x , w ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x , w END SUBROUTINE gauleg END INTERFACE INTERFACE SUBROUTINE gaussj ( a , b ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b END SUBROUTINE gaussj END INTERFACE INTERFACE gcf FUNCTION gcf_s ( a , x , gln ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , x REAL ( SP ), OPTIONAL , INTENT ( OUT ) :: gln REAL ( SP ) :: gcf_s END FUNCTION gcf_s !BL FUNCTION gcf_v ( a , x , gln ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , x REAL ( SP ), DIMENSION (:), OPTIONAL , INTENT ( OUT ) :: gln REAL ( SP ), DIMENSION ( size ( a )) :: gcf_v END FUNCTION gcf_v END INTERFACE INTERFACE FUNCTION golden ( ax , bx , cx , func , tol , xmin ) USE nrtype REAL ( SP ), INTENT ( IN ) :: ax , bx , cx , tol REAL ( SP ), INTENT ( OUT ) :: xmin REAL ( SP ) :: golden INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION golden END INTERFACE INTERFACE gser FUNCTION gser_s ( a , x , gln ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , x REAL ( SP ), OPTIONAL , INTENT ( OUT ) :: gln REAL ( SP ) :: gser_s END FUNCTION gser_s !BL FUNCTION gser_v ( a , x , gln ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , x REAL ( SP ), DIMENSION (:), OPTIONAL , INTENT ( OUT ) :: gln REAL ( SP ), DIMENSION ( size ( a )) :: gser_v END FUNCTION gser_v END INTERFACE INTERFACE SUBROUTINE hqr ( a , wr , wi ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: wr , wi REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a END SUBROUTINE hqr END INTERFACE INTERFACE SUBROUTINE hunt ( xx , x , jlo ) USE nrtype INTEGER ( I4B ), INTENT ( INOUT ) :: jlo REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xx END SUBROUTINE hunt END INTERFACE INTERFACE SUBROUTINE hypdrv ( s , ry , rdyds ) USE nrtype REAL ( SP ), INTENT ( IN ) :: s REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: ry REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: rdyds END SUBROUTINE hypdrv END INTERFACE INTERFACE FUNCTION hypgeo ( a , b , c , z ) USE nrtype COMPLEX ( SPC ), INTENT ( IN ) :: a , b , c , z COMPLEX ( SPC ) :: hypgeo END FUNCTION hypgeo END INTERFACE INTERFACE SUBROUTINE hypser ( a , b , c , z , series , deriv ) USE nrtype COMPLEX ( SPC ), INTENT ( IN ) :: a , b , c , z COMPLEX ( SPC ), INTENT ( OUT ) :: series , deriv END SUBROUTINE hypser END INTERFACE INTERFACE FUNCTION icrc ( crc , buf , jinit , jrev ) USE nrtype CHARACTER ( 1 ), DIMENSION (:), INTENT ( IN ) :: buf INTEGER ( I2B ), INTENT ( IN ) :: crc , jinit INTEGER ( I4B ), INTENT ( IN ) :: jrev INTEGER ( I2B ) :: icrc END FUNCTION icrc END INTERFACE INTERFACE FUNCTION igray ( n , is ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n , is INTEGER ( I4B ) :: igray END FUNCTION igray END INTERFACE INTERFACE RECURSIVE SUBROUTINE index_bypack ( arr , index , partial ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION (:), INTENT ( INOUT ) :: index INTEGER , OPTIONAL , INTENT ( IN ) :: partial END SUBROUTINE index_bypack END INTERFACE INTERFACE indexx SUBROUTINE indexx_sp ( arr , index ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: index END SUBROUTINE indexx_sp SUBROUTINE indexx_i4b ( iarr , index ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: iarr INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: index END SUBROUTINE indexx_i4b END INTERFACE INTERFACE FUNCTION interp ( uc ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: uc REAL ( DP ), DIMENSION ( 2 * size ( uc , 1 ) - 1 , 2 * size ( uc , 1 ) - 1 ) :: interp END FUNCTION interp END INTERFACE INTERFACE FUNCTION rank ( indx ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: indx INTEGER ( I4B ), DIMENSION ( size ( indx )) :: rank END FUNCTION rank END INTERFACE INTERFACE FUNCTION irbit1 ( iseed ) USE nrtype INTEGER ( I4B ), INTENT ( INOUT ) :: iseed INTEGER ( I4B ) :: irbit1 END FUNCTION irbit1 END INTERFACE INTERFACE FUNCTION irbit2 ( iseed ) USE nrtype INTEGER ( I4B ), INTENT ( INOUT ) :: iseed INTEGER ( I4B ) :: irbit2 END FUNCTION irbit2 END INTERFACE INTERFACE SUBROUTINE jacobi ( a , d , v , nrot ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: nrot REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: d REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: v END SUBROUTINE jacobi END INTERFACE INTERFACE SUBROUTINE jacobn ( x , y , dfdx , dfdy ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dfdx REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: dfdy END SUBROUTINE jacobn END INTERFACE INTERFACE FUNCTION julday ( mm , id , iyyy ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: mm , id , iyyy INTEGER ( I4B ) :: julday END FUNCTION julday END INTERFACE INTERFACE SUBROUTINE kendl1 ( data1 , data2 , tau , z , prob ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: tau , z , prob REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 END SUBROUTINE kendl1 END INTERFACE INTERFACE SUBROUTINE kendl2 ( tab , tau , z , prob ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: tab REAL ( SP ), INTENT ( OUT ) :: tau , z , prob END SUBROUTINE kendl2 END INTERFACE INTERFACE FUNCTION kermom ( y , m ) USE nrtype REAL ( DP ), INTENT ( IN ) :: y INTEGER ( I4B ), INTENT ( IN ) :: m REAL ( DP ), DIMENSION ( m ) :: kermom END FUNCTION kermom END INTERFACE INTERFACE SUBROUTINE ks2d1s ( x1 , y1 , quadvl , d1 , prob ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x1 , y1 REAL ( SP ), INTENT ( OUT ) :: d1 , prob INTERFACE SUBROUTINE quadvl ( x , y , fa , fb , fc , fd ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y REAL ( SP ), INTENT ( OUT ) :: fa , fb , fc , fd END SUBROUTINE quadvl END INTERFACE END SUBROUTINE ks2d1s END INTERFACE INTERFACE SUBROUTINE ks2d2s ( x1 , y1 , x2 , y2 , d , prob ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x1 , y1 , x2 , y2 REAL ( SP ), INTENT ( OUT ) :: d , prob END SUBROUTINE ks2d2s END INTERFACE INTERFACE SUBROUTINE ksone ( data , func , d , prob ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: d , prob REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: data INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END SUBROUTINE ksone END INTERFACE INTERFACE SUBROUTINE kstwo ( data1 , data2 , d , prob ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: d , prob REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 END SUBROUTINE kstwo END INTERFACE INTERFACE SUBROUTINE laguer ( a , x , its ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: its COMPLEX ( SPC ), INTENT ( INOUT ) :: x COMPLEX ( SPC ), DIMENSION (:), INTENT ( IN ) :: a END SUBROUTINE laguer END INTERFACE INTERFACE SUBROUTINE lfit ( x , y , sig , a , maska , covar , chisq , funcs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , sig REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: maska REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: covar REAL ( SP ), INTENT ( OUT ) :: chisq INTERFACE SUBROUTINE funcs ( x , arr ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: arr END SUBROUTINE funcs END INTERFACE END SUBROUTINE lfit END INTERFACE INTERFACE SUBROUTINE linbcg ( b , x , itol , tol , itmax , iter , err ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: b REAL ( DP ), DIMENSION (:), INTENT ( INOUT ) :: x INTEGER ( I4B ), INTENT ( IN ) :: itol , itmax REAL ( DP ), INTENT ( IN ) :: tol INTEGER ( I4B ), INTENT ( OUT ) :: iter REAL ( DP ), INTENT ( OUT ) :: err END SUBROUTINE linbcg END INTERFACE INTERFACE SUBROUTINE linmin ( p , xi , fret ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: fret REAL ( SP ), DIMENSION (:), TARGET , INTENT ( INOUT ) :: p , xi END SUBROUTINE linmin END INTERFACE INTERFACE SUBROUTINE lnsrch ( xold , fold , g , p , x , f , stpmax , check , func ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xold , g REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: p REAL ( SP ), INTENT ( IN ) :: fold , stpmax REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x REAL ( SP ), INTENT ( OUT ) :: f LOGICAL ( LGT ), INTENT ( OUT ) :: check INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ) :: func REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x END FUNCTION func END INTERFACE END SUBROUTINE lnsrch END INTERFACE INTERFACE FUNCTION locate ( xx , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xx REAL ( SP ), INTENT ( IN ) :: x INTEGER ( I4B ) :: locate END FUNCTION locate END INTERFACE INTERFACE FUNCTION lop ( u ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: u REAL ( DP ), DIMENSION ( size ( u , 1 ), size ( u , 1 )) :: lop END FUNCTION lop END INTERFACE INTERFACE SUBROUTINE lubksb ( a , indx , b ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: indx REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: b END SUBROUTINE lubksb END INTERFACE INTERFACE SUBROUTINE ludcmp ( a , indx , d ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: indx REAL ( SP ), INTENT ( OUT ) :: d END SUBROUTINE ludcmp END INTERFACE INTERFACE SUBROUTINE machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,& maxexp , eps , epsneg , xmin , xmax ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: ibeta , iexp , irnd , it , machep , maxexp ,& minexp , negep , ngrd REAL ( SP ), INTENT ( OUT ) :: eps , epsneg , xmax , xmin END SUBROUTINE machar END INTERFACE INTERFACE SUBROUTINE medfit ( x , y , a , b , abdev ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), INTENT ( OUT ) :: a , b , abdev END SUBROUTINE medfit END INTERFACE INTERFACE SUBROUTINE memcof ( data , xms , d ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: xms REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: d END SUBROUTINE memcof END INTERFACE INTERFACE SUBROUTINE mgfas ( u , maxcyc ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( INOUT ) :: u INTEGER ( I4B ), INTENT ( IN ) :: maxcyc END SUBROUTINE mgfas END INTERFACE INTERFACE SUBROUTINE mglin ( u , ncycle ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( INOUT ) :: u INTEGER ( I4B ), INTENT ( IN ) :: ncycle END SUBROUTINE mglin END INTERFACE INTERFACE SUBROUTINE midexp ( funk , aa , bb , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: aa , bb REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION funk ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: funk END FUNCTION funk END INTERFACE END SUBROUTINE midexp END INTERFACE INTERFACE SUBROUTINE midinf ( funk , aa , bb , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: aa , bb REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION funk ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: funk END FUNCTION funk END INTERFACE END SUBROUTINE midinf END INTERFACE INTERFACE SUBROUTINE midpnt ( func , a , b , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END SUBROUTINE midpnt END INTERFACE INTERFACE SUBROUTINE midsql ( funk , aa , bb , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: aa , bb REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION funk ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: funk END FUNCTION funk END INTERFACE END SUBROUTINE midsql END INTERFACE INTERFACE SUBROUTINE midsqu ( funk , aa , bb , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: aa , bb REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION funk ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: funk END FUNCTION funk END INTERFACE END SUBROUTINE midsqu END INTERFACE INTERFACE RECURSIVE SUBROUTINE miser ( func , regn , ndim , npts , dith , ave , var ) USE nrtype INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ) :: func REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x END FUNCTION func END INTERFACE REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: regn INTEGER ( I4B ), INTENT ( IN ) :: ndim , npts REAL ( SP ), INTENT ( IN ) :: dith REAL ( SP ), INTENT ( OUT ) :: ave , var END SUBROUTINE miser END INTERFACE INTERFACE SUBROUTINE mmid ( y , dydx , xs , htot , nstep , yout , derivs ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: nstep REAL ( SP ), INTENT ( IN ) :: xs , htot REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y , dydx REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yout INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE mmid END INTERFACE INTERFACE SUBROUTINE mnbrak ( ax , bx , cx , fa , fb , fc , func ) USE nrtype REAL ( SP ), INTENT ( INOUT ) :: ax , bx REAL ( SP ), INTENT ( OUT ) :: cx , fa , fb , fc INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE mnbrak END INTERFACE INTERFACE SUBROUTINE mnewt ( ntrial , x , tolx , tolf , usrfun ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: ntrial REAL ( SP ), INTENT ( IN ) :: tolx , tolf REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: x INTERFACE SUBROUTINE usrfun ( x , fvec , fjac ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: fvec REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: fjac END SUBROUTINE usrfun END INTERFACE END SUBROUTINE mnewt END INTERFACE INTERFACE SUBROUTINE moment ( data , ave , adev , sdev , var , skew , curt ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: ave , adev , sdev , var , skew , curt REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data END SUBROUTINE moment END INTERFACE INTERFACE SUBROUTINE mp2dfr ( a , s , n , m ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ), INTENT ( OUT ) :: m CHARACTER ( 1 ), DIMENSION (:), INTENT ( INOUT ) :: a CHARACTER ( 1 ), DIMENSION (:), INTENT ( OUT ) :: s END SUBROUTINE mp2dfr END INTERFACE INTERFACE SUBROUTINE mpdiv ( q , r , u , v , n , m ) USE nrtype CHARACTER ( 1 ), DIMENSION (:), INTENT ( OUT ) :: q , r CHARACTER ( 1 ), DIMENSION (:), INTENT ( IN ) :: u , v INTEGER ( I4B ), INTENT ( IN ) :: n , m END SUBROUTINE mpdiv END INTERFACE INTERFACE SUBROUTINE mpinv ( u , v , n , m ) USE nrtype CHARACTER ( 1 ), DIMENSION (:), INTENT ( OUT ) :: u CHARACTER ( 1 ), DIMENSION (:), INTENT ( IN ) :: v INTEGER ( I4B ), INTENT ( IN ) :: n , m END SUBROUTINE mpinv END INTERFACE INTERFACE SUBROUTINE mpmul ( w , u , v , n , m ) USE nrtype CHARACTER ( 1 ), DIMENSION (:), INTENT ( IN ) :: u , v CHARACTER ( 1 ), DIMENSION (:), INTENT ( OUT ) :: w INTEGER ( I4B ), INTENT ( IN ) :: n , m END SUBROUTINE mpmul END INTERFACE INTERFACE SUBROUTINE mppi ( n ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n END SUBROUTINE mppi END INTERFACE INTERFACE SUBROUTINE mprove ( a , alud , indx , b , x ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a , alud INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: indx REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: b REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: x END SUBROUTINE mprove END INTERFACE INTERFACE SUBROUTINE mpSQRT ( w , u , v , n , m ) USE nrtype CHARACTER ( 1 ), DIMENSION (:), INTENT ( OUT ) :: w , u CHARACTER ( 1 ), DIMENSION (:), INTENT ( IN ) :: v INTEGER ( I4B ), INTENT ( IN ) :: n , m END SUBROUTINE mpSQRT END INTERFACE INTERFACE SUBROUTINE mrqcof ( x , y , sig , a , maska , alpha , beta , chisq , funcs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , a , sig REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: beta REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: alpha REAL ( SP ), INTENT ( OUT ) :: chisq LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: maska INTERFACE SUBROUTINE funcs ( x , a , yfit , dyda ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yfit REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: dyda END SUBROUTINE funcs END INTERFACE END SUBROUTINE mrqcof END INTERFACE INTERFACE SUBROUTINE mrqmin ( x , y , sig , a , maska , covar , alpha , chisq , funcs , alamda ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , sig REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: covar , alpha REAL ( SP ), INTENT ( OUT ) :: chisq REAL ( SP ), INTENT ( INOUT ) :: alamda LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: maska INTERFACE SUBROUTINE funcs ( x , a , yfit , dyda ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yfit REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: dyda END SUBROUTINE funcs END INTERFACE END SUBROUTINE mrqmin END INTERFACE INTERFACE SUBROUTINE newt ( x , check ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: x LOGICAL ( LGT ), INTENT ( OUT ) :: check END SUBROUTINE newt END INTERFACE INTERFACE SUBROUTINE odeint ( ystart , x1 , x2 , eps , h1 , hmin , derivs , rkqs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: ystart REAL ( SP ), INTENT ( IN ) :: x1 , x2 , eps , h1 , hmin INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs !BL SUBROUTINE rkqs ( y , dydx , x , htry , eps , yscal , hdid , hnext , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: dydx , yscal REAL ( SP ), INTENT ( INOUT ) :: x REAL ( SP ), INTENT ( IN ) :: htry , eps REAL ( SP ), INTENT ( OUT ) :: hdid , hnext INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE rkqs END INTERFACE END SUBROUTINE odeint END INTERFACE INTERFACE SUBROUTINE orthog ( anu , alpha , beta , a , b ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: anu , alpha , beta REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: a , b END SUBROUTINE orthog END INTERFACE INTERFACE SUBROUTINE pade ( cof , resid ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( INOUT ) :: cof REAL ( SP ), INTENT ( OUT ) :: resid END SUBROUTINE pade END INTERFACE INTERFACE FUNCTION pccheb ( d ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: d REAL ( SP ), DIMENSION ( size ( d )) :: pccheb END FUNCTION pccheb END INTERFACE INTERFACE SUBROUTINE pcshft ( a , b , d ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: d END SUBROUTINE pcshft END INTERFACE INTERFACE SUBROUTINE pearsn ( x , y , r , prob , z ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: r , prob , z REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y END SUBROUTINE pearsn END INTERFACE INTERFACE SUBROUTINE period ( x , y , ofac , hifac , px , py , jmax , prob ) USE nrtype INTEGER ( I4B ), INTENT ( OUT ) :: jmax REAL ( SP ), INTENT ( IN ) :: ofac , hifac REAL ( SP ), INTENT ( OUT ) :: prob REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), DIMENSION (:), POINTER :: px , py END SUBROUTINE period END INTERFACE INTERFACE plgndr FUNCTION plgndr_s ( l , m , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: l , m REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: plgndr_s END FUNCTION plgndr_s !BL FUNCTION plgndr_v ( l , m , x ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: l , m REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: plgndr_v END FUNCTION plgndr_v END INTERFACE INTERFACE FUNCTION poidev ( xm ) USE nrtype REAL ( SP ), INTENT ( IN ) :: xm REAL ( SP ) :: poidev END FUNCTION poidev END INTERFACE INTERFACE FUNCTION polcoe ( x , y ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), DIMENSION ( size ( x )) :: polcoe END FUNCTION polcoe END INTERFACE INTERFACE FUNCTION polcof ( xa , ya ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xa , ya REAL ( SP ), DIMENSION ( size ( xa )) :: polcof END FUNCTION polcof END INTERFACE INTERFACE SUBROUTINE poldiv ( u , v , q , r ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: u , v REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: q , r END SUBROUTINE poldiv END INTERFACE INTERFACE SUBROUTINE polin2 ( x1a , x2a , ya , x1 , x2 , y , dy ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x1a , x2a REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: ya REAL ( SP ), INTENT ( IN ) :: x1 , x2 REAL ( SP ), INTENT ( OUT ) :: y , dy END SUBROUTINE polin2 END INTERFACE INTERFACE SUBROUTINE polint ( xa , ya , x , y , dy ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xa , ya REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: y , dy END SUBROUTINE polint END INTERFACE INTERFACE SUBROUTINE powell ( p , xi , ftol , iter , fret ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: p REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: xi INTEGER ( I4B ), INTENT ( OUT ) :: iter REAL ( SP ), INTENT ( IN ) :: ftol REAL ( SP ), INTENT ( OUT ) :: fret END SUBROUTINE powell END INTERFACE INTERFACE FUNCTION predic ( data , d , nfut ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data , d INTEGER ( I4B ), INTENT ( IN ) :: nfut REAL ( SP ), DIMENSION ( nfut ) :: predic END FUNCTION predic END INTERFACE INTERFACE FUNCTION probks ( alam ) USE nrtype REAL ( SP ), INTENT ( IN ) :: alam REAL ( SP ) :: probks END FUNCTION probks END INTERFACE INTERFACE psdes SUBROUTINE psdes_s ( lword , rword ) USE nrtype INTEGER ( I4B ), INTENT ( INOUT ) :: lword , rword END SUBROUTINE psdes_s !BL SUBROUTINE psdes_v ( lword , rword ) USE nrtype INTEGER ( I4B ), DIMENSION (:), INTENT ( INOUT ) :: lword , rword END SUBROUTINE psdes_v END INTERFACE INTERFACE SUBROUTINE pwt ( a , isign ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE pwt END INTERFACE INTERFACE SUBROUTINE pwtset ( n ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n END SUBROUTINE pwtset END INTERFACE INTERFACE pythag FUNCTION pythag_dp ( a , b ) USE nrtype REAL ( DP ), INTENT ( IN ) :: a , b REAL ( DP ) :: pythag_dp END FUNCTION pythag_dp !BL FUNCTION pythag_sp ( a , b ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ) :: pythag_sp END FUNCTION pythag_sp END INTERFACE INTERFACE SUBROUTINE pzextr ( iest , xest , yest , yz , dy ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: iest REAL ( SP ), INTENT ( IN ) :: xest REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: yest REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yz , dy END SUBROUTINE pzextr END INTERFACE INTERFACE SUBROUTINE qrdcmp ( a , c , d , sing ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: c , d LOGICAL ( LGT ), INTENT ( OUT ) :: sing END SUBROUTINE qrdcmp END INTERFACE INTERFACE FUNCTION qromb ( func , a , b ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ) :: qromb INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END FUNCTION qromb END INTERFACE INTERFACE FUNCTION qromo ( func , a , b , choose ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ) :: qromo INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE INTERFACE SUBROUTINE choose ( funk , aa , bb , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: aa , bb REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION funk ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: funk END FUNCTION funk END INTERFACE END SUBROUTINE choose END INTERFACE END FUNCTION qromo END INTERFACE INTERFACE SUBROUTINE qroot ( p , b , c , eps ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: p REAL ( SP ), INTENT ( INOUT ) :: b , c REAL ( SP ), INTENT ( IN ) :: eps END SUBROUTINE qroot END INTERFACE INTERFACE SUBROUTINE qrsolv ( a , c , d , b ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c , d REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: b END SUBROUTINE qrsolv END INTERFACE INTERFACE SUBROUTINE qrupdt ( r , qt , u , v ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: r , qt REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: u REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: v END SUBROUTINE qrupdt END INTERFACE INTERFACE FUNCTION qsimp ( func , a , b ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ) :: qsimp INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END FUNCTION qsimp END INTERFACE INTERFACE FUNCTION qtrap ( func , a , b ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ) :: qtrap INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END FUNCTION qtrap END INTERFACE INTERFACE SUBROUTINE quadct ( x , y , xx , yy , fa , fb , fc , fd ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xx , yy REAL ( SP ), INTENT ( OUT ) :: fa , fb , fc , fd END SUBROUTINE quadct END INTERFACE INTERFACE SUBROUTINE quadmx ( a ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: a END SUBROUTINE quadmx END INTERFACE INTERFACE SUBROUTINE quadvl ( x , y , fa , fb , fc , fd ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y REAL ( SP ), INTENT ( OUT ) :: fa , fb , fc , fd END SUBROUTINE quadvl END INTERFACE INTERFACE FUNCTION ran ( idum ) INTEGER ( selected_int_kind ( 9 )), INTENT ( INOUT ) :: idum REAL :: ran END FUNCTION ran END INTERFACE INTERFACE ran0 SUBROUTINE ran0_s ( harvest ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: harvest END SUBROUTINE ran0_s !BL SUBROUTINE ran0_v ( harvest ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: harvest END SUBROUTINE ran0_v END INTERFACE INTERFACE ran1 SUBROUTINE ran1_s ( harvest ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: harvest END SUBROUTINE ran1_s !BL SUBROUTINE ran1_v ( harvest ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: harvest END SUBROUTINE ran1_v END INTERFACE INTERFACE ran2 SUBROUTINE ran2_s ( harvest ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: harvest END SUBROUTINE ran2_s !BL SUBROUTINE ran2_v ( harvest ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: harvest END SUBROUTINE ran2_v END INTERFACE INTERFACE ran3 SUBROUTINE ran3_s ( harvest ) USE nrtype REAL ( SP ), INTENT ( OUT ) :: harvest END SUBROUTINE ran3_s !BL SUBROUTINE ran3_v ( harvest ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: harvest END SUBROUTINE ran3_v END INTERFACE INTERFACE SUBROUTINE ratint ( xa , ya , x , y , dy ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xa , ya REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: y , dy END SUBROUTINE ratint END INTERFACE INTERFACE SUBROUTINE ratlsq ( func , a , b , mm , kk , cof , dev ) USE nrtype REAL ( DP ), INTENT ( IN ) :: a , b INTEGER ( I4B ), INTENT ( IN ) :: mm , kk REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: cof REAL ( DP ), INTENT ( OUT ) :: dev INTERFACE FUNCTION func ( x ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END SUBROUTINE ratlsq END INTERFACE INTERFACE ratval FUNCTION ratval_s ( x , cof , mm , kk ) USE nrtype REAL ( DP ), INTENT ( IN ) :: x INTEGER ( I4B ), INTENT ( IN ) :: mm , kk REAL ( DP ), DIMENSION ( mm + kk + 1 ), INTENT ( IN ) :: cof REAL ( DP ) :: ratval_s END FUNCTION ratval_s !BL FUNCTION ratval_v ( x , cof , mm , kk ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x INTEGER ( I4B ), INTENT ( IN ) :: mm , kk REAL ( DP ), DIMENSION ( mm + kk + 1 ), INTENT ( IN ) :: cof REAL ( DP ), DIMENSION ( size ( x )) :: ratval_v END FUNCTION ratval_v END INTERFACE INTERFACE rc FUNCTION rc_s ( x , y ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y REAL ( SP ) :: rc_s END FUNCTION rc_s !BL FUNCTION rc_v ( x , y ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), DIMENSION ( size ( x )) :: rc_v END FUNCTION rc_v END INTERFACE INTERFACE rd FUNCTION rd_s ( x , y , z ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y , z REAL ( SP ) :: rd_s END FUNCTION rd_s !BL FUNCTION rd_v ( x , y , z ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , z REAL ( SP ), DIMENSION ( size ( x )) :: rd_v END FUNCTION rd_v END INTERFACE INTERFACE realft SUBROUTINE realft_dp ( data , isign , zdata ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign COMPLEX ( DPC ), DIMENSION (:), OPTIONAL , TARGET :: zdata END SUBROUTINE realft_dp !BL SUBROUTINE realft_sp ( data , isign , zdata ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: data INTEGER ( I4B ), INTENT ( IN ) :: isign COMPLEX ( SPC ), DIMENSION (:), OPTIONAL , TARGET :: zdata END SUBROUTINE realft_sp END INTERFACE INTERFACE RECURSIVE FUNCTION recur1 ( a , b ) RESULT ( u ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a )) :: u END FUNCTION recur1 END INTERFACE INTERFACE FUNCTION recur2 ( a , b , c ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b , c REAL ( SP ), DIMENSION ( size ( a )) :: recur2 END FUNCTION recur2 END INTERFACE INTERFACE SUBROUTINE relax ( u , rhs ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( INOUT ) :: u REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: rhs END SUBROUTINE relax END INTERFACE INTERFACE SUBROUTINE relax2 ( u , rhs ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( INOUT ) :: u REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: rhs END SUBROUTINE relax2 END INTERFACE INTERFACE FUNCTION resid ( u , rhs ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: u , rhs REAL ( DP ), DIMENSION ( size ( u , 1 ), size ( u , 1 )) :: resid END FUNCTION resid END INTERFACE INTERFACE rf FUNCTION rf_s ( x , y , z ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y , z REAL ( SP ) :: rf_s END FUNCTION rf_s !BL FUNCTION rf_v ( x , y , z ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , z REAL ( SP ), DIMENSION ( size ( x )) :: rf_v END FUNCTION rf_v END INTERFACE INTERFACE rj FUNCTION rj_s ( x , y , z , p ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , y , z , p REAL ( SP ) :: rj_s END FUNCTION rj_s !BL FUNCTION rj_v ( x , y , z , p ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , z , p REAL ( SP ), DIMENSION ( size ( x )) :: rj_v END FUNCTION rj_v END INTERFACE INTERFACE SUBROUTINE rk4 ( y , dydx , x , h , yout , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y , dydx REAL ( SP ), INTENT ( IN ) :: x , h REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yout INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE rk4 END INTERFACE INTERFACE SUBROUTINE rkck ( y , dydx , x , h , yout , yerr , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y , dydx REAL ( SP ), INTENT ( IN ) :: x , h REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yout , yerr INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE rkck END INTERFACE INTERFACE SUBROUTINE rkdumb ( vstart , x1 , x2 , nstep , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: vstart REAL ( SP ), INTENT ( IN ) :: x1 , x2 INTEGER ( I4B ), INTENT ( IN ) :: nstep INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE rkdumb END INTERFACE INTERFACE SUBROUTINE rkqs ( y , dydx , x , htry , eps , yscal , hdid , hnext , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: dydx , yscal REAL ( SP ), INTENT ( INOUT ) :: x REAL ( SP ), INTENT ( IN ) :: htry , eps REAL ( SP ), INTENT ( OUT ) :: hdid , hnext INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE rkqs END INTERFACE INTERFACE SUBROUTINE rlft2 ( data , spec , speq , isign ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: data COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( OUT ) :: spec COMPLEX ( SPC ), DIMENSION (:), INTENT ( OUT ) :: speq INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE rlft2 END INTERFACE INTERFACE SUBROUTINE rlft3 ( data , spec , speq , isign ) USE nrtype REAL ( SP ), DIMENSION (:,:,:), INTENT ( INOUT ) :: data COMPLEX ( SPC ), DIMENSION (:,:,:), INTENT ( OUT ) :: spec COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( OUT ) :: speq INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE rlft3 END INTERFACE INTERFACE SUBROUTINE rotate ( r , qt , i , a , b ) USE nrtype REAL ( SP ), DIMENSION (:,:), TARGET , INTENT ( INOUT ) :: r , qt INTEGER ( I4B ), INTENT ( IN ) :: i REAL ( SP ), INTENT ( IN ) :: a , b END SUBROUTINE rotate END INTERFACE INTERFACE SUBROUTINE rsolv ( a , d , b ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: d REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: b END SUBROUTINE rsolv END INTERFACE INTERFACE FUNCTION rstrct ( uf ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: uf REAL ( DP ), DIMENSION (( size ( uf , 1 ) + 1 ) / 2 ,( size ( uf , 1 ) + 1 ) / 2 ) :: rstrct END FUNCTION rstrct END INTERFACE INTERFACE FUNCTION rtbis ( func , x1 , x2 , xacc ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , xacc REAL ( SP ) :: rtbis INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION rtbis END INTERFACE INTERFACE FUNCTION rtflsp ( func , x1 , x2 , xacc ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , xacc REAL ( SP ) :: rtflsp INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION rtflsp END INTERFACE INTERFACE FUNCTION rtnewt ( funcd , x1 , x2 , xacc ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , xacc REAL ( SP ) :: rtnewt INTERFACE SUBROUTINE funcd ( x , fval , fderiv ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: fval , fderiv END SUBROUTINE funcd END INTERFACE END FUNCTION rtnewt END INTERFACE INTERFACE FUNCTION rtsafe ( funcd , x1 , x2 , xacc ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , xacc REAL ( SP ) :: rtsafe INTERFACE SUBROUTINE funcd ( x , fval , fderiv ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: fval , fderiv END SUBROUTINE funcd END INTERFACE END FUNCTION rtsafe END INTERFACE INTERFACE FUNCTION rtsec ( func , x1 , x2 , xacc ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , xacc REAL ( SP ) :: rtsec INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION rtsec END INTERFACE INTERFACE SUBROUTINE rzextr ( iest , xest , yest , yz , dy ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: iest REAL ( SP ), INTENT ( IN ) :: xest REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: yest REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yz , dy END SUBROUTINE rzextr END INTERFACE INTERFACE FUNCTION savgol ( nl , nrr , ld , m ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: nl , nrr , ld , m REAL ( SP ), DIMENSION ( nl + nrr + 1 ) :: savgol END FUNCTION savgol END INTERFACE INTERFACE SUBROUTINE scrsho ( func ) USE nrtype INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE scrsho END INTERFACE INTERFACE FUNCTION select ( k , arr ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: k REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr REAL ( SP ) :: select END FUNCTION select END INTERFACE INTERFACE FUNCTION select_bypack ( k , arr ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: k REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr REAL ( SP ) :: select_bypack END FUNCTION select_bypack END INTERFACE INTERFACE SUBROUTINE select_heap ( arr , heap ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: heap END SUBROUTINE select_heap END INTERFACE INTERFACE FUNCTION select_inplace ( k , arr ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: k REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr REAL ( SP ) :: select_inplace END FUNCTION select_inplace END INTERFACE INTERFACE SUBROUTINE simplx ( a , m1 , m2 , m3 , icase , izrov , iposv ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a INTEGER ( I4B ), INTENT ( IN ) :: m1 , m2 , m3 INTEGER ( I4B ), INTENT ( OUT ) :: icase INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: izrov , iposv END SUBROUTINE simplx END INTERFACE INTERFACE SUBROUTINE simpr ( y , dydx , dfdx , dfdy , xs , htot , nstep , yout , derivs ) USE nrtype REAL ( SP ), INTENT ( IN ) :: xs , htot REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y , dydx , dfdx REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: dfdy INTEGER ( I4B ), INTENT ( IN ) :: nstep REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yout INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE simpr END INTERFACE INTERFACE SUBROUTINE sinft ( y ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y END SUBROUTINE sinft END INTERFACE INTERFACE SUBROUTINE slvsm2 ( u , rhs ) USE nrtype REAL ( DP ), DIMENSION ( 3 , 3 ), INTENT ( OUT ) :: u REAL ( DP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: rhs END SUBROUTINE slvsm2 END INTERFACE INTERFACE SUBROUTINE slvsml ( u , rhs ) USE nrtype REAL ( DP ), DIMENSION ( 3 , 3 ), INTENT ( OUT ) :: u REAL ( DP ), DIMENSION ( 3 , 3 ), INTENT ( IN ) :: rhs END SUBROUTINE slvsml END INTERFACE INTERFACE SUBROUTINE sncndn ( uu , emmc , sn , cn , dn ) USE nrtype REAL ( SP ), INTENT ( IN ) :: uu , emmc REAL ( SP ), INTENT ( OUT ) :: sn , cn , dn END SUBROUTINE sncndn END INTERFACE INTERFACE FUNCTION snrm ( sx , itol ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: sx INTEGER ( I4B ), INTENT ( IN ) :: itol REAL ( DP ) :: snrm END FUNCTION snrm END INTERFACE INTERFACE SUBROUTINE sobseq ( x , init ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: init END SUBROUTINE sobseq END INTERFACE INTERFACE SUBROUTINE solvde ( itmax , conv , slowc , scalv , indexv , nb , y ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: itmax , nb REAL ( SP ), INTENT ( IN ) :: conv , slowc REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: scalv INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: indexv REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: y END SUBROUTINE solvde END INTERFACE INTERFACE SUBROUTINE sor ( a , b , c , d , e , f , u , rjac ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: a , b , c , d , e , f REAL ( DP ), DIMENSION (:,:), INTENT ( INOUT ) :: u REAL ( DP ), INTENT ( IN ) :: rjac END SUBROUTINE sor END INTERFACE INTERFACE SUBROUTINE sort ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort END INTERFACE INTERFACE SUBROUTINE sort2 ( arr , slave ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr , slave END SUBROUTINE sort2 END INTERFACE INTERFACE SUBROUTINE sort3 ( arr , slave1 , slave2 ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr , slave1 , slave2 END SUBROUTINE sort3 END INTERFACE INTERFACE SUBROUTINE sort_bypack ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort_bypack END INTERFACE INTERFACE SUBROUTINE sort_byreshape ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort_byreshape END INTERFACE INTERFACE SUBROUTINE sort_heap ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort_heap END INTERFACE INTERFACE SUBROUTINE sort_pick ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort_pick END INTERFACE INTERFACE SUBROUTINE sort_radix ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort_radix END INTERFACE INTERFACE SUBROUTINE sort_shell ( arr ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: arr END SUBROUTINE sort_shell END INTERFACE INTERFACE SUBROUTINE spctrm ( p , k , ovrlap , unit , n_window ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: p INTEGER ( I4B ), INTENT ( IN ) :: k LOGICAL ( LGT ), INTENT ( IN ) :: ovrlap INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: n_window , unit END SUBROUTINE spctrm END INTERFACE INTERFACE SUBROUTINE spear ( data1 , data2 , d , zd , probd , rs , probrs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 REAL ( SP ), INTENT ( OUT ) :: d , zd , probd , rs , probrs END SUBROUTINE spear END INTERFACE INTERFACE sphbes SUBROUTINE sphbes_s ( n , x , sj , sy , sjp , syp ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), INTENT ( OUT ) :: sj , sy , sjp , syp END SUBROUTINE sphbes_s !BL SUBROUTINE sphbes_v ( n , x , sj , sy , sjp , syp ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: sj , sy , sjp , syp END SUBROUTINE sphbes_v END INTERFACE INTERFACE SUBROUTINE splie2 ( x1a , x2a , ya , y2a ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x1a , x2a REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: ya REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: y2a END SUBROUTINE splie2 END INTERFACE INTERFACE FUNCTION splin2 ( x1a , x2a , ya , y2a , x1 , x2 ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x1a , x2a REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: ya , y2a REAL ( SP ), INTENT ( IN ) :: x1 , x2 REAL ( SP ) :: splin2 END FUNCTION splin2 END INTERFACE INTERFACE SUBROUTINE spline ( x , y , yp1 , ypn , y2 ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y REAL ( SP ), INTENT ( IN ) :: yp1 , ypn REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: y2 END SUBROUTINE spline END INTERFACE INTERFACE FUNCTION splint ( xa , ya , y2a , x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: xa , ya , y2a REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: splint END FUNCTION splint END INTERFACE INTERFACE sprsax SUBROUTINE sprsax_dp ( sa , x , b ) USE nrtype TYPE ( sprs2_dp ), INTENT ( IN ) :: sa REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: b END SUBROUTINE sprsax_dp !BL SUBROUTINE sprsax_sp ( sa , x , b ) USE nrtype TYPE ( sprs2_sp ), INTENT ( IN ) :: sa REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: b END SUBROUTINE sprsax_sp END INTERFACE INTERFACE sprsdiag SUBROUTINE sprsdiag_dp ( sa , b ) USE nrtype TYPE ( sprs2_dp ), INTENT ( IN ) :: sa REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: b END SUBROUTINE sprsdiag_dp !BL SUBROUTINE sprsdiag_sp ( sa , b ) USE nrtype TYPE ( sprs2_sp ), INTENT ( IN ) :: sa REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: b END SUBROUTINE sprsdiag_sp END INTERFACE INTERFACE sprsin SUBROUTINE sprsin_sp ( a , thresh , sa ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: a REAL ( SP ), INTENT ( IN ) :: thresh TYPE ( sprs2_sp ), INTENT ( OUT ) :: sa END SUBROUTINE sprsin_sp !BL SUBROUTINE sprsin_dp ( a , thresh , sa ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: a REAL ( DP ), INTENT ( IN ) :: thresh TYPE ( sprs2_dp ), INTENT ( OUT ) :: sa END SUBROUTINE sprsin_dp END INTERFACE INTERFACE SUBROUTINE sprstp ( sa ) USE nrtype TYPE ( sprs2_sp ), INTENT ( INOUT ) :: sa END SUBROUTINE sprstp END INTERFACE INTERFACE sprstx SUBROUTINE sprstx_dp ( sa , x , b ) USE nrtype TYPE ( sprs2_dp ), INTENT ( IN ) :: sa REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: b END SUBROUTINE sprstx_dp !BL SUBROUTINE sprstx_sp ( sa , x , b ) USE nrtype TYPE ( sprs2_sp ), INTENT ( IN ) :: sa REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: b END SUBROUTINE sprstx_sp END INTERFACE INTERFACE SUBROUTINE stifbs ( y , dydx , x , htry , eps , yscal , hdid , hnext , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: dydx , yscal REAL ( SP ), INTENT ( IN ) :: htry , eps REAL ( SP ), INTENT ( INOUT ) :: x REAL ( SP ), INTENT ( OUT ) :: hdid , hnext INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE stifbs END INTERFACE INTERFACE SUBROUTINE stiff ( y , dydx , x , htry , eps , yscal , hdid , hnext , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: y REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: dydx , yscal REAL ( SP ), INTENT ( INOUT ) :: x REAL ( SP ), INTENT ( IN ) :: htry , eps REAL ( SP ), INTENT ( OUT ) :: hdid , hnext INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE stiff END INTERFACE INTERFACE SUBROUTINE stoerm ( y , d2y , xs , htot , nstep , yout , derivs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y , d2y REAL ( SP ), INTENT ( IN ) :: xs , htot INTEGER ( I4B ), INTENT ( IN ) :: nstep REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: yout INTERFACE SUBROUTINE derivs ( x , y , dydx ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: y REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dydx END SUBROUTINE derivs END INTERFACE END SUBROUTINE stoerm END INTERFACE INTERFACE svbksb SUBROUTINE svbksb_dp ( u , w , v , b , x ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: u , v REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: w , b REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: x END SUBROUTINE svbksb_dp !BL SUBROUTINE svbksb_sp ( u , w , v , b , x ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: u , v REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: w , b REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: x END SUBROUTINE svbksb_sp END INTERFACE INTERFACE svdcmp SUBROUTINE svdcmp_dp ( a , w , v ) USE nrtype REAL ( DP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: w REAL ( DP ), DIMENSION (:,:), INTENT ( OUT ) :: v END SUBROUTINE svdcmp_dp !BL SUBROUTINE svdcmp_sp ( a , w , v ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: w REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: v END SUBROUTINE svdcmp_sp END INTERFACE INTERFACE SUBROUTINE svdfit ( x , y , sig , a , v , w , chisq , funcs ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x , y , sig REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: a , w REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: v REAL ( SP ), INTENT ( OUT ) :: chisq INTERFACE FUNCTION funcs ( x , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: funcs END FUNCTION funcs END INTERFACE END SUBROUTINE svdfit END INTERFACE INTERFACE SUBROUTINE svdvar ( v , w , cvm ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: v REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: w REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: cvm END SUBROUTINE svdvar END INTERFACE INTERFACE FUNCTION toeplz ( r , y ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: r , y REAL ( SP ), DIMENSION ( size ( y )) :: toeplz END FUNCTION toeplz END INTERFACE INTERFACE SUBROUTINE tptest ( data1 , data2 , t , prob ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 REAL ( SP ), INTENT ( OUT ) :: t , prob END SUBROUTINE tptest END INTERFACE INTERFACE SUBROUTINE tqli ( d , e , z ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: d , e REAL ( SP ), DIMENSION (:,:), OPTIONAL , INTENT ( INOUT ) :: z END SUBROUTINE tqli END INTERFACE INTERFACE SUBROUTINE trapzd ( func , a , b , s , n ) USE nrtype REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), INTENT ( INOUT ) :: s INTEGER ( I4B ), INTENT ( IN ) :: n INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( SP ), DIMENSION ( size ( x )) :: func END FUNCTION func END INTERFACE END SUBROUTINE trapzd END INTERFACE INTERFACE SUBROUTINE tred2 ( a , d , e , novectors ) USE nrtype REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: d , e LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: novectors END SUBROUTINE tred2 END INTERFACE !\tOn a purely serial machine, for greater efficiency, remove !\tthe generic name tridag from the following interface, !\tand put it on the next one after that. INTERFACE tridag RECURSIVE SUBROUTINE tridag_par ( a , b , c , r , u ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b , c , r REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: u END SUBROUTINE tridag_par END INTERFACE INTERFACE SUBROUTINE tridag_ser ( a , b , c , r , u ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b , c , r REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: u END SUBROUTINE tridag_ser END INTERFACE INTERFACE SUBROUTINE ttest ( data1 , data2 , t , prob ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 REAL ( SP ), INTENT ( OUT ) :: t , prob END SUBROUTINE ttest END INTERFACE INTERFACE SUBROUTINE tutest ( data1 , data2 , t , prob ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 REAL ( SP ), INTENT ( OUT ) :: t , prob END SUBROUTINE tutest END INTERFACE INTERFACE SUBROUTINE twofft ( data1 , data2 , fft1 , fft2 ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: data1 , data2 COMPLEX ( SPC ), DIMENSION (:), INTENT ( OUT ) :: fft1 , fft2 END SUBROUTINE twofft END INTERFACE INTERFACE FUNCTION vander ( x , q ) USE nrtype REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x , q REAL ( DP ), DIMENSION ( size ( x )) :: vander END FUNCTION vander END INTERFACE INTERFACE SUBROUTINE vegas ( region , func , init , ncall , itmx , nprn , tgral , sd , chi2a ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: region INTEGER ( I4B ), INTENT ( IN ) :: init , ncall , itmx , nprn REAL ( SP ), INTENT ( OUT ) :: tgral , sd , chi2a INTERFACE FUNCTION func ( pt , wgt ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: pt REAL ( SP ), INTENT ( IN ) :: wgt REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE vegas END INTERFACE INTERFACE SUBROUTINE voltra ( t0 , h , t , f , g , ak ) USE nrtype REAL ( SP ), INTENT ( IN ) :: t0 , h REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: t REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: f INTERFACE FUNCTION g ( t ) USE nrtype REAL ( SP ), INTENT ( IN ) :: t REAL ( SP ), DIMENSION (:), POINTER :: g END FUNCTION g !BL FUNCTION ak ( t , s ) USE nrtype REAL ( SP ), INTENT ( IN ) :: t , s REAL ( SP ), DIMENSION (:,:), POINTER :: ak END FUNCTION ak END INTERFACE END SUBROUTINE voltra END INTERFACE INTERFACE SUBROUTINE wt1 ( a , isign , wtstep ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a INTEGER ( I4B ), INTENT ( IN ) :: isign INTERFACE SUBROUTINE wtstep ( a , isign ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE wtstep END INTERFACE END SUBROUTINE wt1 END INTERFACE INTERFACE SUBROUTINE wtn ( a , nn , isign , wtstep ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: nn INTEGER ( I4B ), INTENT ( IN ) :: isign INTERFACE SUBROUTINE wtstep ( a , isign ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a INTEGER ( I4B ), INTENT ( IN ) :: isign END SUBROUTINE wtstep END INTERFACE END SUBROUTINE wtn END INTERFACE INTERFACE FUNCTION wwghts ( n , h , kermom ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), INTENT ( IN ) :: h REAL ( SP ), DIMENSION ( n ) :: wwghts INTERFACE FUNCTION kermom ( y , m ) USE nrtype REAL ( DP ), INTENT ( IN ) :: y INTEGER ( I4B ), INTENT ( IN ) :: m REAL ( DP ), DIMENSION ( m ) :: kermom END FUNCTION kermom END INTERFACE END FUNCTION wwghts END INTERFACE INTERFACE SUBROUTINE zbrac ( func , x1 , x2 , succes ) USE nrtype REAL ( SP ), INTENT ( INOUT ) :: x1 , x2 LOGICAL ( LGT ), INTENT ( OUT ) :: succes INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE zbrac END INTERFACE INTERFACE SUBROUTINE zbrak ( func , x1 , x2 , n , xb1 , xb2 , nb ) USE nrtype INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ), INTENT ( OUT ) :: nb REAL ( SP ), INTENT ( IN ) :: x1 , x2 REAL ( SP ), DIMENSION (:), POINTER :: xb1 , xb2 INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END SUBROUTINE zbrak END INTERFACE INTERFACE FUNCTION zbrent ( func , x1 , x2 , tol ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , tol REAL ( SP ) :: zbrent INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION zbrent END INTERFACE INTERFACE SUBROUTINE zrhqr ( a , rtr , rti ) USE nrtype REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: rtr , rti END SUBROUTINE zrhqr END INTERFACE INTERFACE FUNCTION zriddr ( func , x1 , x2 , xacc ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x1 , x2 , xacc REAL ( SP ) :: zriddr INTERFACE FUNCTION func ( x ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ) :: func END FUNCTION func END INTERFACE END FUNCTION zriddr END INTERFACE INTERFACE SUBROUTINE zroots ( a , roots , polish ) USE nrtype COMPLEX ( SPC ), DIMENSION (:), INTENT ( IN ) :: a COMPLEX ( SPC ), DIMENSION (:), INTENT ( OUT ) :: roots LOGICAL ( LGT ), INTENT ( IN ) :: polish END SUBROUTINE zroots END INTERFACE ! This is to suppress the ranlib \"has no symbols\" message integer , private :: private_dummy END MODULE nr !> @brief Module with calls to subroutines for calculating various special functions. !! @details All the subroutines in this module were taken from the free software available as part of the book Numerical Recipes. !! For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". MODULE special_functions IMPLICIT NONE PUBLIC :: bessik CONTAINS !> @brief Subroutine taken from \"Numerical Recipes\" that calculates the modified Bessel function of SUBROUTINE bessik ( x , xnu , ri , rk , rip , rkp ) USE nrtype ; USE nrutil , ONLY : assert , nrerror USE nr , ONLY : beschb IMPLICIT NONE REAL ( SP ), INTENT ( IN ) :: x , xnu REAL ( SP ), INTENT ( OUT ) :: ri , rk , rip , rkp INTEGER ( I4B ), PARAMETER :: MAXIT = 10000 REAL ( SP ), PARAMETER :: XMIN = 2.0 REAL ( DP ), PARAMETER :: EPS = 1.0e-10_dp , FPMIN = 1.0e-30_dp INTEGER ( I4B ) :: i , l , nl REAL ( DP ) :: a , a1 , b , c , d , del , del1 , delh , dels , e , f , fact , fact2 , ff ,& gam1 , gam2 , gammi , gampl , h , p , pimu , q , q1 , q2 , qnew ,& ril , ril1 , rimu , rip1 , ripl , ritemp , rk1 , rkmu , rkmup , rktemp ,& s , sum , sum1 , x2 , xi , xi2 , xmu , xmu2 call assert ( x > 0.0 , xnu >= 0.0 , 'bessik args' ) nl = int ( xnu + 0.5_dp ) xmu = xnu - nl xmu2 = xmu * xmu xi = 1.0_dp / x xi2 = 2.0_dp * xi h = xnu * xi if ( h < FPMIN ) h = FPMIN b = xi2 * xnu d = 0.0 c = h do i = 1 , MAXIT b = b + xi2 d = 1.0_dp / ( b + d ) c = b + 1.0_dp / c del = c * d h = del * h if ( abs ( del - 1.0_dp ) < EPS ) exit end do if ( i > MAXIT ) call nrerror ( 'x too large in bessik; try asymptotic expansion' ) ril = FPMIN ripl = h * ril ril1 = ril rip1 = ripl fact = xnu * xi do l = nl , 1 , - 1 ritemp = fact * ril + ripl fact = fact - xi ripl = fact * ritemp + ril ril = ritemp end do f = ripl / ril if ( x < XMIN ) then x2 = 0.5_dp * x pimu = PI_D * xmu if ( abs ( pimu ) < EPS ) then fact = 1.0 else fact = pimu / sin ( pimu ) end if d =- log ( x2 ) e = xmu * d if ( abs ( e ) < EPS ) then fact2 = 1.0 else fact2 = sinh ( e ) / e end if call beschb ( xmu , gam1 , gam2 , gampl , gammi ) ff = fact * ( gam1 * cosh ( e ) + gam2 * fact2 * d ) sum = ff e = exp ( e ) p = 0.5_dp * e / gampl q = 0.5_dp / ( e * gammi ) c = 1.0 d = x2 * x2 sum1 = p do i = 1 , MAXIT ff = ( i * ff + p + q ) / ( i * i - xmu2 ) c = c * d / i p = p / ( i - xmu ) q = q / ( i + xmu ) del = c * ff sum = sum + del del1 = c * ( p - i * ff ) sum1 = sum1 + del1 if ( abs ( del ) < abs ( sum ) * EPS ) exit end do if ( i > MAXIT ) call nrerror ( 'bessk series failed to converge' ) rkmu = sum rk1 = sum1 * xi2 else b = 2.0_dp * ( 1.0_dp + x ) d = 1.0_dp / b delh = d h = delh q1 = 0.0 q2 = 1.0 a1 = 0.25_dp - xmu2 c = a1 q = c a =- a1 s = 1.0_dp + q * delh do i = 2 , MAXIT a = a - 2 * ( i - 1 ) c =- a * c / i qnew = ( q1 - b * q2 ) / a q1 = q2 q2 = qnew q = q + c * qnew b = b + 2.0_dp d = 1.0_dp / ( b + a * d ) delh = ( b * d - 1.0_dp ) * delh h = h + delh dels = q * delh s = s + dels if ( abs ( dels / s ) < EPS ) exit end do if ( i > MAXIT ) call nrerror ( 'bessik: failure to converge in cf2' ) h = a1 * h rkmu = SQRT ( PI_D / ( 2.0_dp * x )) * exp ( - x ) / s rk1 = rkmu * ( xmu + x + 0.5_dp - h ) * xi end if rkmup = xmu * xi * rkmu - rk1 rimu = xi / ( f * rkmu - rkmup ) ri = ( rimu * ril1 ) / ril rip = ( rimu * rip1 ) / ril do i = 1 , nl rktemp = ( xmu + i ) * xi2 * rk1 + rkmu rkmu = rk1 rk1 = rktemp end do rk = rkmu rkp = xnu * xi * rkmu - rk1 END SUBROUTINE bessik END MODULE special_functions","tags":"","loc":"sourcefile/special_fun_modules.f90.html"},{"title":"korc_random.f90 – KORC-Full Orbit","text":"Contents Modules korc_random Source Code korc_random.f90 Source Code !include 'mkl_vsl.f90' MODULE korc_random USE , INTRINSIC :: iso_c_binding USE korc_types !    use mkl_vsl_type !    use mkl_vsl IMPLICIT NONE TYPE ( C_PTR ), DIMENSION (:), ALLOCATABLE , PRIVATE :: states TYPE ( C_PTR ), PRIVATE :: state !    TYPE(VSL_STREAM_STATE), PRIVATE :: stream INTERFACE TYPE ( C_PTR ) FUNCTION random_construct_U ( seed ) BIND ( C , NAME = 'random_construct_U' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE :: seed END FUNCTION random_construct_U END INTERFACE INTERFACE TYPE ( C_PTR ) FUNCTION random_construct_N ( seed ) BIND ( C , NAME = 'random_construct_N' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE :: seed END FUNCTION random_construct_N END INTERFACE INTERFACE REAL ( C_DOUBLE ) FUNCTION random_get_number_U ( r ) BIND ( C , NAME = 'random_get_number_U' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE TYPE ( C_PTR ), VALUE :: r END FUNCTION random_get_number_U END INTERFACE INTERFACE REAL ( C_DOUBLE ) FUNCTION random_get_number_N ( r ) BIND ( C , NAME = 'random_get_number_N' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE TYPE ( C_PTR ), VALUE :: r END FUNCTION random_get_number_N END INTERFACE INTERFACE SUBROUTINE random_destroy_U ( r ) BIND ( C , NAME = 'random_destroy_U' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE TYPE ( C_PTR ), VALUE :: r END SUBROUTINE random_destroy_U END INTERFACE INTERFACE SUBROUTINE random_destroy_N ( r ) BIND ( C , NAME = 'random_destroy_N' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE TYPE ( C_PTR ), VALUE :: r END SUBROUTINE random_destroy_N END INTERFACE PUBLIC :: initialize_random CONTAINS SUBROUTINE initialize_random ( seed ) USE omp_lib IMPLICIT NONE INTEGER , INTENT ( IN ) :: seed INTEGER :: num_threads INTEGER :: thread_num num_threads = OMP_GET_MAX_THREADS () IF (. NOT . ALLOCATED ( states )) THEN ALLOCATE ( states ( 0 : num_threads - 1 )) END IF !$OMP PARALLEL PRIVATE(thread_num) thread_num = OMP_GET_THREAD_NUM () states ( thread_num ) = random_construct_U ( seed + thread_num ) !$OMP END PARALLEL END SUBROUTINE initialize_random SUBROUTINE initialize_random_U ( seed ) USE omp_lib IMPLICIT NONE INTEGER , INTENT ( IN ) :: seed state = random_construct_U ( seed ) END SUBROUTINE initialize_random_U SUBROUTINE initialize_random_N ( seed ) USE omp_lib IMPLICIT NONE INTEGER , INTENT ( IN ) :: seed state = random_construct_N ( seed ) END SUBROUTINE initialize_random_N FUNCTION get_random () USE omp_lib IMPLICIT NONE REAL ( rp ) :: get_random get_random = random_get_number_U ( states ( OMP_GET_THREAD_NUM ())) END FUNCTION get_random FUNCTION get_random_U () USE omp_lib IMPLICIT NONE REAL ( rp ) :: get_random_U get_random_U = random_get_number_U ( state ) END FUNCTION get_random_U FUNCTION get_random_N () USE omp_lib IMPLICIT NONE REAL ( rp ) :: get_random_N get_random_N = random_get_number_N ( state ) END FUNCTION get_random_N !SUBROUTINE initialize_random_mkl(seed) !    USE omp_lib !    IMPLICIT NONE !    INTEGER, INTENT(IN) :: seed !    INTEGER             :: num_threads !    INTEGER             :: thread_num !    INTEGER         :: errcode !    integer         :: brng !    brng=VSL_BRNG_MT19937 !   brng=VSL_BRNG_MT2203 !    num_threads = OMP_GET_MAX_THREADS() !    IF (.NOT. ALLOCATED(streams)) THEN !        ALLOCATE(states(0:num_threads - 1)) !    END IF !!$OMP PARALLEL PRIVATE(thread_num) !    thread_num = OMP_GET_THREAD_NUM() !    errcode=vslnewstream(streams(thread_num),brng,seed) !    errcode=vslnewstream(stream,brng,seed) !!$OMP END PARALLEL !END SUBROUTINE !FUNCTION get_random_mkl() !    USE omp_lib !    IMPLICIT NONE ! !    INTEGER, PARAMETER         :: n=8_idef !    REAL(rp),DIMENSION(n)            :: get_random_mkl !    INTEGER         :: errcode !    INTEGER         :: method !    real(rp)        :: mu,sigma !    method=VSL_RNG_METHOD_GAUSSIAN_ICDF !    mu=0._rp !    sigma=1._rp !    errcode = vdrnggaussian(method,streams(OMP_GET_THREAD_NUM()),n, & !         get_random_mkl,mu,sigma) !END FUNCTION !FUNCTION get_random_mkl_N(mu,sigma) !    USE omp_lib !    IMPLICIT NONE ! !    INTEGER, PARAMETER         :: n=8_idef !    REAL(rp)            :: get_random_mkl_N !    REAL(rp),dimension(2)            :: buffer !    INTEGER         :: errcode !    INTEGER         :: method !    real(rp),intent(in)        :: mu,sigma !    method=VSL_RNG_METHOD_GAUSSIAN_BOXMULLER !    mu=0._rp !    sigma=1._rp !    errcode = vdrnggaussian(method,stream,2_idef, & !         buffer,mu,sigma) !    get_random_mkl_N=buffer(1) !END FUNCTION !FUNCTION get_random_mkl_U() !    USE omp_libvdrnggaussian !    IMPLICIT NONE ! !    INTEGER, PARAMETER         :: n=8_idef !    REAL(rp)            :: get_random_mkl_U !    REAL(rp),dimension(2)           :: buffer !    INTEGER         :: errcode !    INTEGER         :: method !    method=VSL_RNG_METHOD_UNIFORM_STD_ACCURATE !    mu=0._rp !    sigma=1._rp !    errcode = vdrnguniform(method,stream,2_idef, & !         buffer,0._rp,1._rp) !    get_random_mkl_U=buffer(2) !END FUNCTION END MODULE korc_random","tags":"","loc":"sourcefile/korc_random.f90.html"},{"title":"korc_profiles.f90 – KORC-Full Orbit","text":"Contents Modules korc_profiles Source Code korc_profiles.f90 Source Code module korc_profiles !! @note Module that contain subroutines for calculating analytical plasma !! profiles and calls to subroutines for interpolating external plasma !! profiles to the particles positions. @endnote use korc_types use korc_hpc use korc_coords use korc_interp use korc_HDF5 use korc_input IMPLICIT NONE PUBLIC :: get_profiles ,& initialize_profiles ,& analytical_profiles_p PRIVATE :: get_analytical_profiles ,& uniform_profiles ,& load_profiles_data_from_hdf5 ,& ALLOCATE_2D_PROFILES_ARRAYS ,& ALLOCATE_3D_PROFILES_ARRAYS CONTAINS subroutine initialize_profiles ( params , P , F ) !! @note Subroutine that initializes the parameters of analytical !! or pre-computed plasma profiles for being used in the !! simulation. @endnote !! KORC can run using either analytical and pre-computed plasma !! profiles. Pre-computed plasma profiles, as in the case of !! pre-computed electric or magnetic fields, are interpolated to !! electrons' position in [[korc_profiles]]. !! !! There are two types of analytical plasma profiles that can be !! used in KORC: 3rd degree polynomial radial plasma profiles, !! !! f(r) = a_3r&#94;3 + a_2r&#94;2 +a_1r + a_0, !! !! and radial plasma profiles with a \\tanh(r) dependency: !! !! f(r) = f_0\\left[1 - \\tanh&#94;n\\left(\\frac{2r}{a}\\right)\\right], !! !! where r is the radial coordinate in toroidal coordinates, !! f_0 is a given plasma parameter at the magnetic axis, !! and a is the plasma radius as measured from the magnetic !! axis to the last closed flux surface. Notice that the larger !! n is, the more uniform the radial profiles are. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( OUT ) :: P !! An instance of KORC's derived type PROFILES containing all !! the information about the plasma profiles used in the !! simulation. See [[korc_types]] and [[korc_profiles]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !CHARACTER(MAX_STRING_LENGTH)    :: ne_profile !! String containing the type of electron density profile !! to be used in the simulation. !CHARACTER(MAX_STRING_LENGTH)    :: Te_profile !! String containing the type of electron temperature profile !! to be used in the simulation. !CHARACTER(MAX_STRING_LENGTH)    :: Zeff_profile !! String containing the type of Z_{eff} profile to be used !! in the simulation. !CHARACTER(MAX_STRING_LENGTH)    :: filename !! Full path to the HDF5 file containing the pre-computed !! plasma profiles. !REAL(rp)                        :: radius_profile !! Plasma radius a as measured from the magnetic axis. !REAL(rp)                        :: neo !! Electron density at the magnetic axis f_0 = n_{e,0}. !REAL(rp)                        :: Teo !! Electron temperature at the magnetic axis f_0 = T_{e,0}. !REAL(rp)                        :: Zeffo !! Z_{eff} at the magnetic axis f_0 = Z_{eff,0}. !REAL(rp)                        :: n_ne !! Exponent n used in \\tanh&#94;n(r) of the electron !! density profile. !REAL(rp)                        :: n_Te !! Exponent n used in \\tanh&#94;n(r) of the electron !! temperature profile. !REAL(rp)                        :: n_Zeff !! Exponent n used in \\tanh&#94;n(r) of the Z_{eff} profile. !REAL(rp), DIMENSION(4)          :: a_ne !! Coefficients of the polynomial electron density profile. !! See detailed description above, !! a_ne=(a_{0},a_{2},a_{3},a_{4}). !REAL(rp), DIMENSION(4)          :: a_Te !! Coefficients of the polynomial electron temperature profile. !! See detailed description above, !! a_Te=(a_{0},a_{2},a_{3},a_{4}). !REAL(rp), DIMENSION(4)          :: a_Zeff !! Coefficients of the Z_{eff} profile. See detailed !! description above, a_Zeff=(a_{0},a_{2},a_{3},a_{4}). !LOGICAL                         :: axisymmetric !! Flag to indicate if the plasma profiles are axisymmetric. INTEGER :: ii , kk !REAL(rp)  ::  n_REr0 !REAL(rp)  ::  n_tauion !REAL(rp)  ::  n_lamfront !REAL(rp)  ::  n_lamback,n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf REAL ( rp ) :: rm , r_a !,psiN_0 !NAMELIST /plasmaProfiles/ radius_profile,ne_profile,neo,n_ne,a_ne, & !     Te_profile,Teo,n_Te,a_Te,n_REr0,n_tauion,n_lamfront,n_lamback, & !     Zeff_profile,Zeffo,n_Zeff,a_Zeff,filename,axisymmetric, & !     n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf,psiN_0 if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * INITIALIZING PROFILES * * * * * * * *\")' ) end if SELECT CASE ( TRIM ( params % profile_model )) CASE ( 'ANALYTICAL' ) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasmaProfiles) !close(default_unit_open) P % a = radius_profile P % R0 = F % Ro P % Z0 = F % Zo P % ne_profile = TRIM ( ne_profile ) P % neo = neo P % n_ne = n_ne P % a_ne = a_ne P % n_REr0 = n_REr0 P % n_tauion = n_tauion P % n_tauin = n_tauin P % n_tauout = n_tauout P % n_shelfdelay = n_shelfdelay P % n_lamfront = n_lamfront P % n_lamback = n_lamback P % n_lamshelf = n_lamshelf P % n_shelf = n_shelf P % psiN_0 = psiN_0 P % Te_profile = TRIM ( Te_profile ) P % Teo = Teo * C_E ! Converted to Joules P % n_Te = n_Te P % a_Te = a_Te P % Zeff_profile = TRIM ( Zeff_profile ) P % Zeffo = Zeffo P % n_Zeff = n_Zeff P % a_Zeff = a_Zeff if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"ANALYTICAL\")' ) write ( output_unit_write , '(\"ne profile: \",A20)' ) P % ne_profile write ( output_unit_write , '(\"Te profile: \",A20)' ) P % Te_profile write ( output_unit_write , '(\"Zeff profile: \",A20)' ) P % Zeff_profile end if if ( params % field_eval . eq . 'interp' ) then P % axisymmetric = axisymmetric P % dims ( 1 ) = F % dims ( 1 ) P % dims ( 3 ) = F % dims ( 3 ) call ALLOCATE_2D_PROFILES_ARRAYS ( P ) P % X % R = F % X % R P % X % Z = F % X % Z do ii = 1_idef , P % dims ( 1 ) do kk = 1_idef , P % dims ( 3 ) rm = sqrt (( P % X % R ( ii ) - P % R0 ) ** 2 + ( P % X % Z ( kk ) - P % Z0 ) ** 2 ) r_a = rm / P % a SELECT CASE ( TRIM ( P % ne_profile )) CASE ( 'FLAT' ) P % ne_2D ( ii , kk ) = P % neo CASE ( 'SPONG' ) P % ne_2D ( ii , kk ) = P % neo * ( 1._rp - 0.2 * r_a ** 8 ) + P % n_ne CASE ( 'RE-EVO' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO1' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO-PSI' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO-PSIN-SG' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO-PSIP-G' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE DEFAULT P % ne_2D ( ii , kk ) = P % neo END SELECT SELECT CASE ( TRIM ( P % Te_profile )) CASE ( 'FLAT' ) P % Te_2D ( ii , kk ) = P % Teo CASE ( 'SPONG' ) P % Te_2D ( ii , kk ) = ( P % Teo - P % n_Te ) * ( 1._rp - 0.6 * r_a ** 2 ) ** 2 + P % n_Te CASE DEFAULT P % Te_2D ( ii , kk ) = P % Teo END SELECT SELECT CASE ( TRIM ( P % Zeff_profile )) CASE ( 'FLAT' ) P % Zeff_2D ( ii , kk ) = P % Zeffo CASE ( 'SPONG' ) P % Zeff_2D ( ii , kk ) = P % Zeffo CASE DEFAULT P % Zeff_2D ( ii , kk ) = P % Zeffo END SELECT end do end do end if CASE ( 'EXTERNAL' ) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasmaProfiles) !close(default_unit_open) P % a = radius_profile P % R0 = F % Ro P % Z0 = F % Zo P % ne_profile = TRIM ( ne_profile ) P % neo = neo P % Te_profile = TRIM ( Te_profile ) P % Teo = Teo * C_E ! Converted to Joules P % Zeff_profile = TRIM ( Zeff_profile ) P % Zeffo = Zeffo if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"EXTERNAL\")' ) write ( output_unit_write , '(\"ne profile:\",A20)' ) P % ne_profile write ( output_unit_write , '(\"Te profile: \",A20)' ) P % Te_profile write ( output_unit_write , '(\"Zeff profile: \",A20)' ) P % Zeff_profile end if P % filename = TRIM ( filename ) P % axisymmetric = axisymmetric call load_profiles_data_from_hdf5 ( params , P ) CASE ( 'UNIFORM' ) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasmaProfiles) !close(default_unit_open) P % a = radius_profile P % R0 = F % Ro P % Z0 = F % Zo P % ne_profile = TRIM ( ne_profile ) P % neo = neo P % n_ne = 0.0_rp P % a_ne = ( / 0.0_rp , 0.0_rp , 0.0_rp , 0.0_rp / ) P % Te_profile = TRIM ( Te_profile ) P % Teo = Teo * C_E ! Converted to Joules P % n_Te = 0.0_rp P % a_Te = ( / 0.0_rp , 0.0_rp , 0.0_rp , 0.0_rp / ) P % Zeff_profile = TRIM ( Zeff_profile ) P % Zeffo = Zeffo P % n_Zeff = 0.0_rp P % a_Zeff = ( / 0.0_rp , 0.0_rp , 0.0_rp , 0.0_rp / ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"UNIFORM\")' ) write ( output_unit_write , '(\"ne profile: \",A20)' ) P % ne_profile write ( output_unit_write , '(\"Te profile: \",A20)' ) P % Te_profile write ( output_unit_write , '(\"Zeff profile: \",A20)' ) P % Zeff_profile end if CASE DEFAULT END SELECT if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * * *\")' ) end if end subroutine initialize_profiles subroutine uniform_profiles ( vars , P ) !! @note Subroutine that returns the value of uniform plasma p !! arameters. @endnote !! This subroutie is used only when the simulation is ran for a 'UNIFORM' !! plasma. As a convention, in a uniform plasma we set !! n_e = n_{e,0}, T_e = T_{e,0}, and Z_{eff} = Z_{eff,0}. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the information !! about the plasma profiles used in the simulation. See [[korc_types]] !! and [[korc_profiles]]. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of PARTICLES containing the variables of a given species. vars % ne = P % neo vars % Te = P % Teo vars % Zeff = P % Zeffo end subroutine uniform_profiles subroutine analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) !! @note Subroutine that calculates the analytical plasma profiles at !! the particles' position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_Z , PSIp REAL ( rp ), INTENT ( IN ) :: time TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne !! Background electron density seen by simulated particles. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: Te !! Backgroun temperature density seen by simulated particles. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: Zeff !! Effective atomic charge seen by simulated particles. INTEGER ( ip ) :: cc , pchunk !! Particle iterator. REAL ( rp ) :: R0 , Z0 , a , ne0 , n_ne , Te0 , n_Te , Zeff0 REAL ( rp ) :: R0_RE , Z0_RE , sigmaR_RE , sigmaZ_RE , psimax_RE REAL ( rp ) :: n_REr0 , n_tauion , n_lamfront , n_lamback , n_lamshelf REAL ( rp ) :: n_psifront , n_psiback , n_psishelf REAL ( rp ) :: n_tauin , n_tauout , n_shelfdelay , n_shelf REAL ( rp ) :: n0t , n_taut REAL ( rp ) :: PSIp0 , PSIp_lim , psiN_0 REAL ( rp ), DIMENSION ( params % pchunk ) :: r_a , rm , rm_RE , PSIpN , PSIp_temp pchunk = params % pchunk R0 = P % R0 Z0 = P % Z0 a = P % a ne0 = P % neo n_ne = P % n_ne Te0 = P % Teo n_Te = P % n_Te Zeff0 = P % Zeffo R0_RE = P % R0_RE Z0_RE = P % Z0_RE n_REr0 = P % n_REr0 n_tauion = P % n_tauion n_tauin = P % n_tauin n_tauout = P % n_tauout n_shelfdelay = P % n_shelfdelay n_lamfront = P % n_lamfront n_lamback = P % n_lamback n_lamshelf = P % n_lamshelf n_psifront = P % n_lamfront * params % cpp % length n_psiback = P % n_lamback * params % cpp % length n_psishelf = P % n_lamshelf * params % cpp % length n_shelf = P % n_shelf PSIp_lim = F % PSIp_lim PSIp0 = F % PSIP_min psiN_0 = P % psiN_0 !    write(output_unit_write,*) 'PSIp',PSIp(1)*(params%cpp%Bo*params%cpp%length**2) !    write(output_unit_write,*) 'PSIp_lim',PSIp_lim*(params%cpp%Bo*params%cpp%length**2) !    write(output_unit_write,*) 'PSIp0',PSIp0*(params%cpp%Bo*params%cpp%length**2) !    write(output_unit_write,'(\"R0_RE: \"E17.10)') R0_RE !    write(output_unit_write,'(\"Z0_RE: \"E17.10)') Z0_RE !    write(output_unit_write,'(\"n_REr0: \"E17.10)') n_REr0 SELECT CASE ( TRIM ( P % ne_profile )) CASE ( 'FLAT' ) !$OMP SIMD do cc = 1_idef , pchunk ne ( cc ) = ne0 end do !$OMP END SIMD CASE ( 'SPONG' ) !$OMP SIMD do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) ** 2 + ( Y_Z ( cc ) - Z0 ) ** 2 ) r_a ( cc ) = rm ( cc ) / a ne ( cc ) = ne0 * ( 1._rp - 0.2 * r_a ( cc ) ** 8 ) + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO' ) !$OMP SIMD do cc = 1_idef , pchunk rm_RE ( cc ) = sqrt (( Y_R ( cc ) - R0_RE ) ** 2 + ( Y_Z ( cc ) - Z0_RE ) ** 2 ) ne ( cc ) = ( ne0 - n_ne ) / 4._rp * ( 1 + tanh (( rm_RE ( cc ) + & n_REr0 * ( time / n_tauion - 1 )) / n_lamfront )) * & ( 1 + tanh ( - ( rm_RE ( cc ) - n_REr0 ) / n_lamback )) + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO1' ) !$OMP SIMD do cc = 1_idef , pchunk rm_RE ( cc ) = sqrt (( Y_R ( cc ) - R0_RE ) ** 2 + ( Y_Z ( cc ) - Z0_RE ) ** 2 ) ne ( cc ) = ( ne0 - n_ne ) / 8._rp * ( 1 + tanh (( rm_RE ( cc ) + & n_REr0 * ( time / n_tauion - 1 )) / n_lamfront )) * & ( 1 + tanh ( - ( rm_RE ( cc ) - n_REr0 ) / n_lamback )) * & ( 2 * ( n_shelf - n_ne ) / ( ne0 - n_ne ) + ( ne0 - n_shelf ) / ( ne0 - n_ne ) * & ( 1 - tanh (( rm_RE ( cc ) + n_REr0 * (( time - n_shelfdelay ) / n_tauin - 1 )) / & n_lamshelf ))) + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO-PSI' ) !$OMP SIMD do cc = 1_idef , pchunk PSIpN ( cc ) = ( PSIp ( cc ) - PSIp0 ) / ( PSIp_lim - PSIp0 ) ne ( cc ) = ( ne0 - n_ne ) / 8._rp * ( 1 + tanh (( sqrt ( abs ( PSIpN ( cc ))) + & sqrt ( abs ( psiN_0 )) * ( time / n_tauion - 1 )) / n_psifront )) * & ( 1 + tanh ( - ( sqrt ( abs ( PSIpN ( cc ))) - sqrt ( abs ( psiN_0 ))) / n_psiback )) * & ( 2 * ( n_shelf - n_ne ) / ( ne0 - n_ne ) + ( ne0 - n_shelf ) / ( ne0 - n_ne ) * & ( 1 - tanh (( sqrt ( abs ( PSIpN ( cc ))) + sqrt ( abs ( psiN_0 )) * & (( time - n_shelfdelay ) / n_tauin - 1 )) / n_psishelf ))) + n_ne end do !$OMP END SIMD !       write(output_unit_write,*) 'at time ',time*params%cpp%time, & !' ne: ',ne(1)/params%cpp%length**3 !       !$OMP SIMD !       do cc=1_idef,8 !          if(isnan(ne(cc))) then !             write(output_unit_write,*) 'PSIp: ',PSIp(cc) !             write(output_unit_write,*) 'PSIp0: ',PSIp0 !             write(output_unit_write,*) 'PSIp_lim: ',PSIp_lim !             write(output_unit_write,*) 'PSIpN: ',PSIpN(cc) !             stop 'ne_eval is a NaN' !          end if !       end do !       !$OMP END SIMD CASE ( 'RE-EVO-PSIN-SG' ) n0t = ( ne0 - n_ne ) / 2._rp * ( tanh ( time / n_tauin ) - & tanh (( time - n_shelfdelay ) / n_tauin )) n_taut = n_psishelf * erf (( time + params % dt / 10 0._rp ) / n_tauion ) !$OMP SIMD do cc = 1_idef , pchunk PSIpN ( cc ) = ( PSIp ( cc ) - PSIp0 ) / ( PSIp_lim - PSIp0 ) ne ( cc ) = n0t * exp ( - ( sqrt ( abs ( PSIpN ( cc ))) - sqrt ( abs ( psiN_0 ))) ** 2._rp / & ( 2._rp * n_taut ** 2._rp )) * ( 1._rp + erf ( - 1 0._rp * & ( sqrt ( abs ( PSIpN ( cc ))) - sqrt ( abs ( psiN_0 ))) / & ( sqrt ( 2._rp ) * n_taut ))) / 2._rp + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO-PSIP-G' ) !       write(output_unit_write,*) 'time: ',time*params%cpp%time n0t = ( ne0 - n_ne ) / 2._rp * ( tanh (( time - n_tauin ) / n_tauin ) - & tanh (( time - n_shelfdelay ) / n_tauout )) n_taut = n_psishelf * erf (( time + params % dt / 10 0._rp ) / n_tauion ) !$OMP SIMD do cc = 1_idef , pchunk PSIp_temp ( cc ) = PSIp ( cc ) * ( params % cpp % Bo * params % cpp % length ** 2 ) ne ( cc ) = n0t * exp ( - ( sqrt ( abs ( PSIp_temp ( cc ))) - sqrt ( abs ( psiN_0 ))) ** 2._rp / & ( 2._rp * n_taut ** 2._rp )) + n_ne end do !$OMP END SIMD CASE DEFAULT !$OMP SIMD do cc = 1_idef , pchunk ne ( cc ) = ne0 end do !$OMP END SIMD END SELECT SELECT CASE ( TRIM ( P % Te_profile )) CASE ( 'FLAT' ) !$OMP SIMD do cc = 1_idef , pchunk Te ( cc ) = Te0 end do !$OMP END SIMD CASE ( 'SPONG' ) !$OMP SIMD do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) ** 2 + ( Y_Z ( cc ) - Z0 ) ** 2 ) r_a ( cc ) = rm ( cc ) / a Te ( cc ) = Te0 * ( 1._rp - 0.6 * r_a ( cc ) ** 2 ) ** 2 + Te0 * n_Te end do !$OMP END SIMD CASE DEFAULT !$OMP SIMD do cc = 1_idef , pchunk Te ( cc ) = P % Teo end do !$OMP END SIMD END SELECT SELECT CASE ( TRIM ( P % Zeff_profile )) CASE ( 'FLAT' ) !$OMP SIMD do cc = 1_idef , pchunk Zeff ( cc ) = P % Zeffo end do !$OMP END SIMD CASE ( 'SPONG' ) !$OMP SIMD do cc = 1_idef , pchunk Zeff ( cc ) = P % Zeffo end do !$OMP END SIMD CASE DEFAULT !$OMP SIMD do cc = 1_idef , pchunk Zeff ( cc ) = P % Zeffo end do !$OMP END SIMD END SELECT !    write(output_unit_write,*) PSIpN(1) !    write(output_unit_write,'(\"ne: \"E17.10)') ne(1)/params%cpp%length**3 !    write(output_unit_write,'(\"rm_RE: \"E17.10)') rm_RE(1) end subroutine analytical_profiles_p subroutine get_analytical_profiles ( P , Y , ne , Te , Zeff , flag ) !! @note Subroutine that calculates the analytical plasma profiles at !! the particles' position. @endnote TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in toroidal coordinates; Y(1,:) = r, Y(2,:) !! = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: ne !! Background electron density seen by simulated particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Te !! Backgroun temperature density seen by simulated particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Zeff !! Effective atomic charge seen by simulated particles. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed !! (flag=T) or not (flag=F). REAL ( rp ) :: r_a !! Normalized toroidal radial position of simulated particles !! r/a, where a is the plasma radius. REAL ( rp ) :: fr !! Calculated radial profile. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,fr,r_a) & !$OMP& SHARED(P,Y,ne,Te,Zeff,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then r_a = Y ( pp , 1 ) / P % a !          write(output_unit_write,'(\"r: \",E17.10)') r_a SELECT CASE ( TRIM ( P % ne_profile )) CASE ( 'TANH' ) fr = 1_ip - TANH ( 2.0_rp * r_a ) ** P % n_ne ne ( pp ) = P % neo * fr CASE ( 'FLAT' ) ne ( pp ) = P % neo CASE ( 'POLYNOMIAL' ) fr = P % a_ne ( 1 ) + P % a_ne ( 2 ) * r_a + P % a_ne ( 3 ) * r_a ** 2 + & P % a_ne ( 4 ) * r_a ** 3 ne ( pp ) = P % neo * fr CASE ( 'SPONG' ) fr = P % neo * ( 1._rp - 0.2 * r_a ** 8 ) + P % neo * P % n_ne ne ( pp ) = P % neo * fr CASE DEFAULT ne ( pp ) = P % neo END SELECT SELECT CASE ( TRIM ( P % Te_profile )) CASE ( 'TANH' ) fr = 1_ip - TANH ( 2.0_rp * r_a ) ** P % n_Te Te ( pp ) = P % Teo * fr CASE ( 'FLAT' ) Te ( pp ) = P % Teo CASE ( 'POLYNOMIAL' ) fr = P % a_Te ( 1 ) + P % a_Te ( 2 ) * r_a + P % a_Te ( 3 ) * r_a ** 2 + & P % a_Te ( 4 ) * r_a ** 3 Te ( pp ) = P % Teo * fr CASE ( 'SPONG' ) fr = P % Teo * ( 1._rp - 0.6 * r_a ** 2 ) ** 2 + P % Teo * P % n_Te ne ( pp ) = P % neo * fr CASE DEFAULT Te ( pp ) = P % Teo END SELECT SELECT CASE ( TRIM ( P % Zeff_profile )) CASE ( 'TANH' ) fr = 1_ip - TANH ( 2.0_rp * r_a ) ** P % n_Zeff Zeff ( pp ) = P % Zeffo * fr CASE ( 'FLAT' ) Zeff ( pp ) = P % Zeffo CASE ( 'POLYNOMIAL' ) fr = P % a_Zeff ( 1 ) + P % a_Zeff ( 2 ) * r_a + P % a_Zeff ( 3 ) * r_a ** 2 + & P % a_Zeff ( 4 ) * r_a ** 3 Zeff ( pp ) = P % Zeffo * fr CASE ( 'SPONG' ) Zeff ( pp ) = P % Zeffo CASE DEFAULT Zeff ( pp ) = P % Zeffo END SELECT end if end do !$OMP END PARALLEL DO end subroutine get_analytical_profiles subroutine get_profiles ( params , vars , P , F ) !! @note Subrotuine that calls the appropriate subroutine for calculating !! or interpolating the plasma profiles at the particles' position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of PARTICLES containing the variables of a given species. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all !! the information about the plasma profiles used in the !! simulation. See [[korc_types] and [[korc_profiles]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. SELECT CASE ( TRIM ( params % profile_model )) CASE ( 'ANALYTICAL' ) !       write(output_unit_write,'(\"Y in: \",E17.10)') vars%Y(1,:) call cyl_to_cart ( vars % Y , vars % X ) !       write(output_unit_write,'(\"X getprof: \",E17.10)') vars%X(1,:) call cart_to_tor_check_if_confined ( vars % X , F , vars % Y , vars % flagCon ) !       write(output_unit_write,'(\"flag: \",I15)') vars%flagCon(1) call get_analytical_profiles ( P , vars % Y , vars % ne , vars % Te , & vars % Zeff , vars % flagCon ) call cart_to_cyl ( vars % X , vars % Y ) !       write(output_unit_write,'(\"Y out: \",E17.10)') vars%Y(1,:) CASE ( 'EXTERNAL' ) call interp_profiles ( params , vars , P ) CASE ( 'UNIFORM' ) call uniform_profiles ( vars , P ) CASE DEFAULT END SELECT end subroutine get_profiles ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ! Subroutines for getting the profiles data from HDF5 files ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * subroutine load_profiles_data_from_hdf5 ( params , P ) !! @note Subroutine that loads pre-computed plasma profiles' data !! from an input HDF5 file. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the !! simulation. See [[korc_types]] and [[korc_profiles]]. CHARACTER ( MAX_STRING_LENGTH ) :: filename !!String containing the name of the input HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a parameter in the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: subgname !! String containing the subgroup name of a parameter in the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !!Name of data set to read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HID_T ) :: subgroup_id !!HDF5 subgroup identifier. REAL ( rp ) :: rdatum !! INTEGER :: h5error !! HDF5 error status. filename = TRIM ( P % filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_profiles_data_from_hdf5 --> h5fopen_f\")' ) end if dset = \"/NR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) P % dims ( 1 ) = INT ( rdatum ) if ( P % axisymmetric ) then P % dims ( 2 ) = 0 else dset = \"/NPHI\" call load_from_hdf5 ( h5file_id , dset , rdatum ) P % dims ( 2 ) = INT ( rdatum ) end if dset = \"/NZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) P % dims ( 3 ) = INT ( rdatum ) if ( P % axisymmetric ) then call ALLOCATE_2D_PROFILES_ARRAYS ( P ) else call ALLOCATE_3D_PROFILES_ARRAYS ( P ) end if dset = \"/R\" call load_array_from_hdf5 ( h5file_id , dset , P % X % R ) if (. NOT . P % axisymmetric ) then dset = \"/PHI\" call load_array_from_hdf5 ( h5file_id , dset , P % X % PHI ) end if dset = \"/Z\" call load_array_from_hdf5 ( h5file_id , dset , P % X % Z ) dset = \"/FLAG\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % FLAG2D ) else call load_array_from_hdf5 ( h5file_id , dset , P % FLAG3D ) end if dset = \"/ne\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % ne_2D ) else call load_array_from_hdf5 ( h5file_id , dset , P % ne_3D ) end if dset = \"/Te\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % Te_2D ) P % Te_2D = P % Te_2D * C_E else call load_array_from_hdf5 ( h5file_id , dset , P % Te_3D ) P % Te_3D = P % Te_3D * C_E end if !write(output_unit_write,'(\"Te: \",E17.10)') P%Te_2D(1,1) dset = \"/Zeff\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % Zeff_2D ) else call load_array_from_hdf5 ( h5file_id , dset , P % Zeff_3D ) end if call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_profiles_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_profiles_data_from_hdf5 !> @brief Subroutine that allocates the mesh information and 2-D arrays for keeping the data of pre-computed plasma profiles. !! !! @param[out] P An instance of KORC's derived type PROFILES containing all the information about the plasma profiles used in the !! simulation. See korc_types.f90 and korc_profiles.f90. subroutine ALLOCATE_2D_PROFILES_ARRAYS ( P ) TYPE ( PROFILES ), INTENT ( INOUT ) :: P ALLOCATE ( P % X % R ( P % dims ( 1 ))) ALLOCATE ( P % X % Z ( P % dims ( 3 ))) ALLOCATE ( P % FLAG2D ( P % dims ( 1 ), P % dims ( 3 ))) ALLOCATE ( P % ne_2D ( P % dims ( 1 ), P % dims ( 3 ))) ALLOCATE ( P % Te_2D ( P % dims ( 1 ), P % dims ( 3 ))) ALLOCATE ( P % Zeff_2D ( P % dims ( 1 ), P % dims ( 3 ))) end subroutine ALLOCATE_2D_PROFILES_ARRAYS subroutine ALLOCATE_3D_PROFILES_ARRAYS ( P ) !! @note Subroutine that allocates the mesh information and 3-D arrays !! for keeping the data of pre-computed plasma profiles. @endnote TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! @param[out] P An instance of KORC's derived type PROFILES containing !! all the information about the plasma profiles used in the !! simulation. See [[korc_types]] and [[korc_profiles]]. ALLOCATE ( P % X % R ( P % dims ( 1 ))) ALLOCATE ( P % X % PHI ( P % dims ( 2 ))) ALLOCATE ( P % X % Z ( P % dims ( 3 ))) ALLOCATE ( P % FLAG3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) ALLOCATE ( P % ne_3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) ALLOCATE ( P % Te_3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) ALLOCATE ( P % Zeff_3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) end subroutine ALLOCATE_3D_PROFILES_ARRAYS end module korc_profiles","tags":"","loc":"sourcefile/korc_profiles.f90.html"},{"title":"korc_spatial_distribution.f90 – KORC-Full Orbit","text":"Contents Modules korc_spatial_distribution Source Code korc_spatial_distribution.f90 Source Code MODULE korc_spatial_distribution !! @note Module with subroutines for generating the initial spatial distribution !! of the different partciles' species in the simulation. @endnote USE korc_types USE korc_constants USE korc_HDF5 USE korc_hpc use korc_fields use korc_profiles use korc_rnd_numbers use korc_random use korc_hammersley_generator use korc_avalanche use korc_experimental_pdf IMPLICIT NONE REAL ( rp ), PRIVATE , PARAMETER :: minmax_buffer_size = 1 0.0_rp PUBLIC :: intitial_spatial_distribution PRIVATE :: uniform ,& disk ,& torus ,& elliptic_torus ,& exponential_elliptic_torus ,& gaussian_elliptic_torus ,& exponential_torus ,& gaussian_torus ,& fzero ,& MH_gaussian_elliptic_torus ,& indicator ,& PSI_ROT ,& Spong_3D ,& Spong_2D , & MH_psi CONTAINS subroutine uniform ( spp ) !! @note Initializing to zero the particles' position when !! simulating a 'UNIFORM' plasma. @endnote !! Even though in a simulation of a uniform plasma the particles' !! position is not advanced, we initialize their position to zero. !! @todo Modify KORC for not allocating the particles' position !! spp%vars%X and to do not use it along the simulation. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the !! parameters and simulation variables of the different !!species in the simulation. spp % vars % X = 0.0_rp end subroutine uniform subroutine disk ( params , spp ) !! @note Subrotuine for generating a uniform disk/ring as the !! initial spatial condition of a given species of particles !! in the simulation. @endnote !! This uniform disk/ring distribution is generated using the !! Inverse Transform Sampling method. In this case, the (toroidal) !! radial distribution function of the particles is: !! !! f(r) = \\left\\{ \\begin{array}{ll} 0 & r<r_{min} \\\\ !! \\frac{1}{2\\pi&#94;2(r_{max}&#94;2-r_{min}&#94;2)R_0} !! & r_{min}<r<r_{max} \\\\ 0 & r>r_{max} \\end{array} \\right., !! !! where r_{min} and r_{max} are the inner and outer !! radius of the uniform ring distribution, and R_0 is the !! cylindrical radial position of the center of the disk/ring distribution. !! This distribution is so that \\int_0&#94;{2\\pi}\\int_{r_{min}}&#94;{r_{max}} f(r) !! J(r,\\theta) drd\\theta = 1 , where \\theta is the poloidal angle, !! and J(r,\\theta)=r(R_0 + r\\cos\\theta) is the Jacobian of the !! transformation of Cartesian coordinates to toroidal coordinates. !! Notice that in the case of a disk r_{min}=0. As a convention, !! this spatial distribution will be generated on the xz-plane. !! Using the Inverse Transform Sampling method we sample f(r), !! and obtain the radial position of the particles as r = \\sqrt{(r_{max}&#94;2 !! - r_{min}&#94;2)U + r_{min}&#94;2}, where U is a uniform deviate in [0,1]. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all !! the parameters and simulation variables of the different !! species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r !! Radial position of the particles r. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform deviates in the range [0,2\\pi] representing !! the uniform poloidal angle \\theta distribution of the particles. ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) r = SQRT (( spp % r_outter ** 2 - spp % r_inner ** 2 ) * r + spp % r_inner ** 2 ) spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( spp % PHIo ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( spp % PHIo ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( r ) end subroutine disk subroutine torus ( params , spp ) !! @note Subrotuine for generating a uniform torus/torus !! shell as the initial spatial condition of a given species !! of particles in the simulation.@endnote !! This distribution is generated using the Inverse Transform !! Sampling method. This distribution follows the same radial !! distribution of a uniform disk/ring distribution, see the !! documentation of the [[disk]] subroutine. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES !! containing all the parameters and simulation variables of the !! different species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r !! Radial position of the particles r. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform deviates in the range [0,2\\pi] !! representing the uniform poloidal angle \\theta !! distribution of the particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta !! Uniform deviates in the range [0,2\\pi] representing !! the uniform toroidal angle \\zeta distribution of the particles. INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( r ) r = SQRT (( spp % r_outter ** 2 - spp % r_inner ** 2 ) * r + spp % r_inner ** 2 ) spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( zeta ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( zeta ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine torus subroutine elliptic_torus ( params , spp ) !! @note Subroutine for generating a uniform elliptic torus as the initial !! spatial condition of a given particle species in the simulation. @endnote !! An initial spatial distribution following the uniform distribution of !! [[torus]] is modified through a shear transformation and a rotation to !! generate a uniform spatial distribution on tori with elliptic cross sections. !! First, we obtain the uniform spatial distribution in a torus of minor radius !! r_0, see [[torus]]. Then, we perform a shear transformation that changes !! the cross section of the torus from circular to a tilted ellipse. In !! cylindrical coordinates this shear transformation is given by: !! !! R' = R + \\alpha Z, !! Z' = Z, !! !! where \\alpha is the shear factor of the transformation. !! Here, R and Z are the radial and vertical position of the particles !! uniformly distributed in a circular torus, R' and Z' are their !! new positions when following a uniform distribution in a torus with !! elliptic circular cross section. The center of the ellipse is !! R_0' = R_0 + \\alpha Z_0, and Z_0 = Z_0, where R_0 and Z_0 !! is the center of the initial circular torus. The major and minor semi-axes !! of the tilted ellipse cross section is: !! !! a' = \\left[ - \\frac{2r_0&#94;2}{\\alpha \\sqrt{\\alpha&#94;2 + 4} - (2+\\alpha&#94;2)} !!  \\right]&#94;{1/2}, !! b' = \\left[ \\frac{2r_0&#94;2}{\\alpha \\sqrt{\\alpha&#94;2 + 4} + (2+\\alpha&#94;2)} !!  \\right]&#94;{1/2}. !! !! Finally, we rotate the ellipse cross section anticlockwise along !! (R_0',Z_0') by \\Theta = \\cot&#94;{-1}(\\alpha/2)/2, so the major semi-axis is !! parallel to the Z-axis. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rotation_angle !! This is the angle \\Theta in the equations above. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform deviates in the range [0,2\\pi] representing the uniform !! poloidal angle \\theta distribution of the particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r !! Radial position of the particles r. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta !! Uniform deviates in the range [0,2\\pi] representing !! the uniform toroidal angle \\zeta distribution of the particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X !! Auxiliary vector used in the coordinate transformations. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y !! Auxiliary vector used in the coordinate transformations. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X1 !! Auxiliary vector used in the coordinate transformations. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y1 !! Auxiliary vector used in the coordinate transformations. ALLOCATE ( X1 ( spp % ppp )) ALLOCATE ( Y1 ( spp % ppp )) ALLOCATE ( X ( spp % ppp )) ALLOCATE ( Y ( spp % ppp )) ALLOCATE ( rotation_angle ( spp % ppp )) ALLOCATE ( theta ( spp % ppp )) ALLOCATE ( zeta ( spp % ppp )) ALLOCATE ( r ( spp % ppp )) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) r = SQRT (( spp % r_outter ** 2 - spp % r_inner ** 2 ) * r + spp % r_inner ** 2 ) Y = r * SIN ( theta ) X = r * COS ( theta ) + spp % shear_factor * Y !> @todo Modify this approximation. rotation_angle = 0.5_rp * C_PI - ATAN ( 1.0_rp , 1.0_rp + spp % shear_factor ); X1 = X * COS ( rotation_angle ) - Y * SIN ( rotation_angle ) + spp % Ro Y1 = X * SIN ( rotation_angle ) + Y * COS ( rotation_angle ) + spp % Zo spp % vars % X (:, 1 ) = X1 * SIN ( zeta ) spp % vars % X (:, 2 ) = X1 * COS ( zeta ) spp % vars % X (:, 3 ) = Y1 DEALLOCATE ( X1 ) DEALLOCATE ( Y1 ) DEALLOCATE ( X ) DEALLOCATE ( Y ) DEALLOCATE ( rotation_angle ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine elliptic_torus !> @note Function used to find the zeros of f(r) of \\ref !! korc_spatial_distribution.exponential_torus. @endnote !! !! @param f Value of function. !! @param r Guess value of radial position of the particles. !! @param a Minor radius of the toroidal distribution r_0 !! @param ko Decay rate of radial distribution, see f(r) of \\ref korc_spatial_distribution.exponential_torus. !! @param P Deviate of a random uniform distribution in the interval [0,1]. FUNCTION fzero ( r , a , ko , P ) RESULT ( f ) REAL ( rp ) :: f REAL ( rp ), INTENT ( IN ) :: r REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: ko REAL ( rp ), INTENT ( IN ) :: P f = EXP ( - ko * r ) * ( 1.0_rp + r * ko ) + ( 1.0_rp - EXP ( - ko * a ) * ( 1.0_rp + a * ko ) ) * P - 1.0_rp END FUNCTION fzero !> @brief Subroutine that generates a exponentially decaying radial distribution of particles in a circular cross-section torus of !! major and minor radi R_0 and r_0, respectively. !! @details We generate this exponentially decaying radial distribution f(r) following the same approach as in !! \\ref korc_spatial_distribution.disk, but this time, the radial distribution is given by: !! !! !! f(r) = \\left\\{ \\begin{array}{ll} \\frac{k_0&#94;2}{4\\pi&#94;2 R_0}\\frac{\\exp{\\left( -k_0 r \\right)}}{1 - \\exp{\\left( -k_0r_0\\right)}\\left[ 1 + k_0 r_0 \\right]} &\\ !! r<r_0 \\\\ 0 & r>r_0 \\end{array} \\right. !! !! !! The radial position of the particles r is obtained using the Inverse Trasnform Sampling method, finding r numerically !! through the Newton-Raphson method. First, we calculate the particles' radial distribution in a disk centered at (R,Z) = (0,0). !! Then, we transfor to a new set of coordinates where the disk is centered at (R,Z) = (R_0,Z_0). Finally, we generate the !! toroidal distribution by givin each particle a toroidal angle \\zeta which follows a uniform distribution in the interval !! [0,2\\pi]. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different !! species in the simulation. !! @param fl Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param fr Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param fm Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rl Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rr Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rm Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param relerr Tolerance used to determine when to stop iterating the Newton-Raphson method for finding r. !! @param r Radial position of the particles r. !! @param theta Uniform deviates in the range [0,2\\pi] representing the uniform poloidal angle \\theta distribution of the particles. !! @param zeta Uniform deviates in the range [0,2\\pi] representing the uniform toroidal angle \\zeta distribution of the particles. !! @param pp Particle iterator. subroutine exponential_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ) :: fl REAL ( rp ) :: fr REAL ( rp ) :: fm REAL ( rp ) :: rl REAL ( rp ) :: rr REAL ( rp ) :: rm REAL ( rp ) :: relerr REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta INTEGER :: pp ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a ! disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) ! Newton-Raphson applied here for finding the radial distribution do pp = 1_idef , spp % ppp rl = 0.0_rp rr = spp % r_outter fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if do while ( relerr . GT . 1.0_rp ) rm = 0.5_rp * ( rr - rl ) + rl fm = fzero ( rm , spp % r_outter , spp % falloff_rate , r ( pp )) if ( SIGN ( 1.0_rp , fm ). EQ . SIGN ( 1.0_rp , fr )) then rr = rm else rl = rm end if fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if end do r ( pp ) = rm end do spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( zeta ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( zeta ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine exponential_torus !> @brief Subroutine that generates an exponentially decaying radial distribution in an elliptic torus as the initial spatial !! condition of a given particle species in the simulation. !! @details As a first step, we generate an exponentially decaying radial distribution in a circular cross-section torus as in !! \\ref korc_spatial_distribution.exponential_torus. Then we transform this spatial distribution to a one in an torus with an !! elliptic cross section, this following the same approach as in \\ref korc_spatial_distribution.elliptic_torus. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different !! species in the simulation. !! @param fl Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param fr Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param fm Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rl Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rr Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rm Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param relerr Tolerance used to determine when to stop iterating the Newton-Raphson method for finding r. !! @param rotation_angle This is the angle \\Theta in \\ref korc_spatial_distribution.elliptic_torus. !! @param r Radial position of the particles r. !! @param theta Uniform deviates in the range [0,2\\pi] representing the uniform poloidal angle \\theta distribution of the particles. !! @param zeta Uniform deviates in the range [0,2\\pi] representing the uniform toroidal angle \\zeta distribution of the particles. !! @param X Auxiliary vector used in the coordinate transformations. !! @param Y Auxiliary vector used in the coordinate transformations. !! @param X1 Auxiliary vector used in the coordinate transformations. !! @param Y1 Auxiliary vector used in the coordinate transformations. !! @param pp Particle iterator. subroutine exponential_elliptic_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ) :: fl REAL ( rp ) :: fr REAL ( rp ) :: fm REAL ( rp ) :: rl REAL ( rp ) :: rr REAL ( rp ) :: rm REAL ( rp ) :: relerr REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rotation_angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X1 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y1 INTEGER :: pp ALLOCATE ( X1 ( spp % ppp )) ALLOCATE ( Y1 ( spp % ppp )) ALLOCATE ( X ( spp % ppp )) ALLOCATE ( Y ( spp % ppp )) ALLOCATE ( rotation_angle ( spp % ppp ) ) ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a ! disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) do pp = 1_idef , spp % ppp rl = 0.0_rp rr = spp % r_outter fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if do while ( relerr . GT . 1.0_rp ) rm = 0.5_rp * ( rr - rl ) + rl fm = fzero ( rm , spp % r_outter , spp % falloff_rate , r ( pp )) if ( SIGN ( 1.0_rp , fm ). EQ . SIGN ( 1.0_rp , fr )) then rr = rm else rl = rm end if fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if end do r ( pp ) = rm end do Y = r * SIN ( theta ) X = r * COS ( theta ) + spp % shear_factor * Y rotation_angle = 0.5_rp * C_PI - ATAN ( 1.0_rp , 1.0_rp + spp % shear_factor ); X1 = X * COS ( rotation_angle ) - Y * SIN ( rotation_angle ) + spp % Ro Y1 = X * SIN ( rotation_angle ) + Y * COS ( rotation_angle ) + spp % Zo spp % vars % X (:, 1 ) = X1 * SIN ( zeta ) spp % vars % X (:, 2 ) = X1 * COS ( zeta ) spp % vars % X (:, 3 ) = Y1 DEALLOCATE ( X1 ) DEALLOCATE ( Y1 ) DEALLOCATE ( X ) DEALLOCATE ( Y ) DEALLOCATE ( rotation_angle ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine exponential_elliptic_torus !> @brief Subroutine that generates a Gaussian radial distribution in an elliptic torus as the initial spatial !! condition of a given particle species in the simulation. !! @details As a first step, we generate an Gaussian radial distribution in a circular cross-section torus as in !! \\ref korc_spatial_distribution.gaussian_torus. Then we transform this spatial distribution to a one in an torus with an !! elliptic cross section, this following the same approach as in \\ref korc_spatial_distribution.elliptic_torus. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different !! species in the simulation. !! @param rotation_angle This is the angle \\Theta in \\ref korc_spatial_distribution.elliptic_torus. !! @param r Radial position of the particles r. !! @param theta Uniform deviates in the range [0,2\\pi] representing the uniform poloidal angle \\theta distribution of the particles. !! @param zeta Uniform deviates in the range [0,2\\pi] representing the uniform toroidal angle \\zeta distribution of the particles. !! @param X Auxiliary vector used in the coordinate transformations. !! @param Y Auxiliary vector used in the coordinate transformations. !! @param X1 Auxiliary vector used in the coordinate transformations. !! @param Y1 Auxiliary vector used in the coordinate transformations. !! @param sigma Standard deviation \\sigma of the radial distribution function. !! @param pp Particle iterator. subroutine gaussian_elliptic_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rotation_angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X1 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y1 REAL ( rp ) :: sigma INTEGER :: pp ALLOCATE ( X1 ( spp % ppp )) ALLOCATE ( Y1 ( spp % ppp )) ALLOCATE ( X ( spp % ppp )) ALLOCATE ( Y ( spp % ppp )) ALLOCATE ( rotation_angle ( spp % ppp ) ) ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a ! disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) sigma = 1.0_rp / SQRT ( 2.0_rp * ( spp % falloff_rate / params % cpp % length )) sigma = sigma / params % cpp % length r = sigma * SQRT ( - 2.0_rp * LOG ( 1.0_rp - ( 1.0_rp - & EXP ( - 0.5_rp * spp % r_outter ** 2 / sigma ** 2 )) * r )) !  spp%vars%X(:,1) = ( spp%Ro + r*COS(theta) )*SIN(zeta) !  spp%vars%X(:,2) = ( spp%Ro + r*COS(theta) )*COS(zeta) !  spp%vars%X(:,3) = spp%Zo + r*SIN(theta) Y = r * SIN ( theta ) X = r * COS ( theta ) + spp % shear_factor * Y rotation_angle = 0.5_rp * C_PI - ATAN ( 1.0_rp , 1.0_rp + spp % shear_factor ); X1 = X * COS ( rotation_angle ) - Y * SIN ( rotation_angle ) + spp % Ro Y1 = X * SIN ( rotation_angle ) + Y * COS ( rotation_angle ) + spp % Zo spp % vars % X (:, 1 ) = X1 * SIN ( zeta ) spp % vars % X (:, 2 ) = X1 * COS ( zeta ) spp % vars % X (:, 3 ) = Y1 DEALLOCATE ( X1 ) DEALLOCATE ( Y1 ) DEALLOCATE ( X ) DEALLOCATE ( Y ) DEALLOCATE ( rotation_angle ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine gaussian_elliptic_torus FUNCTION PSI_ROT ( R , R0 , sigR , Z , Z0 , sigZ , theta ) REAL ( rp ), INTENT ( IN ) :: R !! R-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: R0 !! R-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigR !! Variance of first dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: Z !! Z-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: Z0 !! Z-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigZ !! Variance of second dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: theta !! Angle of counter-clockwise rotation (in radians), of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: PSI_ROT !! Argument of exponential comprising 2D Gaussian distribution PSI_ROT = ( R - R0 ) ** 2 * (( cos ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( sin ( theta )) ** 2 / ( 2 * sigZ ** 2 )) + & 2 * ( R - R0 ) * ( Z - Z0 ) * cos ( theta ) * sin ( theta ) * ( 1 / ( 2 * sigR ** 2 ) - 1 / ( 2 * sigZ ** 2 )) + & ( Z - Z0 ) ** 2 * (( sin ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( cos ( theta )) ** 2 / ( 2 * sigZ ** 2 )) END FUNCTION PSI_ROT FUNCTION indicator ( psi , psi_max ) REAL ( rp ), INTENT ( IN ) :: psi REAL ( rp ), INTENT ( IN ) :: psi_max REAL ( rp ) :: indicator IF ( psi . LT . psi_max ) THEN indicator = 1 ELSE indicator = 0 END IF END FUNCTION indicator FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = mean + sigma * SQRT ( - 2.0_rp * LOG ( rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm subroutine MH_gaussian_elliptic_torus ( params , spp ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples !! REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ZETA_samples !! REAL ( rp ) :: psi_max_buff !! REAL ( rp ) :: theta_rad !! REAL ( rp ) :: R_buffer !! REAL ( rp ) :: Z_buffer !! REAL ( rp ) :: R_test !! REAL ( rp ) :: Z_test !! REAL ( rp ) :: psi0 !! REAL ( rp ) :: psi1 !! REAL ( rp ) :: rand_unif !! REAL ( rp ) :: ratio !! INTEGER :: nsamples !! INTEGER :: ii !! Particle iterator. INTEGER :: mpierr LOGICAL :: accepted nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.1_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( ZETA_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo ii = 2_idef do while ( ii . LE . 1000_idef ) R_test = R_buffer + random_norm ( 0.0_rp , spp % sigmaR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % sigmaZ ) psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , spp % sigmaZ , theta_rad ) ratio = indicator ( psi1 , spp % psi_max ) * R_test * EXP ( - psi1 ) / ( R_buffer * EXP ( - psi0 )) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) R_test = R_buffer + random_norm ( 0.0_rp , spp % sigmaR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % sigmaZ ) psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , spp % sigmaZ , theta_rad ) ratio = indicator ( psi1 , psi_max_buff ) * R_test * EXP ( - psi1 ) / ( R_buffer * EXP ( - psi0 )) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test end if end if IF ( INT ( indicator ( psi1 , spp % psi_max )). EQ . 1. and . accepted ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer !           call RANDOM_NUMBER(rand_unif) ZETA_samples ( ii ) = 2.0_rp * C_PI !!*rand_unif ii = ii + 1_idef END IF end do end if CALL MPI_SCATTER ( R_samples * sin ( ZETA_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( R_samples * cos ( ZETA_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , spp % vars % X (:, 3 ), & spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( ZETA_samples ) end if end subroutine MH_gaussian_elliptic_torus !> @brief Subroutine that generates a Gaussian radial distribution of particles in a circular cross-section torus of !! major and minor radi R_0 and r_0, respectively. !! @details We generate this exponentially decaying radial distribution f(r) following the same approach as in !! \\ref korc_spatial_distribution.disk, but this time, the radial distribution is given by: !! !! !! f(r) = \\left\\{ \\begin{array}{ll} \\frac{1}{4\\pi&#94;2 \\sigma&#94;2 R_0}\\frac{\\exp{\\left( -\\frac{r&#94;2}{2\\sigma&#94;2} \\right)}}{1 - \\exp{\\left( -\\frac{r_0&#94;2}{2\\sigma&#94;2} \\right)}} &\\ !! r<r_0 \\\\ 0 & r>r_0 \\end{array} \\right.  !! !! !! The radial position of the particles r is obtained using the Inverse Trasnform Sampling method, finding r numerically !! through the Newton-Raphson method. First, we calculate the particles' radial distribution in a disk centered at (R,Z) = (0,0). !! Then, we transfor to a new set of coordinates where the disk is centered at (R,Z) = (R_0,Z_0). Finally, we generate the !! toroidal distribution by givin each particle a toroidal angle \\zeta which follows a uniform distribution in the interval !! [0,2\\pi]. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different !! species in the simulation. !! @param fl Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param fr Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param fm Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rl Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rr Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param rm Variable used in the Newton-Raphson method for finding the radial position of each particle. !! @param relerr Tolerance used to determine when to stop iterating the Newton-Raphson method for finding r. !! @param r Radial position of the particles r. !! @param theta Uniform deviates in the range [0,2\\pi] representing the uniform poloidal angle \\theta distribution of the particles. !! @param zeta Uniform deviates in the range [0,2\\pi] representing the uniform toroidal angle \\zeta distribution of the particles. !! @param pp Particle iterator. subroutine gaussian_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r ! temporary vars REAL ( rp ) :: sigma ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) sigma = 1.0_rp / SQRT ( 2.0_rp * ( spp % falloff_rate / params % cpp % length )) sigma = sigma / params % cpp % length r = sigma * SQRT ( - 2.0_rp * LOG ( 1.0_rp - ( 1.0_rp - & EXP ( - 0.5_rp * spp % r_outter ** 2 / sigma ** 2 )) * r )) spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( zeta ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( zeta ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine gaussian_torus function Spong_2D ( R0 , b , w , dlam , R , Z , T ) REAL ( rp ), INTENT ( IN ) :: R0 REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ), INTENT ( IN ) :: w REAL ( rp ), INTENT ( IN ) :: dlam REAL ( rp ), INTENT ( IN ) :: R REAL ( rp ), INTENT ( IN ) :: Z REAL ( rp ), INTENT ( IN ) :: T Real ( rp ) :: rm Real ( rp ) :: lam REAL ( rp ) :: Spong_2D rm = sqrt (( R - R0 ) ** 2 + Z ** 2 ) lam = ( sin ( deg2rad ( T ))) ** 2 Spong_2D = ( 1 - tanh (( rm - b ) / w )) / ( 1 - tanh ( - b / w )) * exp ( - ( lam / dlam ) ** 2 ) end function Spong_2D subroutine Spong_3D ( params , spp ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: T_samples !! Pitch angle of all samples REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: T_buffer !! Previous sample of pitch angle REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: T_test !! Present sample of pitch angle REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: f0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: f1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.1_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp ! buffer at minimum pitch angle boundary if ( spp % etao_lims ( 1 ). GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = spp % etao_lims ( 1 ) - REAL ( ii , rp ) * & ( spp % etao_lims ( 2 ) - spp % etao_lims ( 1 )) / 100_rp if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = spp % etao_lims ( 1 ) end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = spp % etao_lims ( 2 ) + REAL ( ii , rp ) * & ( spp % etao_lims ( 2 ) - spp % etao_lims ( 1 )) / 100_rp if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( T_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo call RANDOM_NUMBER ( rand_unif ) T_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * rand_unif !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length ii = 1_idef do while ( ii . LE . 1000_idef ) !        write(output_unit_write,'(\"burn:\",I15)') ii R_test = R_buffer + random_norm ( 0.0_rp , spp % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % dZ ) T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) ! Test that pitch angle and momentum are within chosen boundary do while (( T_test . GT . spp % etao_lims ( 2 )). OR . & ( T_test . LT . spp % etao_lims ( 1 ))) T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) f0 = Spong_2D ( spp % Ro , spp % Spong_b , spp % Spong_w , spp % Spong_dlam , & R_buffer , Z_buffer , T_buffer ) else psi0 = psi1 f0 = f1 end if psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) f1 = Spong_2D ( spp % Ro , spp % Spong_b , spp % Spong_w , spp % Spong_dlam , & R_test , Z_test , T_test ) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 !        write(output_unit_write,'(\"f0: \",E17.10)') f0 !        write(output_unit_write,'(\"f1: \",E17.10)') f1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator ( psi1 , spp % psi_max ) * R_test * EXP ( - psi1 ) * f1 / & ( R_buffer * EXP ( - psi0 ) * f0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , 10000 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if R_test = R_buffer + random_norm ( 0.0_rp , spp % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % dZ ) T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) ! Selection boundary is set with buffer region do while (( T_test . GT . max_pitch_angle ). OR . & ( T_test . LT . min_pitch_angle )) if ( T_test . lt . 0 ) then T_test = abs ( T_test ) exit end if T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) end do psi0 = psi1 f0 = f1 psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) f1 = Spong_2D ( spp % Ro , spp % Spong_b , spp % Spong_w , spp % Spong_dlam , & R_test , Z_test , T_test ) ratio = indicator ( psi1 , psi_max_buff ) * R_test * EXP ( - psi1 ) * f1 / & ( R_buffer * EXP ( - psi0 ) * f0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test end if end if ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator ( psi1 , spp % psi_max )). EQ . 1 ). AND . & ( T_buffer . LE . spp % etao_lims ( 2 )). AND . & ( T_buffer . GE . spp % etao_lims ( 1 ))) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer T_samples ( ii ) = T_buffer ! Sample phi location uniformly call RANDOM_NUMBER ( rand_unif ) PHI_samples ( ii ) = 2.0_rp * C_PI * rand_unif ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length end if CALL MPI_SCATTER ( R_samples * cos ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( R_samples * sin ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) !  CALL MPI_SCATTER(T_samples,spp%ppp,MPI_REAL8, & !       spp%vars%eta,spp%ppp,MPI_REAL8,0,MPI_COMM_WORLD,mpierr) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( T_samples ) end if end subroutine Spong_3D subroutine MH_psi ( params , spp , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples , X_samples , Y_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ) :: min_R , max_R REAL ( rp ) :: min_Z , max_Z REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: psi_max , psi_max_buff REAL ( rp ) :: PSIp_lim , PSIP0 , PSIN , PSIN0 , PSIN1 , sigma , psi0 , psi1 REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator LOGICAL :: accepted INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , * ) '*** START SAMPLING ***' end if nsamples = spp % ppp * params % mpi_params % nmpi params % GC_coords = . TRUE . PSIp_lim = F % PSIp_lim if ( params % field_model . eq . 'M3D_C1' ) then min_R = params % rmin / params % cpp % length max_R = params % rmax / params % cpp % length min_Z = params % Zmin / params % cpp % length max_Z = params % Zmax / params % cpp % length PSIp0 = F % PSIp_0 psi_max = spp % psi_max psi_max_buff = spp % psi_max else min_R = minval ( F % X % R ) max_R = maxval ( F % X % R ) min_Z = minval ( F % X % Z ) max_Z = maxval ( F % X % Z ) PSIp0 = F % PSIP_min psi_max = spp % psi_max psi_max_buff = spp % psi_max * 2._rp end if sigma = spp % sigmaR * params % cpp % length !write(output_unit_write,*) min_R,max_R !write(output_unit_write,*) min_Z,max_Z ALLOCATE ( R_samples ( nsamples )) ALLOCATE ( X_samples ( nsamples )) ALLOCATE ( Y_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes if ( params % mpi_params % rank . EQ . 0_idef ) then ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if write ( output_unit_write , '(\"Begin burn: \",I10)' ) accepted = . false . ii = 1_idef do while ( ii . LE . 1000_idef ) if ( modulo ( ii , 100 ). eq . 0 ) then write ( output_unit_write , '(\"Burn: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then spp % vars % Y ( 1 , 1 ) = R_buffer spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_buffer !write(6,*) 'R',R_buffer !write(6,*) 'Z',Z_buffer if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_vector_potential ( spp % vars , F , params ) else call get_fields ( params , spp % vars , F ) end if spp % vars % flagCon = 1_is !write(6,*) 'may have crashed' !write(6,*) 'R',R_buffer !write(6,*) 'Z',Z_buffer !write(6,*) 'PSIlim',PSIp_lim !write(6,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI1',psi1 !write(6,*) 'PSI0',psi0 !write(output_unit_write,*) 'PSIN1',PSIN1 !write(6,*) 'PSIN0',PSIN0 psi0 = spp % vars % PSI_P ( 1 ) PSIN0 = ( psi0 - PSIp0 ) / ( PSIp_lim - PSIp0 ) end if if ( accepted ) then PSIN0 = PSIN1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0._rp spp % vars % Y ( 1 , 3 ) = Z_test if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_vector_potential ( spp % vars , F , params ) else call get_fields ( params , spp % vars , F ) end if spp % vars % flagCon = 1_is psi1 = spp % vars % PSI_P ( 1 ) !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI',psi1 PSIN1 = ( psi1 - PSIp0 ) / ( PSIp_lim - PSIp0 ) !write(output_unit_write,*) 'R',R_test !write(output_unit_write,*) 'Z',Z_test !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI1',psi1 !write(output_unit_write,*) 'PSI0',psi0 !write(output_unit_write,*) 'PSIN',PSIN1 !write(output_unit_write,*) 'PSIN0',PSIN0 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator ( PSIN1 , psi_max ) * & R_test * EXP ( - PSIN1 / sigma ) / & ( R_buffer * EXP ( - PSIN0 / sigma )) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef !write(output_unit_write,*) 'PSIN',PSIN1 else !           call RANDOM_NUMBER(rand_unif) !           if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef !write(output_unit_write,*) 'PSIN',PSIN1 end if end if end do ! Transient ! write ( output_unit_write , '(\"Begin sample: \",I10)' ) ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do if ( accepted ) then PSIN0 = PSIN1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_vector_potential ( spp % vars , F , params ) else call get_fields ( params , spp % vars , F ) end if spp % vars % flagCon = 1_is psi1 = spp % vars % PSI_P ( 1 ) !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI',psi1 PSIN1 = ( psi1 - PSIp0 ) / ( PSIp_lim - PSIp0 ) !write(output_unit_write,*) 'R',R_test !write(output_unit_write,*) 'Z',Z_test !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI1',psi1 !write(output_unit_write,*) 'PSI0',psi0 !write(output_unit_write,*) 'PSIN',PSIN1 !write(output_unit_write,*) 'PSIN0',PSIN0 ratio = indicator ( PSIN1 , psi_max_buff ) * & R_test * EXP ( - PSIN1 / sigma ) / & ( R_buffer * EXP ( - PSIN0 / sigma )) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test else !call RANDOM_NUMBER(rand_unif) !if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test end if end if !        write(output_unit_write,'(\"R: \",E17.10)') R_buffer !        write(output_unit_write,'(\"Z: \",E17.10)') Z_buffer ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator ( PSIN1 , psi_max )). EQ . 1 ). AND . & ACCEPTED ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer !write(output_unit_write,*) 'PSIN',PSIN1 !           write(output_unit_write,*) 'RS',R_buffer ! Sample phi location uniformly !call RANDOM_NUMBER(rand_unif) !PHI_samples(ii) = 2.0_rp*C_PI*rand_unif !PHI_samples(ii) = 2.0_rp*C_PI*get_random_mkl_U() PHI_samples ( ii ) = 2.0_rp * C_PI * get_random_U () ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length X_samples = R_samples * cos ( PHI_samples ) Y_samples = R_samples * sin ( PHI_samples ) !     write(output_unit_write,*) 'R_samples',R_samples !     write(output_unit_write,*) 'PHI_samples',PHI_samples !     write(output_unit_write,*) 'Z_samples',Z_samples !     write(output_unit_write,*) 'G_samples',G_samples !     write(output_unit_write,*) 'eta_samples',eta_samples end if params % GC_coords = . FALSE . call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( X_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Y_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) DEALLOCATE ( R_samples ) DEALLOCATE ( X_samples ) DEALLOCATE ( Y_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) end subroutine MH_psi subroutine intitial_spatial_distribution ( params , spp , P , F ) !! @note Subroutine that contains calls to the different subroutines !! for initializing the simulated particles with various !! spatial distribution functions. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters and !! simulation variables of the different species in the simulation. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. INTEGER :: ss !! Species iterator. INTEGER :: mpierr do ss = 1_idef , params % num_species SELECT CASE ( TRIM ( spp ( ss )% spatial_distribution )) CASE ( 'UNIFORM' ) call uniform ( spp ( ss )) CASE ( 'DISK' ) call disk ( params , spp ( ss )) CASE ( 'TORUS' ) call torus ( params , spp ( ss )) CASE ( 'EXPONENTIAL-TORUS' ) call exponential_torus ( params , spp ( ss )) CASE ( 'GAUSSIAN-TORUS' ) call gaussian_torus ( params , spp ( ss )) CASE ( 'ELLIPTIC-TORUS' ) call elliptic_torus ( params , spp ( ss )) CASE ( 'EXPONENTIAL-ELLIPTIC-TORUS' ) call exponential_elliptic_torus ( params , spp ( ss )) CASE ( 'GAUSSIAN-ELLIPTIC-TORUS' ) call gaussian_elliptic_torus ( params , spp ( ss )) CASE ( '2D-GAUSSIAN-ELLIPTIC-TORUS-MH' ) call MH_gaussian_elliptic_torus ( params , spp ( ss )) CASE ( 'AVALANCHE-4D' ) call get_Avalanche_4D ( params , spp ( ss ), P , F ) !! In addition to spatial distribution function, [[Avalanche_4D]] !! samples the avalanche distribution function used to initialize !! the components of velocity for all particles. CASE ( 'TRACER' ) spp ( ss )% vars % X (:, 1 ) = spp ( ss )% Xtrace ( 1 ) spp ( ss )% vars % X (:, 2 ) = spp ( ss )% Xtrace ( 2 ) spp ( ss )% vars % X (:, 3 ) = spp ( ss )% Xtrace ( 3 ) CASE ( 'SPONG-3D' ) call Spong_3D ( params , spp ( ss )) CASE ( 'HOLLMANN-3D' ) call get_Hollmann_distribution_3D ( params , spp ( ss ), F ) CASE ( 'HOLLMANN-3D-PSI' ) call get_Hollmann_distribution_3D_psi ( params , spp ( ss ), F ) CASE ( 'MH_psi' ) if ( spp ( ss )% ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) & 'num_samples need to be atleast 10 but is only: ' , & spp ( ss )% ppp * params % mpi_params % nmpi end if call korc_abort end if call MH_psi ( params , spp ( ss ), F ) CASE DEFAULT call torus ( params , spp ( ss )) END SELECT end do end subroutine intitial_spatial_distribution END MODULE korc_spatial_distribution","tags":"","loc":"sourcefile/korc_spatial_distribution.f90.html"},{"title":"korc_velocity_distribution.f90 – KORC-Full Orbit","text":"Contents Modules korc_velocity_distribution Source Code korc_velocity_distribution.f90 Source Code MODULE korc_velocity_distribution !! @note Module containing subroutines to initialize the velocity !! distribution of the simulated particles. @endnote USE korc_types USE korc_constants USE korc_HDF5 USE korc_hpc use korc_fields use korc_rnd_numbers use korc_hammersley_generator use korc_avalanche use korc_experimental_pdf use korc_energy_pdfs use korc_simple_equilibrium_pdf IMPLICIT NONE PUBLIC :: initial_gyro_distribution ,& thermal_distribution ,& initial_energy_pitch_dist PRIVATE :: fth_3V ,& random_norm ,& gyro_distribution CONTAINS FUNCTION fth_3V ( Vth , V ) !! @note Function used to sample the probability density function of a !! thermal plasma in the 3-dimensional velocity space. @endnote !! This function returns f_{T_e}(v) = \\exp{\\left( v&#94;2/2v_{T_e}&#94;2 \\right)}, !! where v_{T_e} = \\sqrt{T_e/m_e} is !! the temperature of the thermal electrons, and v = |\\mathbf{v}| !! is the speed of the sampled electron. REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: V !! Velocity of the sampled electron \\mathbf{v}. REAL ( rp ), INTENT ( IN ) :: Vth !! Thermal velocity of the background electrons v_{T_e}. REAL ( rp ) :: fth_3V !! Value of f_{T_e}(v). fth_3V = EXP ( - 0.5_rp * DOT_PRODUCT ( V , V ) / Vth ** 2.0_rp ) END FUNCTION fth_3V FUNCTION random_norm ( mu , sigma ) !! @note Gaussian random number generator. @endnote !! This function returns a deviate of a Gaussian distribution !! f_G(x;\\mu,\\sigma) = !! \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp{\\left( -(x-\\mu)&#94;2/2\\sigma&#94;2 \\right)}, !! !! with mean \\mu, and standard deviation \\sigma. !! !! We use the Inverse Transform Sampling Method for sampling x. !! With this method we get x = \\sqrt{-2\\log{(1-y)}}\\cos(2\\pi z), !! where y and z are uniform random numbers in the interval [0,1]. REAL ( rp ), INTENT ( IN ) :: mu !! Mean value \\mu of the Gaussian distribution. REAL ( rp ), INTENT ( IN ) :: sigma !! Standard deviation \\sigma of the Gaussian distribution. REAL ( rp ) :: random_norm !! Sampled number x from the Gaussian distribution f_G(x;\\mu,\\sigma). REAL ( rp ) :: rand1 !! Uniform random number in the interval [0,1]. REAL ( rp ) :: rand2 !! Uniform random number in the interval [0,1]. call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = SQRT ( - 2.0_rp * LOG ( 1.0_rp - rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm subroutine thermal_distribution ( params , spp ) !! @note Subroutine that samples a thermal distribution function !! of electrons for generating the initial condition of a set of !! simulated particles. @endnote !! This subroutine uses the Inverse Transform Sampling Method along !! with the  Metropolis-Hastings algorithm to generate an !! initial condition of the velocity distribution that follows a !! 3-dimensional (in velocity space) thermal distribution. !! @todo Check that the gyro-distribution is initialized right in !! this function. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the !! parameters and simulation variables of the different species !! in the simulation. REAL ( rp ) :: Vmax !! Velocity cutoff where we stop sampling the tail of the thermal !! distribution. REAL ( rp ) :: vsq !! REAL ( rp ) :: Vth !! Thermal velocity of the sampled distribution v_{T_e} = !! \\sqrt{T_e/m_e}. REAL ( rp ) :: sv !! Step to sample the velocity space using the Metropolis-Hastings !! algorithm. REAL ( rp ) :: ratio !! Ratio used to accept or reject a sampling in the Metropolis-Hastings !! algorithm. REAL ( rp ) :: rand_unif !! Uniform random deviate in the interval  [0,1]. REAL ( rp ), DIMENSION ( 3 ) :: V !! Sampled velocity. REAL ( rp ), DIMENSION ( 3 ) :: U !! Sampled velocity. REAL ( rp ), DIMENSION ( 3 ) :: b = ( / 1.0_rp , 0.0_rp , 0.0_rp / ) !! Temporary variable representing a unit vector along the x-axis. INTEGER :: ii !! Iterator. INTEGER :: ppp !! Number of particles per species. Vmax = 0.9_rp Vth = SQRT ( spp % Eo * ABS ( spp % q ) / spp % m ) ppp = spp % ppp V = ( / 0.0_rp , 0.0_rp , 0.0_rp / ) sv = Vth / 1 0.0_rp ii = 2_idef do while ( ii . LE . 1000_idef ) U ( 1 ) = V ( 1 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 1 )) . GT . Vmax ) U ( 1 ) = V ( 1 ) + random_norm ( 0.0_rp , sv ) end do U ( 2 ) = V ( 2 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 2 )) . GT . Vmax ) U ( 2 ) = V ( 2 ) + random_norm ( 0.0_rp , sv ) end do U ( 3 ) = V ( 3 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 3 )) . GT . Vmax ) U ( 3 ) = V ( 3 ) + random_norm ( 0.0_rp , sv ) end do ratio = fth_3V ( Vth , U ) / fth_3V ( Vth , V ) if ( ratio . GE . 1.0_rp ) then V = U ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( ratio . GT . rand_unif ) then V = U ii = ii + 1_idef end if end if end do spp % vars % V ( 1 , 1 ) = V ( 1 ) spp % vars % V ( 1 , 2 ) = V ( 2 ) spp % vars % V ( 1 , 3 ) = V ( 3 ) ii = 2_idef do while ( ii . LE . ppp ) U ( 1 ) = spp % vars % V ( ii - 1 , 1 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 1 )) . GT . Vmax ) U ( 1 ) = spp % vars % V ( ii - 1 , 1 ) + random_norm ( 0.0_rp , sv ) end do U ( 2 ) = spp % vars % V ( ii - 1 , 2 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 2 )) . GT . Vmax ) U ( 2 ) = spp % vars % V ( ii - 1 , 2 ) + random_norm ( 0.0_rp , sv ) end do U ( 3 ) = spp % vars % V ( ii - 1 , 3 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 3 )) . GT . Vmax ) U ( 3 ) = spp % vars % V ( ii - 1 , 3 ) + random_norm ( 0.0_rp , sv ) end do ratio = fth_3V ( Vth , U ) / fth_3V ( Vth , spp % vars % V ( ii - 1 ,:)) if ( ratio . GE . 1.0_rp ) then spp % vars % V ( ii , 1 ) = U ( 1 ) spp % vars % V ( ii , 2 ) = U ( 2 ) spp % vars % V ( ii , 3 ) = U ( 3 ) ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( ratio . GT . rand_unif ) then spp % vars % V ( ii , 1 ) = U ( 1 ) spp % vars % V ( ii , 2 ) = U ( 2 ) spp % vars % V ( ii , 3 ) = U ( 3 ) ii = ii + 1_idef end if end if end do do ii = 1_idef , ppp vsq = spp % vars % V ( ii , 1 ) * spp % vars % V ( ii , 1 ) & + spp % vars % V ( ii , 2 ) * spp % vars % V ( ii , 2 ) & + spp % vars % V ( ii , 3 ) * spp % vars % V ( ii , 3 ) spp % vars % g ( ii ) = 1.0_rp / SQRT ( 1.0_rp - vsq ) spp % vars % eta ( ii ) = ACOS ( spp % vars % V ( ii , 1 ) / SQRT ( vsq )) end do spp % go = spp % Eo / ( spp % m * C_C ** 2 ) spp % etao = 9 0.0_rp end subroutine thermal_distribution subroutine initial_energy_pitch_dist ( params , spp ) !! @note Subroutine that calls subroutines of different modules to !! initialize the energy and pitch-angle distribution in various ways. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters and !! simulation variables of the different species in the simulation. INTEGER :: ii !! Species iterator. INTEGER :: mpierr !! MPI error status. do ii = 1_idef , params % num_species if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * SPECIES: \",I2,\" * * * * * * * * * * *\")' ) ii write ( output_unit_write , '(\"Particles per MPI process: \",I16)' ) spp ( ii )% ppp write ( output_unit_write , '(\"Energy distribution is: \",A20)' ) & TRIM ( spp ( ii )% energy_distribution ) write ( output_unit_write , '(\"Pitch-angle distribution is: \",A20)' ) & TRIM ( spp ( ii )% pitch_distribution ) write ( output_unit_write , '(\"Spatial distribution is: \",A20)' ) & TRIM ( spp ( ii )% spatial_distribution ) write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if SELECT CASE ( TRIM ( spp ( ii )% energy_distribution )) CASE ( 'MONOENERGETIC' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergetic spp ( ii )% Eo_lims = ( / spp ( ii )% Eo , spp ( ii )% Eo / ) CASE ( 'THERMAL' ) call thermal_distribution ( params , spp ( ii )) spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) - & spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'AVALANCHE' ) call get_avalanche_distribution ( params , spp ( ii )% vars % g , & spp ( ii )% vars % eta , spp ( ii )% go , spp ( ii )% etao ) spp ( ii )% Eo = spp ( ii )% m * C_C ** 2 * spp ( ii )% go - spp ( ii )% m * C_C ** 2 spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'HOLLMANN' ) call get_Hollmann_distribution ( params , spp ( ii )) !          spp(ii)%Eo = spp(ii)%m*C_C**2*spp(ii)%go - spp(ii)%m*C_C**2 spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'EXPERIMENTAL-GAMMA' ) call get_experimentalG_distribution ( params , spp ( ii )% vars % g , & spp ( ii )% vars % eta , & spp ( ii )% go , spp ( ii )% etao ) spp ( ii )% Eo = spp ( ii )% m * C_C ** 2 * spp ( ii )% go - spp ( ii )% m * C_C ** 2 spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'GAMMA' ) call get_gamma_distribution ( params , spp ( ii )% vars % g , spp ( ii )% go ) spp ( ii )% Eo = spp ( ii )% m * C_C ** 2 * spp ( ii )% go - spp ( ii )% m * C_C ** 2 spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'UNIFORM' ) spp ( ii )% Eo = spp ( ii )% Eo_lims ( 1 ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) call generate_2D_hammersley_sequence ( params % mpi_params % rank , & params % mpi_params % nmpi , spp ( ii )% vars % g , spp ( ii )% vars % eta ) spp ( ii )% vars % g = ( spp ( ii )% Eo_lims ( 2 ) - & spp ( ii )% Eo_lims ( 1 )) * spp ( ii )% vars % g / ( spp ( ii )% m * C_C ** 2 ) + & ( spp ( ii )% Eo_lims ( 1 ) + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) CASE ( 'AVALANCHE-4D' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergy from input file until sampled in Avalanche_4D CASE ( 'HOLLMANN-3D' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergy from input file until sampled in Hollmann_3D CASE ( 'HOLLMANN-3D-PSI' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergy from input file until sampled in Hollmann_3D CASE DEFAULT ! Something to be done END SELECT call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) SELECT CASE ( TRIM ( spp ( ii )% pitch_distribution )) CASE ( 'MONOPITCH' ) spp ( ii )% vars % eta = spp ( ii )% etao ! Mono-pitch-angle if ( spp ( ii )% spatial_distribution . ne . 'SPONG-3D' ) then spp ( ii )% etao_lims = ( / spp ( ii )% etao , spp ( ii )% etao / ) end if CASE ( 'THERMAL' ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ), & MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'AVALANCHE' ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ), & MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'HOLLMANN' ) !          spp(ii)%vars%eta = spp(ii)%etao !          spp(ii)%etao_lims = (/MINVAL(spp(ii)%vars%eta), & !               MAXVAL(spp(ii)%vars%eta)/) CASE ( 'EXPERIMENTAL-GAMMA' ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ), & MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'UNIFORM' ) spp ( ii )% etao = spp ( ii )% etao_lims ( 1 ) spp ( ii )% vars % eta = ( spp ( ii )% etao_lims ( 2 ) - & spp ( ii )% etao_lims ( 1 )) * spp ( ii )% vars % eta + spp ( ii )% etao_lims ( 1 ) CASE ( 'SIMPLE-EQUILIBRIUM' ) call get_equilibrium_distribution ( params , spp ( ii )% vars % eta , & spp ( ii )% go , spp ( ii )% etao ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ),& MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'AVALANCHE-4D' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Avalanche_4D CASE ( 'HOLLMANN-3D' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Hollmann_3D CASE ( 'HOLLMANN-3D-PSI' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Hollmann_3D CASE ( 'SPONG-3D' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Spong_3D CASE DEFAULT ! Something to be done END SELECT call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) end do end subroutine initial_energy_pitch_dist subroutine gyro_distribution ( params , F , spp ) !! @Note Subroutine that initializes the gyro-angle distribution !! of the particles. @endnote !! When evolving the particles in the 6-D phase space, in addition to !! the position (3 degrees of freedom), energy (one degree of freedom), !! pitch angle (one degree of freedom), we need to define the gyro-angle !! of the particle (one degree of freedom), which is given by the pitch !! angle and the direction of the local magnetic field. By default, this !! subroutine generates a uniform gyro-angle distribution. !! @note Notice that all the simulation variables are normalized !! here. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. This structure !! has the information of the magnetic field. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the !! parameters and !! simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: b1 !! Basis vector pointing along the local magnetic field, that is, !!  along \\mathbf{b} = \\mathbf{B}/B. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: b2 !! Basis vector perpendicular to b1 REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: b3 !! Basis vector perpendicular to b1 and b2. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Vo !! Initial particle speed. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V1 !!  Velocity component along b1. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V2 !! Velocity component along b2. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V3 !! Velocity component along b3. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform random number in the interval [0,2\\pi] !! representing the gyro-angle. INTEGER :: jj !! Particle iterator. ALLOCATE ( Vo ( spp % ppp )) ALLOCATE ( V1 ( spp % ppp )) ALLOCATE ( V2 ( spp % ppp )) ALLOCATE ( V3 ( spp % ppp )) ALLOCATE ( b1 ( spp % ppp , 3 )) ALLOCATE ( b2 ( spp % ppp , 3 )) ALLOCATE ( b3 ( spp % ppp , 3 )) ALLOCATE ( theta ( spp % ppp ) ) ! * * * * INITIALIZE VELOCITY * * * * call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta if ( spp % spatial_distribution . eq . 'TRACER' ) theta = 2.0 * C_PI Vo = SQRT ( 1.0_rp - 1.0_rp / ( spp % vars % g (:) ** 2 ) ) V1 = Vo * COS ( C_PI * spp % vars % eta / 18 0.0_rp ) V2 = Vo * SIN ( C_PI * spp % vars % eta / 18 0.0_rp ) * COS ( theta ) V3 = Vo * SIN ( C_PI * spp % vars % eta / 18 0.0_rp ) * SIN ( theta ) call unitVectors ( params , spp % vars % X , F , b1 , b2 , b3 , spp % vars % flagCon , & spp % vars % cart , spp % vars % hint ) !! Call to subroutine [[unitVectors]] in [[korc_fields]]. !write(output_unit_write,*) 'X',spp%vars%X !write(output_unit_write,*) 'b-hat',b1 do jj = 1_idef , spp % ppp if ( spp % vars % flagCon ( jj ) . EQ . 1_idef ) then spp % vars % V ( jj , 1 ) = V1 ( jj ) * b1 ( jj , 1 ) + V2 ( jj ) * b2 ( jj , 1 ) + V3 ( jj ) * b3 ( jj , 1 ) spp % vars % V ( jj , 2 ) = V1 ( jj ) * b1 ( jj , 2 ) + V2 ( jj ) * b2 ( jj , 2 ) + V3 ( jj ) * b3 ( jj , 2 ) spp % vars % V ( jj , 3 ) = V1 ( jj ) * b1 ( jj , 3 ) + V2 ( jj ) * b2 ( jj , 3 ) + V3 ( jj ) * b3 ( jj , 3 ) end if end do !    write(output_unit_write,'(\"Vx: \",E17.10)') spp%vars%V(:,1) !    write(output_unit_write,'(\"Vy: \",E17.10)') spp%vars%V(:,2) !    write(output_unit_write,'(\"Vz: \",E17.10)') spp%vars%V(:,3) DEALLOCATE ( theta ) DEALLOCATE ( Vo ) DEALLOCATE ( V1 ) DEALLOCATE ( V2 ) DEALLOCATE ( V3 ) DEALLOCATE ( b1 ) DEALLOCATE ( b2 ) DEALLOCATE ( b3 ) end subroutine gyro_distribution subroutine initial_gyro_distribution ( params , F , spp ) !! @note Subroutine that works as an interface for initializing various !! gyro-angle distributions for the different simulated particle !! species. @endnote !! @todo At this moment this subroutine only calls the subroutine !! to generate !! a uniform gyro-angle distribution. This will be modified later. @endtodo TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. This structure has !! the information of the magnetic field. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. INTEGER :: ss !! Species iterator. do ss = 1_idef , params % num_species SELECT CASE ( TRIM ( spp ( ss )% energy_distribution )) CASE ( 'THERMAL' ) !Nothing, all was done in initialize_particles through !thermal_distribution CASE DEFAULT call gyro_distribution ( params , F , spp ( ss )) END SELECT end do end subroutine initial_gyro_distribution END MODULE korc_velocity_distribution","tags":"","loc":"sourcefile/korc_velocity_distribution.f90.html"},{"title":"korc_hammersley_generator.f90 – KORC-Full Orbit","text":"Contents Modules korc_hammersley_generator Source Code korc_hammersley_generator.f90 Source Code !> @brief Module containing subroutines for generating 1-D and 2-D Hammersley quasi-Monte Carlo sequences. !! @details The algorithm and code for generating the 1-D Hammersley sequence was developed by John Burkardt at the Florida State University. !! Visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\" for more information. !! The algorithm and code for generating the 2-D Hammersley sequence was developed by L. Carbajal at the Oak Ridge National Lab. MODULE korc_hammersley_generator use korc_types IMPLICIT NONE PUBLIC :: hammersley ,& generate_2D_hammersley_sequence PRIVATE :: hammersley_inverse ,& hammersley_sequence ,& r8mat_print ,& r8mat_print_some ,& timestamp ,& prime CONTAINS !> @brief Subroutine for generating a 2-D Hammersley sequence. !! @details This subroutine uses the algorithm for generating a 1-D Hammersley sequence. !! Each MPI process in KORC generates a (different) subset of pairs (X,Y) of a 2-D Hammersley sequence. The total number of pairs (X,Y) !! is NMPIS*N, where NMPIS is the number of MPI processes in the simulation and N is the number of particles followed by each MPI process. !! Each subset of pairs (X,Y) has N elements. !! !! @param[in,out] X 1-D array with elements of a 2-D Hammersley sequence. !! @param[in,out] Y 1-D array with elements of a 2-D Hammersley sequence. !! @param[in] ID MPI rank of MPI process. !! @param[in] NMPIS Total number of MPI processes in the simulation. !! @param N Number of particles per MPI process. !! @param offset An offset to indicate the subroutine what subset of the 2-D Harmmersley sequence will be generated. !! @param ii Particle iterator. subroutine generate_2D_hammersley_sequence ( ID , NMPIS , X , Y ) REAL ( rp ), DIMENSION (:), INTENT ( INOUT ) :: X REAL ( rp ), DIMENSION (:), INTENT ( INOUT ) :: Y INTEGER , INTENT ( IN ) :: ID INTEGER , INTENT ( IN ) :: NMPIS INTEGER ( 4 ) :: N INTEGER ( 4 ) :: offset REAL ( 8 ), DIMENSION ( 2 ) :: R INTEGER ( 4 ) :: ii N = INT ( SIZE ( X ), 4 ) offset = ( INT ( ID + 1_idef , 4 ) - 1 _ 4 ) * N !\twrite(output_unit_write,'(\"MPI process: \",I5,\" offset: \",I5)') ID, offset do ii = 1 _ 4 , N call hammersley ( ii + INT ( offset , 4 ), 2 _ 4 , N * INT ( NMPIS , 4 ), R ) X ( ii ) = REAL ( R ( 1 ), rp ) Y ( ii ) = REAL ( R ( 2 ), rp ) end do end subroutine generate_2D_hammersley_sequence !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". subroutine hammersley ( i , m , n , r ) !*****************************************************************************80 ! !! HAMMERSLEY computes an element of a Hammersley sequence. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    20 August 2016 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    John Hammersley, !    Monte Carlo methods for solving multivariable problems, !    Proceedings of the New York Academy of Science, !    Volume 86, 1960, pages 844-874. ! !  Parameters: ! !    Input, integer ( kind = 4 ) I, the index of the element of the sequence. !    0 <= I. ! !    Input, integer ( kind = 4 ) M, the spatial dimension. ! !    Input, integer ( kind = 4 ) N, the \"base\" for the first component. !    1 <= N. ! !    Output, real ( kind = 8 ) R(M), the element of the sequence with index I. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) d integer ( kind = 4 ) i integer ( kind = 4 ) i1 integer ( kind = 4 ) j integer ( kind = 4 ) n !  integer ( kind = 4 ) prime real ( kind = 8 ) prime_inv ( 2 : m ) real ( kind = 8 ) r ( m ) integer ( kind = 4 ) t ( 2 : m ) t ( 2 : m ) = abs ( i ) ! !  Carry out the computation. ! do i1 = 2 , m prime_inv ( i1 ) = 1.0D+00 / real ( prime ( i1 - 1 ), kind = 8 ) end do r ( 1 ) = real ( mod ( i , n + 1 ), kind = 8 ) / real ( n , kind = 8 ) r ( 2 : m ) = 0.0D+00 do while ( any ( t ( 2 : m ) /= 0 ) ) do j = 2 , m d = mod ( t ( j ), prime ( j - 1 ) ) r ( j ) = r ( j ) + real ( d , kind = 8 ) * prime_inv ( j ) prime_inv ( j ) = prime_inv ( j ) / real ( prime ( j - 1 ), kind = 8 ) t ( j ) = ( t ( j ) / prime ( j - 1 ) ) end do end do return end subroutine hammersley !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". subroutine hammersley_inverse ( r , m , n , i ) !*****************************************************************************80 ! !! HAMMERSLEY_INVERSE inverts an element of the Hammersley sequence. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    20 August 2016 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, real ( kind = 8 ) R(M), the I-th element of the Hammersley sequence. !    0 <= R < 1.0 ! !    Input, integer ( kind = 4 ) M, the spatial dimension. ! !    Input, integer ( kind = 4 ) N, the \"base\" for the first component. !    1 <= N. ! !    Output, integer ( kind = 4 ) I, the index of the element of the sequence. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) d integer ( kind = 4 ) i integer ( kind = 4 ) n integer ( kind = 4 ) p real ( kind = 8 ) r ( m ) real ( kind = 8 ) t if ( any ( r ( 1 : m ) < 0.0D+00 ) . or . any ( 1.0D+00 < r ( 1 : m ) ) ) then write ( * , '(a)' ) '' write ( * , '(a)' ) 'HAMMERSLEY_INVERSE - Fatal error!' write ( * , '(a)' ) '  0 <= R <= 1.0 is required.' stop 1 end if if ( m < 1 ) then write ( * , '(a)' ) '' write ( * , '(a)' ) 'HAMMERSLEY_INVERSE - Fatal error!' write ( * , '(a)' ) '  1 <= M is required.' stop 1 end if if ( n < 1 ) then write ( * , '(a)' ) '' write ( * , '(a)' ) 'HAMMERSLEY_INVERSE - Fatal error!' write ( * , '(a)' ) '  1 <= N is required.' stop 1 end if ! !  Invert using the second component only, because working with base !  2 is accurate. ! if ( 2 <= m ) then i = 0 t = r ( 2 ) p = 1 do while ( t /= 0.0D+00 ) t = t * 2.0D+00 d = int ( t ) i = i + d * p p = p * 2 t = mod ( t , 1.0D+00 ) end do else i = nint ( real ( n , kind = 8 ) * r ( 1 ) ) end if return end subroutine hammersley_inverse !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". function prime ( n ) !*****************************************************************************80 ! !! PRIME returns any of the first PRIME_MAX prime numbers. ! !  Discussion: ! !    PRIME_MAX is 1600, and the largest prime stored is 13499. ! !    Thanks to Bart Vandewoestyne for pointing out a typo, 18 February 2005. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 February 2005 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    Milton Abramowitz, Irene Stegun, !    Handbook of Mathematical Functions, !    US Department of Commerce, 1964, pages 870-873. ! !    Daniel Zwillinger, !    CRC Standard Mathematical Tables and Formulae, !    30th Edition, !    CRC Press, 1996, pages 95-98. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the index of the desired prime number. !    In general, is should be true that 0 <= N <= PRIME_MAX. !    N = -1 returns PRIME_MAX, the index of the largest prime available. !    N = 0 is legal, returning PRIME = 1. ! !    Output, integer ( kind = 4 ) PRIME, the N-th prime.  If N is out of range, !    PRIME is returned as -1. ! implicit none integer ( kind = 4 ), parameter :: prime_max = 1600 integer ( kind = 4 ), save :: icall = 0 integer ( kind = 4 ) n integer ( kind = 4 ), save , dimension ( prime_max ) :: npvec integer ( kind = 4 ) prime if ( icall == 0 ) then icall = 1 npvec ( 1 : 100 ) = ( / & 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , & 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , & 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , & 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , & 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , & 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , & 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , & 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , & 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , & 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 / ) npvec ( 101 : 200 ) = ( / & 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , & 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , & 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , & 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , & 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , & 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , & 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , & 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , & 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , & 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 / ) npvec ( 201 : 300 ) = ( / & 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , & 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , & 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , & 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , & 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , & 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , & 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , & 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , & 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , & 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 / ) npvec ( 301 : 400 ) = ( / & 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , & 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , & 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , & 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , & 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , & 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , & 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , & 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , & 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , & 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 / ) npvec ( 401 : 500 ) = ( / & 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , & 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , & 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , & 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , & 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , & 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , & 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , & 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , & 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , & 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 / ) npvec ( 501 : 600 ) = ( / & 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , & 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , & 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , & 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , & 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , & 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , & 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , & 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , & 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , & 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 / ) npvec ( 601 : 700 ) = ( / & 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , & 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , & 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , & 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , & 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , & 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , & 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , & 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , & 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , & 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 / ) npvec ( 701 : 800 ) = ( / & 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , & 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , & 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , & 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , & 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , & 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , & 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , & 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , & 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , & 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 / ) npvec ( 801 : 900 ) = ( / & 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , & 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , & 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , & 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , & 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , & 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , & 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , & 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , & 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , & 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 / ) npvec ( 901 : 1000 ) = ( / & 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , & 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , & 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , & 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , & 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , & 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , & 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , & 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , & 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , & 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 / ) npvec ( 1001 : 1100 ) = ( / & 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , & 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , & 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , & 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , & 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , & 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , & 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , & 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , & 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , & 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 / ) npvec ( 1101 : 1200 ) = ( / & 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , & 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , & 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , & 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , & 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , & 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , & 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , & 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , & 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , & 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 / ) npvec ( 1201 : 1300 ) = ( / & 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , & 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , & 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , & 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , & 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , & 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , & 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , & 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , & 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , & 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 / ) npvec ( 1301 : 1400 ) = ( / & 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , & 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , & 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , & 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , & 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , & 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , & 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , & 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , & 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , & 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 / ) npvec ( 1401 : 1500 ) = ( / & 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , & 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , & 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , & 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , & 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , & 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , & 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , & 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , & 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , & 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 / ) npvec ( 1501 : 1600 ) = ( / & 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , & 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , & 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , & 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , & 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , & 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , & 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , & 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , & 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , & 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 / ) end if if ( n == - 1 ) then prime = prime_max else if ( n == 0 ) then prime = 1 else if ( n <= prime_max ) then prime = npvec ( n ) else prime = - 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'PRIME - Fatal error!' write ( * , '(a,i8)' ) '  Illegal prime index N = ' , n write ( * , '(a,i8)' ) '  N should be between 1 and PRIME_MAX =' , prime_max stop 1 end if return end function prime !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". subroutine hammersley_sequence ( i1 , i2 , m , n , r ) !*****************************************************************************80 ! !! HAMMERSLEY_SEQUENCE computes elements I1 through I2 of a Hammersley sequence. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    20 August 2016 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    John Hammersley, !    Monte Carlo methods for solving multivariable problems, !    Proceedings of the New York Academy of Science, !    Volume 86, 1960, pages 844-874. ! !  Parameters: ! !    Input, integer ( kind = 4 ) I1, I2, the indices of the first and last !    elements of the sequence.  0 <= I1, I2. ! !    Input, integer ( kind = 4 ) M, the spatial dimension. ! !    Input, integer ( kind = 4 ) N, the \"base\" for the first component. !    1 <= N. ! !    Output, real ( kind = 8 ) R(M,abs(I1-I2)+1), the elements of the sequence !    with indices I1 through I2. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) d integer ( kind = 4 ) i integer ( kind = 4 ) i1 integer ( kind = 4 ) i2 integer ( kind = 4 ) i3 integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) n !  integer ( kind = 4 ) prime real ( kind = 8 ) prime_inv ( 2 : m ) real ( kind = 8 ) r ( m , abs ( i1 - i2 ) + 1 ) integer ( kind = 4 ) t ( 2 : m ) if ( i1 <= i2 ) then i3 = + 1 else i3 = - 1 end if l = abs ( i2 - i1 ) + 1 r ( 1 : m , 1 : l ) = 0.0D+00 k = 0 do i = i1 , i2 , i3 t ( 2 : m ) = i ! !  Carry out the computation. ! do j = 2 , m prime_inv ( j ) = 1.0D+00 / real ( prime ( j - 1 ), kind = 8 ) end do k = k + 1 ; r ( 1 , k ) = real ( mod ( i , n + 1 ), kind = 8 ) / real ( n , kind = 8 ) do while ( any ( t ( 2 : m ) /= 0 ) ) do j = 2 , m d = mod ( t ( j ), prime ( j - 1 ) ) r ( j , k ) = r ( j , k ) + real ( d , kind = 8 ) * prime_inv ( j ) prime_inv ( j ) = prime_inv ( j ) / real ( prime ( j - 1 ), kind = 8 ) t ( j ) = ( t ( j ) / prime ( j - 1 ) ) end do end do end do return end subroutine hammersley_sequence !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows in A. ! !    Input, integer ( kind = 4 ) N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    10 September 2009 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ( kind = 4 ) ILO, JLO, the first row and column to print. ! !    Input, integer ( kind = 4 ) IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) if ( m <= 0 . or . n <= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  (None)' return end if do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j end do write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) end if end do write ( * , '(i5,a,5a14)' ) i , ':' , ( ctemp ( j ), j = 1 , inc ) end do end do return end subroutine r8mat_print_some !> @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". subroutine timestamp ( ) !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    31 May 2001   9:45:54.872 AM ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 May 2013 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return end subroutine timestamp END MODULE korc_hammersley_generator","tags":"","loc":"sourcefile/korc_hammersley_generator.f90.html"},{"title":"korc_energy_pdfs.f90 – KORC-Full Orbit","text":"Contents Modules korc_energy_pdfs Source Code korc_energy_pdfs.f90 Source Code !> @brief Module that contains subroutines and functions to sample various energy distributions. MODULE korc_energy_pdfs USE korc_types USE korc_constants USE korc_HDF5 USE korc_hpc USE korc_input IMPLICIT NONE !> @brief KORC derived type that contains information about a given Gamma distribution function @f$f_\\Gamma(x,\\kappa,\\theta)@f$. !! @details We write a given Gamma distribution function in terms of its shape factor @f$\\kappa@f$ and scale factor !! @f$\\theta@f$, so that: !! !! !! @f$f_\\Gamma(x,\\kappa,\\theta) = \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. TYPE , PRIVATE :: GAMMA_PARAMS REAL ( rp ) :: min_energy !< Minimum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV. REAL ( rp ) :: max_energy !< Maximum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV. REAL ( rp ) :: min_p !< Minimum momentum of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$. REAL ( rp ) :: max_p !< Maximum momentum of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$. REAL ( rp ) :: k !< Shape factor @f$\\kappa@f$. REAL ( rp ) :: t !< Scale factor @f$\\theta@f$. END TYPE GAMMA_PARAMS TYPE ( GAMMA_PARAMS ), PRIVATE :: gamma_pdf_params !< An instance of the KORC derived type GAMMA_PARAMS REAL ( rp ), PRIVATE , PARAMETER :: co = ( C_E * 1.0E6 ) / ( C_ME * C_C ** 2 ) !< Constant with units to transform @f$\\mathcal{E}@f$ in !! @f$f_\\Gamma(\\mathcal{E},\\kappa,\\theta)@f$ from MeV to Joules. REAL ( rp ), PRIVATE , PARAMETER :: minmax_buffer_size = 1 0.0_rp !< This is the size of the buffer zone in each direction when !!using a Metropolis-Hastings method to sample a distribution. PUBLIC :: get_gamma_distribution PRIVATE :: initialize_gamma_params ,& save_gamma_params ,& sample_gamma_distribution ,& deg2rad ,& fRE ,& random_norm ,& fGamma CONTAINS !> @brief Subroutine that contains calls to subroutine to generate a gamma distribution for the energy distribution of a given !! species in the simulation. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] g Relativistic gamma factor @f$\\gamma@f$ of the particles in a given species in the simulation. These are so that, they follow !! a Gamma distribution in energy. The parameters of the Gamma distributions are given by the user. !! @param[out] go Mean value of @f$\\gamma@f$ of the particles in a given species. used to calculate the minimum required time step to !! resolve in detail the full-orbit dynamics of the particles. SUBROUTINE get_gamma_distribution ( params , g , go ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), INTENT ( OUT ) :: go call initialize_gamma_params ( params ) call save_gamma_params ( params ) call sample_gamma_distribution ( params , g , go ) END SUBROUTINE get_gamma_distribution !> @brief Subroutine that reads from the input file the parameters of the Gamma distribution !! @f$f_\\Gamma(x,\\kappa,\\theta) = \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. !! !! @param[in] params Core KORC simulation parameters. !! @param max_energy Maximum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV. !! @param min_energy Minimum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV. !! @param k Shape factor @f$\\kappa@f$. !! @param t Scale factor @f$\\theta@f$. SUBROUTINE initialize_gamma_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ) :: max_energy REAL ( rp ) :: min_energy REAL ( rp ) :: k REAL ( rp ) :: t !NAMELIST /EnergyGammaPDF/ max_energy,min_energy,k,t !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=EnergyGammaPDF) !close(default_unit_open) gamma_pdf_params % min_energy = min_energy_gamma * C_E ! In Joules gamma_pdf_params % max_energy = max_energy_gamma * C_E ! In Joules gamma_pdf_params % k = k_gamma gamma_pdf_params % t = t_gamma gamma_pdf_params % max_p = SQRT (( gamma_pdf_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc gamma_pdf_params % min_p = SQRT (( gamma_pdf_params % min_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc END SUBROUTINE initialize_gamma_params !> @brief Function that converts @f$x@f$ from degrees to radians. !! !! @param x Angle @f$x@f$ in degrees. !! @param deg2rad Angle @f$x@f$ converted to radians. FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad !> @brief Function that calculates the value of the Gamma distribution @f$f_\\Gamma(x,\\kappa,\\theta) = !! \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. !! !! @param x Variable @f$x@f$ of @f$f_\\Gamma(x,\\kappa,\\theta)@f$. !! @param k Shape factor @f$\\kappa@f$ of @f$f_\\Gamma(x,\\kappa,\\theta)@f$. !! @param t Scale factor @f$\\theta@f$ of @f$f_\\Gamma(x,\\kappa,\\theta)@f$. !! @param fGamma Computed value of @f$f_\\Gamma(x,\\kappa,\\theta)@f$. FUNCTION fGamma ( x , k , t ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ), INTENT ( IN ) :: k REAL ( rp ), INTENT ( IN ) :: t REAL ( rp ) :: fGamma fGamma = x ** ( k - 1.0_rp ) * EXP ( - x / t ) / ( GAMMA ( k ) * t ** k ) END FUNCTION fGamma !> Evaluation of the energy distribution function @f$f_{RE}(\\mathcal{E})@f$ of runaway electrons as function of the normalized momentum !! @f$p' = p/m_ec@f$. Here, @f$p'@f$ is the normalized momentum and @f$m_e@f$ and @f$c@f$ are the electron mass and the speed of light. !! !! @param p Normalized momentum @f$p' = p/m_ec@f$ of a given electron in the simulation. !! @param fRE Computed value of the energy distribution function of runaway electrons. !! @param Eo Normalized energy @f$\\mathcal{E}' = \\sqrt{1 + p'}@f$ of the the electron with normalized momentum @f$p'@f$. FUNCTION fRE ( p ) REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRE REAL ( rp ) :: Eo ! In units of mc&#94;2 Eo = SQRT ( p ** 2.0_rp + 1.0_rp ) fRE = fGamma ( Eo , gamma_pdf_params % k , gamma_pdf_params % t * co ) END FUNCTION fRE !> @brief Gaussian random number generator. !! @details This function returns a deviate of a Gaussian distribution @f$f_G(x;\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp{\\left( -(x-\\mu)&#94;2/2\\sigma&#94;2 \\right)}@f$, !! with mean @f$\\mu@f$, and standard deviation @f$\\sigma@f$. !! !! We use the Inverse Transform Sampling Method for sampling @f$x@f$. With this method we get @f$x = \\sqrt{-2\\log{(1-y)}}\\cos(2\\pi z)@f$, !! where @f$y@f$ and @f$z@f$ are uniform random numbers in the interval @f$[0,1]@f$. !! !! @param[in] mu Mean value @f$\\mu@f$ of the Gaussian distribution. !! @param[in] mu Standard deviation @f$\\sigma@f$ of the Gaussian distribution. !! @param random_norm Sampled number @f$x@f$ from the Gaussian distribution @f$f_G(x;\\mu,\\sigma)@f$. !! @param rand1 Uniform random number in the interval @f$[0,1]@f$. !! @param rand2 Uniform random number in the interval @f$[0,1]@f$. FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 REAL ( rp ) :: rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = SQRT ( - 2.0_rp * LOG ( 1.0_rp - rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm !> @brief Subroutine that samples a Gamma distribution representing the runaways' (marginal) energy distribution function. !! @details This subroutine uses the Metropolis-Hastings method for sampling the Gamma distribution representing the runaways' !! (marginal) energy distribution function. Unlike the typical Metropolis-Hasting method, after setting the boundaries of the region !! we want to sample, we perform a sampling in a larger region that contains the original sampling area plus a buffer region. !! After finishing the first sampling, we only keep the particles in the original sampling region, the particles in the p_buffer !! are sampled again until all of them lie within the original sampling region. This method ensures that the boundaries are !! well sampled. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] g Relativistic gamma factor @f$\\gamma@f$ of the particles in a given species in the simulation. These are so that, !! they follow a Gamma distribution in energy. The parameters of the Gamma distributions are given by the user. !! @param[out] go Mean value of @f$\\gamma@f$ of the particles in a given species. used to calculate the minimum required time step to !! resolve in detail the full-orbit dynamics of the particles. !! @param p Sampled normalized momentum @f$p' = p/m_ec@f$ of particles in a given particle species. !! @param p_buffer Size along the momentum axis of the buffer used in the Metropolis-Hastings method. !! @param p_test The test value of the normalized momentum used in the Metropolis-Hastings method. !! @param ratio Ratio of probabilities used to determine when a move in during the sampling is kept as part of the sampled chain. !! @param rand_unif A deviate of a uniform random distribution in the interval @f$[0,1]@f$. !! @param p_samples Temporary array to keep the sampled normalized momentum. !! @param deta Step size along the pitch-angle direction of the random walk used in the Metropolis-Hastings sampling. !! @param dp  Step size along the momentum direction of the random walk used in the Metropolis-Hastings sampling. !! @param ii Iterator. !! @param ppp Number of particles per MPI processes. !! @param nsamples Number of total samples in the initial condition of a given simulation. !! @param mpierr MPI error status. SUBROUTINE sample_gamma_distribution ( params , g , go ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: p_buffer REAL ( rp ) :: p_test REAL ( rp ) :: ratio REAL ( rp ) :: rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_samples REAL ( rp ) :: deta REAL ( rp ) :: dp INTEGER :: ii INTEGER :: ppp INTEGER :: nsamples INTEGER :: mpierr ppp = SIZE ( g ) nsamples = ppp * params % mpi_params % nmpi ALLOCATE ( p ( ppp )) dp = 1.0_rp if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( p_samples ( nsamples )) ! Number of samples to distribute among all MPI processes call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) p_buffer = gamma_pdf_params % min_p + ( gamma_pdf_params % max_p - gamma_pdf_params % min_p ) * rand_unif ii = 2_idef do while ( ii . LE . 1000000_idef ) p_test = p_buffer + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . gamma_pdf_params % min_p ). OR .( p_test . GT . gamma_pdf_params % max_p )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( p_test ) / fRE ( p_buffer ) if ( ratio . GE . 1.0_rp ) then p_buffer = p_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_buffer = p_test ii = ii + 1_idef end if end if end do call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) p_samples ( 1 ) = p_buffer ii = 2_idef do while ( ii . LE . nsamples ) p_test = p_samples ( ii - 1 ) + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . gamma_pdf_params % min_p ). OR .( p_test . GT . gamma_pdf_params % max_p )) p_test = p_samples ( ii - 1 ) + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( p_test ) / fRE ( p_samples ( ii - 1 )) if ( ratio . GE . 1.0_rp ) then p_samples ( ii ) = p_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_samples ( ii ) = p_test ii = ii + 1_idef end if end if end do go = SUM ( SQRT ( 1.0_rp + p_samples ** 2 )) / nsamples end if CALL MPI_SCATTER ( p_samples , ppp , MPI_REAL8 , p , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( go , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) g = SQRT ( 1.0_rp + p ** 2 ) DEALLOCATE ( p ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( p_samples ) end if END SUBROUTINE sample_gamma_distribution !> @brief Surboutine that saves the Gamma distribution parameters to the HDF5 file <i>gamma_distribution_parameters.h5</i>. !! !! @param[in] params Core KORC simulation parameters. !! @param filename String containing the name of the HDF5 file. !! @param gname String containing the group name of a set of KORC parameters. !! @param attr_array An 1-D array with attributes of 1-D real or integer arrays that are passed to KORC interfaces of HDF5 I/O subroutines. !! @param dset Name of data set to be saved to file. !! @param attr A single attributes of real or integer data that is passed to KORC interfaces of HDF5 I/O subroutines. !! @param h5file_id HDF5 file identifier. !! @param group_id HDF5 group identifier. !! @param h5error HDF5 error status. !! @param units Temporary variable used to add physical units to KORC parameters. SUBROUTINE save_gamma_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"gamma_distribution_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * gamma_pdf_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * gamma_pdf_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % max_p , attr ) dset = TRIM ( gname ) // \"/min_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % min_p , attr ) dset = TRIM ( gname ) // \"/k\" attr = \"Shape factor\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % k , attr ) dset = TRIM ( gname ) // \"/t\" attr = \"Scale factor\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % t , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_gamma_params END MODULE korc_energy_pdfs","tags":"","loc":"sourcefile/korc_energy_pdfs.f90.html"},{"title":"korc_ppusher.f90 – KORC-Full Orbit","text":"Contents Modules korc_ppusher Source Code korc_ppusher.f90 Source Code module korc_ppusher !! @note Module with subroutines for advancing the particles' position and !! velocity in the simulations. @endnote use korc_types use korc_constants use korc_fields use korc_profiles use korc_interp use korc_collisions use korc_hpc IMPLICIT NONE REAL ( rp ), PRIVATE :: E0 !! Dimensionless vacuum permittivity \\epsilon_0 \\times (m_{ch}&#94;2 !! v_{ch}&#94;3/q_{ch}&#94;3 B_{ch}), see [[korc_units]]. PRIVATE :: cross ,& radiation_force_p ,& GCEoM_p ,& GCEoM1_p ,& aux_fields PUBLIC :: initialize_particle_pusher ,& adv_FOeqn_top ,& adv_FOinterp_top ,& adv_FOm3dc1_top ,& advance_FOeqn_vars ,& advance_FOinterp_vars ,& advance_GCeqn_vars ,& advance_GCinterp_psi_vars ,& advance_GCinterp_B_vars ,& GC_init ,& FO_init ,& adv_GCeqn_top ,& adv_GCinterp_psi_top ,& adv_GCinterp_psiwE_top ,& adv_GCinterp_psi2x1t_top ,& adv_GCinterp_psi_top_FS ,& adv_GCinterp_B_top ,& adv_GCinterp_B2D_top ,& adv_GCinterp_2DBdB_top ,& adv_GCinterp_3DBdB_top ,& adv_GCinterp_3DBdB1_top contains subroutine initialize_particle_pusher ( params ) !! @note This subroutine initializes all the variables needed for advancing !! the particles' position and velocity. @endnote !! This subroutine is specially useful when we need to define or initialize !! values of parameters used to calculate derived quantities. !! The intent of this subroutine is to work as a constructor of the module. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. E0 = C_E0 * ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) / & ( params % cpp % charge ** 3 * params % cpp % Bo ) end subroutine initialize_particle_pusher pure function cross ( a , b ) !! @note Function that calculates and returns the cross product !! \\mathbf{a}\\times \\mathbf{b}. These vectors are in Cartesian !! coordinates. @endnote !! @note Notice that all the variables in this subroutine have been !! normalized using the characteristic scales in [[korc_units]]. @endnote REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: a !! Vector \\mathbf{a}. REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: b !! Vector \\mathbf{b}. REAL ( rp ), DIMENSION ( 3 ) :: cross !!Value of \\mathbf{a}\\times \\mathbf{b} cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross subroutine radiation_force_p ( pchunk , q_cache , m_cache , U_X , U_Y , U_Z , E_X , E_Y , E_Z , & B_X , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: U_X , U_Y , U_Z !! \\mathbf{u} = \\gamma \\mathbf{v}, where \\mathbf{v} is the !! particle's velocity. REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z !! Electric field \\mathbf{E} seen by each particle. This is given !! in Cartesian coordinates. REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z !! Magnetic field \\mathbf{B} seen by each particle. This is given !! in Cartesian coordinates. REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Frad_X , Frad_Y , Frad_Z !! The calculated synchrotron radiation reaction force \\mathbf{F}_R. REAL ( rp ), DIMENSION ( 3 ) :: F1 !! The component \\mathbf{F}_1 of \\mathbf{F}_R. REAL ( rp ), DIMENSION ( pchunk ) :: F2_X , F2_Y , F2_Z !! The component \\mathbf{F}_2 of \\mathbf{F}_R. REAL ( rp ), DIMENSION ( pchunk ) :: F3_X , F3_Y , F3_Z !! The component \\mathbf{F}_3 of \\mathbf{F}_R. REAL ( rp ), DIMENSION ( pchunk ) :: V_X , V_Y , V_Z !! The particle's velocity \\mathbf{v}. REAL ( rp ), DIMENSION ( pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( pchunk ) :: cross_EB_X , cross_EB_Y , cross_EB_Z REAL ( rp ), DIMENSION ( pchunk ) :: cross_BV_X , cross_BV_Y , cross_BV_Z REAL ( rp ), DIMENSION ( pchunk ) :: cross_BBV_X , cross_BBV_Y , cross_BBV_Z REAL ( rp ), DIMENSION ( pchunk ) :: dot_EV , dot_vecvec !! An auxiliary 3-D vector. REAL ( rp ), DIMENSION ( pchunk ) :: g !! The relativistic \\gamma factor of the particle. REAL ( rp ) :: tmp INTEGER :: cc !$OMP SIMD !    !$OMP& aligned(g,U_X,U_Y,U_Z,V_X,V_Y,V_Z, & !    !$OMP& cross_EB_X,cross_EB_Y,cross_EB_Z,E_X,E_Y,E_Z,B_X,B_Y,B_Z, & !    !$OMP& dot_EV,cross_BV_X,cross_BV_Y,cross_BV_Z, & !    !$OMP& cross_BBV_X,cross_BBV_Y,cross_BBV_Z,F2_X,F2_Y,F2_Z, & !    !$OMP& vec_X,vec_Y,vec_Z,dot_vecvec,F3_X,F3_Y,F3_Z, & !    !$OMP& Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g ( cc ) = SQRT ( 1.0_rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) tmp = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_EB_X ( cc ) = E_Y ( cc ) * B_Z ( cc ) - E_Z ( cc ) * B_Y ( cc ) cross_EB_Y ( cc ) = E_Z ( cc ) * B_X ( cc ) - E_X ( cc ) * B_Z ( cc ) cross_EB_Z ( cc ) = E_X ( cc ) * B_Y ( cc ) - E_Y ( cc ) * B_X ( cc ) dot_EV ( cc ) = E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc ) cross_BV_X ( cc ) = B_Y ( cc ) * V_Z ( cc ) - B_Z ( cc ) * V_Y ( cc ) cross_BV_Y ( cc ) = B_Z ( cc ) * V_X ( cc ) - B_X ( cc ) * V_Z ( cc ) cross_BV_Z ( cc ) = B_X ( cc ) * V_Y ( cc ) - B_Y ( cc ) * V_X ( cc ) cross_BBV_X ( cc ) = B_Y ( cc ) * cross_BV_Z ( cc ) - B_Z ( cc ) * cross_BV_Y ( cc ) cross_BBV_Y ( cc ) = B_Z ( cc ) * cross_BV_X ( cc ) - B_X ( cc ) * cross_BV_Z ( cc ) cross_BBV_Z ( cc ) = B_X ( cc ) * cross_BV_Y ( cc ) - B_Y ( cc ) * cross_BV_X ( cc ) F2_X ( cc ) = tmp * ( dot_EV ( cc ) * E_X ( cc ) + cross_EB_X ( cc ) + cross_BBV_X ( cc ) ) F2_Y ( cc ) = tmp * ( dot_EV ( cc ) * E_Y ( cc ) + cross_EB_Y ( cc ) + cross_BBV_Y ( cc ) ) F2_Z ( cc ) = tmp * ( dot_EV ( cc ) * E_Z ( cc ) + cross_EB_Z ( cc ) + cross_BBV_Z ( cc ) ) vec_X ( cc ) = E_X ( cc ) - cross_BV_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) - cross_BV_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) - cross_BV_Z ( cc ) dot_vecvec ( cc ) = vec_X ( cc ) * vec_X ( cc ) + vec_Y ( cc ) * vec_Y ( cc ) + vec_Z ( cc ) * vec_Z ( cc ) F3_X ( cc ) = ( tmp * g ( cc ) ** 2 ) * ( dot_EV ( cc ) ** 2 - dot_vecvec ( cc ) ) * V_X ( cc ) F3_Y ( cc ) = ( tmp * g ( cc ) ** 2 ) * ( dot_EV ( cc ) ** 2 - dot_vecvec ( cc ) ) * V_Y ( cc ) F3_Z ( cc ) = ( tmp * g ( cc ) ** 2 ) * ( dot_EV ( cc ) ** 2 - dot_vecvec ( cc ) ) * V_Z ( cc ) Frad_X ( cc ) = F2_X ( cc ) + F3_X ( cc ) Frad_Y ( cc ) = F2_Y ( cc ) + F3_Y ( cc ) Frad_Z ( cc ) = F2_Z ( cc ) + F3_Z ( cc ) end do !$OMP END SIMD end subroutine radiation_force_p subroutine FO_init ( params , F , spp , output , step ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: Prad !! Total radiated power of each particle. REAL ( rp ) :: Bmag1 !! Magnitude of the magnetic field seen by each particle . REAL ( rp ) :: v !! Speed of each particle. REAL ( rp ) :: vpar !! Parallel velocity v_\\parallel = \\mathbf{v}\\cdot \\hat{b}. REAL ( rp ) :: vperp !! Perpendicular velocity v_\\parallel = |\\mathbf{v} - (\\mathbf{v}\\cdot !! \\hat{b})\\hat{b}|. REAL ( rp ) :: tmp !! Temporary variable used for various computations. REAL ( rp ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( 3 ) :: Frad !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( 3 ) :: vec !! Auxiliary vector used in various computations. REAL ( rp ), DIMENSION ( 3 ) :: b_unit !! Unitary vector pointing along the local magnetic field \\hat{b}. INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. LOGICAL , intent ( in ) :: output LOGICAL , intent ( in ) :: step REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , lam , R0 , q0 , ar TYPE ( C_PTR ), DIMENSION ( params % pchunk ) :: hint INTEGER ( is ) , DIMENSION ( params % pchunk ) :: flagCon , flagCol pchunk = params % pchunk B0 = F % Bo EF0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo ar = F % AB % a do ii = 1_idef , params % num_species m_cache = spp ( ii )% m q_cache = spp ( ii )% q if ( output ) then !$OMP PARALLEL DO default(none) & !$OMP firstprivate(m_cache,q_cache,B0,EF0,lam,R0,q0,ar,pchunk) & !$OMP& shared(params,ii,spp,F) & !$OMP& PRIVATE(pp,cc,X_X,X_Y,X_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,Y_R,Y_PHI,Y_Z,flagCon,flagCol,PSIp,hint) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) B_X ( cc ) = 0._rp B_Y ( cc ) = 0._rp B_Z ( cc ) = 0._rp E_X ( cc ) = 0._rp E_Y ( cc ) = 0._rp E_Z ( cc ) = 0._rp PSIp ( cc ) = 10 0._rp flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if ( params % field_model . eq . 'M3D_C1' ) then !$OMP SIMD do cc = 1_idef , pchunk hint ( cc ) = spp ( ii )% vars % hint ( pp - 1 + cc ) end do !$OMP END SIMD end if call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) if ( params % field_model ( 1 : 3 ). eq . 'ANA' ) then call analytical_fields_p ( pchunk , B0 , EF0 , R0 , q0 , lam , ar , & X_X , X_Y , X_Z , & B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon ) else if ( params % orbit_model ( 3 : 5 ). eq . 'new' ) then call interp_FOfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) else if ( params % orbit_model ( 3 : 5 ). eq . 'old' ) then call interp_FOfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) else if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_FOmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_X , B_Y , B_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_FOelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_X , E_Y , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) end if !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD if ( params % field_model . eq . 'M3D_C1' ) then !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % hint ( pp - 1 + cc ) = hint ( cc ) end do !$OMP END SIMD end if end do !$OMP END PARALLEL DO !! Calls [[get_fields]] in [[korc_fields]]. ! Interpolates fields at local particles' position and keeps in ! spp%vars. Fields in (R,\\phi,Z) coordinates. !          write(output_unit_write,'(\"korc_ppusher\")') !          write(output_unit_write,'(\"B_X: \",E17.10)') spp(ii)%vars%B(:,1) !          write(output_unit_write,'(\"B_Z: \",E17.10)') spp(ii)%vars%B(:,2) !          write(output_unit_write,'(\"B_Y: \",E17.10)') spp(ii)%vars%B(:,3) !$OMP PARALLEL DO DEFAULT(none) SHARED(ii,spp) & !$OMP& FIRSTPRIVATE(E0) & !$OMP& PRIVATE(pp,b_unit,Bmag1,vpar,v,vperp,vec,tmp) do pp = 1_idef , spp ( ii )% ppp Bmag1 = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) ! Parallel unit vector b_unit = spp ( ii )% vars % B ( pp ,:) / Bmag1 !write(output_unit_write,*) 'X',spp(1)%vars%X !write(output_unit_write,*) 'b-hat',b_unit v = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % V ( pp ,:), spp ( ii )% vars % V ( pp ,:))) if ( v . GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar = DOT_PRODUCT ( spp ( ii )% vars % V ( pp ,:), b_unit ) vperp = DOT_PRODUCT ( spp ( ii )% vars % V ( pp ,:), & spp ( ii )% vars % V ( pp ,:)) & - vpar ** 2 if ( vperp . GE . korc_zero ) then vperp = SQRT ( vperp ) else vperp = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp ) = 18 0.0_rp * MODULO ( ATAN2 ( vperp , vpar ), & 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp ) = 0.5_rp * spp ( ii )% m * & spp ( ii )% vars % g ( pp ) ** 2 * vperp ** 2 / Bmag1 ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp = spp ( ii )% q ** 4 / ( 6.0_rp * C_PI * E0 * spp ( ii )% m ** 2 ) vec = spp ( ii )% vars % E ( pp ,:) + cross ( spp ( ii )% vars % V ( pp ,:), & spp ( ii )% vars % B ( pp ,:)) spp ( ii )% vars % Prad ( pp ) = tmp * ( DOT_PRODUCT ( spp ( ii )% & vars % E ( pp ,:), & spp ( ii )% vars % E ( pp ,:)) + & DOT_PRODUCT ( cross ( spp ( ii )% vars % V ( pp ,:), & spp ( ii )% vars % B ( pp ,:)), spp ( ii )% vars % E ( pp ,:)) + & spp ( ii )% vars % g ( pp ) ** 2 * & ( DOT_PRODUCT ( spp ( ii )% vars % E ( pp ,:), & spp ( ii )% vars % V ( pp ,:)) ** 2 - DOT_PRODUCT ( vec , vec )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp ) = spp ( ii )% q * DOT_PRODUCT ( & spp ( ii )% vars % E ( pp ,:), spp ( ii )% vars % V ( pp ,:)) else spp ( ii )% vars % eta ( pp ) = 0.0_rp spp ( ii )% vars % mu ( pp ) = 0.0_rp spp ( ii )% vars % Prad ( pp ) = 0.0_rp spp ( ii )% vars % Pin ( pp ) = 0.0_rp end if end do ! loop over particles on an mpi process !$OMP END PARALLEL DO end if !(if output) if ( step . and .(. not . params % FokPlan )) then dt = 0.5_rp * params % dt !$OMP PARALLEL DO FIRSTPRIVATE(dt) PRIVATE(pp,cc) & !$OMP& SHARED(ii,spp,params) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) + & dt * spp ( ii )% vars % V ( pp - 1 + cc , 1 ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) + & dt * spp ( ii )% vars % V ( pp - 1 + cc , 2 ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) + & dt * spp ( ii )% vars % V ( pp - 1 + cc , 3 ) end do !$OMP END SIMD end do !$OMP END PARALLEL DO end if !(if step) end do ! over species end subroutine FO_init subroutine adv_FOeqn_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: v , vpar , vperp REAL ( rp ), DIMENSION ( params % pchunk ) :: tmp REAL ( rp ), DIMENSION ( params % pchunk ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z , PSIp INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: B0 , EF0 , R0 , q0 , lam , ar REAL ( rp ) :: a , m_cache , q_cache REAL ( rp ) :: ne0 , Te0 , Zeff0 INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk m_cache = spp ( ii )% m q_cache = spp ( ii )% q a = q_cache * params % dt / m_cache B0 = F % Bo EF0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo ar = F % AB % a !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(E0,a,m_cache,q_cache,B0,EF0,lam,R0,q0,ar,pchunk)& !$OMP& shared(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,X_X,X_Y,X_Z,V_X,V_Y,V_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,b_unit_X,b_unit_Y,b_unit_Z,v,vpar,vperp,tmp, & !$OMP& cross_X,cross_Y,cross_Z,vec_X,vec_Y,vec_Z,g,flagCon,flagCol,PSIp) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) V_X ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_Y ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) V_Z ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 3 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) g ( cc ) = spp ( ii )% vars % g ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call analytical_fields_p ( pchunk , B0 , EF0 , R0 , q0 , lam , ar , X_X , X_Y , X_Z , & B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon ) call advance_FOeqn_vars ( tt , a , q_cache , m_cache , params , & X_X , X_Y , X_Z , V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & P , F , g , flagCon , flagCol , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = X_X ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = X_Y ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = X_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) end do !$OMP END SIMD else !$OMP SIMD do cc = 1_idef , pchunk B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) end do !$OMP END SIMD call advance_FP3Deqn_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , & g , m_cache , B0 , lam , R0 , q0 , EF0 , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & P , F , flagCon , flagCol , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD end if !$OMP SIMD !          !$OMP& aligned(Bmag,B_X,B_Y,B_Z, & !          !$OMP& b_unit_X,b_unit_Y,b_unit_Z,v,V_X,V_Y,V_Z,vpar, & !          !$OMP& vperp,tmp,cross_X,cross_Y,cross_Z, & !          !$OMP& vec_X,vec_Y,vec_Z,E_X,E_Y,E_Z) do cc = 1_idef , pchunk !Derived output data Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Parallel unit vector b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) v ( cc ) = SQRT ( V_X ( cc ) * V_X ( cc ) + V_Y ( cc ) * V_Y ( cc ) + V_Z ( cc ) * V_Z ( cc )) if ( v ( cc ). GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar ( cc ) = ( V_X ( cc ) * b_unit_X ( cc ) + V_Y ( cc ) * b_unit_Y ( cc ) + & V_Z ( cc ) * b_unit_Z ( cc )) vperp ( cc ) = v ( cc ) ** 2 - vpar ( cc ) ** 2 if ( vperp ( cc ) . GE . korc_zero ) then vperp ( cc ) = SQRT ( vperp ( cc ) ) else vperp ( cc ) = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp - 1 + cc ) = 18 0.0_rp * & MODULO ( ATAN2 ( vperp ( cc ), vpar ( cc )), 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.5_rp * m_cache * & g ( cc ) ** 2 * vperp ( cc ) ** 2 / Bmag ( cc ) ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp ( cc ) = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) vec_X ( cc ) = E_X ( cc ) + cross_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) + cross_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) + cross_Z ( cc ) spp ( ii )% vars % Prad ( pp - 1 + cc ) = tmp ( cc ) * & ( E_X ( cc ) * E_X ( cc ) + E_Y ( cc ) * E_Y ( cc ) + E_Z ( cc ) * E_Z ( cc ) + & cross_X ( cc ) * E_X ( cc ) + cross_Y ( cc ) * E_Y ( cc ) + & cross_Z ( cc ) * E_Z ( cc ) + g ( cc ) ** 2 * & (( E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) ** 2 & - vec_X ( cc ) * vec_X ( cc ) - vec_Y ( cc ) * vec_Y ( cc ) - & vec_Z ( cc ) * vec_Z ( cc )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp - 1 + cc ) = q_cache * ( E_X ( cc ) * V_X ( cc ) + & E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) else spp ( ii )% vars % eta ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Prad ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Pin ( pp - 1 + cc ) = 0.0_rp end if end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_FOeqn_top subroutine advance_FOeqn_vars ( tt , a , q_cache , m_cache , params , X_X , X_Y , X_Z , & V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , P , F , g , flagCon , flagCol , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. INTEGER ( ip ), INTENT ( IN ) :: tt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), INTENT ( in ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( params % pchunk ) :: sigma !! This variable is \\sigma = \\gamma'&#94;2 - \\tau&#94;2 in the above equations. REAL ( rp ), DIMENSION ( params % pchunk ) :: us !! This variable is u&#94;{*} = p&#94;{*}/m where  p&#94;{*} = !! \\mathbf{p}'\\cdot \\mathbf{\\tau}/mc. !! Variable 'u&#94;*' in Vay, J.-L. PoP (200params%pchunk). REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: gp , g0 !! Relativistic factor \\gamma. REAL ( rp ), DIMENSION ( params % pchunk ) :: s !! This variable is s = 1/(1+t&#94;2) in the equations above. !! Variable 's' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ) :: U_hs_X , U_hs_Y , U_hs_Z !! Is \\mathbf{u}=\\mathbf{p}/m at half-time step (i+1/2) in !! the absence of radiation losses or collisions. \\mathbf{u}&#94;{i+1/2} = !! \\mathbf{u}&#94;i + \\frac{q\\Delta t}{2m}\\left( \\mathbf{E}&#94;{i+1/2} + !! \\mathbf{v}&#94;i\\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: tau_X , tau_Y , tau_Z !! This variable is \\mathbf{\\tau} = (q\\Delta t/2)\\mathbf{B}&#94;{i+1/2}. REAL ( rp ), DIMENSION ( params % pchunk ) :: up_X , up_Y , up_Z !! This variable is \\mathbf{u}'= \\mathbf{p}'/m, where \\mathbf{p}' !! = \\mathbf{p}&#94;i + q\\Delta t \\left( \\mathbf{E}&#94;{i+1/2} + !! \\frac{\\mathbf{v}&#94;i}{2} \\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: t_X , t_Y , t_Z !! This variable is \\mathbf{t} = {\\mathbf \\tau}/\\gamma&#94;{i+1}. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: U_L_X , U_L_Y , U_L_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_RC_X , U_RC_Y , U_RC_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_os_X , U_os_Y , U_os_Z !! This variable is \\mathbf{u}&#94;{i+1}= \\mathbf{p}&#94;{i+1}/m. REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Frad_X , Frad_Y , Frad_Z !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff , Y_R , Y_PHI , Y_Z INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( inout ) :: flagCon , flagCol dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(g0,g,U_X,U_Y,U_Z,V_X,V_Y,V_Z,Bmag,B_X,B_Y,B_Z, & !    !$OMP& U_L_X,U_L_Y,U_L_Z,U_RC_X,U_RC_Y,U_RC_Z, & !    !$OMP& cross_X,cross_Y,cross_Z,U_hs_X,U_hs_Y,U_hs_Z,E_X,E_Y,E_Z, & !    !$OMP& tau_X,tau_Y,tau_Z,up_X,up_Y,up_Z,gp,sigma,us,t_X,t_Y,t_Z,s, & !    !$OMP& U_os_X,U_os_Y,U_os_Z,Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g0 ( cc ) = g ( cc ) U_X ( cc ) = g ( cc ) * V_X ( cc ) U_Y ( cc ) = g ( cc ) * V_Y ( cc ) U_Z ( cc ) = g ( cc ) * V_Z ( cc ) ! Magnitude of magnetic field Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) U_L_X ( cc ) = U_X ( cc ) U_L_Y ( cc ) = U_Y ( cc ) U_L_Z ( cc ) = U_Z ( cc ) U_RC_X ( cc ) = U_X ( cc ) U_RC_Y ( cc ) = U_Y ( cc ) U_RC_Z ( cc ) = U_Z ( cc ) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) U_hs_X ( cc ) = U_L_X ( cc ) + 0.5_rp * a * ( E_X ( cc ) + cross_X ( cc )) U_hs_Y ( cc ) = U_L_Y ( cc ) + 0.5_rp * a * ( E_Y ( cc ) + cross_Y ( cc )) U_hs_Z ( cc ) = U_L_Z ( cc ) + 0.5_rp * a * ( E_Z ( cc ) + cross_Z ( cc )) tau_X ( cc ) = 0.5_rp * a * B_X ( cc ) tau_Y ( cc ) = 0.5_rp * a * B_Y ( cc ) tau_Z ( cc ) = 0.5_rp * a * B_Z ( cc ) up_X ( cc ) = U_hs_X ( cc ) + 0.5_rp * a * E_X ( cc ) up_Y ( cc ) = U_hs_Y ( cc ) + 0.5_rp * a * E_Y ( cc ) up_Z ( cc ) = U_hs_Z ( cc ) + 0.5_rp * a * E_Z ( cc ) gp ( cc ) = SQRT ( 1.0_rp + up_X ( cc ) * up_X ( cc ) + up_Y ( cc ) * up_Y ( cc ) + & up_Z ( cc ) * up_Z ( cc ) ) sigma ( cc ) = gp ( cc ) * gp ( cc ) - ( tau_X ( cc ) * tau_X ( cc ) + & tau_Y ( cc ) * tau_Y ( cc ) + tau_Z ( cc ) * tau_Z ( cc )) us ( cc ) = up_X ( cc ) * tau_X ( cc ) + up_Y ( cc ) * tau_Y ( cc ) + & up_Z ( cc ) * tau_Z ( cc ) ! variable 'u&#94;*' in Vay, J.-L. PoP (2008) g ( cc ) = SQRT ( 0.5_rp * ( sigma ( cc ) + SQRT ( sigma ( cc ) * sigma ( cc ) + & 4.0_rp * ( tau_X ( cc ) * tau_X ( cc ) + tau_Y ( cc ) * tau_Y ( cc ) + & tau_Z ( cc ) * tau_Z ( cc ) + us ( cc ) * us ( cc )))) ) t_X ( cc ) = tau_X ( cc ) / g ( cc ) t_Y ( cc ) = tau_Y ( cc ) / g ( cc ) t_Z ( cc ) = tau_Z ( cc ) / g ( cc ) s ( cc ) = 1.0_rp / ( 1.0_rp + t_X ( cc ) * t_X ( cc ) + t_Y ( cc ) * t_Y ( cc ) + & t_Z ( cc ) * t_Z ( cc )) ! variable 's' in Vay, J.-L. PoP (2008) cross_X ( cc ) = up_Y ( cc ) * t_Z ( cc ) - up_Z ( cc ) * t_Y ( cc ) cross_Y ( cc ) = up_Z ( cc ) * t_X ( cc ) - up_X ( cc ) * t_Z ( cc ) cross_Z ( cc ) = up_X ( cc ) * t_Y ( cc ) - up_Y ( cc ) * t_X ( cc ) U_L_X ( cc ) = s ( cc ) * ( up_X ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_X ( cc ) + cross_X ( cc )) U_L_Y ( cc ) = s ( cc ) * ( up_Y ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Y ( cc ) + cross_Y ( cc )) U_L_Z ( cc ) = s ( cc ) * ( up_Z ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Z ( cc ) + cross_Z ( cc )) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! U_os_X ( cc ) = 0.5_rp * ( U_L_X ( cc ) + U_X ( cc )) U_os_Y ( cc ) = 0.5_rp * ( U_L_Y ( cc ) + U_Y ( cc )) U_os_Z ( cc ) = 0.5_rp * ( U_L_Z ( cc ) + U_Z ( cc )) ! Splitting operator for including radiation if ( params % radiation ) then !! Calls [[radiation_force]] in [[korc_ppusher]]. call radiation_force_p ( pchunk , q_cache , m_cache , U_os_X , U_os_Y , U_os_Z , & E_X , E_Y , E_Z , B_Z , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) U_RC_X ( cc ) = U_RC_X ( cc ) + a * Frad_X ( cc ) / q_cache U_RC_Y ( cc ) = U_RC_Y ( cc ) + a * Frad_Y ( cc ) / q_cache U_RC_Z ( cc ) = U_RC_Z ( cc ) + a * Frad_Z ( cc ) / q_cache end if ! Splitting operator for including radiation U_X ( cc ) = U_L_X ( cc ) + U_RC_X ( cc ) - U_X ( cc ) U_Y ( cc ) = U_L_Y ( cc ) + U_RC_Y ( cc ) - U_Y ( cc ) U_Z ( cc ) = U_L_Z ( cc ) + U_RC_Z ( cc ) - U_Z ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end if if ( params % radiation . or . params % collisions ) then !$OMP SIMD !       !$OMP& aligned(g,U_X,U_Y,U_Z) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) end do !$OMP END SIMD end if !$OMP SIMD !    !$OMP& aligned(g,g0,V_X,V_Y,V_Z,U_X,U_Y,U_Z,X_X,X_Y,X_Z,flagCon,flagCol) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then g ( cc ) = g0 ( cc ) else V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end if X_X ( cc ) = X_X ( cc ) + dt * V_X ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Y ( cc ) = X_Y ( cc ) + dt * V_Y ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Z ( cc ) = X_Z ( cc ) + dt * V_Z ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) end do !$OMP END SIMD end subroutine advance_FOeqn_vars subroutine advance_FP3Deqn_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , g , & m_cache , B0 , lam , R0 , q0 , EF0 , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & P , F , flagCon , flagCol , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon , flagCol REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), intent ( in ) :: B0 , EF0 , R0 , q0 , lam , m_cache pchunk = params % pchunk !    call analytical_fields_p(B0,EF0,R0,q0,lam,X_X,X_Y,X_Z, & !         B_X,B_Y,B_Z,E_X,E_Y,E_Z) !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk U_X ( cc ) = V_X ( cc ) * g ( cc ) U_Y ( cc ) = V_Y ( cc ) * g ( cc ) U_Z ( cc ) = V_Z ( cc ) * g ( cc ) end do !$OMP END SIMD do tt = 1_ip , params % t_skip call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end do !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end do !$OMP END SIMD end subroutine advance_FP3Deqn_vars subroutine adv_FOm3dc1_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: v , vpar , vperp REAL ( rp ), DIMENSION ( params % pchunk ) :: tmp REAL ( rp ), DIMENSION ( params % pchunk ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp TYPE ( C_PTR ), DIMENSION ( params % pchunk ) :: hint INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: a , m_cache , q_cache INTEGER :: ii !! Species iterator. INTEGER :: pp , pchunk !! Particles iterator. INTEGER :: cc !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk m_cache = spp ( ii )% m q_cache = spp ( ii )% q a = q_cache * params % dt / m_cache !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(a,m_cache,q_cache,E0,pchunk) & !$OMP& shared(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,X_X,X_Y,X_Z,V_X,V_Y,V_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,b_unit_X,b_unit_Y,b_unit_Z,v,vpar,vperp,tmp, & !$OMP& cross_X,cross_Y,cross_Z,vec_X,vec_Y,vec_Z,g, & !$OMP& Y_R,Y_PHI,Y_Z,flagCon,flagCol,PSIp,hint) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) V_X ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_Y ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) V_Z ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 3 ) B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) hint ( cc ) = spp ( ii )% vars % hint ( pp - 1 + cc ) g ( cc ) = spp ( ii )% vars % g ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'Yin: ',Y_R,Y_PHI,Y_Z !write(output_unit_write,*) 'Bin: ',B_X,B_Y,B_Z if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) call get_m3d_c1_FOmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_X , B_Y , B_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_FOelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_X , E_Y , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call advance_FOm3dc1_vars ( tt , a , q_cache , m_cache , params , & X_X , X_Y , X_Z , V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & g , flagCon , flagCol , P , F , PSIp ) end do !timestep iterator call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) !write(output_unit_write,*) 'Yout: ',Y_R,Y_PHI,Y_Z !write(output_unit_write,*) 'Bout: ',B_X,B_Y,B_Z !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = X_X ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = X_Y ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = X_Z ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % hint ( pp - 1 + cc ) = hint ( cc ) end do !$OMP END SIMD else !$OMP SIMD do cc = 1_idef , pchunk B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) end do !$OMP END SIMD call advance_FP3Dinterp_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , & g , m_cache , B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon , flagCol , P , F , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) end do !$OMP END SIMD end if !$OMP SIMD !          !$OMP& aligned(Bmag,B_X,B_Y,B_Z, & !          !$OMP& b_unit_X,b_unit_Y,b_unit_Z,v,V_X,V_Y,V_Z,vpar, & !          !$OMP& vperp,tmp,cross_X,cross_Y,cross_Z, & !          !$OMP& vec_X,vec_Y,vec_Z,E_X,E_Y,E_Z) do cc = 1_idef , pchunk !Derived output data Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Parallel unit vector b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) v ( cc ) = SQRT ( V_X ( cc ) * V_X ( cc ) + V_Y ( cc ) * V_Y ( cc ) + V_Z ( cc ) * V_Z ( cc )) if ( v ( cc ). GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar ( cc ) = ( V_X ( cc ) * b_unit_X ( cc ) + V_Y ( cc ) * b_unit_Y ( cc ) + & V_Z ( cc ) * b_unit_Z ( cc )) vperp ( cc ) = v ( cc ) ** 2 - vpar ( cc ) ** 2 if ( vperp ( cc ) . GE . korc_zero ) then vperp ( cc ) = SQRT ( vperp ( cc ) ) else vperp ( cc ) = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp - 1 + cc ) = 18 0.0_rp * & MODULO ( ATAN2 ( vperp ( cc ), vpar ( cc )), 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.5_rp * m_cache * & g ( cc ) ** 2 * vperp ( cc ) ** 2 / Bmag ( cc ) ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp ( cc ) = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) vec_X ( cc ) = E_X ( cc ) + cross_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) + cross_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) + cross_Z ( cc ) spp ( ii )% vars % Prad ( pp - 1 + cc ) = tmp ( cc ) * & ( E_X ( cc ) * E_X ( cc ) + E_Y ( cc ) * E_Y ( cc ) + E_Z ( cc ) * E_Z ( cc ) + & cross_X ( cc ) * E_X ( cc ) + cross_Y ( cc ) * E_Y ( cc ) + & cross_Z ( cc ) * E_Z ( cc ) + g ( cc ) ** 2 * & (( E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) ** 2 & - vec_X ( cc ) * vec_X ( cc ) + vec_Y ( cc ) * vec_Y ( cc ) + & vec_Z ( cc ) * vec_Z ( cc )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp - 1 + cc ) = q_cache * ( E_X ( cc ) * V_X ( cc ) + & E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) else spp ( ii )% vars % eta ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Prad ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Pin ( pp - 1 + cc ) = 0.0_rp end if end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_FOm3dc1_top subroutine adv_FOinterp_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: v , vpar , vperp REAL ( rp ), DIMENSION ( params % pchunk ) :: tmp REAL ( rp ), DIMENSION ( params % pchunk ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: a , m_cache , q_cache INTEGER :: ii !! Species iterator. INTEGER :: pp , pchunk !! Particles iterator. INTEGER :: cc !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk m_cache = spp ( ii )% m q_cache = spp ( ii )% q a = q_cache * params % dt / m_cache !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(a,m_cache,q_cache,pchunk) & !$OMP& shared(params,ii,spp,P,F) & !$OMP& PRIVATE(E0,pp,tt,Bmag,cc,X_X,X_Y,X_Z,V_X,V_Y,V_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,b_unit_X,b_unit_Y,b_unit_Z,v,vpar,vperp,tmp, & !$OMP& cross_X,cross_Y,cross_Z,vec_X,vec_Y,vec_Z,g, & !$OMP& Y_R,Y_PHI,Y_Z,flagCon,flagCol,PSIp) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) V_X ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_Y ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) V_Z ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 3 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) g ( cc ) = spp ( ii )% vars % g ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) if ( params % orbit_model ( 3 : 5 ). eq . 'new' ) then call interp_FOfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) else if ( params % orbit_model ( 3 : 5 ). eq . 'old' ) then call interp_FOfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) end if !               write(output_unit_write,'(\"B_X: \",E17.10)') B_X(1) !               write(output_unit_write,'(\"B_Y: \",E17.10)') B_Y(1) !               write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z(1) call advance_FOinterp_vars ( tt , a , q_cache , m_cache , params , & X_X , X_Y , X_Z , V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & g , flagCon , flagCol , P , F , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = X_X ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = X_Y ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = X_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else !$OMP SIMD do cc = 1_idef , pchunk B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) end do !$OMP END SIMD call advance_FP3Dinterp_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , & g , m_cache , B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon , flagCol , P , F , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) end do !$OMP END SIMD end if !$OMP SIMD !          !$OMP& aligned(Bmag,B_X,B_Y,B_Z, & !          !$OMP& b_unit_X,b_unit_Y,b_unit_Z,v,V_X,V_Y,V_Z,vpar, & !          !$OMP& vperp,tmp,cross_X,cross_Y,cross_Z, & !          !$OMP& vec_X,vec_Y,vec_Z,E_X,E_Y,E_Z) do cc = 1_idef , pchunk !Derived output data Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Parallel unit vector b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) v ( cc ) = SQRT ( V_X ( cc ) * V_X ( cc ) + V_Y ( cc ) * V_Y ( cc ) + V_Z ( cc ) * V_Z ( cc )) if ( v ( cc ). GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar ( cc ) = ( V_X ( cc ) * b_unit_X ( cc ) + V_Y ( cc ) * b_unit_Y ( cc ) + & V_Z ( cc ) * b_unit_Z ( cc )) vperp ( cc ) = v ( cc ) ** 2 - vpar ( cc ) ** 2 if ( vperp ( cc ) . GE . korc_zero ) then vperp ( cc ) = SQRT ( vperp ( cc ) ) else vperp ( cc ) = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp - 1 + cc ) = 18 0.0_rp * & MODULO ( ATAN2 ( vperp ( cc ), vpar ( cc )), 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.5_rp * m_cache * & g ( cc ) ** 2 * vperp ( cc ) ** 2 / Bmag ( cc ) ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp ( cc ) = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) vec_X ( cc ) = E_X ( cc ) + cross_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) + cross_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) + cross_Z ( cc ) spp ( ii )% vars % Prad ( pp - 1 + cc ) = tmp ( cc ) * & ( E_X ( cc ) * E_X ( cc ) + E_Y ( cc ) * E_Y ( cc ) + E_Z ( cc ) * E_Z ( cc ) + & cross_X ( cc ) * E_X ( cc ) + cross_Y ( cc ) * E_Y ( cc ) + & cross_Z ( cc ) * E_Z ( cc ) + g ( cc ) ** 2 * & (( E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) ** 2 & - vec_X ( cc ) * vec_X ( cc ) + vec_Y ( cc ) * vec_Y ( cc ) + & vec_Z ( cc ) * vec_Z ( cc )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp - 1 + cc ) = q_cache * ( E_X ( cc ) * V_X ( cc ) + & E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) else spp ( ii )% vars % eta ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Prad ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Pin ( pp - 1 + cc ) = 0.0_rp end if end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_FOinterp_top subroutine advance_FOinterp_vars ( tt , a , q_cache , m_cache , params , X_X , X_Y , X_Z , & V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , g , flagCon , flagCol , P , F , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ), INTENT ( IN ) :: tt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), INTENT ( in ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( params % pchunk ) :: sigma !! This variable is \\sigma = \\gamma'&#94;2 - \\tau&#94;2 in the above equations. REAL ( rp ), DIMENSION ( params % pchunk ) :: us !! This variable is u&#94;{*} = p&#94;{*}/m where  p&#94;{*} = !! \\mathbf{p}'\\cdot \\mathbf{\\tau}/mc. !! Variable 'u&#94;*' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: gp , g0 !! Relativistic factor \\gamma. REAL ( rp ), DIMENSION ( params % pchunk ) :: s !! This variable is s = 1/(1+t&#94;2) in the equations above. !! Variable 's' in Vay, J.-L. PoP (200params%pchunk). REAL ( rp ), DIMENSION ( params % pchunk ) :: U_hs_X , U_hs_Y , U_hs_Z !! Is \\mathbf{u}=\\mathbf{p}/m at half-time step (i+1/2) in !! the absence of radiation losses or collisions. \\mathbf{u}&#94;{i+1/2} = !! \\mathbf{u}&#94;i + \\frac{q\\Delta t}{2m}\\left( \\mathbf{E}&#94;{i+1/2} + !! \\mathbf{v}&#94;i\\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: tau_X , tau_Y , tau_Z !! This variable is \\mathbf{\\tau} = (q\\Delta t/2)\\mathbf{B}&#94;{i+1/2}. REAL ( rp ), DIMENSION ( params % pchunk ) :: up_X , up_Y , up_Z !! This variable is \\mathbf{u}'= \\mathbf{p}'/m, where \\mathbf{p}' !! = \\mathbf{p}&#94;i + q\\Delta t \\left( \\mathbf{E}&#94;{i+1/2} + !! \\frac{\\mathbf{v}&#94;i}{2} \\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: t_X , t_Y , t_Z !! This variable is \\mathbf{t} = {\\mathbf \\tau}/\\gamma&#94;{i+1}. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: U_L_X , U_L_Y , U_L_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_RC_X , U_RC_Y , U_RC_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_os_X , U_os_Y , U_os_Z !! This variable is \\mathbf{u}&#94;{i+1}= \\mathbf{p}&#94;{i+1}/m. REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Frad_X , Frad_Y , Frad_Z !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( is ) , DIMENSION ( params % pchunk ), intent ( inout ) :: flagCon , flagCol dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(g0,g,U_X,U_Y,U_Z,V_X,V_Y,V_Z,Bmag,B_X,B_Y,B_Z, & !    !$OMP& U_L_X,U_L_Y,U_L_Z,U_RC_X,U_RC_Y,U_RC_Z, & !    !$OMP& cross_X,cross_Y,cross_Z,U_hs_X,U_hs_Y,U_hs_Z,E_X,E_Y,E_Z, & !    !$OMP& tau_X,tau_Y,tau_Z,up_X,up_Y,up_Z,gp,sigma,us,t_X,t_Y,t_Z,s, & !    !$OMP& U_os_X,U_os_Y,U_os_Z,Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g0 ( cc ) = g ( cc ) U_X ( cc ) = g ( cc ) * V_X ( cc ) U_Y ( cc ) = g ( cc ) * V_Y ( cc ) U_Z ( cc ) = g ( cc ) * V_Z ( cc ) ! Magnitude of magnetic field Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) U_L_X ( cc ) = U_X ( cc ) U_L_Y ( cc ) = U_Y ( cc ) U_L_Z ( cc ) = U_Z ( cc ) U_RC_X ( cc ) = U_X ( cc ) U_RC_Y ( cc ) = U_Y ( cc ) U_RC_Z ( cc ) = U_Z ( cc ) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) U_hs_X ( cc ) = U_L_X ( cc ) + 0.5_rp * a * ( E_X ( cc ) + cross_X ( cc )) U_hs_Y ( cc ) = U_L_Y ( cc ) + 0.5_rp * a * ( E_Y ( cc ) + cross_Y ( cc )) U_hs_Z ( cc ) = U_L_Z ( cc ) + 0.5_rp * a * ( E_Z ( cc ) + cross_Z ( cc )) tau_X ( cc ) = 0.5_rp * a * B_X ( cc ) tau_Y ( cc ) = 0.5_rp * a * B_Y ( cc ) tau_Z ( cc ) = 0.5_rp * a * B_Z ( cc ) up_X ( cc ) = U_hs_X ( cc ) + 0.5_rp * a * E_X ( cc ) up_Y ( cc ) = U_hs_Y ( cc ) + 0.5_rp * a * E_Y ( cc ) up_Z ( cc ) = U_hs_Z ( cc ) + 0.5_rp * a * E_Z ( cc ) gp ( cc ) = SQRT ( 1.0_rp + up_X ( cc ) * up_X ( cc ) + up_Y ( cc ) * up_Y ( cc ) + & up_Z ( cc ) * up_Z ( cc ) ) sigma ( cc ) = gp ( cc ) * gp ( cc ) - ( tau_X ( cc ) * tau_X ( cc ) + & tau_Y ( cc ) * tau_Y ( cc ) + tau_Z ( cc ) * tau_Z ( cc )) us ( cc ) = up_X ( cc ) * tau_X ( cc ) + up_Y ( cc ) * tau_Y ( cc ) + & up_Z ( cc ) * tau_Z ( cc ) ! variable 'u&#94;*' in Vay, J.-L. PoP (2008) g ( cc ) = SQRT ( 0.5_rp * ( sigma ( cc ) + SQRT ( sigma ( cc ) * sigma ( cc ) + & 4.0_rp * ( tau_X ( cc ) * tau_X ( cc ) + tau_Y ( cc ) * tau_Y ( cc ) + & tau_Z ( cc ) * tau_Z ( cc ) + us ( cc ) * us ( cc )))) ) t_X ( cc ) = tau_X ( cc ) / g ( cc ) t_Y ( cc ) = tau_Y ( cc ) / g ( cc ) t_Z ( cc ) = tau_Z ( cc ) / g ( cc ) s ( cc ) = 1.0_rp / ( 1.0_rp + t_X ( cc ) * t_X ( cc ) + t_Y ( cc ) * t_Y ( cc ) + & t_Z ( cc ) * t_Z ( cc )) ! variable 's' in Vay, J.-L. PoP (2008) cross_X ( cc ) = up_Y ( cc ) * t_Z ( cc ) - up_Z ( cc ) * t_Y ( cc ) cross_Y ( cc ) = up_Z ( cc ) * t_X ( cc ) - up_X ( cc ) * t_Z ( cc ) cross_Z ( cc ) = up_X ( cc ) * t_Y ( cc ) - up_Y ( cc ) * t_X ( cc ) U_L_X ( cc ) = s ( cc ) * ( up_X ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_X ( cc ) + cross_X ( cc )) U_L_Y ( cc ) = s ( cc ) * ( up_Y ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Y ( cc ) + cross_Y ( cc )) U_L_Z ( cc ) = s ( cc ) * ( up_Z ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Z ( cc ) + cross_Z ( cc )) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! U_os_X ( cc ) = 0.5_rp * ( U_L_X ( cc ) + U_X ( cc )) U_os_Y ( cc ) = 0.5_rp * ( U_L_Y ( cc ) + U_Y ( cc )) U_os_Z ( cc ) = 0.5_rp * ( U_L_Z ( cc ) + U_Z ( cc )) ! Splitting operator for including radiation if ( params % radiation ) then !! Calls [[radiation_force]] in [[korc_ppusher]]. call radiation_force_p ( pchunk , q_cache , m_cache , U_os_X , U_os_Y , U_os_Z , & E_X , E_Y , E_Z , B_Z , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) U_RC_X ( cc ) = U_RC_X ( cc ) + a * Frad_X ( cc ) / q_cache U_RC_Y ( cc ) = U_RC_Y ( cc ) + a * Frad_Y ( cc ) / q_cache U_RC_Z ( cc ) = U_RC_Z ( cc ) + a * Frad_Z ( cc ) / q_cache end if ! Splitting operator for including radiation U_X ( cc ) = U_L_X ( cc ) + U_RC_X ( cc ) - U_X ( cc ) U_Y ( cc ) = U_L_Y ( cc ) + U_RC_Y ( cc ) - U_Y ( cc ) U_Z ( cc ) = U_L_Z ( cc ) + U_RC_Z ( cc ) - U_Z ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end if if ( params % radiation . or . params % collisions ) then !$OMP SIMD !       !$OMP& aligned(g,U_X,U_Y,U_Z) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) end do !$OMP END SIMD end if !$OMP SIMD !    !$OMP& aligned(g,g0,V_X,V_Y,V_Z,U_X,U_Y,U_Z,X_X,X_Y,X_Z,flagCon,flagCol) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then g ( cc ) = g0 ( cc ) else V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end if X_X ( cc ) = X_X ( cc ) + dt * V_X ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Y ( cc ) = X_Y ( cc ) + dt * V_Y ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Z ( cc ) = X_Z ( cc ) + dt * V_Z ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) end do !$OMP END SIMD end subroutine advance_FOinterp_vars subroutine advance_FOm3dc1_vars ( tt , a , q_cache , m_cache , params , X_X , X_Y , X_Z , & V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , g , flagCon , flagCol , P , F , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ), INTENT ( IN ) :: tt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), INTENT ( in ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( params % pchunk ) :: sigma !! This variable is \\sigma = \\gamma'&#94;2 - \\tau&#94;2 in the above equations. REAL ( rp ), DIMENSION ( params % pchunk ) :: us !! This variable is u&#94;{*} = p&#94;{*}/m where  p&#94;{*} = !! \\mathbf{p}'\\cdot \\mathbf{\\tau}/mc. !! Variable 'u&#94;*' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: gp , g0 !! Relativistic factor \\gamma. REAL ( rp ), DIMENSION ( params % pchunk ) :: s !! This variable is s = 1/(1+t&#94;2) in the equations above. !! Variable 's' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ) :: U_hs_X , U_hs_Y , U_hs_Z !! Is \\mathbf{u}=\\mathbf{p}/m at half-time step (i+1/2) in !! the absence of radiation losses or collisions. \\mathbf{u}&#94;{i+1/2} = !! \\mathbf{u}&#94;i + \\frac{q\\Delta t}{2m}\\left( \\mathbf{E}&#94;{i+1/2} + !! \\mathbf{v}&#94;i\\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: tau_X , tau_Y , tau_Z !! This variable is \\mathbf{\\tau} = (q\\Delta t/2)\\mathbf{B}&#94;{i+1/2}. REAL ( rp ), DIMENSION ( params % pchunk ) :: up_X , up_Y , up_Z !! This variable is \\mathbf{u}'= \\mathbf{p}'/m, where \\mathbf{p}' !! = \\mathbf{p}&#94;i + q\\Delta t \\left( \\mathbf{E}&#94;{i+1/2} + !! \\frac{\\mathbf{v}&#94;i}{2} \\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: t_X , t_Y , t_Z !! This variable is \\mathbf{t} = {\\mathbf \\tau}/\\gamma&#94;{i+1}. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: U_L_X , U_L_Y , U_L_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_RC_X , U_RC_Y , U_RC_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_os_X , U_os_Y , U_os_Z !! This variable is \\mathbf{u}&#94;{i+1}= \\mathbf{p}&#94;{i+1}/m. REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Frad_X , Frad_Y , Frad_Z !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( is ) , DIMENSION ( params % pchunk ), intent ( inout ) :: flagCon , flagCol dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(g0,g,U_X,U_Y,U_Z,V_X,V_Y,V_Z,Bmag,B_X,B_Y,B_Z, & !    !$OMP& U_L_X,U_L_Y,U_L_Z,U_RC_X,U_RC_Y,U_RC_Z, & !    !$OMP& cross_X,cross_Y,cross_Z,U_hs_X,U_hs_Y,U_hs_Z,E_X,E_Y,E_Z, & !    !$OMP& tau_X,tau_Y,tau_Z,up_X,up_Y,up_Z,gp,sigma,us,t_X,t_Y,t_Z,s, & !    !$OMP& U_os_X,U_os_Y,U_os_Z,Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g0 ( cc ) = g ( cc ) U_X ( cc ) = g ( cc ) * V_X ( cc ) U_Y ( cc ) = g ( cc ) * V_Y ( cc ) U_Z ( cc ) = g ( cc ) * V_Z ( cc ) ! Magnitude of magnetic field Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) U_L_X ( cc ) = U_X ( cc ) U_L_Y ( cc ) = U_Y ( cc ) U_L_Z ( cc ) = U_Z ( cc ) U_RC_X ( cc ) = U_X ( cc ) U_RC_Y ( cc ) = U_Y ( cc ) U_RC_Z ( cc ) = U_Z ( cc ) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) U_hs_X ( cc ) = U_L_X ( cc ) + 0.5_rp * a * ( E_X ( cc ) + cross_X ( cc )) U_hs_Y ( cc ) = U_L_Y ( cc ) + 0.5_rp * a * ( E_Y ( cc ) + cross_Y ( cc )) U_hs_Z ( cc ) = U_L_Z ( cc ) + 0.5_rp * a * ( E_Z ( cc ) + cross_Z ( cc )) tau_X ( cc ) = 0.5_rp * a * B_X ( cc ) tau_Y ( cc ) = 0.5_rp * a * B_Y ( cc ) tau_Z ( cc ) = 0.5_rp * a * B_Z ( cc ) up_X ( cc ) = U_hs_X ( cc ) + 0.5_rp * a * E_X ( cc ) up_Y ( cc ) = U_hs_Y ( cc ) + 0.5_rp * a * E_Y ( cc ) up_Z ( cc ) = U_hs_Z ( cc ) + 0.5_rp * a * E_Z ( cc ) gp ( cc ) = SQRT ( 1.0_rp + up_X ( cc ) * up_X ( cc ) + up_Y ( cc ) * up_Y ( cc ) + & up_Z ( cc ) * up_Z ( cc ) ) sigma ( cc ) = gp ( cc ) * gp ( cc ) - ( tau_X ( cc ) * tau_X ( cc ) + & tau_Y ( cc ) * tau_Y ( cc ) + tau_Z ( cc ) * tau_Z ( cc )) us ( cc ) = up_X ( cc ) * tau_X ( cc ) + up_Y ( cc ) * tau_Y ( cc ) + & up_Z ( cc ) * tau_Z ( cc ) ! variable 'u&#94;*' in Vay, J.-L. PoP (2008) g ( cc ) = SQRT ( 0.5_rp * ( sigma ( cc ) + SQRT ( sigma ( cc ) * sigma ( cc ) + & 4.0_rp * ( tau_X ( cc ) * tau_X ( cc ) + tau_Y ( cc ) * tau_Y ( cc ) + & tau_Z ( cc ) * tau_Z ( cc ) + us ( cc ) * us ( cc )))) ) t_X ( cc ) = tau_X ( cc ) / g ( cc ) t_Y ( cc ) = tau_Y ( cc ) / g ( cc ) t_Z ( cc ) = tau_Z ( cc ) / g ( cc ) s ( cc ) = 1.0_rp / ( 1.0_rp + t_X ( cc ) * t_X ( cc ) + t_Y ( cc ) * t_Y ( cc ) + & t_Z ( cc ) * t_Z ( cc )) ! variable 's' in Vay, J.-L. PoP (2008) cross_X ( cc ) = up_Y ( cc ) * t_Z ( cc ) - up_Z ( cc ) * t_Y ( cc ) cross_Y ( cc ) = up_Z ( cc ) * t_X ( cc ) - up_X ( cc ) * t_Z ( cc ) cross_Z ( cc ) = up_X ( cc ) * t_Y ( cc ) - up_Y ( cc ) * t_X ( cc ) U_L_X ( cc ) = s ( cc ) * ( up_X ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_X ( cc ) + cross_X ( cc )) U_L_Y ( cc ) = s ( cc ) * ( up_Y ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Y ( cc ) + cross_Y ( cc )) U_L_Z ( cc ) = s ( cc ) * ( up_Z ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Z ( cc ) + cross_Z ( cc )) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! U_os_X ( cc ) = 0.5_rp * ( U_L_X ( cc ) + U_X ( cc )) U_os_Y ( cc ) = 0.5_rp * ( U_L_Y ( cc ) + U_Y ( cc )) U_os_Z ( cc ) = 0.5_rp * ( U_L_Z ( cc ) + U_Z ( cc )) ! Splitting operator for including radiation if ( params % radiation ) then !! Calls [[radiation_force]] in [[korc_ppusher]]. call radiation_force_p ( pchunk , q_cache , m_cache , U_os_X , U_os_Y , U_os_Z , & E_X , E_Y , E_Z , B_Z , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) U_RC_X ( cc ) = U_RC_X ( cc ) + a * Frad_X ( cc ) / q_cache U_RC_Y ( cc ) = U_RC_Y ( cc ) + a * Frad_Y ( cc ) / q_cache U_RC_Z ( cc ) = U_RC_Z ( cc ) + a * Frad_Z ( cc ) / q_cache end if ! Splitting operator for including radiation U_X ( cc ) = U_L_X ( cc ) + U_RC_X ( cc ) - U_X ( cc ) U_Y ( cc ) = U_L_Y ( cc ) + U_RC_Y ( cc ) - U_Y ( cc ) U_Z ( cc ) = U_L_Z ( cc ) + U_RC_Z ( cc ) - U_Z ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end if if ( params % radiation . or . params % collisions ) then !$OMP SIMD !       !$OMP& aligned(g,U_X,U_Y,U_Z) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) end do !$OMP END SIMD end if !$OMP SIMD !    !$OMP& aligned(g,g0,V_X,V_Y,V_Z,U_X,U_Y,U_Z,X_X,X_Y,X_Z,flagCon,flagCol) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then g ( cc ) = g0 ( cc ) else V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end if X_X ( cc ) = X_X ( cc ) + dt * V_X ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Y ( cc ) = X_Y ( cc ) + dt * V_Y ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Z ( cc ) = X_Z ( cc ) + dt * V_Z ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) end do !$OMP END SIMD end subroutine advance_FOm3dc1_vars subroutine advance_FP3Dinterp_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , g , & m_cache , B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon , flagCol , P , F , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( in ) :: m_cache pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk U_X ( cc ) = V_X ( cc ) * g ( cc ) U_Y ( cc ) = V_Y ( cc ) * g ( cc ) U_Z ( cc ) = V_Z ( cc ) * g ( cc ) end do !$OMP END SIMD do tt = 1_ip , params % t_skip call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end do !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end do !$OMP END SIMD end subroutine advance_FP3Dinterp_vars subroutine GC_init ( params , F , spp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. REAL ( rp ) :: Bmag1 , pmag REAL ( rp ) :: Bmagc REAL ( rp ) :: rm REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: RAphi REAL ( rp ), DIMENSION ( 3 ) :: bhat REAL ( rp ), DIMENSION ( 3 ) :: bhatc REAL ( rp ), DIMENSION ( params % pchunk ) :: E_PHI REAL ( rp ), DIMENSION (:), ALLOCATABLE :: RVphi REAL ( rp ), DIMENSION ( params % pchunk ) :: rm8 , Y_R , Y_Z , V_PLL , vpll , gam real ( rp ), dimension ( F % dim_1D ) :: Vpart , Vpartave , VpartOMP real ( rp ) :: dr integer :: rind !    write(output_unit_write,'(\"eta\",E17.10)') spp(ii)%vars%eta(pp) !    write(output_unit_write,'(\"gam\",E17.10)') spp(ii)%vars%g(pp) do ii = 1_idef , params % num_species pchunk = params % pchunk if ( spp ( ii )% spatial_distribution . eq . 'TRACER' . and . & params % FO_GC_compare ) then call get_fields ( params , spp ( ii )% vars , F ) !! Calls [[get_fields]] in [[korc_fields]]. ! Interpolates fields at local particles' position and keeps in ! spp%vars. Fields in (R,\\phi,Z) coordinates. ALLOCATE ( RAphi ( spp ( ii )% ppp , 2 )) ALLOCATE ( RVphi ( spp ( ii )% ppp )) RAphi = 0.0_rp call cart_to_cyl ( spp ( ii )% vars % X , spp ( ii )% vars % Y ) !$OMP PARALLEL DO SHARED(params,ii,spp,F,RAphi,RVphi) & !$OMP&  PRIVATE(pp,Bmag1,bhat,rm) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then RVphi ( pp ) = ( - sin ( spp ( ii )% vars % Y ( pp , 2 )) * spp ( ii )% vars % V ( pp , 1 ) + & cos ( spp ( ii )% vars % Y ( pp , 2 )) * spp ( ii )% vars % V ( pp , 2 )) * & spp ( ii )% vars % Y ( pp , 1 ) Bmag1 = SQRT ( spp ( ii )% vars % B ( pp , 1 ) * spp ( ii )% vars % B ( pp , 1 ) + & spp ( ii )% vars % B ( pp , 2 ) * spp ( ii )% vars % B ( pp , 2 ) + & spp ( ii )% vars % B ( pp , 3 ) * spp ( ii )% vars % B ( pp , 3 )) !             write(output_unit_write,'(\"pp: \",I16)') pp !             write(output_unit_write,'(\"Bmag: \",E17.10)') Bmag bhat = spp ( ii )% vars % B ( pp ,:) / Bmag1 if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then rm = sqrt (( spp ( ii )% vars % Y ( pp , 1 ) - F % AB % Ro ) ** 2 + & ( spp ( ii )% vars % Y ( pp , 3 )) ** 2 ) RAphi ( pp , 1 ) =- F % AB % lambda ** 2 * F % AB % Bo / ( 2 * F % AB % qo ) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then RAphi ( pp , 1 ) = spp ( ii )% vars % PSI_P ( pp ) / ( 2 * C_PI ) end if !             write(output_unit_write,'(\"bhat: \",E17.10)') bhat !             write(output_unit_write,'(\"V: \",E17.10)') spp(ii)%vars%V(pp,:) spp ( ii )% vars % X ( pp ,:) = spp ( ii )% vars % X ( pp ,:) - & spp ( ii )% m * spp ( ii )% vars % g ( pp ) * & cross ( bhat , spp ( ii )% vars % V ( pp ,:)) / ( spp ( ii )% q * Bmag1 ) ! transforming from particle location to associated ! GC location end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO call cart_to_cyl ( spp ( ii )% vars % X , spp ( ii )% vars % Y ) call get_fields ( params , spp ( ii )% vars , F ) !$OMP PARALLEL DO SHARED(params,ii,spp,F,RAphi,RVphi) & !$OMP&  PRIVATE(pp,rm) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then rm = sqrt (( spp ( ii )% vars % Y ( pp , 1 ) - F % AB % Ro ) ** 2 + & ( spp ( ii )% vars % Y ( pp , 3 )) ** 2 ) RAphi ( pp , 2 ) =- F % AB % lambda ** 2 * F % AB % Bo / ( 2 * F % AB % qo ) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then RAphi ( pp , 2 ) = spp ( ii )% vars % PSI_P ( pp ) / ( 2 * C_PI ) end if write ( output_unit_write , '(\"RAphi1: \",E17.10)' ) RAphi ( pp , 1 ) write ( output_unit_write , '(\"RAphi2: \",E17.10)' ) RAphi ( pp , 2 ) spp ( ii )% vars % V ( pp , 1 ) = ( spp ( ii )% m * spp ( ii )% vars % g ( pp ) * & RVphi ( pp ) + spp ( ii )% q * ( RAphi ( pp , 1 ) - RAphi ( pp , 2 ))) / & spp ( ii )% vars % Y ( pp , 1 ) !GC ppar end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO !$OMP PARALLEL DO SHARED(ii,spp) PRIVATE(pp,Bmagc,bhatc) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then Bmagc = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) bhatc = spp ( ii )% vars % B ( pp ,:) / Bmagc spp ( ii )% vars % V ( pp , 1 ) = spp ( ii )% vars % V ( pp , 1 ) / & bhatc ( 2 ) !GC ppar spp ( ii )% vars % V ( pp , 2 ) = spp ( ii )% m / ( 2 * Bmagc ) * & ( spp ( ii )% vars % g ( pp ) ** 2 - & ( 1 + ( spp ( ii )% vars % V ( pp , 1 ) / spp ( ii )% m ) ** 2 )) !GC mu end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO params % GC_coords = . TRUE . DEALLOCATE ( RAphi ) DEALLOCATE ( RVphi ) !Preparing Output Data call get_fields ( params , spp ( ii )% vars , F ) !$OMP PARALLEL DO shared(F,params,spp) & !$OMP& PRIVATE(cc,pp,E_PHI,Y_R) firstprivate(pchunk) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) end do !$OMP END SIMD call add_analytical_E_p ( params , 0_ip , F , E_PHI , Y_R ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end do !$OMP END PARALLEL DO !$OMP PARALLEL DO SHARED(ii,spp) PRIVATE(pp,Bmag1) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then Bmag1 = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) spp ( ii )% vars % g ( pp ) = sqrt ( 1 + ( spp ( ii )% vars % V ( pp , 1 )) ** 2 + & 2 * spp ( ii )% vars % V ( pp , 2 ) * Bmag1 ) !                write(output_unit_write,'(\"Bmag:\",E17.10)') Bmag1 !                write(output_unit_write,'(\"PPLL:\",E17.10)') spp(ii)%vars%V(pp,1) !                write(output_unit_write,'(\"MU:\",E17.10)') spp(ii)%vars%V(pp,2) spp ( ii )% vars % eta ( pp ) = atan2 ( sqrt ( 2 * spp ( ii )% m * Bmag1 * & spp ( ii )% vars % V ( pp , 2 )), spp ( ii )% vars % V ( pp , 1 )) * 18 0.0_rp / C_PI !                             write(output_unit_write,'(\"BR\",E17.10)') spp(ii)%vars%B(pp,1) !                             write(output_unit_write,'(\"BPHI\",E17.10)') spp(ii)%vars%B(pp,2) !                             write(output_unit_write,'(\"BZ\",E17.10)') spp(ii)%vars%B(pp,3) !             write(output_unit_write,'(\"ppll\",E17.10)') spp(ii)%vars%V(pp,1) !             write(output_unit_write,'(\"pperp\",E17.10)') sqrt(2*spp(ii)%m*Bmag1* & !                  spp(ii)%vars%V(pp,2)) !                             write(output_unit_write,'(\"eta GCinit\",E17.10)') spp(ii)%vars%eta(pp) !             write(output_unit_write,'(\"gam\",E17.10)') spp(ii)%vars%g(pp) end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO else if (( spp ( ii )% spatial_distribution . eq . 'TRACER' ). or . & ( spp ( ii )% spatial_distribution . eq . 'TORUS' ). or . & ( spp ( ii )% spatial_distribution . eq . & '2D-GAUSSIAN-ELLIPTIC-TORUS-MH' )) & call cart_to_cyl ( spp ( ii )% vars % X , spp ( ii )% vars % Y ) params % GC_coords = . TRUE . do pp = 1_idef , spp ( ii )% ppp spp ( ii )% vars % E ( pp , 1 ) = 0._rp spp ( ii )% vars % E ( pp , 2 ) = 0._rp spp ( ii )% vars % E ( pp , 3 ) = 0._rp end do call get_fields ( params , spp ( ii )% vars , F ) !write(output_unit_write,*) spp(1)%vars%PSI_P !$OMP PARALLEL DO SHARED(ii,spp) PRIVATE(pp,Bmag1) do pp = 1_idef , spp ( ii )% ppp !             if ( spp(ii)%vars%flagCon(pp) .EQ. 1_is ) then !                write(output_unit_write,'(\"BR: \",E17.10)') spp(ii)%vars%B(pp,1) !                write(output_unit_write,'(\"BPHI: \",E17.10)') spp(ii)%vars%B(pp,2) !                write(output_unit_write,'(\"BZ: \",E17.10)') spp(ii)%vars%B(pp,3) Bmag1 = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) pmag = sqrt ( spp ( ii )% vars % g ( pp ) ** 2 - 1 ) spp ( ii )% vars % V ( pp , 1 ) = pmag * cos ( deg2rad ( spp ( ii )% vars % eta ( pp ))) spp ( ii )% vars % V ( pp , 2 ) = ( pmag * & sin ( deg2rad ( spp ( ii )% vars % eta ( pp )))) ** 2 / & ( 2 * spp ( ii )% m * Bmag1 ) !    write(output_unit_write,'(\"BR\",E17.10)') spp(ii)%vars%B(pp,1) !    write(output_unit_write,'(\"BPHI\",E17.10)') spp(ii)%vars%B(pp,2) !    write(output_unit_write,'(\"BZ\",E17.10)') spp(ii)%vars%B(pp,3) !write(output_unit_write,'(\"ppll\",E17.10)') spp(ii)%vars%V(pp,1) !write(output_unit_write,'(\"mu\",E17.10)') spp(ii)%vars%V(pp,2) !     write(output_unit_write,'(\"eta\",E17.10)') spp(ii)%vars%eta(pp) !     write(output_unit_write,'(\"gam\",E17.10)') spp(ii)%vars%g(pp) !             end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO !$OMP PARALLEL DO shared(F,params,spp) & !$OMP& PRIVATE(pp,cc,E_PHI,Y_R) firstprivate(pchunk) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) end do !$OMP END SIMD if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then call add_analytical_E_p ( params , 0_ip , F , E_PHI , Y_R ) end if !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end do !$OMP END PARALLEL DO end if end do ! loop over particle species end subroutine GC_init FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad FUNCTION rad2deg ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: rad2deg rad2deg = x * 18 0.0_rp / C_PI END FUNCTION rad2deg subroutine adv_GCeqn_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z , E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ) :: B0 , EF0 , R0 , q0 , lam , ar , m_cache , q_cache , ne0 , Te0 , Zeff0 INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol LOGICAL :: ss_collisions !! Logical variable that indicates if collisions are included in !! the simulation. INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. real ( rp ), dimension ( F % dim_1D ) :: Vden , Vdenave , VdenOMP do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m do ttt = 1_ip , params % t_it_SC VdenOMP = 0._rp !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(E0,q_cache,m_cache,pchunk) & !$OMP& shared(F,P,params,ii,spp) & !$OMP& PRIVATE(pp,tt,ttt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !$OMP& flagCon,flagCol,B_R,B_PHI,B_Z,E_PHI,PSIp, & !$OMP& Vden,Vdenave) & !$OMP& REDUCTION(+:VdenOMP) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_p ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then Vdenave = 0._rp do tt = 1_ip , params % t_skip !                   write(output_unit_write,*) params%mpi_params%rank,'Y_R',Y_R call advance_GCeqn_vars ( spp ( ii )% vars , pp , & tt + params % t_skip * ( ttt - 1 ), params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , flagCon , flagCol , q_cache , m_cache , & B_R , B_PHI , B_Z , F , P , PSIp , E_PHI ) !                   write(output_unit_write,*) params%mpi_params%rank,'Y_R',Y_R if ( params % SC_E ) then call calculate_SC_p ( params , F , B_R , B_PHI , B_Z , Y_R , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , Vden ) Vdenave = ( Vdenave * REAL ( tt - 1_ip ) + Vden ) / REAL ( tt ) end if end do !timestep iterator VdenOMP = VdenOMP + Vdenave !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPeqn_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , flagCon , flagCol , m_cache , & F , P , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) end do !$OMP END SIMD end if call analytical_fields_Bmag_p ( pchunk , F , Y_R , Y_PHI , Y_Z , & Bmag , E_PHI ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc ) * m_cache ) spp ( ii )% vars % eta ( pp - 1 + cc ) = rad2deg ( atan2 ( sqrt ( 2 * m_cache * & Bmag ( cc ) * spp ( ii )% vars % V ( pp - 1 + cc , 2 )), & spp ( ii )% vars % V ( pp - 1 + cc , 1 ))) end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO if ( params % SC_E ) then call calculate_SC_E1D ( params , F , VdenOMP ) end if end do end do !species iterator end subroutine adv_GCeqn_top subroutine advance_GCeqn_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , & flagCon , flagCol , q_cache , m_cache , B_R , B_PHI , B_Z , F , P , PSIp , E_PHI ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type PROFILES. REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), INTENT ( IN ) :: tt !! time iterator. INTEGER , INTENT ( IN ) :: pp REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , V0 , E_Z , E_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , ne , Te , Zeff INTEGER ( is ), dimension ( params % pchunk ), intent ( inout ) :: flagCon , flagCol REAL ( rp ) :: ar , R0 REAL ( rp ), intent ( IN ) :: q_cache , m_cache ar = F % AB % a R0 = F % AB % Ro pchunk = params % pchunk dt = params % dt !    write(output_unit_write,'(\"Y_R 0: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 0: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 0: \",E17.10)') Y_Z(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0 ( cc ) = V_PLL ( cc ) end do !$OMP END SIMD call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if !    write(output_unit_write,'(\"ER:\",E17.10)') E_R !    write(output_unit_write,'(\"EPHI:\",E17.10)') E_PHI !    write(output_unit_write,'(\"EZ:\",E17.10)') E_Z call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k1_R,k1_PHI,k1_Z,k1_PLL) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) !       vars%RHS(pp-1+cc,1)=RHS_R(cc) !       vars%RHS(pp-1+cc,2)=RHS_PHI(cc) !       vars%RHS(pp-1+cc,3)=RHS_Z(cc) !       vars%RHS(pp-1+cc,4)=RHS_PLL(cc) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a1 * k1_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 1: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 1: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 1: \",E17.10)') Y_Z(1) !    write(output_unit_write,'(\"k1R: \",E17.10)') k1_R(1) !    write(output_unit_write,'(\"k1PHI: \",E17.10)') k1_PHI(1) !    write(output_unit_write,'(\"k1Z: \",E17.10)') k1_Z(1) !    write(output_unit_write,'(\"k1PLL: \",E17.10)') k1_PLL(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k2_R,k2_PHI,k2_Z,k2_PLL) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 2: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 2: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 2: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k3_R,k3_PHI,k3_Z,k3_PLL) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 3: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 3: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 3: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k4_R,k4_PHI,k4_Z,k4_PLL) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 4: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 4: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 4: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k5_R,k5_PHI,k5_Z,k5_PLL) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 5: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 5: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 5: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k6_R,k6_PHI,k6_Z,k6_PLL) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 6: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 6: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 6: \",E17.10)') Y_Z(1) call cyl_check_if_confined_p ( pchunk , ar , R0 , Y_R , Y_Z , flagCon ) !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,Y0_R,Y0_PHI,Y0_Z,V0) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) end if end do !$OMP END SIMD call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCeqn_vars subroutine advance_FPeqn_vars ( params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , flagCon , flagCol , & m_cache , F , P , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: E_PHI INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( in ) :: m_cache REAL ( rp ), DIMENSION ( params % pchunk ) :: ne do tt = 1_ip , params % t_skip call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !       write(output_unit_write,'(\"Collision Loop in FP\")') end do end subroutine advance_FPeqn_vars subroutine adv_GCinterp_psi_top_FS ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. real ( rp ), dimension ( F % dim_1D ) :: Vden , Vdenave , VdenOMP !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m do ttt = 1_ip , params % t_it_SC VdenOMP = 0._rp !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne, & !$OMP& Vden,Vdenave) & !$OMP& REDUCTION(+:VdenOMP) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then Vdenave = 0._rp do tt = 1_ip , params % t_skip call advance_GCinterp_psi_vars_FS ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z ) call calculate_SC_p_FS ( params , F , B_R , B_PHI , B_Z , PSIp , & V_PLL , V_MU , m_cache , flagCon , flagCol , Vden ) !                   write(output_unit_write,*) 'pre-Vdenave',Vdenave(F%dim_1D) Vdenave = ( Vdenave * REAL ( tt - 1_ip ) + Vden ) / REAL ( tt ) !                   write(output_unit_write,*) 'Vden',Vden(F%dim_1D) !                   write(output_unit_write,*) 'post-Vdenave',Vdenave(F%dim_1D) !                   if (pp.eq.9_idef) write(output_unit_write,*) 'Vdenave',Vdenave(F%dim_1D) end do !timestep iterator !                write(output_unit_write,*) 'Vdenave',Vdenave(F%dim_1D) VdenOMP = VdenOMP + Vdenave !                write(output_unit_write,*) 'VdenOMP',VdenOMP(F%dim_1D) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO !write(output_unit_write,*) 'VdenOMP',VdenOMP(F%dim_1D) call calculate_SC_E1D_FS ( params , F , VdenOMP ) end do end do !species iterator end subroutine adv_GCinterp_psi_top_FS subroutine adv_GCinterp_psi_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,E_R,E_Z) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_psi_vars ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else if ( params % FokPlan . and . params % collisions ) then call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else do tt = 1_ip , params % t_skip call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) end do !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_psi_top subroutine adv_GCinterp_m3dc1_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar TYPE ( C_PTR ), DIMENSION ( params % pchunk ) :: hint INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,Te,E_R,E_Z,hint) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_R ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_PHI ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) gradB_R ( cc ) = spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) gradB_PHI ( cc ) = spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) gradB_Z ( cc ) = spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) curlb_R ( cc ) = spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) curlb_PHI ( cc ) = spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) curlb_Z ( cc ) = spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) hint ( cc ) = spp ( ii )% vars % hint ( pp - 1 + cc ) ne ( cc ) = spp ( ii )% vars % ne ( pp - 1 + cc ) Te ( cc ) = spp ( ii )% vars % Te ( pp - 1 + cc ) end do !$OMP END SIMD do tt = 1_ip , params % t_skip call advance_GCinterp_m3dc1_vars ( spp ( ii )% vars , pp , tt , & params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , & flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne , Te , hint ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_R ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) spp ( ii )% vars % Te ( pp - 1 + cc ) = Te ( cc ) spp ( ii )% vars % hint ( pp - 1 + cc ) = hint ( cc ) end do !$OMP END SIMD !$OMP SIMD do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_m3dc1_top subroutine adv_GCinterp_psiwE_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,E_R,E_Z) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_psiwE_vars ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else if ( params % FokPlan . and . params % collisions ) then call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else do tt = 1_ip , params % t_skip call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) end do !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_psiwE_top subroutine adv_GCinterp_psi2x1t_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar , time INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,time,E_R,E_Z) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_psi2x1t_vars ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else if ( params % FokPlan . and . params % collisions ) then call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else do tt = 1_ip , params % t_skip time = params % init_time + ( params % it - 1 + tt ) * & params % dt call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp , time ) end do !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_psi2x1t_top subroutine adv_GCinterp_B_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_B_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_B_top subroutine adv_GCinterp_B2D_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_B2D_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_B2D_top subroutine adv_GCinterp_2DBdB_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_2DBdB_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_2DBdB_top subroutine adv_GCinterp_3DBdB1_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species q_cache = spp ( ii )% q m_cache = spp ( ii )% m pchunk = params % pchunk !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_3DBdB1_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_3DBdB1_top subroutine adv_GCinterp_3DBdB_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species q_cache = spp ( ii )% q m_cache = spp ( ii )% m pchunk = params % pchunk !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,PSIp) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_3DBdB_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_3DBdB_top subroutine advance_GCinterp_psi_vars_FS ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !    write(output_unit_write,*) 'R',Y_R(1) !    write(output_unit_write,*) 'PHI',Y_PHI(1) !    write(output_unit_write,*) 'Z',Y_Z(1) !    write(output_unit_write,*) 'PPLL',V_PLL(1) !    write(output_unit_write,*) 'MU',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psi_vars_FS subroutine advance_GCinterp_psi_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'R0',Y_R(1) !write(output_unit_write,*) 'PHI0',Y_PHI(1) !write(output_unit_write,*) 'Z0',Y_Z(1) !write(output_unit_write,*) 'PPLL0',V_PLL(1) !write(output_unit_write,*) 'MU0',V_MU(1) !write(output_unit_write,*) 'ER',E_R(1) !write(output_unit_write,*) 'EPHI',E_PHI(1) !write(output_unit_write,*) 'EZ',E_Z(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) !write(output_unit_write,*) 'ER',E_R(1) !write(output_unit_write,*) 'EPHI',E_PHI(1) !write(output_unit_write,*) 'EZ',E_Z(1) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) !write(output_unit_write,*) 'ER',E_R(1) !write(output_unit_write,*) 'EPHI',E_PHI(1) !write(output_unit_write,*) 'EZ',E_Z(1) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R0',Y_R(1) !write(output_unit_write,*) 'PHI0',Y_PHI(1) !write(output_unit_write,*) 'Z0',Y_Z(1) !write(output_unit_write,*) 'PPLL0',V_PLL(1) !write(output_unit_write,*) 'MU0',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'ER',E_R(1) !    write(output_unit_write,*) 'EPHI',E_PHI(1) !    write(output_unit_write,*) 'EZ',E_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD ! write(output_unit_write,*) 'R1',Y_R(1) ! write(output_unit_write,*) 'PHI1',Y_PHI(1) ! write(output_unit_write,*) 'Z1',Y_Z(1) ! write(output_unit_write,*) 'PPLL1',V_PLL(1) ! write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psi_vars subroutine advance_GCinterp_m3dc1_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , PSIp ,& curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne , Te , hint ) USE omp_lib IMPLICIT NONE !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI , E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: ne , Te REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER :: thread_num thread_num = OMP_GET_THREAD_NUM () dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'R0',Y_R(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'PHI0',Y_PHI(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'Z0',Y_Z(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'PPLL0',V_PLL(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'MU0',V_MU(1) call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'B',B_R(1),B_PHI(1),B_Z(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'gradB',gradB_R(1),gradB_PHI(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'curlB',curlB_R(1),curlB_PHI(1),curlB_Z(1) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'R1',Y_R(1) !write(output_unit_write,*) 'PHI1',Y_PHI(1) !write(output_unit_write,*) 'Z1',Y_Z(1) !write(output_unit_write,*) 'PPLL1',V_PLL(1) !write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD !write(6,*) E_PHI if ( params % collisions ) then call include_CoulombCollisions_GCm3dc1_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , Te , PSIp , hint ) end if !write(6,*) E_PHI end subroutine advance_GCinterp_m3dc1_vars subroutine advance_GCinterp_psiwE_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R1',Y_R(1) !    write(output_unit_write,*) 'PHI1',Y_PHI(1) !!    write(output_unit_write,*) 'Z1',Y_Z(1) !   write(output_unit_write,*) 'PPLL1',V_PLL(1) !   write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psiwE_vars subroutine advance_GCinterp_psi2x1t_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt , time !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk time = params % init_time + ( params % it - 1 + tt ) * params % dt !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R1',Y_R(1) !    write(output_unit_write,*) 'PHI1',Y_PHI(1) !!    write(output_unit_write,*) 'Z1',Y_Z(1) !   write(output_unit_write,*) 'PPLL1',V_PLL(1) !   write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psi2x1t_vars subroutine advance_GCinterp_B2D_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_B2D_vars subroutine advance_GCinterp_2DBdB_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !write(output_unit_write,*) 'gradBR',gradB_R(1) !write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !write(output_unit_write,*) 'gradBZ',gradB_Z(1) !write(output_unit_write,*) 'curlBR',curlB_R(1) !write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !write(output_unit_write,*) 'curlBZ',curlB_Z(1) !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_2DBdB_vars subroutine advance_GCinterp_3DBdB_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !write(output_unit_write,*) 'gradBR',gradB_R(1) !write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !write(output_unit_write,*) 'gradBZ',gradB_Z(1) !write(output_unit_write,*) 'curlBR',curlB_R(1) !write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !write(output_unit_write,*) 'curlBZ',curlB_Z(1) !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_3DBdB_vars subroutine advance_GCinterp_3DBdB1_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !write(output_unit_write,*) 'gradBR',gradB_R(1) !write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !write(output_unit_write,*) 'gradBZ',gradB_Z(1) !write(output_unit_write,*) 'curlBR',curlB_R(1) !write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !write(output_unit_write,*) 'curlBZ',curlB_Z(1) !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_3DBdB1_vars subroutine advance_GCinterp_B_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_B_vars subroutine advance_FPinterp_vars ( params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , & m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), intent ( in ) :: m_cache INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne !    write(output_unit_write,'(\"E_PHI_FP: \",E17.10)') E_PHI do tt = 1_ip , params % t_skip call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !       write(output_unit_write,'(\"Collision Loop in FP\")') end do !    write(output_unit_write,'(\"V_PLL: \",E17.10)') V_PLL !    write(output_unit_write,'(\"V_MU: \",E17.10)') V_MU end subroutine advance_FPinterp_vars subroutine GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , & gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , bhat_R , bhat_PHI , bhat_Z , Bst_R , Bst_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: BstdotE , BstdotgradB , EcrossB_R , EcrossB_PHI , bdotBst REAL ( rp ), DIMENSION ( params % pchunk ) :: bcrossgradB_R , bcrossgradB_PHI , bcrossgradB_Z , gamgc REAL ( rp ), DIMENSION ( params % pchunk ) :: EcrossB_Z , Bst_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: pm , xi , tau_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: gradB_R , gradB_PHI , gradB_Z , curlb_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: curlb_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_R , RHS_PHI , RHS_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_PLL REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: V_PLL , V_MU , Y_R , curlb_PHI REAL ( rp ), INTENT ( in ) :: q_cache , m_cache INTEGER ( ip ) :: cc , pchunk pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(gradB_R,gradB_PHI,gradB_Z,curlb_R,curlb_Z, & !    !$OMP& B_R,B_PHI,B_Z,E_R,E_PHI,E_Z,RHS_R,RHS_PHI,RHS_Z,RHS_PLL, & !    !$OMP& V_PLL,V_MU,Y_R,curlb_PHI) do cc = 1_idef , pchunk Bmag ( cc ) = SQRT ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) bhat_R ( cc ) = B_R ( cc ) / Bmag ( cc ) bhat_PHI ( cc ) = B_PHI ( cc ) / Bmag ( cc ) bhat_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) Bst_R ( cc ) = q_cache * B_R ( cc ) + V_PLL ( cc ) * curlb_R ( cc ) Bst_PHI ( cc ) = q_cache * B_PHI ( cc ) + V_PLL ( cc ) * curlb_PHI ( cc ) Bst_Z ( cc ) = q_cache * B_Z ( cc ) + V_PLL ( cc ) * curlb_Z ( cc ) bdotBst ( cc ) = bhat_R ( cc ) * Bst_R ( cc ) + bhat_PHI ( cc ) * Bst_PHI ( cc ) + & bhat_Z ( cc ) * Bst_Z ( cc ) BstdotE ( cc ) = Bst_R ( cc ) * E_R ( cc ) + Bst_PHI ( cc ) * E_PHI ( cc ) + Bst_Z ( cc ) * E_Z ( cc ) BstdotgradB ( cc ) = Bst_R ( cc ) * gradB_R ( cc ) + Bst_PHI ( cc ) * gradB_PHI ( cc ) + & Bst_Z ( cc ) * gradB_Z ( cc ) Ecrossb_R ( cc ) = E_PHI ( cc ) * bhat_Z ( cc ) - E_Z ( cc ) * bhat_PHI ( cc ) Ecrossb_PHI ( cc ) = E_Z ( cc ) * bhat_R ( cc ) - E_R ( cc ) * bhat_Z ( cc ) Ecrossb_Z ( cc ) = E_R ( cc ) * bhat_PHI ( cc ) - E_PHI ( cc ) * bhat_R ( cc ) bcrossgradB_R ( cc ) = bhat_PHI ( cc ) * gradB_Z ( cc ) - bhat_Z ( cc ) * gradB_PHI ( cc ) bcrossgradB_PHI ( cc ) = bhat_Z ( cc ) * gradB_R ( cc ) - bhat_R ( cc ) * gradB_Z ( cc ) bcrossgradB_Z ( cc ) = bhat_R ( cc ) * gradB_PHI ( cc ) - bhat_PHI ( cc ) * gradB_R ( cc ) gamgc ( cc ) = sqrt ( 1 + V_PLL ( cc ) * V_PLL ( cc ) + 2 * V_MU ( cc ) * Bmag ( cc )) pm ( cc ) = sqrt ( gamgc ( cc ) ** 2 - 1 ) xi ( cc ) = V_PLL ( cc ) / pm ( cc ) RHS_R ( cc ) = ( q_cache * Ecrossb_R ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_R ( cc ) + V_PLL ( cc ) * Bst_R ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PHI ( cc ) = ( q_cache * Ecrossb_PHI ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_PHI ( cc ) + V_PLL ( cc ) * Bst_PHI ( cc )) / ( m_cache * gamgc ( cc ))) / & ( Y_R ( cc ) * bdotBst ( cc )) RHS_Z ( cc ) = ( q_cache * Ecrossb_Z ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_Z ( cc ) + V_PLL ( cc ) * Bst_Z ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PLL ( cc ) = ( q_cache * BstdotE ( cc ) - V_MU ( cc ) * BstdotgradB ( cc ) / gamgc ( cc )) / & bdotBst ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'RHS_R: ',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI: ',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z: ',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL: ',RHS_PLL(1) end subroutine GCEoM_p subroutine GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( PROFILES ), INTENT ( IN ) :: P REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , bhat_R , bhat_PHI , bhat_Z , Bst_R , Bst_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: BstdotE , BstdotgradB , EcrossB_R , EcrossB_PHI , bdotBst REAL ( rp ), DIMENSION ( params % pchunk ) :: bcrossgradB_R , bcrossgradB_PHI , bcrossgradB_Z , gamgc REAL ( rp ), DIMENSION ( params % pchunk ) :: EcrossB_Z , Bst_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: pm , xi , tau_R REAL ( rp ), DIMENSION ( params % pchunk ) :: SR_PLL , SR_MU , BREM_PLL , BREM_MU , BREM_P REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: gradB_R , gradB_PHI , gradB_Z , curlb_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: curlb_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_R , RHS_PHI , RHS_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: V_PLL , V_MU , Y_R , Y_Z , curlb_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: PSIp REAL ( rp ), INTENT ( in ) :: q_cache , m_cache INTEGER ( ip ) :: cc , pchunk INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ) :: time , re_cache , alpha_cache REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff , Te REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(gradB_R,gradB_PHI,gradB_Z,curlb_R,curlb_Z, & !    !$OMP& B_R,B_PHI,B_Z,E_R,E_PHI,E_Z,RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& V_PLL,V_MU,Y_R,curlb_PHI,tau_R) do cc = 1_idef , pchunk ne ( cc ) =- 1._rp Te ( cc ) =- 1._rp Zeff ( cc ) =- 1._rp Bmag ( cc ) = SQRT ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) bhat_R ( cc ) = B_R ( cc ) / Bmag ( cc ) bhat_PHI ( cc ) = B_PHI ( cc ) / Bmag ( cc ) bhat_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) Bst_R ( cc ) = q_cache * B_R ( cc ) + V_PLL ( cc ) * curlb_R ( cc ) Bst_PHI ( cc ) = q_cache * B_PHI ( cc ) + V_PLL ( cc ) * curlb_PHI ( cc ) Bst_Z ( cc ) = q_cache * B_Z ( cc ) + V_PLL ( cc ) * curlb_Z ( cc ) ! write(output_unit_write,*) 'bmag',Bmag(cc),'bhat',bhat_R(cc),bhat_PHI(cc),bhat_Z(cc),'Bst',Bst_R(cc),Bst_PHI(cc),Bst_Z(cc) bdotBst ( cc ) = bhat_R ( cc ) * Bst_R ( cc ) + bhat_PHI ( cc ) * Bst_PHI ( cc ) + & bhat_Z ( cc ) * Bst_Z ( cc ) BstdotE ( cc ) = Bst_R ( cc ) * E_R ( cc ) + Bst_PHI ( cc ) * E_PHI ( cc ) + Bst_Z ( cc ) * E_Z ( cc ) BstdotgradB ( cc ) = Bst_R ( cc ) * gradB_R ( cc ) + Bst_PHI ( cc ) * gradB_PHI ( cc ) + & Bst_Z ( cc ) * gradB_Z ( cc ) !write(output_unit_write,*) 'bdotBst',bdotBst(cc),BstdotE(cc),BstdotgradB(cc) Ecrossb_R ( cc ) = E_PHI ( cc ) * bhat_Z ( cc ) - E_Z ( cc ) * bhat_PHI ( cc ) Ecrossb_PHI ( cc ) = E_Z ( cc ) * bhat_R ( cc ) - E_R ( cc ) * bhat_Z ( cc ) Ecrossb_Z ( cc ) = E_R ( cc ) * bhat_PHI ( cc ) - E_PHI ( cc ) * bhat_R ( cc ) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(cc),Ecrossb_PHI(cc),Ecrossb_Z(cc) bcrossgradB_R ( cc ) = bhat_PHI ( cc ) * gradB_Z ( cc ) - bhat_Z ( cc ) * gradB_PHI ( cc ) bcrossgradB_PHI ( cc ) = bhat_Z ( cc ) * gradB_R ( cc ) - bhat_R ( cc ) * gradB_Z ( cc ) bcrossgradB_Z ( cc ) = bhat_R ( cc ) * gradB_PHI ( cc ) - bhat_PHI ( cc ) * gradB_R ( cc ) ! write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(cc),bcrossgradB_PHI(cc),bcrossgradB_Z(cc) gamgc ( cc ) = sqrt ( 1 + V_PLL ( cc ) * V_PLL ( cc ) + 2 * V_MU ( cc ) * Bmag ( cc )) pm ( cc ) = sqrt ( gamgc ( cc ) ** 2 - 1 ) xi ( cc ) = V_PLL ( cc ) / pm ( cc ) RHS_R ( cc ) = ( q_cache * Ecrossb_R ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_R ( cc ) + V_PLL ( cc ) * Bst_R ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PHI ( cc ) = ( q_cache * Ecrossb_PHI ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_PHI ( cc ) + V_PLL ( cc ) * Bst_PHI ( cc )) / ( m_cache * gamgc ( cc ))) / & ( Y_R ( cc ) * bdotBst ( cc )) RHS_Z ( cc ) = ( q_cache * Ecrossb_Z ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_Z ( cc ) + V_PLL ( cc ) * Bst_Z ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PLL ( cc ) = ( q_cache * BstdotE ( cc ) - V_MU ( cc ) * BstdotgradB ( cc ) / gamgc ( cc )) / & bdotBst ( cc ) RHS_MU ( cc ) = 0._rp end do !$OMP END SIMD !write(output_unit_write,*) 'bmag',Bmag(1),'bhat',bhat_R(1),bhat_PHI(1),bhat_Z(1),'Bst',Bst_R(1),Bst_PHI(1),Bst_Z(1) !write(output_unit_write,*) 'bdotBst',bdotBst(1),BstdotE(1),BstdotgradB(1) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(1),Ecrossb_PHI(1),Ecrossb_Z(1) !write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(1),bcrossgradB_PHI(1),bcrossgradB_Z(1) !    !$OMP SIMD !    do cc=1_idef,8 !       if(isnan(RHS_R(cc))) stop 'RHS_R0 is a NaN' !       if(isnan(RHS_PHI(cc))) stop 'RHS_PHI0 is a NaN' !       if(isnan(RHS_Z(cc))) stop 'RHS_Z0 is a NaN' !       if(isnan(RHS_PLL(cc))) stop 'RHS_PLL0 is a NaN' !       if(isnan(RHS_MU(cc))) stop 'RHS_MU0 is a NaN' !    end do !    !$OMP END SIMD if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !       write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) re_cache = C_RE / params % cpp % length alpha_cache = C_a time = params % init_time + ( params % it - 1 + tt ) * params % dt call analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) !$OMP SIMD !       !$OMP& aligned(tau_R,Bmag,RHS_PLL,V_PLL,xi,gamgc,RHS_MU,V_MU) do cc = 1_idef , pchunk tau_R ( cc ) = 6 * C_PI * E0 / ( Bmag ( cc ) * Bmag ( cc )) SR_PLL ( cc ) = V_PLL ( cc ) * ( 1._rp - xi ( cc ) * xi ( cc )) / tau_R ( cc ) * & ( 1._rp / gamgc ( cc ) - gamgc ( cc )) SR_MU ( cc ) =- 2._rp * V_MU ( cc ) / tau_R ( cc ) * & ( gamgc ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) + xi ( cc ) * xi ( cc ) / gamgc ( cc )) !Normalizations done here BREM_P ( cc ) =- 4._rp * re_cache ** 2 * ne ( cc ) * & Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * alpha_cache * & ( gamgc ( cc ) - 1._rp ) * ( log ( 2._rp * gamgc ( cc )) - 1._rp / 3._rp ) BREM_PLL ( cc ) = xi ( cc ) * BREM_P ( cc ) BREM_MU ( cc ) = ( 1._rp - xi ( cc ) * xi ( cc )) * V_PLL ( cc ) / & ( Bmag ( cc ) * xi ( cc )) * BREM_P ( cc ) RHS_PLL ( cc ) = RHS_PLL ( cc ) + SR_PLL ( cc ) + BREM_PLL ( cc ) RHS_MU ( cc ) = SR_MU ( cc ) + BREM_MU ( cc ) end do !$OMP END SIMD end if if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( ne ( cc ))) stop 'ne is a NaN' if ( isnan ( Zeff ( cc ))) stop 'Zeff is a NaN' if ( isnan ( BREM_P ( cc ))) stop 'BREM_P is a NaN' if ( isnan ( BREM_PLL ( cc ))) stop 'BREM_PLL is a NaN' if ( isnan ( BREM_MU ( cc ))) stop 'BREM_MU is a NaN' if ( isnan ( SR_PLL ( cc ))) stop 'SR_PLL is a NaN' if ( isnan ( SR_MU ( cc ))) stop 'SR_MU is a NaN' end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( gamgc ( cc ))) stop 'gamgc is a NaN' if ( isnan ( RHS_R ( cc ))) stop 'RHS_R1 is a NaN' if ( isnan ( RHS_PHI ( cc ))) stop 'RHS_PHI1 is a NaN' if ( isnan ( RHS_Z ( cc ))) stop 'RHS_Z1 is a NaN' if ( isnan ( RHS_PLL ( cc ))) stop 'RHS_PLL1 is a NaN' if ( isnan ( RHS_MU ( cc ))) stop 'RHS_MU1 is a NaN' end do !$OMP END SIMD !    write(output_unit_write,*) 'RHS_R: ',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI: ',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z: ',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL: ',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU: ',RHS_MU(1) end subroutine GCEoM1_p subroutine GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , Te , flag , hint ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( PROFILES ), INTENT ( IN ) :: P REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , bhat_R , bhat_PHI , bhat_Z , Bst_R , Bst_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: BstdotE , BstdotgradB , EcrossB_R , EcrossB_PHI , bdotBst REAL ( rp ), DIMENSION ( params % pchunk ) :: bcrossgradB_R , bcrossgradB_PHI , bcrossgradB_Z , gamgc REAL ( rp ), DIMENSION ( params % pchunk ) :: EcrossB_Z , Bst_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: pm , xi , tau_R REAL ( rp ), DIMENSION ( params % pchunk ) :: SR_PLL , SR_MU , BREM_PLL , BREM_MU , BREM_P REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: gradB_R , gradB_PHI , gradB_Z , curlb_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: curlb_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_R , RHS_PHI , RHS_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: V_PLL , V_MU , Y_R , Y_PHI , Y_Z , curlb_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: PSIp REAL ( rp ), INTENT ( in ) :: q_cache , m_cache INTEGER ( ip ) :: cc , pchunk INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ) :: time , re_cache , alpha_cache REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne , Te TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flag pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(gradB_R,gradB_PHI,gradB_Z,curlb_R,curlb_Z, & !    !$OMP& B_R,B_PHI,B_Z,E_R,E_PHI,E_Z,RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& V_PLL,V_MU,Y_R,curlb_PHI,tau_R) do cc = 1_idef , pchunk ne ( cc ) =- 1._rp Te ( cc ) =- 1._rp Zeff ( cc ) =- 1._rp Bmag ( cc ) = SQRT ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) bhat_R ( cc ) = B_R ( cc ) / Bmag ( cc ) bhat_PHI ( cc ) = B_PHI ( cc ) / Bmag ( cc ) bhat_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) Bst_R ( cc ) = q_cache * B_R ( cc ) + V_PLL ( cc ) * curlb_R ( cc ) Bst_PHI ( cc ) = q_cache * B_PHI ( cc ) + V_PLL ( cc ) * curlb_PHI ( cc ) Bst_Z ( cc ) = q_cache * B_Z ( cc ) + V_PLL ( cc ) * curlb_Z ( cc ) ! write(output_unit_write,*) 'bmag',Bmag(cc),'bhat',bhat_R(cc),bhat_PHI(cc),bhat_Z(cc),'Bst',Bst_R(cc),Bst_PHI(cc),Bst_Z(cc) bdotBst ( cc ) = bhat_R ( cc ) * Bst_R ( cc ) + bhat_PHI ( cc ) * Bst_PHI ( cc ) + & bhat_Z ( cc ) * Bst_Z ( cc ) BstdotE ( cc ) = Bst_R ( cc ) * E_R ( cc ) + Bst_PHI ( cc ) * E_PHI ( cc ) + Bst_Z ( cc ) * E_Z ( cc ) BstdotgradB ( cc ) = Bst_R ( cc ) * gradB_R ( cc ) + Bst_PHI ( cc ) * gradB_PHI ( cc ) + & Bst_Z ( cc ) * gradB_Z ( cc ) !write(output_unit_write,*) 'bdotBst',bdotBst(cc),BstdotE(cc),BstdotgradB(cc) Ecrossb_R ( cc ) = E_PHI ( cc ) * bhat_Z ( cc ) - E_Z ( cc ) * bhat_PHI ( cc ) Ecrossb_PHI ( cc ) = E_Z ( cc ) * bhat_R ( cc ) - E_R ( cc ) * bhat_Z ( cc ) Ecrossb_Z ( cc ) = E_R ( cc ) * bhat_PHI ( cc ) - E_PHI ( cc ) * bhat_R ( cc ) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(cc),Ecrossb_PHI(cc),Ecrossb_Z(cc) bcrossgradB_R ( cc ) = bhat_PHI ( cc ) * gradB_Z ( cc ) - bhat_Z ( cc ) * gradB_PHI ( cc ) bcrossgradB_PHI ( cc ) = bhat_Z ( cc ) * gradB_R ( cc ) - bhat_R ( cc ) * gradB_Z ( cc ) bcrossgradB_Z ( cc ) = bhat_R ( cc ) * gradB_PHI ( cc ) - bhat_PHI ( cc ) * gradB_R ( cc ) ! write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(cc),bcrossgradB_PHI(cc),bcrossgradB_Z(cc) gamgc ( cc ) = sqrt ( 1 + V_PLL ( cc ) * V_PLL ( cc ) + 2 * V_MU ( cc ) * Bmag ( cc )) pm ( cc ) = sqrt ( gamgc ( cc ) ** 2 - 1 ) xi ( cc ) = V_PLL ( cc ) / pm ( cc ) RHS_R ( cc ) = ( q_cache * Ecrossb_R ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_R ( cc ) + V_PLL ( cc ) * Bst_R ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PHI ( cc ) = ( q_cache * Ecrossb_PHI ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_PHI ( cc ) + V_PLL ( cc ) * Bst_PHI ( cc )) / ( m_cache * gamgc ( cc ))) / & ( Y_R ( cc ) * bdotBst ( cc )) RHS_Z ( cc ) = ( q_cache * Ecrossb_Z ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_Z ( cc ) + V_PLL ( cc ) * Bst_Z ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PLL ( cc ) = ( q_cache * BstdotE ( cc ) - V_MU ( cc ) * BstdotgradB ( cc ) / gamgc ( cc )) / & bdotBst ( cc ) RHS_MU ( cc ) = 0._rp end do !$OMP END SIMD !write(output_unit_write,*) 'bmag',Bmag(1),'bhat',bhat_R(1),bhat_PHI(1),bhat_Z(1),'Bst',Bst_R(1),Bst_PHI(1),Bst_Z(1) !write(output_unit_write,*) 'bdotBst',bdotBst(1),BstdotE(1),BstdotgradB(1) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(1),Ecrossb_PHI(1),Ecrossb_Z(1) !write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(1),bcrossgradB_PHI(1),bcrossgradB_Z(1) !    !$OMP SIMD !    do cc=1_idef,8 !       if(isnan(RHS_R(cc))) stop 'RHS_R0 is a NaN' !       if(isnan(RHS_PHI(cc))) stop 'RHS_PHI0 is a NaN' !       if(isnan(RHS_Z(cc))) stop 'RHS_Z0 is a NaN' !       if(isnan(RHS_PLL(cc))) stop 'RHS_PLL0 is a NaN' !       if(isnan(RHS_MU(cc))) stop 'RHS_MU0 is a NaN' !    end do !    !$OMP END SIMD if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !       write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) re_cache = C_RE / params % cpp % length alpha_cache = C_a call get_m3d_c1_profile_p ( params , P , Y_R , Y_PHI , Y_Z , & ne , Te , flag , hint ) !$OMP SIMD !       !$OMP& aligned(tau_R,Bmag,RHS_PLL,V_PLL,xi,gamgc,RHS_MU,V_MU) do cc = 1_idef , pchunk tau_R ( cc ) = 6 * C_PI * E0 / ( Bmag ( cc ) * Bmag ( cc )) SR_PLL ( cc ) = V_PLL ( cc ) * ( 1._rp - xi ( cc ) * xi ( cc )) / tau_R ( cc ) * & ( 1._rp / gamgc ( cc ) - gamgc ( cc )) SR_MU ( cc ) =- 2._rp * V_MU ( cc ) / tau_R ( cc ) * & ( gamgc ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) + xi ( cc ) * xi ( cc ) / gamgc ( cc )) !Normalizations done here BREM_P ( cc ) =- 4._rp * re_cache ** 2 * ne ( cc ) * & Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * alpha_cache * & ( gamgc ( cc ) - 1._rp ) * ( log ( 2._rp * gamgc ( cc )) - 1._rp / 3._rp ) BREM_PLL ( cc ) = xi ( cc ) * BREM_P ( cc ) BREM_MU ( cc ) = ( 1._rp - xi ( cc ) * xi ( cc )) * V_PLL ( cc ) / & ( Bmag ( cc ) * xi ( cc )) * BREM_P ( cc ) RHS_PLL ( cc ) = RHS_PLL ( cc ) + SR_PLL ( cc ) + BREM_PLL ( cc ) RHS_MU ( cc ) = SR_MU ( cc ) + BREM_MU ( cc ) end do !$OMP END SIMD end if if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( ne ( cc ))) stop 'ne is a NaN' if ( isnan ( Zeff ( cc ))) stop 'Zeff is a NaN' if ( isnan ( BREM_P ( cc ))) stop 'BREM_P is a NaN' if ( isnan ( BREM_PLL ( cc ))) stop 'BREM_PLL is a NaN' if ( isnan ( BREM_MU ( cc ))) stop 'BREM_MU is a NaN' if ( isnan ( SR_PLL ( cc ))) stop 'SR_PLL is a NaN' if ( isnan ( SR_MU ( cc ))) stop 'SR_MU is a NaN' end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( gamgc ( cc ))) stop 'gamgc is a NaN' if ( isnan ( RHS_R ( cc ))) stop 'RHS_R1 is a NaN' if ( isnan ( RHS_PHI ( cc ))) stop 'RHS_PHI1 is a NaN' if ( isnan ( RHS_Z ( cc ))) stop 'RHS_Z1 is a NaN' if ( isnan ( RHS_PLL ( cc ))) stop 'RHS_PLL1 is a NaN' if ( isnan ( RHS_MU ( cc ))) stop 'RHS_MU1 is a NaN' end do !$OMP END SIMD !    write(output_unit_write,*) 'RHS_R: ',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI: ',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z: ',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL: ',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU: ',RHS_MU(1) end subroutine GCEoM1_m3dc1_p subroutine aux_fields ( pp , spp , gradB , curlb , Bmag ) TYPE ( SPECIES ), INTENT ( IN ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( 3 ), INTENT ( INOUT ) :: gradB REAL ( rp ), DIMENSION ( 3 ), INTENT ( INOUT ) :: curlb REAL ( rp ), INTENT ( IN ) :: Bmag REAL ( rp ) :: dRB REAL ( rp ) :: dPHIB REAL ( rp ) :: dZB INTEGER :: pp dRB = ( spp % vars % B ( pp , 1 ) * spp % vars % BR ( pp , 1 ) + & spp % vars % B ( pp , 2 ) * spp % vars % BPHI ( pp , 1 ) + & spp % vars % B ( pp , 3 ) * spp % vars % BZ ( pp , 1 )) / Bmag dPHIB = ( spp % vars % B ( pp , 1 ) * spp % vars % BR ( pp , 2 ) + & spp % vars % B ( pp , 2 ) * spp % vars % BPHI ( pp , 2 ) + & spp % vars % B ( pp , 3 ) * spp % vars % BZ ( pp , 2 )) / Bmag dZB = ( spp % vars % B ( pp , 1 ) * spp % vars % BR ( pp , 3 ) + & spp % vars % B ( pp , 2 ) * spp % vars % BPHI ( pp , 3 ) + & spp % vars % B ( pp , 3 ) * spp % vars % BZ ( pp , 3 )) / Bmag gradB ( 1 ) = dRB gradB ( 2 ) = dPHIB / spp % vars % Y ( pp , 1 ) gradB ( 3 ) = dZB curlb ( 1 ) = (( Bmag * spp % vars % BZ ( pp , 2 ) - spp % vars % B ( pp , 3 ) * dPHIB ) / spp % vars % Y ( pp , 1 ) - & ( Bmag * spp % vars % BPHI ( pp , 3 ) - spp % vars % B ( pp , 2 ) * dZB )) / Bmag ** 2 curlb ( 2 ) = (( Bmag * spp % vars % BR ( pp , 3 ) - spp % vars % B ( pp , 1 ) * dZB ) - & ( Bmag * spp % vars % BZ ( pp , 1 ) - spp % vars % B ( pp , 3 ) * dRB )) / Bmag ** 2 curlb ( 3 ) = (( Bmag * spp % vars % BPHI ( pp , 1 ) - spp % vars % B ( pp , 2 ) * dRB ) - & ( Bmag * spp % vars % BPHI ( pp , 1 ) - spp % vars % B ( pp , 1 ) * dPHIB ) / & spp % vars % Y ( pp , 1 )) / Bmag ** 2 + & spp % vars % B ( pp , 2 ) / ( Bmag * spp % vars % Y ( pp , 1 )) end subroutine aux_fields end module korc_ppusher","tags":"","loc":"sourcefile/korc_ppusher.f90.html"},{"title":"korc_interp.f90 – KORC-Full Orbit","text":"Contents Modules korc_interp Source Code korc_interp.f90 Source Code module korc_interp !! @note Module containing functions and subroutines for performing !! interpolations using the PSPLINE library. @endnote !! For a detailed documentation of the PSPLINE library we refer the !! user to \"https://w3.pppl.gov/ntcc/PSPLINE/\". use korc_types use korc_coords use korc_rnd_numbers use korc_hpc use EZspline_obj ! psplines module use EZspline ! psplines module #ifdef M3D_C1 use korc_m3d_c1 #endif !$ use OMP_LIB IMPLICIT NONE #ifdef DOUBLE_PRECISION TYPE , PRIVATE :: KORC_3D_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for !! cylindrical components of vector fields !! \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + F_\\phi\\hat{e}_phi + !! F_Z\\hat{e}_Z. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline3_r8 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: PHI !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both !! ends of the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_3D_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_2X1T_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for !! cylindrical components of vector fields !! \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + F_\\phi\\hat{e}_phi + !! F_Z\\hat{e}_Z. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline3_r8 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: T !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NT !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCST = ( / 0 , 0 / ) !! Periodic boundary condition for the interpolants at both !! ends of the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2X1T_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_2D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline2_r8 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline2_r8 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline2_r8 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2D_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_1D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline1_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline1_r8 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline1_r8 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline1_r8 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: Nrm !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSrm = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER :: NPSIP !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSPSIP = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. END TYPE KORC_1D_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_3D_PROFILES_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,\\phi,Z), !! temperature T_e(R,\\phi,Z), and effective charge number !! Z_{eff}(R,\\phi,Z) profiles. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: ne !! Interpolant of background electron density n_e(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Te !! Interpolant of background electron temperature T_e(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both ends of !! the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the Z direction. END TYPE KORC_3D_PROFILES_INTERPOLANT TYPE , PRIVATE :: KORC_2D_PROFILES_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,Z), temperature T_e(R,Z), and !! effective charge number Z_{eff}(R,Z) profiles. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r8 ) :: ne !! Interpolant of background electron density n_e(R,Z). TYPE ( EZspline2_r8 ) :: Te !! Interpolant of background electron temperature T_e(R,Z). TYPE ( EZspline2_r8 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2D_PROFILES_INTERPOLANT #elif SINGLE_PRECISION TYPE , PRIVATE :: KORC_3D_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for cylindrical !! components of vector fields \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + !! F_\\phi\\hat{e}_phi + F_Z\\hat{e}_Z. !! Real precision of 4 bytes. @endnote TYPE ( EZspline3_r4 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r4 ) :: PHI !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r4 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both ends of !! the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends of !! the Z direction. END TYPE KORC_3D_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_2X1T_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for cylindrical !! components of vector fields \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + !! F_\\phi\\hat{e}_phi + F_Z\\hat{e}_Z. !! Real precision of 4 bytes. @endnote TYPE ( EZspline3_r4 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r4 ) :: T !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r4 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NT !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCST = ( / 0 , 0 / ) !! Periodic boundary condition for the interpolants at both ends of !! the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends of !! the Z direction. END TYPE KORC_2X1T_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_2D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for cylindrical !! components of vector fields \\mathbf{F}(R,Z) = F_R\\hat{e}_R + !! F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 4 bytes. @endnote TYPE ( EZspline2_r4 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline2_r4 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline2_r4 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline2_r4 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the Z direction. END TYPE KORC_2D_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_1D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline1_r4 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline1_r4 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline1_r4 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline1_r4 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: Nrm !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSrm = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. END TYPE KORC_1D_FIELDS_INTERPOLANT TYPE , PRIVATE :: KORC_3D_PROFILES_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,\\phi,Z), !! temperature T_e(R,\\phi,Z), and effective charge number !! Z_{eff}(R,\\phi,Z) profiles. !! Real precision of 4 bytes. @endnote TYPE ( EZspline3_r4 ) :: ne !! Interpolant of background electron density n_e(R,\\phi,Z). TYPE ( EZspline3_r4 ) :: Te !! Interpolant of background electron temperature T_e(R,\\phi,Z). TYPE ( EZspline3_r4 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends of !! the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both ends of !! the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the Z direction. END TYPE KORC_3D_PROFILES_INTERPOLANT TYPE , PRIVATE :: KORC_2D_PROFILES_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of the density n_e(R,Z), !! temperature T_e(R,Z), and effective charge number Z_{eff}(R,Z) profiles. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r4 ) :: ne !! Interpolant of background electron density n_e(R,Z). TYPE ( EZspline2_r4 ) :: Te !! Interpolant of background electron temperature T_e(R,Z). TYPE ( EZspline2_r4 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the Z direction. END TYPE KORC_2D_PROFILES_INTERPOLANT #endif TYPE , PRIVATE :: KORC_INTERPOLANT_DOMAIN !! @note Derived type containing 2-D and 3-D arrays with the information of !! the spatial domain where the fields and profiles are known. !! This info is used for detecting when a particle is lost, and therefore not !! followed anymore. @endnote INTEGER ( KIND = 1 ), DIMENSION (:), ALLOCATABLE :: FLAG1D !! 2-D array with info of the spatial domain where the axisymmetric fields !! and plasma profiles are known. INTEGER ( KIND = 1 ), DIMENSION (:,:), ALLOCATABLE :: FLAG2D !! 2-D array with info of the spatial domain where the axisymmetric fields !! and plasma profiles are known. INTEGER ( KIND = 1 ), DIMENSION (:,:,:), ALLOCATABLE :: FLAG3D !! 3-D array with info of the spatial domain where the 3-D fields and plasma !! profiles are known. REAL ( rp ) :: Ro !! Smaller radial position of the fields and profiles domain. REAL ( rp ) :: Zo !! Smaller vertical position of the fields and profiles domain REAL ( rp ) :: To REAL ( rp ) :: Drm REAL ( rp ) :: DPSIP REAL ( rp ) :: DR !! Separation between grid points along the radial direction. REAL ( rp ) :: DPHI ! ! Separation between grid points along the azimuthal direction. REAL ( rp ) :: DT ! ! Separation between grid points along the azimuthal direction. REAL ( rp ) :: DZ !! Separation between grid points along the vertical direction. END TYPE KORC_INTERPOLANT_DOMAIN TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: bfield_2d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: bfield_3d !! An instance of KORC_3D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_2X1T_FIELDS_INTERPOLANT ), PRIVATE :: bfield_2X1T TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: dbdR_2d TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: dbdPHI_2d TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: dbdZ_2d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: dbdR_3d TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: dbdPHI_3d TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: dbdZ_3d !! An instance of KORC_3D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: efield_2d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the electric field. TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: efield_3d !! An instance of KORC_3D_FIELDS_INTERPOLANT for interpolating !! the electric field. TYPE ( KORC_1D_FIELDS_INTERPOLANT ), PRIVATE :: efield_SC1d !! An instance of KORC_1D_FIELDS_INTERPOLANT for interpolating !! the self-consistent electric field. TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: gradB_2d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_2D_FIELDS_INTERPOLANT ), PRIVATE :: curlb_2d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: gradB_3d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_3D_FIELDS_INTERPOLANT ), PRIVATE :: curlb_3d !! An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating !! the magnetic field. TYPE ( KORC_INTERPOLANT_DOMAIN ), PRIVATE :: fields_domain !! An instance of KORC_INTERPOLANT_DOMAIN used for interpolating fields. TYPE ( KORC_2D_PROFILES_INTERPOLANT ), PRIVATE :: profiles_2d !! An instance of KORC_2D_PROFILES_INTERPOLANT for interpolating plasma !! profiles. TYPE ( KORC_3D_PROFILES_INTERPOLANT ), PRIVATE :: profiles_3d !! An instance of KORC_3D_PROFILES_INTERPOLANT for interpolating plasma !! profiles. TYPE ( KORC_INTERPOLANT_DOMAIN ), PRIVATE :: profiles_domain !! An instance of KORC_INTERPOLANT_DOMAIN used for interpolating plasma !! profiles. INTEGER :: ezerr !! Error status during PSPLINE interpolations. PUBLIC :: interp_fields ,& interp_fields_p ,& interp_fields_3D_p ,& interp_FOfields_p ,& interp_FOfields1_p ,& interp_bmag_p ,& interp_collision_p ,& !       interp_fields_FO_p,& interp_profiles ,& initialize_fields_interpolant ,& initialize_profiles_interpolant ,& finalize_interpolants ,& calculate_initial_magnetic_field ,& calculate_magnetic_field_p ,& calculate_GCfields_p ,& calculate_GCfieldswE_p ,& calculate_GCfields_2x1t_p ,& calculate_GCfields_p_FS ,& calculate_2DBdBfields_p ,& calculate_3DBdBfields_p ,& calculate_3DBdBfields1_p ,& sample_poloidal_flux ,& initialize_SC1D_field_interpolant ,& add_interp_SCE_p ,& initialize_SC1D_field_interpolant_FS ,& add_interp_SCE_p_FS PRIVATE :: interp_3D_bfields ,& interp_2D_bfields ,& interp_3D_efields ,& interp_2D_efields ,& interp_2D_profiles ,& interp_3D_profiles ,& check_if_in_fields_domain ,& check_if_in_profiles_domain ,& check_if_in_profiles_domain_p ,& check_if_in_fields_domain_p ,& interp_2D_gradBfields ,& interp_2D_curlbfields ,& gradient_2D_Bfields CONTAINS subroutine initialize_fields_interpolant ( params , F ) !! @note Subroutine that initializes fields interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of fields in the KORC-dervied-type variable F. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. integer :: ii , jj if ((( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ). or . & ( params % field_eval . eq . 'interp' )). and . & (. not . params % field_model . eq . 'M3D_C1' )) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING FIELDS INTERPOLANT * * * *\")' ) end if ! * * * * * * * * MAGNETIC FIELD * * * * * * * * ! if ( F % Bflux . or . F % ReInterp_2x1t ) then if ( F % ReInterp_2x1t ) then if (. not .( EZspline_allocated ( bfield_2d % A ))) then bfield_2d % NR = F % dims ( 1 ) bfield_2d % NZ = F % dims ( 3 ) ! Initializing poloidal flux interpolant call EZspline_init ( bfield_2d % A , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % A % x1 = F % X % R bfield_2d % A % x2 = F % X % Z end if !write(output_unit_write,'(\"R\",E17.10)') F%X%R !write(output_unit_write,'(\"Z\",E17.10)') F%X%Z call EZspline_setup ( bfield_2d % A , F % PSIp3D (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) !write(output_unit_write,'(\"bfield_2d%A: \",E17.10)') bfield_2d%A%fspl(1,:,:) if (. not . ALLOCATED ( fields_domain % FLAG2D )) & ALLOCATE ( fields_domain % FLAG2D ( bfield_2d % NR , bfield_2d % NZ )) fields_domain % FLAG2D = F % FLAG3D (:, F % ind_2x1t ,:) fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) F % Bflux3D = . FALSE . else if ( EZspline_allocated ( bfield_2d % A )) & call Ezspline_free ( bfield_2d % A , ezerr ) bfield_2d % NR = F % dims ( 1 ) bfield_2d % NZ = F % dims ( 3 ) ! Initializing poloidal flux interpolant call EZspline_init ( bfield_2d % A , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % A % x1 = F % X % R bfield_2d % A % x2 = F % X % Z !write(output_unit_write,'(\"R\",E17.10)') F%X%R !write(output_unit_write,'(\"Z\",E17.10)') F%X%Z call EZspline_setup ( bfield_2d % A , F % PSIp , ezerr , . TRUE .) call EZspline_error ( ezerr ) !write(output_unit_write,'(\"bfield_2d%A: \",E17.10)') bfield_2d%A%fspl(1,:,:) if (. not . ALLOCATED ( fields_domain % FLAG2D )) & ALLOCATE ( fields_domain % FLAG2D ( bfield_2d % NR , bfield_2d % NZ )) fields_domain % FLAG2D = F % FLAG2D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) endif end if if ( F % Bflux3D ) then if ( F % Dim2x1t ) then bfield_2X1T % NR = F % dims ( 1 ) bfield_2X1T % NT = F % dims ( 2 ) bfield_2X1T % NZ = F % dims ( 3 ) call EZspline_init ( bfield_2X1T % A , bfield_2X1T % NR , bfield_2X1T % NT , & bfield_2X1T % NZ ,& bfield_2X1T % BCSR , bfield_2X1T % BCST , bfield_2X1T % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2X1T % A % x1 = F % X % R bfield_2X1T % A % x2 = F % X % PHI bfield_2X1T % A % x3 = F % X % Z !write(output_unit_write,*) F%X%PHI call EZspline_setup ( bfield_2X1T % A , F % PSIp3D , ezerr , . TRUE .) call EZspline_error ( ezerr ) if (. not . ALLOCATED ( fields_domain % FLAG3D )) & ALLOCATE ( fields_domain % FLAG3D ( bfield_2X1T % NR , bfield_2X1T % NT , & bfield_2X1T % NZ )) fields_domain % FLAG3D = F % FLAG3D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DT = ABS ( F % X % PHI ( 2 ) - F % X % PHI ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) fields_domain % To = F % X % PHI ( 1 ) else bfield_3d % NR = F % dims ( 1 ) bfield_3d % NPHI = F % dims ( 2 ) bfield_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( bfield_3d % A , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % A % x1 = F % X % R ! bfield_3d%R%x2 = F%X%PHI bfield_3d % A % x3 = F % X % Z call EZspline_setup ( bfield_3d % A , F % PSIp3D , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if end if if ( F % Bfield ) then if ( F % axisymmetric_fields ) then bfield_2d % NR = F % dims ( 1 ) bfield_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( bfield_2d % R , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % R % x1 = F % X % R bfield_2d % R % x2 = F % X % Z call EZspline_setup ( bfield_2d % R , F % B_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( bfield_2d % PHI , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % PHI % x1 = F % X % R bfield_2d % PHI % x2 = F % X % Z call EZspline_setup ( bfield_2d % PHI , F % B_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( bfield_2d % Z , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % Z % x1 = F % X % R bfield_2d % Z % x2 = F % X % Z call EZspline_setup ( bfield_2d % Z , F % B_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) !             do ii=1_idef,bfield_2d%PHI%n1 !                do jj=1_idef,bfield_2d%PHI%n2 !                   write(output_unit_write,'(\"BPHI_spline1 at R \",E17.10,\", Z \",E17.10,\": \",E17.10)') & !                        bfield_2d%PHI%x1(ii)*params%cpp%length, & !                        bfield_2d%PHI%x2(jj)*params%cpp%length, & !                        bfield_2d%PHI%fspl(1,ii,jj)*params%cpp%Bo !                end do !             end do if ( params % orbit_model . eq . 'GCpre' ) then gradB_2d % NR = F % dims ( 1 ) gradB_2d % NZ = F % dims ( 3 ) ! Initializing GRADBR component call EZspline_init ( gradB_2d % R , gradB_2d % NR , gradB_2d % NZ , & gradB_2d % BCSR , gradB_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_2d % R % x1 = F % X % R gradB_2d % R % x2 = F % X % Z call EZspline_setup ( gradB_2d % R , F % gradB_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBPHI component call EZspline_init ( gradB_2d % PHI , gradB_2d % NR , gradB_2d % NZ , & gradB_2d % BCSR , gradB_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_2d % PHI % x1 = F % X % R gradB_2d % PHI % x2 = F % X % Z call EZspline_setup ( gradB_2d % PHI , F % gradB_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBZ component call EZspline_init ( gradB_2d % Z , gradB_2d % NR , gradB_2d % NZ , & gradB_2d % BCSR , gradB_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_2d % Z % x1 = F % X % R gradB_2d % Z % x2 = F % X % Z call EZspline_setup ( gradB_2d % Z , F % gradB_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) curlb_2d % NR = F % dims ( 1 ) curlb_2d % NZ = F % dims ( 3 ) ! Initializing CURLBR component call EZspline_init ( curlb_2d % R , curlb_2d % NR , curlb_2d % NZ , & curlb_2d % BCSR , curlb_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_2d % R % x1 = F % X % R curlb_2d % R % x2 = F % X % Z call EZspline_setup ( curlb_2d % R , F % curlb_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBPHI component call EZspline_init ( curlb_2d % PHI , curlb_2d % NR , curlb_2d % NZ , & curlb_2d % BCSR , curlb_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_2d % PHI % x1 = F % X % R curlb_2d % PHI % x2 = F % X % Z call EZspline_setup ( curlb_2d % PHI , F % curlb_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBZ component call EZspline_init ( curlb_2d % Z , curlb_2d % NR , curlb_2d % NZ , & curlb_2d % BCSR , curlb_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_2d % Z % x1 = F % X % R curlb_2d % Z % x2 = F % X % Z call EZspline_setup ( curlb_2d % Z , F % curlb_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if if (. not . ALLOCATED ( fields_domain % FLAG2D )) & ALLOCATE ( fields_domain % FLAG2D ( bfield_2d % NR , bfield_2d % NZ )) fields_domain % FLAG2D = F % FLAG2D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) else bfield_3d % NR = F % dims ( 1 ) bfield_3d % NPHI = F % dims ( 2 ) bfield_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( bfield_3d % R , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % R % x1 = F % X % R bfield_3d % R % x2 = F % X % PHI bfield_3d % R % x3 = F % X % Z call EZspline_setup ( bfield_3d % R , F % B_3D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( bfield_3d % PHI , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % PHI % x1 = F % X % R bfield_3d % PHI % x2 = F % X % PHI bfield_3d % PHI % x3 = F % X % Z call EZspline_setup ( bfield_3d % PHI , F % B_3D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) !write(output_unit_write,*) bfield_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( bfield_3d % Z , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % Z % x1 = F % X % R bfield_3d % Z % x2 = F % X % PHI bfield_3d % Z % x3 = F % X % Z call EZspline_setup ( bfield_3d % Z , F % B_3D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) if ( params % orbit_model . eq . 'GCpre' ) then gradB_3d % NR = F % dims ( 1 ) gradB_3d % NPHI = F % dims ( 2 ) gradB_3d % NZ = F % dims ( 3 ) ! Initializing GRADBR component call EZspline_init ( gradB_3d % R , gradB_3d % NR , gradB_3d % NPHI ,& gradB_3d % NZ , gradB_3d % BCSR , gradB_3d % BCSPHI , & gradB_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_3d % R % x1 = F % X % R !gradB_3d%R%x2 = F%X%PHI gradB_3d % R % x3 = F % X % Z call EZspline_setup ( gradB_3d % R , F % gradB_3D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBPHI component call EZspline_init ( gradB_3d % PHI , gradB_3d % NR , gradB_3d % NPHI ,& gradB_3d % NZ , gradB_3d % BCSR , gradB_3d % BCSPHI , & gradB_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_3d % PHI % x1 = F % X % R !gradB_3d%PHI%x2 = F%X%PHI gradB_3d % PHI % x3 = F % X % Z call EZspline_setup ( gradB_3d % PHI , F % gradB_3D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBZ component call EZspline_init ( gradB_3d % Z , gradB_3d % NR , gradB_3d % NPHI ,& gradB_3d % NZ , gradB_3d % BCSR , gradB_3d % BCSPHI , & gradB_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_3d % Z % x1 = F % X % R !gradB_3d%Z%x2 = F%X%PHI gradB_3d % Z % x3 = F % X % Z call EZspline_setup ( gradB_3d % Z , F % gradB_3D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) curlb_3d % NR = F % dims ( 1 ) curlb_3d % NPHI = F % dims ( 2 ) curlb_3d % NZ = F % dims ( 3 ) ! Initializing CURLBR component call EZspline_init ( curlb_3d % R , curlb_3d % NR , curlb_3d % NPHI ,& curlb_3d % NZ , curlb_3d % BCSR , curlb_3d % BCSPHI , & curlb_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_3d % R % x1 = F % X % R !curlb_3d%R%x2 = F%X%PHI curlb_3d % R % x3 = F % X % Z call EZspline_setup ( curlb_3d % R , F % curlb_3D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBPHI component call EZspline_init ( curlb_3d % PHI , curlb_3d % NR , curlb_3d % NPHI ,& curlb_3d % NZ , curlb_3d % BCSR , curlb_3d % BCSPHI , & curlb_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_3d % PHI % x1 = F % X % R !curlb_3d%PHI%x2 = F%X%PHI curlb_3d % PHI % x3 = F % X % Z call EZspline_setup ( curlb_3d % PHI , F % curlb_3D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBZ component call EZspline_init ( curlb_3d % Z , curlb_3d % NR , curlb_3d % NPHI ,& curlb_3d % NZ , curlb_3d % BCSR , curlb_3d % BCSPHI , & curlb_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_3d % Z % x1 = F % X % R !curlb_3d%Z%x2 = F%X%PHI curlb_3d % Z % x3 = F % X % Z call EZspline_setup ( curlb_3d % Z , F % curlb_3D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if ALLOCATE ( fields_domain % FLAG3D ( bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ )) fields_domain % FLAG3D = F % FLAG3D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DPHI = 2.0_rp * C_PI / bfield_3d % NPHI fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) end if end if if ( F % dBfield ) then if ( F % axisymmetric_fields ) then ! dBdR dbdR_2d % NR = F % dims ( 1 ) dbdR_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( dbdR_2d % R , dbdR_2d % NR , dbdR_2d % NZ , & dbdR_2d % BCSR , dbdR_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_2d % R % x1 = F % X % R dbdR_2d % R % x2 = F % X % Z call EZspline_setup ( dbdR_2d % R , F % dBdR_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( dbdR_2d % PHI , dbdR_2d % NR , dbdR_2d % NZ , & dbdR_2d % BCSR , dbdR_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_2d % PHI % x1 = F % X % R dbdR_2d % PHI % x2 = F % X % Z call EZspline_setup ( dbdR_2d % PHI , F % dBdR_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( dbdR_2d % Z , dbdR_2d % NR , dbdR_2d % NZ , & dbdR_2d % BCSR , dbdR_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_2d % Z % x1 = F % X % R dbdR_2d % Z % x2 = F % X % Z call EZspline_setup ( dbdR_2d % Z , F % dBdR_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) !dBdPHI dbdPHI_2d % NR = F % dims ( 1 ) dbdPHI_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( dbdPHI_2d % R , dbdPHI_2d % NR , dbdPHI_2d % NZ , & dbdPHI_2d % BCSR , dbdPHI_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_2d % R % x1 = F % X % R dbdPHI_2d % R % x2 = F % X % Z call EZspline_setup ( dbdPHI_2d % R , F % dBdPHI_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( dbdPHI_2d % PHI , dbdPHI_2d % NR , dbdPHI_2d % NZ , & dbdPHI_2d % BCSR , dbdPHI_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_2d % PHI % x1 = F % X % R dbdPHI_2d % PHI % x2 = F % X % Z call EZspline_setup ( dbdPHI_2d % PHI , F % dBdPHI_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( dbdPHI_2d % Z , dbdPHI_2d % NR , dbdPHI_2d % NZ , & dbdPHI_2d % BCSR , dbdPHI_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_2d % Z % x1 = F % X % R dbdPHI_2d % Z % x2 = F % X % Z call EZspline_setup ( dbdPHI_2d % Z , F % dBdPHI_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) !dBdZ dbdZ_2d % NR = F % dims ( 1 ) dbdZ_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( dbdZ_2d % R , dbdZ_2d % NR , dbdZ_2d % NZ , & dbdZ_2d % BCSR , dbdZ_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_2d % R % x1 = F % X % R dbdZ_2d % R % x2 = F % X % Z call EZspline_setup ( dbdZ_2d % R , F % dBdZ_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( dbdZ_2d % PHI , dbdZ_2d % NR , dbdZ_2d % NZ , & dbdZ_2d % BCSR , dbdZ_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_2d % PHI % x1 = F % X % R dbdZ_2d % PHI % x2 = F % X % Z call EZspline_setup ( dbdZ_2d % PHI , F % dBdZ_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( dbdZ_2d % Z , dbdZ_2d % NR , dbdZ_2d % NZ , & dbdZ_2d % BCSR , dbdZ_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_2d % Z % x1 = F % X % R dbdZ_2d % Z % x2 = F % X % Z call EZspline_setup ( dbdZ_2d % Z , F % dBdZ_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) else ! dBdR dbdR_3d % NR = F % dims ( 1 ) dbdR_3d % NPHI = F % dims ( 2 ) dbdR_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( dbdR_3d % R , dbdR_3d % NR , dbdR_3d % NPHI , & dbdR_3d % NZ ,& dbdR_3d % BCSR , dbdR_3d % BCSPHI , dbdR_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_3d % R % x1 = F % X % R ! dbdR_3d%R%x2 = F%X%PHI dbdR_3d % R % x3 = F % X % Z call EZspline_setup ( dbdR_3d % R , F % dBdR_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( dbdR_3d % PHI , dbdR_3d % NR , dbdR_3d % NPHI , & dbdR_3d % NZ ,& dbdR_3d % BCSR , dbdR_3d % BCSPHI , dbdR_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_3d % PHI % x1 = F % X % R ! dbdR_3d%PHI%x2 = F%X%PHI dbdR_3d % PHI % x3 = F % X % Z call EZspline_setup ( dbdR_3d % PHI , F % dBdR_3D % PHI , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,*) dbdR_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( dbdR_3d % Z , dbdR_3d % NR , dbdR_3d % NPHI , & dbdR_3d % NZ ,& dbdR_3d % BCSR , dbdR_3d % BCSPHI , dbdR_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_3d % Z % x1 = F % X % R ! dbdR_3d%Z%x2 = F%X%PHI dbdR_3d % Z % x3 = F % X % Z call EZspline_setup ( dbdR_3d % Z , F % dBdR_3D % Z , ezerr ) call EZspline_error ( ezerr ) !dBdPHI dbdPHI_3d % NR = F % dims ( 1 ) dbdPHI_3d % NPHI = F % dims ( 2 ) dbdPHI_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( dbdPHI_3d % R , dbdPHI_3d % NR , dbdPHI_3d % NPHI , & dbdPHI_3d % NZ ,& dbdPHI_3d % BCSR , dbdPHI_3d % BCSPHI , dbdPHI_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_3d % R % x1 = F % X % R ! dbdPHI_3d%R%x2 = F%X%PHI dbdPHI_3d % R % x3 = F % X % Z call EZspline_setup ( dbdPHI_3d % R , F % dBdPHI_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( dbdPHI_3d % PHI , dbdPHI_3d % NR , dbdPHI_3d % NPHI , & dbdPHI_3d % NZ ,& dbdPHI_3d % BCSR , dbdPHI_3d % BCSPHI , dbdPHI_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_3d % PHI % x1 = F % X % R ! dbdPHI_3d%PHI%x2 = F%X%PHI dbdPHI_3d % PHI % x3 = F % X % Z call EZspline_setup ( dbdPHI_3d % PHI , F % dBdPHI_3D % PHI , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,*) dbdPHI_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( dbdPHI_3d % Z , dbdPHI_3d % NR , dbdPHI_3d % NPHI , & dbdPHI_3d % NZ ,& dbdPHI_3d % BCSR , dbdPHI_3d % BCSPHI , dbdPHI_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_3d % Z % x1 = F % X % R ! dbdPHI_3d%Z%x2 = F%X%PHI dbdPHI_3d % Z % x3 = F % X % Z call EZspline_setup ( dbdPHI_3d % Z , F % dBdPHI_3D % Z , ezerr ) call EZspline_error ( ezerr ) !dBdZ dbdZ_3d % NR = F % dims ( 1 ) dbdZ_3d % NPHI = F % dims ( 2 ) dbdZ_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( dbdZ_3d % R , dbdZ_3d % NR , dbdZ_3d % NPHI , & dbdZ_3d % NZ ,& dbdZ_3d % BCSR , dbdZ_3d % BCSPHI , dbdZ_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_3d % R % x1 = F % X % R ! dbdZ_3d%R%x2 = F%X%PHI dbdZ_3d % R % x3 = F % X % Z call EZspline_setup ( dbdZ_3d % R , F % dBdZ_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( dbdZ_3d % PHI , dbdZ_3d % NR , dbdZ_3d % NPHI , & dbdZ_3d % NZ ,& dbdZ_3d % BCSR , dbdZ_3d % BCSPHI , dbdZ_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_3d % PHI % x1 = F % X % R ! dbdZ_3d%PHI%x2 = F%X%PHI dbdZ_3d % PHI % x3 = F % X % Z call EZspline_setup ( dbdZ_3d % PHI , F % dBdZ_3D % PHI , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,*) dbdZ_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( dbdZ_3d % Z , dbdZ_3d % NR , dbdZ_3d % NPHI , & dbdZ_3d % NZ ,& dbdZ_3d % BCSR , dbdZ_3d % BCSPHI , dbdZ_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_3d % Z % x1 = F % X % R ! dbdZ_3d%Z%x2 = F%X%PHI dbdZ_3d % Z % x3 = F % X % Z call EZspline_setup ( dbdZ_3d % Z , F % dBdZ_3D % Z , ezerr ) call EZspline_error ( ezerr ) end if end if fields_domain % Ro = F % X % R ( 1 ) fields_domain % Zo = F % X % Z ( 1 ) ! * * * * * * * * ELECTRIC FIELD * * * * * * * * ! if ( F % Efield . AND .( params % field_eval . eq . 'interp' )) then if ( F % axisymmetric_fields ) then if ( F % ReInterp_2x1t ) then if (. not .( EZspline_allocated ( efield_2d % PHI ))) then efield_2d % NR = F % dims ( 1 ) efield_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( efield_2d % R , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % R % x1 = F % X % R efield_2d % R % x2 = F % X % Z ! Initializing PHI component call EZspline_init ( efield_2d % PHI , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % PHI % x1 = F % X % R efield_2d % PHI % x2 = F % X % Z ! Initializing Z component call EZspline_init ( efield_2d % Z , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % Z % x1 = F % X % R efield_2d % Z % x2 = F % X % Z end if call EZspline_setup ( efield_2d % R , F % E_3D % R (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) call EZspline_setup ( efield_2d % PHI , F % E_3D % PHI (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) call EZspline_setup ( efield_2d % Z , F % E_3D % Z (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) !                write(output_unit_write,'(\"efield_2d%PHI: \",E17.10)') efield_2d%PHI%fspl(1,:,:) else efield_2d % NR = F % dims ( 1 ) efield_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( efield_2d % R , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % R % x1 = F % X % R efield_2d % R % x2 = F % X % Z call EZspline_setup ( efield_2d % R , F % E_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( efield_2d % PHI , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % PHI % x1 = F % X % R efield_2d % PHI % x2 = F % X % Z call EZspline_setup ( efield_2d % PHI , F % E_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( efield_2d % Z , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % Z % x1 = F % X % R efield_2d % Z % x2 = F % X % Z call EZspline_setup ( efield_2d % Z , F % E_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if else efield_3d % NR = F % dims ( 1 ) efield_3d % NPHI = F % dims ( 2 ) efield_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( efield_3d % R , efield_3d % NR , efield_3d % NPHI , efield_3d % NZ ,& efield_3d % BCSR , efield_3d % BCSPHI , efield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_3d % R % x1 = F % X % R ! efield_3d%R%x2 = F%X%PHI efield_3d % R % x3 = F % X % Z call EZspline_setup ( efield_3d % R , F % E_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( efield_3d % PHI , efield_3d % NR , efield_3d % NPHI , & efield_3d % NZ , efield_3d % BCSR , efield_3d % BCSPHI , efield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_3d % PHI % x1 = F % X % R ! efield_3d%PHI%x2 = F%X%PHI efield_3d % PHI % x3 = F % X % Z call EZspline_setup ( efield_3d % PHI , F % E_3D % PHI , ezerr ) call EZspline_error ( ezerr ) ! Initializing Z component of interpolant call EZspline_init ( efield_3d % Z , efield_3d % NR , efield_3d % NPHI , efield_3d % NZ ,& efield_3d % BCSR , efield_3d % BCSPHI , efield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_3d % Z % x1 = F % X % R ! efield_3d%Z%x2 = F%X%PHI efield_3d % Z % x3 = F % X % Z call EZspline_setup ( efield_3d % Z , F % E_3D % Z , ezerr ) call EZspline_error ( ezerr ) end if end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * INTERPOLANT INITIALIZED * * * * * *\",/)' ) end if else if ( params % field_model ( 1 : 10 ) . EQ . 'ANALYTICAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * USING ANALYTICAL MAGNETIC FIELD * * * *\",/)' ) end if else if ( params % field_model . EQ . 'UNIFORM' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * USING UNIFORM MAGNETIC FIELD * * * *\",/)' ) end if end if end subroutine initialize_fields_interpolant subroutine initialize_SC1D_field_interpolant ( params , F ) !! @note Subroutine that initializes fields interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of fields in the KORC-dervied-type variable F. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. integer :: ii , jj !    if (EZspline_allocated(efield_SC1d%PHI)) & !         call Ezspline_free(efield_SC1d%PHI, ezerr) if (. not .( EZspline_allocated ( efield_SC1d % PHI ))) then efield_SC1d % Nrm = F % dim_1D call EZspline_init ( efield_SC1d % PHI , efield_SC1d % Nrm , & efield_SC1d % BCSrm , ezerr ) call EZspline_error ( ezerr ) efield_SC1d % PHI % x1 = F % r_1D / params % cpp % length end if call EZspline_setup ( efield_SC1d % PHI , F % E_SC_1D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) if (. not . ALLOCATED ( fields_domain % FLAG1D )) & ALLOCATE ( fields_domain % FLAG1D ( efield_SC1d % Nrm )) fields_domain % Drm = ABS ( F % r_1D ( 2 ) - F % r_1D ( 1 )) end subroutine initialize_SC1D_field_interpolant subroutine initialize_SC1D_field_interpolant_FS ( params , F ) !! @note Subroutine that initializes fields interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of fields in the KORC-dervied-type variable F. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. integer :: ii , jj !    if (EZspline_allocated(efield_SC1d%PHI)) & !         call Ezspline_free(efield_SC1d%PHI, ezerr) if (. not .( EZspline_allocated ( efield_SC1d % PHI ))) then efield_SC1d % NPSIP = F % dim_1D call EZspline_init ( efield_SC1d % PHI , efield_SC1d % NPSIP , & efield_SC1d % BCSPSIP , ezerr ) call EZspline_error ( ezerr ) efield_SC1d % PHI % x1 = F % PSIP_1D / ( params % cpp % Bo * params % cpp % length ** 2 ) end if call EZspline_setup ( efield_SC1d % PHI , F % E_SC_1D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) if (. not . ALLOCATED ( fields_domain % FLAG1D )) & ALLOCATE ( fields_domain % FLAG1D ( efield_SC1d % Nrm )) fields_domain % DPSIP = ABS ( F % PSIP_1D ( 2 ) - F % PSIP_1D ( 1 )) end subroutine initialize_SC1D_field_interpolant_FS subroutine check_if_in_fields_domain ( F , Y , flag ) !! @note Subrotuine that checks if particles in the simulation are within !! the spatial domain where interpolants and fields are known. @endnote !! External fields and interpolants can have different spatial domains where !! they are defined. Therefore, it is necessary to !! check if a given particle has left these spatial domains to stop !! following it, otherwise this will cause an error in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed in the !! simulation (flag=1), or not (flag=0). INTEGER :: IR !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the radial position of the particles. INTEGER :: IPHI !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the azimuthal position of the particles. INTEGER :: IZ !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the vertical position of the particles. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if !    write(output_unit_write,'(\"R: \",E15.10)') Y(1,1) !    write(output_unit_write,'(\"PHI: \",E15.10)') Y(2,1) !    write(output_unit_write,'(\"Z: \",E15.10)') Y(1,3) !    write(output_unit_write,*) 'Flag',flag(1) if ( ALLOCATED ( fields_domain % FLAG3D )) then if ( F % Dim2x1t ) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_2X1T) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( fields_domain % FLAG3D ( IR , 1 , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_2X1T % NR ). OR .( IZ . GT . bfield_2X1T % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IPHI,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_3d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y ( pp , 2 ) + 0.5_rp * fields_domain % DPHI ) / & fields_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( fields_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_3d % NR ). OR .( IZ . GT . bfield_3d % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if end do !$OMP END PARALLEL DO end if else if ( ALLOCATED ( fields_domain % FLAG2D )) then if ( F % Dim2x1t ) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_2d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( IR . lt . 0 ). or .( IZ . lt . 0 ). or .( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ )) then !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ if (( fields_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR .(( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ ))) then !write(output_unit_write,*) 'here' flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_2d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( IR . lt . 0 ). or .( IZ . lt . 0 ). or .( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ )) then !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if if (( fields_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR .(( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO endif end if end subroutine check_if_in_fields_domain subroutine check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag ) !! @note Subrotuine that checks if particles in the simulation are within !! the spatial domain where interpolants and fields are known. @endnote !! External fields and interpolants can have different spatial domains where !! they are defined. Therefore, it is necessary to !! check if a given particle has left these spatial domains to !! stop following it, otherwise this will cause an error in the simulation. INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed in the !! simulation (flag=1), or not (flag=0). INTEGER :: IR !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the radial position of the particles. INTEGER :: IPHI !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the azimuthal position of the particles. INTEGER :: IZ !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the vertical position of the particles. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Species iterator. !    write(output_unit_write,'(\"YR:\",E17.10)') Y_R !    write(output_unit_write,'(\"YPHI:\",E17.10)') Y_PHI !    write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z !    write(output_unit_write,'(\"Ro:\",E17.10)') fields_domain%Ro !    write(output_unit_write,'(\"Zo:\",E17.10)') fields_domain%Zo !    write(output_unit_write,'(\"DR:\",E17.10)') fields_domain%DR !    write(output_unit_write,'(\"DZ:\",E17.10)') fields_domain%DZ !    write(output_unit_write,'(\"DT:\",E17.10)') fields_domain%DT if ( ALLOCATED ( fields_domain % FLAG3D )) then if ( F % Dim2x1t ) then !$OMP SIMD !       !$OMP&  aligned(IR,IPHI,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - fields_domain % Ro + & 0.5_rp * fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y_PHI ( pp ) - fields_domain % To & + 0.5_rp * fields_domain % DT ) / fields_domain % DT ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( fields_domain % Zo ) + & 0.5_rp * fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) !             write(output_unit_write,'(\"IR: \",I16)') IR !             write(output_unit_write,'(\"IPHI: \",I16)') IPHI !             write(output_unit_write,'(\"IZ: \",I16)') IZ if (( fields_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_2X1T % NR ). OR .( IZ . GT . bfield_2X1T % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y_R(pp) !write(output_unit_write,'(\"YPHI:\",E17.10)') Y_PHI(pp) !write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z(pp) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"IZ: \",I16)') IZ !call KORC_ABORT() end if !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"flag: \",I16)') flag(pp) end do !$OMP END SIMD else !$OMP SIMD !       !$OMP&  aligned(IR,IPHI,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - fields_domain % Ro + & 0.5_rp * fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y_PHI ( pp ) + 0.5_rp * fields_domain % DPHI ) / & fields_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( fields_domain % Zo ) + & 0.5_rp * fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( fields_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_3d % NR ). OR .( IZ . GT . bfield_3d % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y_R !write(output_unit_write,'(\"YPHI:\",E17.10)') Y_PHI !write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"IZ: \",I16)') IZ !call KORC_ABORT() end if !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"flag: \",I16)') flag(pp) end do !$OMP END SIMD end if else if ( ALLOCATED ( fields_domain % FLAG2D )) then !$OMP SIMD !       !$OMP& aligned(IR,IZ) do pp = 1_idef , pchunk !write(output_unit_write,*) Y_R(pp),Y_Z(pp),fields_domain%Ro,fields_domain%DR,fields_domain%Zo,fields_domain%DZ IR = INT ( FLOOR (( Y_R ( pp ) - fields_domain % Ro + & 0.5_rp * fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( fields_domain % Zo ) + & 0.5_rp * fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) !          write(output_unit_write,*) pp !          write(output_unit_write,'(\"Size of fields_domain R: \",I16)') & !               size(fields_domain%FLAG2D,1) !          write(output_unit_write,'(\"Size of fields_domain Z: \",I16)') & !               size(fields_domain%FLAG2D,2) !          if ((IR.lt.0).or.(IZ.lt.0)) then !             write(output_unit_write,'(\"YR:\",E17.10)') Y_R(pp) !             write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z(pp) !             write(output_unit_write,'(\"IR: \",I16)') IR !             write(output_unit_write,'(\"IZ: \",I16)') IZ !          end if if (( fields_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ ))) then flag ( pp ) = 0_is !             write(output_unit_write,'(\"Shit''s fucked.\")') end if end do !$OMP END SIMD !       write(output_unit_write,'(\"Shit''s not fucked.\")') end if end subroutine check_if_in_fields_domain_p subroutine initialize_profiles_interpolant ( params , P ) !! @note Subroutine that initializes plasma profiles interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of plasma profiles in the KORC-dervied-type variable P. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! An instance of KORC's derived type PROFILES containing !! all the information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. !#ifdef M3D_C1 !    P%M3D_C1_ne = -1 !    P%M3D_C1_te = -1 !    P%M3D_C1_zeff = -1 !#endif if ( params % collisions ) then if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING PROFILES INTERPOLANT * * * *\")' ) end if if ( P % axisymmetric ) then profiles_2d % NR = P % dims ( 1 ) profiles_2d % NZ = P % dims ( 3 ) !             write(output_unit_write,'(\"NR\",I15)') profiles_2d%NR !             write(output_unit_write,'(\"NZ\",I15)') profiles_2d%NR ! Initializing ne !\t\t\tcall EZspline_init(profiles_2d%ne,profiles_2d%NR, & !profiles_2d%NZ,profiles_2d%BCSR,profiles_2d%BCSZ,ezerr) call EZspline_init ( profiles_2d % ne , profiles_2d % NR , profiles_2d % NZ , & profiles_2d % BCSR , profiles_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_2d % ne % x1 = P % X % R profiles_2d % ne % x2 = P % X % Z call EZspline_setup ( profiles_2d % ne , P % ne_2D , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Te !\t\t\tcall EZspline_init(profiles_2d%Te,profiles_2d%NR, & !profiles_2d%NZ,profiles_2d%BCSR,profiles_2d%BCSZ,ezerr) call EZspline_init ( profiles_2d % Te , profiles_2d % NR , profiles_2d % NZ , & profiles_2d % BCSR , profiles_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_2d % Te % x1 = P % X % R profiles_2d % Te % x2 = P % X % Z !             write(output_unit_write,'(\"Te_interp_R\",E17.10)') profiles_2d%Te%x1 !             write(output_unit_write,'(\"Te_interp_Z\",E17.10)') profiles_2d%Te%x2 !             write(output_unit_write,'(\"Te\",E17.10)') P%Te_2D(10,:) call EZspline_setup ( profiles_2d % Te , P % Te_2D , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Zeff !\t\t\tcall EZspline_init(profiles_2d%Zeff, & !profiles_2d%NR,profiles_2d%NZ,profiles_2d%BCSR,profiles_2d%BCSZ,ezerr) call EZspline_init ( profiles_2d % Zeff , profiles_2d % NR , & profiles_2d % NZ , profiles_2d % BCSR , profiles_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_2d % Zeff % x1 = P % X % R profiles_2d % Zeff % x2 = P % X % Z call EZspline_setup ( profiles_2d % Zeff , P % Zeff_2D , ezerr , . TRUE .) call EZspline_error ( ezerr ) ALLOCATE ( profiles_domain % FLAG2D ( profiles_2d % NR , profiles_2d % NZ )) profiles_domain % FLAG2D = P % FLAG2D profiles_domain % DR = ABS ( P % X % R ( 2 ) - P % X % R ( 1 )) profiles_domain % DZ = ABS ( P % X % Z ( 2 ) - P % X % Z ( 1 )) else profiles_3d % NR = P % dims ( 1 ) profiles_3d % NPHI = P % dims ( 2 ) profiles_3d % NZ = P % dims ( 3 ) ! Initializing ne call EZspline_init ( profiles_3d % ne , profiles_3d % NR , & profiles_3d % NPHI , profiles_3d % NZ ,& profiles_3d % BCSR , profiles_3d % BCSPHI , profiles_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_3d % ne % x1 = P % X % R ! profiles_3d%ne%x2 = P%X%PHI profiles_3d % ne % x3 = P % X % Z call EZspline_setup ( profiles_3d % ne , P % ne_3D , ezerr ) call EZspline_error ( ezerr ) ! Initializing Te call EZspline_init ( profiles_3d % Te , profiles_3d % NR , & profiles_3d % NPHI , profiles_3d % NZ ,& profiles_3d % BCSR , profiles_3d % BCSPHI , profiles_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_3d % Te % x1 = P % X % R ! profiles_3d%Te%x2 = P%X%PHI profiles_3d % Te % x3 = P % X % Z call EZspline_setup ( profiles_3d % Te , P % Te_3D , ezerr ) call EZspline_error ( ezerr ) ! Initializing Zeff call EZspline_init ( profiles_3d % Zeff , profiles_3d % NR , & profiles_3d % NPHI , profiles_3d % NZ ,& profiles_3d % BCSR , profiles_3d % BCSPHI , profiles_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_3d % Zeff % x1 = P % X % R ! profiles_3d%Zeff%x2 = P%X%PHI profiles_3d % Zeff % x3 = P % X % Z call EZspline_setup ( profiles_3d % Zeff , P % Zeff_3D , ezerr ) call EZspline_error ( ezerr ) ALLOCATE ( profiles_domain % FLAG3D ( profiles_3d % NR , profiles_3d % NPHI , & profiles_3d % NZ )) profiles_domain % FLAG3D = P % FLAG3D profiles_domain % DR = ABS ( P % X % R ( 2 ) - P % X % R ( 1 )) profiles_domain % DPHI = 2.0_rp * C_PI / profiles_3d % NPHI profiles_domain % DZ = ABS ( P % X % Z ( 2 ) - P % X % Z ( 1 )) end if profiles_domain % Ro = P % X % R ( 1 ) profiles_domain % Zo = P % X % Z ( 1 ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * INTERPOLANT   INITIALIZED * * * * * *\",/)' ) end if else if ( params % profile_model ( 1 : 10 ) . EQ . 'ANALYTICAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * USING ANALYTICAL PROFILES * * * *\",/)' ) end if else if ( params % profile_model . EQ . 'UNIFORM' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * UNIFORM PLASMA: NO PROFILES USED * * * *\",/)' ) end if end if end if end subroutine initialize_profiles_interpolant subroutine check_if_in_profiles_domain ( Y , flag ) !! @note Subrotuine that checks if particles in the simulation are !! within the spatial domain where interpolants and plasma profiles !! are known. @endnote !!External plasma profiles and interpolants can have different spatial !! domains where they are defined. Therefore, it is necessary to check !! if a given particle has left these spatial domains to stop following !! it, otherwise this will cause an error in the simulation. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed !! in the simulation (flag=1), or not (flag=0). INTEGER :: IR !! @param IR Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the radial position of the particles. INTEGER :: IPHI !! @param IPHI Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the azimuthal position of the particles. INTEGER :: IZ !! @param IZ Variable used to localize the grid cell in the !! (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the vertical position of the particles. INTEGER ( ip ) :: pp !! @param pp Particle iterator. INTEGER ( ip ) :: ss !! @param ss Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if if ( ALLOCATED ( profiles_domain % FLAG3D )) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IPHI,IZ) & !$OMP& SHARED(Y,flag,profiles_domain,profiles_3d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y ( pp , 2 ) + 0.5_rp * profiles_domain % DPHI ) / & profiles_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_3d % NR ). OR .( IZ . GT . profiles_3d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,profiles_domain,profiles_2d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_2d % NR ). OR .( IZ . GT . profiles_2d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO end if end subroutine check_if_in_profiles_domain subroutine check_if_in_profiles_domain_p ( pchunk , Y_R , Y_PHI , Y_Z , flag ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( 8 ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( 8 ), INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed !! in the simulation (flag=1), or not (flag=0). INTEGER :: IR !! @param IR Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the radial position of the particles. INTEGER :: IPHI !! @param IPHI Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the azimuthal position of the particles. INTEGER :: IZ !! @param IZ Variable used to localize the grid cell in the !! (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the vertical position of the particles. INTEGER ( ip ) :: pp !! @param pp Particle iterator. INTEGER ( ip ) :: ss !! @param ss Species iterator. if ( ALLOCATED ( profiles_domain % FLAG3D )) then !$OMP SIMD !       !$OMP& aligned(IR,IPHI,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y_PHI ( pp ) + 0.5_rp * profiles_domain % DPHI ) / & profiles_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_3d % NR ). OR .( IZ . GT . profiles_3d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END SIMD else !$OMP SIMD !       !$OMP& aligned(IR,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_2d % NR ). OR .( IZ . GT . profiles_2d % NZ ))) then flag ( pp ) = 0_is !             write(output_unit_write,'(\"Shit''s fucked.\")') end if end do !$OMP END SIMD !       write(output_unit_write,'(\"Shit''s not fucked.\")') end if end subroutine check_if_in_profiles_domain_p subroutine interp_2D_bfields ( params , Y , B , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric magnetic !! field to the particles' position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Cartesian components of interpolated magnetic field components. !! B(1,:)=B_x, B(2,:)=B_y, and B(3,:)=B_z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,B,flag,bfield_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( bfield_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( bfield_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( bfield_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then B ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = F ( pp , 3 ) else B ( pp , 1 ) = F ( pp , 1 ) B ( pp , 2 ) = F ( pp , 2 ) B ( pp , 3 ) = F ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_bfields subroutine gradient_2D_Bfields ( Y , BR , BPHI , BZ , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! gradient of the magnitude of themagnetic field to the particles' !! position. Stored as cylindrical components of field. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: BR !! Cylindrical components of gradient of R-component of magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: BPHI !! Cylindrical components of gradient of R-component of magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: BZ !! Cylindrical components of gradient of R-component of magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( 2 , ss )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(Y,BR,BPHI,BZ,flag,bfield_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_gradient ( bfield_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F (:, pp ), ezerr ) call EZspline_error ( ezerr ) BR ( pp , 1 ) = F ( pp , 1 ) BR ( pp , 2 ) = 0._rp BR ( pp , 3 ) = F ( pp , 2 ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_gradient ( bfield_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F (:, pp ), & ezerr ) call EZspline_error ( ezerr ) BPHI ( pp , 1 ) = F ( pp , 1 ) BPHI ( pp , 2 ) = 0._rp BPHI ( pp , 3 ) = F ( pp , 2 ) call EZspline_gradient ( bfield_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F (:, pp ), ezerr ) call EZspline_error ( ezerr ) BZ ( pp , 1 ) = F ( pp , 1 ) BZ ( pp , 2 ) = 0._rp BZ ( pp , 3 ) = F ( pp , 2 ) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine gradient_2D_Bfields subroutine interp_2D_gradBfields ( Y , gradB , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! gradient of the magnitude of themagnetic field to the particles' !! position. Stored as cylindrical components of field. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: gradB !! Cylindirical components of interpolated gradient of magnitude of !! magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,gradB,flag,gradB_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( gradB_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( gradB_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( gradB_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"PS R-gradB \",E17.10)') F(pp,1) !        write(output_unit_write,'(\"PS PHI-gradB \",E17.10)') F(pp,2) !        write(output_unit_write,'(\"PS Z-gradB \",E17.10)') F(pp,3) gradB ( pp , 1 ) = F ( pp , 1 ) gradB ( pp , 2 ) = F ( pp , 2 ) gradB ( pp , 3 ) = F ( pp , 3 ) !        write(output_unit_write,'(\"PHI-gradB \",E17.10)') gradB(2,1) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_gradBfields subroutine interp_2D_curlbfields ( Y , curlb , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! curl of the magnetic field unit vector to the particles' !! position. Stored as cylindrical components of field. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: curlb !! Cylindirical components of interpolated curl of direction of !! magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,curlb,flag,curlb_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( curlb_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( curlb_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( curlb_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) curlb ( pp , 1 ) = F ( pp , 1 ) curlb ( pp , 2 ) = F ( pp , 2 ) curlb ( pp , 3 ) = F ( pp , 3 ) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_curlbfields subroutine interp_FOfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( pchunk ) :: B_R , B_PHI REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: E_R , E_PHI REAL ( rp ), DIMENSION ( pchunk ) :: cP , sP !  INTEGER(ip) :: ezerr INTEGER :: cc !! Particle chunk iterator. INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % A , pchunk , Y_R , Y_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , efield_2d % R , & efield_2d % PHI , efield_2d % Z , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD !  !$OMP& aligned (cP,sP,B_X,B_Y,E_X,E_Y,Y_PHI,B_R,B_PHI,E_R,E_PHI) do cc = 1_idef , pchunk cP ( cc ) = cos ( Y_PHI ( cc )) sP ( cc ) = sin ( Y_PHI ( cc )) B_X ( cc ) = B_R ( cc ) * cP ( cc ) - B_PHI ( cc ) * sP ( cc ) B_Y ( cc ) = B_R ( cc ) * sP ( cc ) + B_PHI ( cc ) * cP ( cc ) E_X ( cc ) = E_R ( cc ) * cP ( cc ) - E_PHI ( cc ) * sP ( cc ) E_Y ( cc ) = E_R ( cc ) * sP ( cc ) + E_PHI ( cc ) * cP ( cc ) end do !$OMP END SIMD end subroutine interp_FOfields_p subroutine interp_FOfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , PSIp , & flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( pchunk ) :: B_R , B_PHI REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: E_R , E_PHI REAL ( rp ), DIMENSION ( pchunk ) :: cP , sP !  INTEGER(ip) :: ezerr INTEGER :: cc !! Particle chunk iterator. INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % A , pchunk , Y_R , Y_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) call calculate_magnetic_field_p ( pchunk , F , Y_R , Y_Z , B_R , B_PHI , B_Z ) call EZspline_interp ( efield_2d % R , efield_2d % PHI , efield_2d % Z , pchunk , Y_R , Y_Z , & E_R , E_PHI , E_Z , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD !  !$OMP& aligned (cP,sP,B_X,B_Y,E_X,E_Y,Y_PHI,B_R,B_PHI,E_R,E_PHI) do cc = 1_idef , pchunk cP ( cc ) = cos ( Y_PHI ( cc )) sP ( cc ) = sin ( Y_PHI ( cc )) B_X ( cc ) = B_R ( cc ) * cP ( cc ) - B_PHI ( cc ) * sP ( cc ) B_Y ( cc ) = B_R ( cc ) * sP ( cc ) + B_PHI ( cc ) * cP ( cc ) E_X ( cc ) = E_R ( cc ) * cP ( cc ) - E_PHI ( cc ) * sP ( cc ) E_Y ( cc ) = E_R ( cc ) * sP ( cc ) + E_PHI ( cc ) * cP ( cc ) end do !$OMP END SIMD end subroutine interp_FOfields1_p subroutine interp_FOcollision_p ( pchunk , Y_R , Y_PHI , Y_Z , ne , Te , Zeff , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_profiles_domain_p ( pchunk , Y_R , Y_PHI , Y_Z , flag_cache ) !  write(output_unit_write,'(\"YR: \",E17.10)') Y_R(1) !  write(output_unit_write,'(\"YPHI: \",E17.10)') Y_PHI(1) !  write(output_unit_write,'(\"YZ: \",E17.10)') Y_Z(1) !  write(output_unit_write,'(\"Te_interp_R\",E17.10)') profiles_2d%Te%x1 !  write(output_unit_write,'(\"Te_interp_Z\",E17.10)') profiles_2d%Te%x2 call EZspline_interp ( profiles_2d % ne , profiles_2d % Te , & profiles_2d % Zeff , pchunk , Y_R , Y_Z , ne , Te , Zeff , ezerr ) ! this will call PSPLINE routine EZspline_interp2_bmag_cloud_r8 as there ! is the same number of entries call EZspline_error ( ezerr ) end subroutine interp_FOcollision_p subroutine interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlB_R , curlB_PHI , curlB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache !write(output_unit_write,*) Y_R,Y_Z,flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , efield_2d % R , & efield_2d % PHI , efield_2d % Z , gradB_2d % R , gradB_2d % PHI , gradB_2d % Z , & curlb_2d % R , curlb_2d % PHI , curlb_2d % Z , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , gradB_R , gradB_PHI , gradB_Z , curlb_R , curlb_PHI , curlb_Z , & ezerr ) call EZspline_error ( ezerr ) end subroutine interp_fields_p subroutine interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlB_R , curlB_PHI , curlB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache REAL ( rp ), DIMENSION ( pchunk ) :: Y_PHI_mod Y_PHI_mod = modulo ( Y_PHI , 2._rp * C_PI ) !  write(output_unit_write,*) Y_PHI(1) !  write(output_unit_write,*) Y_PHI_mod(1) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI_mod , Y_Z , flag_cache ) call EZspline_interp ( bfield_3d % R , bfield_3d % PHI , bfield_3d % Z , efield_3d % R , & efield_3d % PHI , efield_3d % Z , gradB_3d % R , gradB_3d % PHI , gradB_3d % Z , & curlb_3d % R , curlb_3d % PHI , curlb_3d % Z , pchunk , Y_R , Y_PHI_mod , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , gradB_R , gradB_PHI , gradB_Z , curlb_R , curlb_PHI , curlb_Z , & ezerr ) call EZspline_error ( ezerr ) end subroutine interp_fields_3D_p subroutine interp_collision_p ( pchunk , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & ne , Te , Zeff , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache !  INTEGER(ip) :: ezerr call check_if_in_profiles_domain_p ( pchunk , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , efield_2d % R , & efield_2d % PHI , efield_2d % Z , profiles_2d % ne , profiles_2d % Te , & profiles_2d % Zeff , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , ne , Te , Zeff , ezerr ) call EZspline_error ( ezerr ) end subroutine interp_collision_p subroutine interp_bmag_p ( pchunk , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z !  INTEGER(ip) :: ezerr call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , & pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , ezerr ) call EZspline_error ( ezerr ) end subroutine interp_bmag_p !> @brief Subroutine for interpolating the pre-computed, 3-D magnetic field to the particles' position. !! !! @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. !! @param[in,out] B Cartesian components of interpolated magnetic field components. B(1,:)=B_x, B(2,:)=B_y, and B(3,:)=B_z. !! @param F Cylindrical components of interpolated magnetic field components. F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. !! @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0). !! @param pp Particle iterator. !! @param ss Species iterator. subroutine interp_3D_bfields ( params , Y , B , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag INTEGER :: pp INTEGER :: ss ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,B,flag,bfield_3d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( bfield_3d % R , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( bfield_3d % PHI , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( bfield_3d % Z , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then B ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = F ( pp , 3 ) else B ( pp , 1 ) = F ( pp , 1 ) B ( pp , 2 ) = F ( pp , 2 ) B ( pp , 3 ) = F ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_3D_bfields !> @brief Subroutine that calculates the axisymmetric magnetic field to the particles' position using the poloidal magnetic flux. !! @details When the poloidal magnetic flux \\Psi(R,Z) is used in a KORC simulation, the magnetic field components are calculated as it follows: !! !! !! B_R = \\frac{1}{R}\\frac{\\partial \\Psi}{\\partial Z}, !! B_\\phi = \\frac{RoBo}{R}, !! B_Z = -\\frac{1}{R}\\frac{\\partial \\Psi}{\\partial R}, !! !! !! where Ro and Bo are the radial position of the magnetic axis and the magnetic field as measured at the magnetic axis, respectively. !! First, the derivatives of the poloidal magnetic flux are calculated at the particles' position using the PSPLINE interpolant of !! the poloidal magnetic flux. Then, we calculate the cylindrical components of the magnetic field, and finally we calculate its Cartesian !! components that will be used in the particle pusher. !! !! @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. !! @param[in] F An instance of KORC's derived type FIELDS containing all the information about the fields used in the simulation. !! See korc_types.f90 and korc_fields.f90. !! @param[in,out] B Cartesian components of interpolated magnetic field components. B(1,:)=B_x, B(2,:)=B_y, and B(3,:)=B_x. !! @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0). !! @param A Variable containing the partial derivatives of the poloidal magnetic flux \\Psi(R,Z) and the cylindrical components !! of the magnetic field (its value changes through the subroutine). !! @param pp Particle iterator. !! @param ss Species iterator. subroutine calculate_magnetic_field ( params , Y , F , B , E , PSI_P , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: PSI_P INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: A INTEGER :: pp INTEGER :: ss if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if ALLOCATE ( A ( ss , 3 )) A = 0._rp if ( F % Dim2x1t . and .(. not . F % ReInterp_2x1t )) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,A,B,flag,bfield_2X1T,PSI_P) do pp = 1_idef , ss !        write(output_unit_write,'(\"pp: \",I16)') pp !        write(output_unit_write,'(\"Y_R: \",E17.10)') Y(:,1) !      write(output_unit_write,'(\"Y_PHI: \",E17.10)') Y(:,2) !      write(output_unit_write,'(\"Y_Z: \",E17.10)') Y(:,3) call EZspline_interp ( bfield_2X1T % A , Y ( pp , 1 ), F % t0_2x1t , Y ( pp , 3 ), & PSI_P ( pp ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"PSI_P: \",E17.10)') PSI_P(1) ! FR = (dA/dZ)/R call EZspline_derivative ( bfield_2X1T % A , 0 , 0 , 1 , Y ( pp , 1 ), F % t0_2x1t , & Y ( pp , 3 ), A ( pp , 1 ), ezerr ) !\t\t\tcall EZspline_error(ezerr) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is else !           write(output_unit_write,'(\"R*B_R: \",E17.10)') A(pp,1) !if(params%SC_E) A(pp,1)=A(pp,1)/(2*C_PI) A ( pp , 1 ) = A ( pp , 1 ) / Y ( pp , 1 ) ! FPHI = Fo*Ro/R A ( pp , 2 ) = - F % Bo * F % Ro / Y ( pp , 1 ) ! FR = -(dA/dR)/R call EZspline_derivative ( bfield_2X1T % A , 1 , 0 , 0 , Y ( pp , 1 ), & F % t0_2x1t , Y ( pp , 3 ), A ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) !           write(output_unit_write,'(\"R*B_Z: \",E17.10)') A(pp,3) !if(params%SC_E) A(pp,3)=A(pp,3)/(2*C_PI) call EZspline_derivative ( bfield_2X1T % A , 0 , 1 , 0 , Y ( pp , 1 ), & F % t0_2x1t , Y ( pp , 3 ), E ( pp , 2 ), ezerr ) E ( pp , 2 ) = E ( pp , 2 ) / ( 2 * C_PI * Y ( pp , 1 )) A ( pp , 3 ) = - A ( pp , 3 ) / Y ( pp , 1 ) if (. not . params % GC_coords ) then B ( pp , 1 ) = A ( pp , 1 ) * COS ( Y ( pp , 2 )) - A ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = A ( pp , 1 ) * SIN ( Y ( pp , 2 )) + A ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = A ( pp , 3 ) E ( pp , 1 ) = - E ( pp , 2 ) * sin ( Y ( pp , 2 )) E ( pp , 2 ) = E ( pp , 2 ) * cos ( Y ( pp , 2 )) else B ( pp , 1 ) = A ( pp , 1 ) B ( pp , 2 ) = A ( pp , 2 ) B ( pp , 3 ) = A ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,A,B,flag,bfield_2d,PSI_P) do pp = 1_idef , ss !        write(output_unit_write,'(\"pp: \",I16)') pp !        write(output_unit_write,'(\"Y_R: \",E17.10)') Y(:,1) !      write(output_unit_write,'(\"Y_PHI: \",E17.10)') Y(:,2) !      write(output_unit_write,'(\"Y_Z: \",E17.10)') Y(:,3) call EZspline_interp ( bfield_2d % A , Y ( pp , 1 ), Y ( pp , 3 ), & PSI_P ( pp ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"PSI_P: \",E17.10)') PSI_P(1) ! FR = (dA/dZ)/R call EZspline_derivative ( bfield_2d % A , 0 , 1 , Y ( pp , 1 ), Y ( pp , 3 ), & A ( pp , 1 ), ezerr ) !\t\t\tcall EZspline_error(ezerr) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is else !           write(output_unit_write,'(\"R*B_R: \",E17.10)') A(pp,1) !if(params%SC_E) A(pp,1)=A(pp,1)/(2*C_PI) A ( pp , 1 ) = A ( pp , 1 ) / Y ( pp , 1 ) ! FPHI = Fo*Ro/R A ( pp , 2 ) = - F % Bo * F % Ro / Y ( pp , 1 ) ! FR = -(dA/dR)/R call EZspline_derivative ( bfield_2d % A , 1 , 0 , Y ( pp , 1 ), Y ( pp , 3 ), & A ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) !           write(output_unit_write,'(\"R*B_Z: \",E17.10)') A(pp,3) !if(params%SC_E) A(pp,3)=A(pp,3)/(2*C_PI) A ( pp , 3 ) = - A ( pp , 3 ) / Y ( pp , 1 ) if (. not . params % GC_coords ) then B ( pp , 1 ) = A ( pp , 1 ) * COS ( Y ( pp , 2 )) - A ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = A ( pp , 1 ) * SIN ( Y ( pp , 2 )) + A ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = A ( pp , 3 ) else B ( pp , 1 ) = A ( pp , 1 ) B ( pp , 2 ) = A ( pp , 2 ) B ( pp , 3 ) = A ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO end if !  write(output_unit_write,'(\"calculate_fields\")') !  write(output_unit_write,'(\"B_R: \",E17.10)') A(:,1) !  write(output_unit_write,'(\"B_PHI: \",E17.10)') A(:,2) !  write(output_unit_write,'(\"B_Z: \",E17.10)') A(:,3) !  write(output_unit_write,'(\"B_X: \",E17.10)') B(:,1) !  write(output_unit_write,'(\"B_Y: \",E17.10)') B(:,2) !  write(output_unit_write,'(\"B_Z: \",E17.10)') B(:,3) DEALLOCATE ( A ) end subroutine calculate_magnetic_field subroutine calculate_magnetic_field_p ( pchunk , F , Y_R , Y_Z , B_R , B_PHI , B_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z INTEGER :: pp REAL ( rp ), DIMENSION ( pchunk ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 2 ) :: A call EZspline_interp ( bfield_2d % A , pchunk , Y_R , Y_Z , & PSIp , ezerr ) call EZspline_error ( ezerr ) ! FR = (dA/dZ)/R call EZspline_gradient ( bfield_2d % A , pchunk , Y_R , Y_Z , & A , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,'(\"dPSIp/dR: \",E17.10)') A(:,1) !write(output_unit_write,'(\"dPSIp/dZ: \",E17.10)') A(:,2) !write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R B_R = A (:, 2 ) / Y_R ! FPHI = Fo*Ro/R B_PHI = - F % Bo * F % Ro / Y_R ! FR = -(dA/dR)/R !     write(output_unit_write,'(\"R*B_Z: \",E17.10)') B_Z(1) B_Z = - A (:, 1 ) / Y_R !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R(1) !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z(1) !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHI: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_magnetic_field_p subroutine calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk , 3 ) :: BR , BPHI , BZ REAL ( rp ), DIMENSION ( pchunk ) :: dBRdR , dBPHIdR , dBZdR REAL ( rp ), DIMENSION ( pchunk ) :: dBRdPHI , dBPHIdPHI , dBZdPHI REAL ( rp ), DIMENSION ( pchunk ) :: dBRdZ , dBPHIdZ , dBZdZ REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , & efield_2d % R , efield_2d % PHI , efield_2d % Z , bfield_2d % A , & pchunk , Y_R , Y_Z , BR , BPHI , BZ , E_R , E_PHI , E_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) !  call EZspline_interp(bfield_2d%R,bfield_2d%PHI,bfield_2d%Z, & !       dbdR_2d%R,dbdR_2d%PHI,dBdR_2d%Z, & !       dbdPHI_2d%R,dbdPHI_2d%PHI,dbdPHI_2d%Z, & !       dbdZ_2d%R,dbdZ_2d%PHI,dbdZ_2d%Z, & !       efield_2d%R,efield_2d%PHI,efield_2d%Z,8,Y_R,Y_Z,B_R,B_PHI,B_Z, & !       dBRdR,dBPHIdR,dBZdR,dBRdPHI,dBPHIdPHI,dBZdPHI,dBRdZ,dBPHIdZ,dBZdZ, & !       E_R,E_PHI,E_Z,ezerr) !  call EZspline_error(ezerr) !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk B_R ( cc ) = BR ( cc , 1 ) B_PHI ( cc ) = BPHI ( cc , 1 ) B_Z ( cc ) = BZ ( cc , 1 ) dBRdR ( cc ) = BR ( cc , 2 ) dBRdPHI ( cc ) = 0._rp dBRdZ ( cc ) = BR ( cc , 3 ) dBPHIdR ( cc ) = BPHI ( cc , 2 ) dBPHIdPHI ( cc ) = 0._rp dBPHIdZ ( cc ) = BPHI ( cc , 3 ) dBZdR ( cc ) = BZ ( cc , 2 ) dBZdPHI ( cc ) = 0._rp dBZdZ ( cc ) = BZ ( cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dBRdR ( cc ) + B_PHI ( cc ) * dBPHIdR ( cc ) + & B_Z ( cc ) * dBZdR ( cc )) / Bmag ( cc ) gradB_PHI ( cc ) = ( B_R ( cc ) * dBRdPHI ( cc ) + B_PHI ( cc ) * dBPHIdPHI ( cc ) + & B_Z ( cc ) * dBZdPHI ( cc )) / ( Y_R ( cc ) * Bmag ( cc )) gradB_Z ( cc ) = ( B_R ( cc ) * dBRdZ ( cc ) + B_PHI ( cc ) * dBPHIdZ ( cc ) + & B_Z ( cc ) * dBZdZ ( cc )) / Bmag ( cc ) curlb_R ( cc ) = ( Bmag ( cc ) * dBZdPHI ( cc ) / Y_R ( cc ) - B_Z ( cc ) * gradB_PHI ( cc ) - & Bmag ( cc ) * dBPHIdZ ( cc ) + B_PHI ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) * dBRdZ ( cc ) - B_R ( cc ) * gradB_Z ( cc ) - & Bmag ( cc ) * dBZdR ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * bmag ( cc )) curlb_Z ( cc ) = ( Bmag ( cc ) * B_PHI ( cc ) / Y_R ( cc ) + Bmag ( cc ) * dBPHIdR ( cc ) - & B_PHI ( cc ) * gradB_R ( cc ) - Bmag ( cc ) * dBRdPHI ( cc ) / Y_R ( cc ) + & B_R ( cc ) * gradB_PHI ( cc )) / ( Bmag ( cc ) * bmag ( cc )) end do !$OMP END SIMD !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHIinterp: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_2DBdBfields_p subroutine calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z real ( rp ), DIMENSION ( pchunk ) :: Y_PHI_mod TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ) :: dBRdR , dBPHIdR , dBZdR REAL ( rp ), DIMENSION ( pchunk ) :: dBRdPHI , dBPHIdPHI , dBZdPHI REAL ( rp ), DIMENSION ( pchunk ) :: dBRdZ , dBPHIdZ , dBZdZ REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache Y_PHI_mod = modulo ( Y_PHI , 2._rp * C_PI ) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI_mod , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , & dbdR_2d % R , dbdR_2d % PHI , dBdR_2d % Z , & dbdPHI_2d % R , dbdPHI_2d % PHI , dbdPHI_2d % Z , & dbdZ_2d % R , dbdZ_2d % PHI , dbdZ_2d % Z , & efield_2d % R , efield_2d % PHI , efield_2d % Z , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & dBRdR , dBPHIdR , dBZdR , dBRdPHI , dBPHIdPHI , dBZdPHI , dBRdZ , dBPHIdZ , dBZdZ , & E_R , E_PHI , E_Z , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dBRdR ( cc ) + B_PHI ( cc ) * dBPHIdR ( cc ) + & B_Z ( cc ) * dBZdR ( cc )) / Bmag ( cc ) gradB_PHI ( cc ) = ( B_R ( cc ) * dBRdPHI ( cc ) + B_PHI ( cc ) * dBPHIdPHI ( cc ) + & B_Z ( cc ) * dBZdPHI ( cc )) / ( Y_R ( cc ) * Bmag ( cc )) gradB_Z ( cc ) = ( B_R ( cc ) * dBRdZ ( cc ) + B_PHI ( cc ) * dBPHIdZ ( cc ) + & B_Z ( cc ) * dBZdZ ( cc )) / Bmag ( cc ) curlb_R ( cc ) = ( Bmag ( cc ) * dBZdPHI ( cc ) / Y_R ( cc ) - B_Z ( cc ) * gradB_PHI ( cc ) - & Bmag ( cc ) * dBPHIdZ ( cc ) + B_PHI ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) * dBRdZ ( cc ) - B_R ( cc ) * gradB_Z ( cc ) - & Bmag ( cc ) * dBZdR ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) = ( Bmag ( cc ) * B_PHI ( cc ) / Y_R ( cc ) + Bmag ( cc ) * dBPHIdR ( cc ) - & B_PHI ( cc ) * gradB_R ( cc ) - Bmag ( cc ) * dBRdPHI ( cc ) / Y_R ( cc ) + & B_R ( cc ) * gradB_PHI ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) end do !$OMP END SIMD !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHIinterp: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_3DBdBfields_p subroutine calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z real ( rp ), DIMENSION ( pchunk ) :: Y_PHI_mod TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk , 4 ) :: BR , BPHI , BZ REAL ( rp ), DIMENSION ( pchunk ) :: dBRdR , dBPHIdR , dBZdR REAL ( rp ), DIMENSION ( pchunk ) :: dBRdPHI , dBPHIdPHI , dBZdPHI REAL ( rp ), DIMENSION ( pchunk ) :: dBRdZ , dBPHIdZ , dBZdZ REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache Y_PHI_mod = modulo ( Y_PHI , 2._rp * C_PI ) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI_mod , Y_Z , flag_cache ) call EZspline_interp ( bfield_3d % R , bfield_3d % PHI , bfield_3d % Z , & efield_3d % R , efield_3d % PHI , efield_3d % Z , bfield_3d % A , & pchunk , Y_R , Y_PHI_mod , Y_Z , BR , BPHI , BZ , E_R , E_PHI , E_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) !  call EZspline_interp(bfield_2d%R,bfield_2d%PHI,bfield_2d%Z, & !       dbdR_2d%R,dbdR_2d%PHI,dBdR_2d%Z, & !       dbdPHI_2d%R,dbdPHI_2d%PHI,dbdPHI_2d%Z, & !       dbdZ_2d%R,dbdZ_2d%PHI,dbdZ_2d%Z, & !       efield_2d%R,efield_2d%PHI,efield_2d%Z,8,Y_R,Y_Z,B_R,B_PHI,B_Z, & !       dBRdR,dBPHIdR,dBZdR,dBRdPHI,dBPHIdPHI,dBZdPHI,dBRdZ,dBPHIdZ,dBZdZ, & !       E_R,E_PHI,E_Z,ezerr) !  call EZspline_error(ezerr) !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk B_R ( cc ) = BR ( cc , 1 ) B_PHI ( cc ) = BPHI ( cc , 1 ) B_Z ( cc ) = BZ ( cc , 1 ) dBRdR ( cc ) = BR ( cc , 2 ) dBRdPHI ( cc ) = BR ( cc , 3 ) dBRdZ ( cc ) = BR ( cc , 4 ) dBPHIdR ( cc ) = BPHI ( cc , 2 ) dBPHIdPHI ( cc ) = BPHI ( cc , 3 ) dBPHIdZ ( cc ) = BPHI ( cc , 4 ) dBZdR ( cc ) = BZ ( cc , 2 ) dBZdPHI ( cc ) = BZ ( cc , 3 ) dBZdZ ( cc ) = BZ ( cc , 4 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dBRdR ( cc ) + B_PHI ( cc ) * dBPHIdR ( cc ) + & B_Z ( cc ) * dBZdR ( cc )) / Bmag ( cc ) gradB_PHI ( cc ) = ( B_R ( cc ) * dBRdPHI ( cc ) + B_PHI ( cc ) * dBPHIdPHI ( cc ) + & B_Z ( cc ) * dBZdPHI ( cc )) / ( Y_R ( cc ) * Bmag ( cc )) gradB_Z ( cc ) = ( B_R ( cc ) * dBRdZ ( cc ) + B_PHI ( cc ) * dBPHIdZ ( cc ) + & B_Z ( cc ) * dBZdZ ( cc )) / Bmag ( cc ) curlb_R ( cc ) = ( Bmag ( cc ) * dBZdPHI ( cc ) / Y_R ( cc ) - B_Z ( cc ) * gradB_PHI ( cc ) - & Bmag ( cc ) * dBPHIdZ ( cc ) + B_PHI ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) * dBRdZ ( cc ) - B_R ( cc ) * gradB_Z ( cc ) - & Bmag ( cc ) * dBZdR ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) = ( Bmag ( cc ) * B_PHI ( cc ) / Y_R ( cc ) + Bmag ( cc ) * dBPHIdR ( cc ) - & B_PHI ( cc ) * gradB_R ( cc ) - Bmag ( cc ) * dBRdPHI ( cc ) / Y_R ( cc ) + & B_R ( cc ) * gradB_PHI ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) end do !$OMP END SIMD !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHIinterp: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_3DBdBfields1_p subroutine calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag , EPHI INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2d % A , efield_2d % PHI , pchunk , Y_R , Y_Z , A , & EPHI , ezerr ) call EZspline_error ( ezerr ) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dZ !A(:,4) = d&#94;2PSIp/dR&#94;2 !A(:,5) = d&#94;2PSIp/dZ&#94;2 !A(:,6) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) B_R ( cc ) = A ( cc , 3 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 4 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 5 ) - B_Z ( cc ) * A ( cc , 6 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 4 ) + A ( cc , 5 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) if ( F % E_2x1t ) then E_R ( cc ) = 0._rp E_PHI ( cc ) = EPHI ( cc ) E_Z ( cc ) = 0._rp else E_R ( cc ) = 0._rp E_PHI ( cc ) = 0._rp E_Z ( cc ) = 0._rp end if end do end subroutine calculate_GCfieldswE_p subroutine calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2d % A , pchunk , Y_R , Y_Z , A , ezerr ) call EZspline_error ( ezerr ) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dZ !A(:,4) = d&#94;2PSIp/dR&#94;2 !A(:,5) = d&#94;2PSIp/dZ&#94;2 !A(:,6) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) B_R ( cc ) = A ( cc , 3 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 4 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 5 ) - B_Z ( cc ) * A ( cc , 6 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 4 ) + A ( cc , 5 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) E_R ( cc ) = 0._rp E_PHI ( cc ) = F % Eo * F % Ro / Y_R ( cc ) E_Z ( cc ) = 0._rp end do end subroutine calculate_GCfields_p subroutine calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp , time ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 7 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache REAL ( rp ), INTENT ( IN ) :: time REAL ( rp ), DIMENSION ( pchunk ) :: Y_T !$OMP SIMD do cc = 1_idef , pchunk Y_T ( cc ) = F % t0_2x1t + time end do !$OMP END SIMD !write(output_unit_write,*) 't0',F%t0_2x1t,'time',time,'Y_T',Y_T(1) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_T , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2X1T % A , pchunk , Y_R , Y_T , Y_Z , A , ezerr ) call EZspline_error ( ezerr ) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dT !A(:,4) = dPSIp/dZ !A(:,5) = d&#94;2PSIp/dR&#94;2 !A(:,6) = d&#94;2PSIp/dZ&#94;2 !A(:,7) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) B_R ( cc ) = A ( cc , 4 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 7 ) - B_Z ( cc ) * A ( cc , 5 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 7 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 5 ) + A ( cc , 6 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) if ( F % E_2x1t ) then E_R ( cc ) = 0._rp E_PHI ( cc ) = A ( cc , 3 ) / ( 2._rp * C_PI * Y_R ( cc )) E_Z ( cc ) = 0._rp else E_R ( cc ) = 0._rp E_PHI ( cc ) = 0._rp E_Z ( cc ) = 0._rp end if end do !$OMP END SIMD end subroutine calculate_GCfields_2x1t_p subroutine calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2d % A , pchunk , Y_R , Y_Z , A , ezerr ) call EZspline_error ( ezerr ) !write (output_unit_write,*) A(1,1),A(1,2) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dZ !A(:,4) = d&#94;2PSIp/dR&#94;2 !A(:,5) = d&#94;2PSIp/dZ&#94;2 !A(:,6) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) A ( cc , 2 ) = A ( cc , 2 ) / ( 2 * C_PI ) A ( cc , 3 ) = A ( cc , 3 ) / ( 2 * C_PI ) A ( cc , 4 ) = A ( cc , 4 ) / ( 2 * C_PI ) A ( cc , 5 ) = A ( cc , 5 ) / ( 2 * C_PI ) A ( cc , 6 ) = A ( cc , 6 ) / ( 2 * C_PI ) B_R ( cc ) = A ( cc , 3 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 4 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 5 ) - B_Z ( cc ) * A ( cc , 6 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 4 ) + A ( cc , 5 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) E_R ( cc ) = 0._rp E_PHI ( cc ) = F % Eo * F % Ro / Y_R ( cc ) E_Z ( cc ) = 0._rp end do end subroutine calculate_GCfields_p_FS subroutine add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: rm , E_SC_PHI REAL ( rp ) :: R0 , Z0 INTEGER :: cc , pchunk pchunk = params % pchunk R0 = F % Ro Z0 = F % Zo !$OMP SIMD do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) * ( Y_R ( cc ) - R0 ) + ( Y_Z ( cc ) - Z0 ) * ( Y_Z ( cc ) - Z0 )) end do !$OMP END SIMD call EZspline_interp ( efield_SC1d % PHI , pchunk , rm , E_SC_PHI , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = E_PHI ( cc ) + E_SC_PHI ( cc ) end do !$OMP END SIMD end subroutine add_interp_SCE_p subroutine add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: E_SC_PHI INTEGER :: cc , pchunk pchunk = params % pchunk call EZspline_interp ( efield_SC1d % PHI , pchunk , PSIp , E_SC_PHI , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = E_PHI ( cc ) + E_SC_PHI ( cc ) end do !$OMP END SIMD end subroutine add_interp_SCE_p_FS subroutine calculate_initial_magnetic_field ( F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F REAL ( rp ), dimension ( F % dims ( 1 ), F % dims ( 3 ), 2 ) :: gradA INTEGER :: ii INTEGER :: jj call EZspline_interp ( bfield_2d % A , F % dims ( 1 ), F % dims ( 3 ), F % X % R , F % X % Z , & F % PSIp , ezerr ) call EZspline_error ( ezerr ) ! FR = (dA/dZ)/R call EZspline_gradient ( bfield_2d % A , F % dims ( 1 ), F % dims ( 3 ), F % X % R , F % X % Z , & gradA , ezerr ) call EZspline_error ( ezerr ) do ii = 1 , F % dims ( 1 ) F % B_2D % R ( ii ,:) = gradA ( ii ,:, 2 ) / F % X % R ( ii ) F % B_2D % PHI ( ii ,:) = - F % Bo * F % Ro / F % X % R ( ii ) F % B_2D % Z ( ii ,:) = - gradA ( ii ,:, 1 ) / F % X % R ( ii ) end do !        write(output_unit_write,'(\"AR\",E17.10)') gradA(1) !        write(output_unit_write,'(\"AZ\",E17.10)') gradA(2) end subroutine calculate_initial_magnetic_field subroutine sample_poloidal_flux ( F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F ! FR = (dA/dZ)/R call EZspline_interp ( bfield_2d % A , F % dims ( 1 ), F % dims ( 3 ), F % X % R , F % X % Z , & F % PSIp , ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"AR\",E17.10)') gradA(1) !        write(output_unit_write,'(\"AZ\",E17.10)') gradA(2) end subroutine sample_poloidal_flux !> @brief Subroutine for interpolating the pre-computed, axisymmetric electric field to the particles' position. !! !! @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. !! @param[in,out] E Cartesian components of interpolated electric field components. E(1,:)=E_x, E(2,:)=E_y, and E(3,:)=E_z. !! @param F Cylindrical components of interpolated magnetic field components. F(1,:)=E_R, F(2,:)=E_\\phi, and F(3,:)=E_Z. !! @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0). !! @param pp Particle iterator. !! @param ss Species iterator. subroutine interp_2D_efields ( params , Y , E , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag INTEGER :: pp INTEGER :: ss !  write(output_unit_write,*) 'interp E fields' if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,E,flag,efield_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( efield_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( efield_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( efield_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then E ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) E ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) E ( pp , 3 ) = F ( pp , 3 ) else E ( pp , 1 ) = F ( pp , 1 ) E ( pp , 2 ) = F ( pp , 2 ) E ( pp , 3 ) = F ( pp , 3 ) end if !write(output_unit_write,*) 'EPHI',E(pp,2) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_efields !> @brief Subroutine for interpolating the pre-computed 3-D electric field to the particles' position. !! !! @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. !! @param[in,out] E Cartesian components of interpolated electric field components. E(1,:)=E_x, E(2,:)=E_y, and E(3,:)=E_z. !! @param F Cylindrical components of interpolated magnetic field components. F(1,:)=E_R, F(2,:)=E_\\phi, and F(3,:)=E_Z. !! @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0). !! @param pp Particle iterator. !! @param ss Species iterator. subroutine interp_3D_efields ( params , Y , E , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag INTEGER :: pp INTEGER :: ss ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,E,flag,efield_3d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( efield_3d % R , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( efield_3d % PHI , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( efield_3d % Z , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then E ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) E ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) E ( pp , 3 ) = F ( pp , 3 ) else E ( pp , 1 ) = F ( pp , 1 ) E ( pp , 2 ) = F ( pp , 2 ) E ( pp , 3 ) = F ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_3D_efields subroutine interp_fields ( params , prtcls , F ) !! @note Subroutine that works as an interface for calling the !! appropriate subroutines for interpolating or calculating the !! electric and magnetic fields. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls !! An instance of PARTICLES containing the variables of a given species. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the !! information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. if (. not . params % GC_coords ) call cart_to_cyl ( prtcls % X , prtcls % Y ) !  write(output_unit_write,'(\"BR: \",E17.10)') prtcls%BR(:,1) !  write(output_unit_write,'(\"Y: \",E17.10)') prtcls%X(2,1) !  write(output_unit_write,'(\"Z: \",E17.10)') prtcls%X(3,1) call check_if_in_fields_domain ( F , prtcls % Y , prtcls % flagCon ) !write(output_unit_write,*) 'checked domain' #ifdef M3D_C1 if ( TRIM ( params % field_model ) . eq . 'M3D_C1' ) then if ( F % M3D_C1_B . ge . 0 ) then call get_m3d_c1_magnetic_fields ( prtcls , F , params ) end if if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_electric_fields ( prtcls , F , params ) end if if ( F % M3D_C1_A . ge . 0 ) then call get_m3d_c1_vector_potential ( prtcls , F , params ) end if end if #endif if (( ALLOCATED ( F % PSIp ). and . F % Bflux ). or . F % ReInterp_2x1t ) then !     write(output_unit_write,'(\"3 size of PSI_P: \",I16)') size(prtcls%PSI_P) !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) !     write(output_unit_write,'(\"PSI_P: \",E17.10)') prtcls%PSI_P call calculate_magnetic_field ( params , prtcls % Y , F , prtcls % B , prtcls % E , & prtcls % PSI_P , prtcls % flagCon ) !write(output_unit_write,*) 'interp PSIp' !     write(output_unit_write,'(\"interp_fields\")') !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) end if if ( ALLOCATED ( F % PSIp3D ). and . F % Bflux3D ) then !     write(output_unit_write,'(\"3 size of PSI_P: \",I16)') size(prtcls%PSI_P) !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) !     write(output_unit_write,'(\"PSI_P: \",E17.10)') prtcls%PSI_P call calculate_magnetic_field ( params , prtcls % Y , F , prtcls % B , prtcls % E , & prtcls % PSI_P , prtcls % flagCon ) !     write(output_unit_write,'(\"interp_fields\")') !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) end if if ( ALLOCATED ( F % B_2D % R ). and . F % Bfield ) then call interp_2D_bfields ( params , prtcls % Y , prtcls % B , prtcls % flagCon ) end if if ( ALLOCATED ( F % B_3D % R ). and . F % Bfield ) then call interp_3D_bfields ( params , prtcls % Y , prtcls % B , prtcls % flagCon ) end if !  if (ALLOCATED(F%E_2D%R).and.F%Efield) then !     call interp_2D_efields(params,prtcls%Y,prtcls%E,prtcls%flagCon) !  end if if ( ALLOCATED ( F % E_3D % R ). and . F % Efield . and .(. not . F % ReInterp_2x1t )) then call interp_3D_efields ( params , prtcls % Y , prtcls % E , prtcls % flagCon ) end if if ( ALLOCATED ( F % E_3D % R ). and . F % Efield . and . F % ReInterp_2x1t ) then call interp_2D_efields ( params , prtcls % Y , prtcls % E , prtcls % flagCon ) !     write(output_unit_write,*) 'interpolated efield' end if if ( params % GC_coords . and . ALLOCATED ( F % gradB_2D % R ). and . F % Bfield ) then call interp_2D_gradBfields ( prtcls % Y , prtcls % gradB , prtcls % flagCon ) end if if ( params % GC_coords . and . ALLOCATED ( F % gradB_2D % R ). and . F % Bfield ) then call interp_2D_curlbfields ( prtcls % Y , prtcls % curlb , prtcls % flagCon ) end if if ( params % GC_coords . and . params % orbit_model ( 3 : 6 ) == 'grad' ) then call gradient_2D_bfields ( prtcls % Y , prtcls % BR , prtcls % BPHI , & prtcls % BZ , prtcls % flagCon ) end if end subroutine interp_fields subroutine interp_2D_profiles ( Y , ne , Te , Zeff , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! plasma profiles to the particles' position. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: ne !! Interpolated background electron density !!n_e(R,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Te !! Interpolated background electron temperature T_e(R,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Zeff !! Interpolated effective charge number Z_{eff}(R,Z). INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the !! simulation (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if !  write(output_unit_write,'(\"Also R_buffer: \",E17.10)') Y(1,ss) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(Y,ne,Te,Zeff,flag,profiles_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( profiles_2d % ne , Y ( pp , 1 ), Y ( pp , 3 ), ne ( pp ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"Also R_buffer: \",E17.10)') Y(pp,1) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( profiles_2d % Te , Y ( pp , 1 ), Y ( pp , 3 ), Te ( pp ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( profiles_2d % Zeff , Y ( pp , 1 ), Y ( pp , 3 ), Zeff ( pp ), ezerr ) call EZspline_error ( ezerr ) end if end do !$OMP END PARALLEL DO end subroutine interp_2D_profiles subroutine interp_3D_profiles ( Y , ne , Te , Zeff , flag ) !! @note Subroutine for interpolating the pre-computed, !! 3-D plasma profiles to the particles' position. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: ne !! Interpolated background electron density n_e(R,\\phi,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Te !! Interpolated background electron temperature T_e(R,\\phi,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Zeff !! Interpolated effective charge number Z_{eff}(R,\\phi,Z). INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in !! the simulation (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(Y,ne,Te,Zeff,flag,profiles_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( profiles_3d % ne , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & ne ( pp ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( profiles_3d % Te , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & Te ( pp ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( profiles_3d % Zeff , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & Zeff ( pp ), ezerr ) call EZspline_error ( ezerr ) end if end do !$OMP END PARALLEL DO end subroutine interp_3D_profiles subroutine interp_profiles ( params , prtcls , P ) !! @note Subroutine that calls the appropriate subroutines for !! interpolating the 2-D or 3-D plasma profiles to the particles' !! position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls !! An instance of PARTICLES containing the variables of a !! given species. Call to this subroutine generally passes spp%vars. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See[[ korc_types]] and [[korc_profiles]]. if (. not . params % GC_coords ) call cart_to_cyl ( prtcls % X , prtcls % X ) !write(output_unit_write,'(\"Also R_buffer: \",E17.10)') prtcls%Y(1,1) call check_if_in_profiles_domain ( prtcls % Y , prtcls % flagCon ) if ( ALLOCATED ( P % ne_2D )) then !     write(output_unit_write,'(\"Also R_buffer: \",E17.10)') prtcls%X(1,1) call interp_2D_profiles ( prtcls % Y , prtcls % ne , prtcls % Te , prtcls % Zeff , & prtcls % flagCon ) else if ( ALLOCATED ( P % ne_3D )) then call interp_3D_profiles ( prtcls % Y , prtcls % ne , prtcls % Te , prtcls % Zeff , & prtcls % flagCon ) #ifdef M3D_C1 else if ( P % M3D_C1_ne . ge . 0 . or . & P % M3D_C1_te . ge . 0 . or . & P % M3D_C1_zeff . ge . 0 ) then call get_m3d_c1_profile ( prtcls , P , params ) #endif else write ( output_unit_write , '(\"Error: NO PROFILES ALLOCATED\")' ) call KORC_ABORT () end if end subroutine interp_profiles !> @brief Subroutine that frees memory allocated for PSPLINE interpolants. !! !! @param[in] params Core KORC simulation parameters. subroutine finalize_interpolants ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if (( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ). or . & ( params % field_eval . eq . 'interp' )) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * FINALIZING FIELD INTERPOLANT * * * *\")' ) end if if ( EZspline_allocated ( bfield_3d % R )) call Ezspline_free ( bfield_3d % R , ezerr ) if ( EZspline_allocated ( bfield_3d % PHI )) & call Ezspline_free ( bfield_3d % PHI , ezerr ) if ( EZspline_allocated ( bfield_3d % Z )) call Ezspline_free ( bfield_3d % Z , ezerr ) if ( EZspline_allocated ( bfield_2d % A )) call Ezspline_free ( bfield_2d % A , ezerr ) if ( EZspline_allocated ( bfield_2d % R )) call Ezspline_free ( bfield_2d % R , ezerr ) if ( EZspline_allocated ( bfield_2d % PHI )) & call Ezspline_free ( bfield_2d % PHI , ezerr ) if ( EZspline_allocated ( bfield_2d % Z )) call Ezspline_free ( bfield_2d % Z , ezerr ) if ( EZspline_allocated ( gradB_2d % R )) call Ezspline_free ( gradB_2d % R , ezerr ) if ( EZspline_allocated ( gradB_2d % PHI )) & call Ezspline_free ( gradB_2d % PHI , ezerr ) if ( EZspline_allocated ( gradB_2d % Z )) call Ezspline_free ( gradB_2d % Z , ezerr ) if ( EZspline_allocated ( curlb_2d % R )) call Ezspline_free ( curlb_2d % R , ezerr ) if ( EZspline_allocated ( curlb_2d % PHI )) & call Ezspline_free ( curlb_2d % PHI , ezerr ) if ( EZspline_allocated ( gradB_3d % R )) call Ezspline_free ( gradB_3d % R , ezerr ) if ( EZspline_allocated ( gradB_3d % PHI )) & call Ezspline_free ( gradB_3d % PHI , ezerr ) if ( EZspline_allocated ( gradB_3d % Z )) call Ezspline_free ( gradB_3d % Z , ezerr ) if ( EZspline_allocated ( curlb_3d % R )) call Ezspline_free ( curlb_3d % R , ezerr ) if ( EZspline_allocated ( curlb_3d % PHI )) & call Ezspline_free ( curlb_3d % PHI , ezerr ) if ( EZspline_allocated ( curlb_3d % Z )) call Ezspline_free ( curlb_3d % Z , ezerr ) if ( ALLOCATED ( profiles_domain % FLAG2D )) DEALLOCATE ( profiles_domain % FLAG2D ) if ( ALLOCATED ( profiles_domain % FLAG3D )) DEALLOCATE ( profiles_domain % FLAG3D ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * FIELD INTERPOLANT FINALIZED * * * *\")' ) end if end if if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * FINALIZING PROFILE INTERPOLANT * * * *\")' ) end if if ( EZspline_allocated ( profiles_3d % ne )) & call Ezspline_free ( profiles_3d % ne , ezerr ) if ( EZspline_allocated ( profiles_3d % Te )) & call Ezspline_free ( profiles_3d % Te , ezerr ) if ( EZspline_allocated ( profiles_3d % Zeff )) call Ezspline_free ( & profiles_3d % Zeff , ezerr ) if ( EZspline_allocated ( profiles_2d % ne )) & call Ezspline_free ( profiles_2d % ne , ezerr ) if ( EZspline_allocated ( profiles_2d % Te )) & call Ezspline_free ( profiles_2d % Te , ezerr ) if ( EZspline_allocated ( profiles_2d % Zeff )) call Ezspline_free ( & profiles_2d % Zeff , ezerr ) if ( ALLOCATED ( profiles_domain % FLAG2D )) DEALLOCATE ( profiles_domain % FLAG2D ) if ( ALLOCATED ( profiles_domain % FLAG3D )) DEALLOCATE ( profiles_domain % FLAG3D ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * PROFILE INTERPOLANT FINALIZED * * * *\")' ) end if end if end subroutine finalize_interpolants #ifdef M3D_C1 !!  @note FIXME Add documentation subroutine get_m3d_c1_magnetic_fields ( prtcls , F , params ) USE omp_lib IMPLICIT NONE TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Btmp TYPE ( C_PTR ), DIMENSION ( size ( prtcls % hint )) :: hint INTEGER :: thread_num !    write(output_unit_write,*) 'in m3dc1 B' if ( prtcls % cart ) then !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x = prtcls % X ( pp ,:) * params % cpp % length status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & prtcls % B ( pp , 1 ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % B ( pp ,:) = 0 prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if end if end do !$OMP END PARALLEL DO else !       write(output_unit_write,*) 'in cart false' !hint=prtcls%hint !write(output_unit_write,*) 'hint: ',hint Btmp = 0._rp !$OMP PARALLEL DO DEFAULT(none) & !$OMP& SHARED(prtcls,params,F) & !$OMP& PRIVATE(pp,status,x,thread_num) & !$OMP& FIRSTPRIVATE(Btmp) do pp = 1 , SIZE ( prtcls % hint ) thread_num = OMP_GET_THREAD_NUM () if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( pp , 1 ) * params % cpp % length x ( 2 ) = prtcls % Y ( pp , 2 ) x ( 3 ) = prtcls % Y ( pp , 3 ) * params % cpp % length !prtcls%hint(pp)=c_null_ptr !write(output_unit_write,*) 'thread',thread_num,'X',x !             prtcls%hint(pp)=c_null_ptr !write(output_unit_write,*) 'thread',thread_num,'before interpolating B' status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & Btmp ( 1 ), prtcls % hint ( pp )) !write(output_unit_write,*) 'thread',thread_num,'interpolated B' if ( status . eq . FIO_NO_DATA ) then prtcls % B ( pp ,:) = 0 prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if if (. not . params % GC_coords ) then prtcls % B ( pp , 1 ) = ( Btmp ( 1 ) * cos ( x ( 2 )) - Btmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Bo prtcls % B ( pp , 2 ) = ( Btmp ( 1 ) * sin ( x ( 2 )) + Btmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Bo prtcls % B ( pp , 3 ) = Btmp ( 3 ) / params % cpp % Bo else prtcls % B ( pp , 1 ) = Btmp ( 1 ) / params % cpp % Bo prtcls % B ( pp , 2 ) = Btmp ( 2 ) / params % cpp % Bo prtcls % B ( pp , 3 ) = Btmp ( 3 ) / params % cpp % Bo end if end if end do !$OMP END PARALLEL DO end if end subroutine get_m3d_c1_magnetic_fields subroutine get_m3d_c1_FOmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_X , B_Y , B_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: B_X , B_Y , B_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Btmp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & Btmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then B_X ( pp ) = ( Btmp ( 1 ) * cos ( x ( 2 )) - Btmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Bo B_Y ( pp ) = ( Btmp ( 1 ) * sin ( x ( 2 )) + Btmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Bo B_Z ( pp ) = Btmp ( 3 ) / params % cpp % Bo else if ( status . eq . FIO_NO_DATA ) then flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_FOmagnetic_fields_p subroutine get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: curlb_R , curlb_PHI , curlb_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Btmp REAL ( rp ), DIMENSION ( 9 ) :: dBtmp REAL ( rp ) :: Bmag , dBRdR , dBPHIdR , dBZdR , dBRdPHI , dBPHIdPHI , dBZdPHI , dBRdZ , dBPHIdZ , dBZdZ pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr !if (pp.eq.1) write(output_unit_write,*) 'Yinterp',x status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & Btmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then !if (pp.eq.1) write(output_unit_write,*) 'interp success!' B_R ( pp ) = Btmp ( 1 ) / params % cpp % Bo B_PHI ( pp ) = Btmp ( 2 ) / params % cpp % Bo B_Z ( pp ) = Btmp ( 3 ) / params % cpp % Bo Bmag = sqrt ( B_R ( pp ) * B_R ( pp ) + B_PHI ( pp ) * B_PHI ( pp ) + B_Z ( pp ) * B_Z ( pp )) status = fio_eval_field_deriv ( F % M3D_C1_B , x ( 1 ), dBtmp ( 1 ), hint ( pp )) !dBRdR=dBtmp(FIO_DR_R)*(params%cpp%length/params%cpp%Bo) !dBPHIdR=dBtmp(FIO_DR_PHI)*(params%cpp%length/params%cpp%Bo) !dBZdR=dBtmp(FIO_DR_Z)*(params%cpp%length/params%cpp%Bo) !dBRdPHI=dBtmp(FIO_DPHI_R)*(params%cpp%length/params%cpp%Bo) !dBPHIdPHI=dBtmp(FIO_DPHI_PHI)*(params%cpp%length/params%cpp%Bo) !dBZdPHI=dBtmp(FIO_DPHI_Z)*(params%cpp%length/params%cpp%Bo) !dBRdZ=dBtmp(FIO_DZ_R)*(params%cpp%length/params%cpp%Bo) !dBPHIdZ=dBtmp(FIO_DZ_PHI)*(params%cpp%length/params%cpp%Bo) !dBZdZ=dBtmp(FIO_DZ_Z)*(params%cpp%length/params%cpp%Bo) dBRdR = dBtmp ( 1 ) * ( params % cpp % length / params % cpp % Bo ) dBPHIdR = dBtmp ( 2 ) * ( params % cpp % length / params % cpp % Bo ) dBZdR = dBtmp ( 3 ) * ( params % cpp % length / params % cpp % Bo ) dBRdPHI = dBtmp ( 4 ) * ( params % cpp % length / params % cpp % Bo ) dBPHIdPHI = dBtmp ( 5 ) * ( params % cpp % length / params % cpp % Bo ) dBZdPHI = dBtmp ( 6 ) * ( params % cpp % length / params % cpp % Bo ) dBRdZ = dBtmp ( 7 ) * ( params % cpp % length / params % cpp % Bo ) dBPHIdZ = dBtmp ( 8 ) * ( params % cpp % length / params % cpp % Bo ) dBZdZ = dBtmp ( 9 ) * ( params % cpp % length / params % cpp % Bo ) gradB_R ( pp ) = ( B_R ( pp ) * dBRdR + B_PHI ( pp ) * dBPHIdR + B_Z ( pp ) * dBZdR ) / & Bmag gradB_PHI ( pp ) = ( B_R ( pp ) * dBRdPHI + B_PHI ( pp ) * dBPHIdPHI + & B_Z ( pp ) * dBZdPHI ) / ( Y_R ( pp ) * Bmag ) gradB_Z ( pp ) = ( B_R ( pp ) * dBRdZ + B_PHI ( pp ) * dBPHIdZ + B_Z ( pp ) * dBZdZ ) / & Bmag curlb_R ( pp ) = ( Bmag / Y_R ( pp ) * dBZdPHI - B_Z ( pp ) * gradB_PHI ( pp ) - & Bmag * dBPHIdZ + B_PHI ( pp ) * gradB_Z ( pp )) / ( Bmag * Bmag ) curlb_PHI ( pp ) = ( Bmag * dBRdZ - B_R ( pp ) * gradB_Z ( pp ) - & Bmag * dBZdR + B_Z ( pp ) * gradB_R ( pp )) / ( Bmag * Bmag ) curlb_Z ( pp ) = ( Bmag / Y_R ( pp ) * B_PHI ( pp ) + Bmag * dBPHIdR - & B_PHI ( pp ) * gradB_R ( pp ) - & Bmag / Y_R ( pp ) * dBRdPHI + B_R ( pp ) * gradB_PHI ( pp )) / ( Bmag * Bmag ) else if ( status . eq . FIO_NO_DATA ) then flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_GCmagnetic_fields_p subroutine get_m3d_c1_vector_potential ( prtcls , F , params ) TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Atmp integer ( ip ) :: ss if ( prtcls % Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( prtcls % Y , 1 ) end if Atmp = 0._rp !$OMP PARALLEL DO DEFAULT(SHARED) & !$OMP& PRIVATE(pp,status,x) & !$OMP& FIRSTPRIVATE(Atmp) do pp = 1 , ss if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( pp , 1 ) * params % cpp % length x ( 2 ) = prtcls % Y ( pp , 2 ) x ( 3 ) = prtcls % Y ( pp , 3 ) * params % cpp % length !prtcls%hint(pp)=c_null_ptr !write(output_unit_write,*) F%M3D_C1_A,x,Atmp status = fio_eval_field ( F % M3D_C1_A , x ( 1 ), & Atmp ( 1 ), prtcls % hint ( pp )) if ( status . eq . FIO_SUCCESS ) then prtcls % PSI_P ( pp ) =- Atmp ( 2 ) * x ( 1 ) else if ( status . eq . FIO_NO_DATA ) then prtcls % PSI_P ( pp ) = 10 0._rp prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is prtcls % PSI_P ( pp ) = 10 0._rp end if end if end do !$OMP END PARALLEL DO end subroutine get_m3d_c1_vector_potential subroutine get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: PSIp INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Atmp integer ( ip ) :: ss pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr status = fio_eval_field ( F % M3D_C1_A , x ( 1 ), & Atmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then PSIp ( pp ) =- Atmp ( 2 ) * x ( 1 ) else if ( status . eq . FIO_NO_DATA ) then PSIp ( pp ) = 10 0._rp flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then PSIp ( pp ) = 10 0._rp flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_vector_potential_p !!  @note FIXME Add documentation subroutine get_m3d_c1_electric_fields ( prtcls , F , params ) TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Etmp if ( prtcls % cart ) then !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x = prtcls % X ( pp ,:) * params % cpp % length status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & prtcls % E ( pp , 1 ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % E ( pp ,:) = 0 else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if end if end do !$OMP END PARALLEL DO else Etmp = 0._rp !$OMP PARALLEL DO DEFAULT(none) & !$OMP& SHARED(prtcls,params,F) & !$OMP& PRIVATE(pp,status,x) & !$OMP& FIRSTPRIVATE(Etmp) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( pp , 1 ) * params % cpp % length x ( 2 ) = prtcls % Y ( pp , 2 ) x ( 3 ) = prtcls % Y ( pp , 3 ) * params % cpp % length status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & Etmp ( 1 ), prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % E ( pp ,:) = 0 prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if if (. not . params % GC_coords ) then prtcls % E ( pp , 1 ) = ( Etmp ( 1 ) * cos ( x ( 2 )) - Etmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Eo prtcls % E ( pp , 2 ) = ( Etmp ( 1 ) * sin ( x ( 2 )) + Etmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Eo prtcls % E ( pp , 3 ) = Etmp ( 3 ) / params % cpp % Eo else prtcls % E ( pp , 1 ) = Etmp ( 1 ) / params % cpp % Eo prtcls % E ( pp , 2 ) = Etmp ( 2 ) / params % cpp % Eo prtcls % E ( pp , 3 ) = Etmp ( 3 ) / params % cpp % Eo end if end if end do !$OMP END PARALLEL DO end if end subroutine get_m3d_c1_electric_fields subroutine get_m3d_c1_FOelectric_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & E_X , E_Y , E_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_X , E_Y , E_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Etmp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & Etmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then E_X ( pp ) = ( Etmp ( 1 ) * cos ( x ( 2 )) - Etmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Eo E_Y ( pp ) = ( Etmp ( 1 ) * sin ( x ( 2 )) + Etmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Eo E_Z ( pp ) = Etmp ( 3 ) / params % cpp % Eo else if ( status . eq . FIO_NO_DATA ) then E_X ( pp ) = 0 E_Y ( pp ) = 0 E_Z ( pp ) = 0 flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_FOelectric_fields_p subroutine get_m3d_c1_GCelectric_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & E_R , E_PHI , E_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Etmp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & Etmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then E_R ( pp ) = Etmp ( 1 ) / params % cpp % Eo E_PHI ( pp ) = Etmp ( 2 ) / params % cpp % Eo E_Z ( pp ) = Etmp ( 3 ) / params % cpp % Eo else if ( status . eq . FIO_NO_DATA ) then E_R ( pp ) = 0 E_PHI ( pp ) = 0 E_Z ( pp ) = 0 flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if !          write(6,*) E_R,E_PHI,E_Z end if end do end subroutine get_m3d_c1_GCelectric_fields_p subroutine get_m3d_c1_profile ( prtcls , P , params ) TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x if ( prtcls % cart ) then !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x = prtcls % X ( pp ,:) * params % cpp % length status = fio_eval_field ( P % M3D_C1_ne , x ( 1 ), & prtcls % ne ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % ne ( pp ) = 0 else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is CYCLE end if status = fio_eval_field ( P % M3D_C1_te , x ( 1 ), & prtcls % te ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % te ( pp ) = 0 end if status = fio_eval_field ( P % M3D_C1_zeff , x ( 1 ), & prtcls % Zeff ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % Zeff ( pp ) = 1 end if end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( 1 , pp ) * params % cpp % length x ( 2 ) = prtcls % Y ( 2 , pp ) x ( 3 ) = prtcls % Y ( 3 , pp ) * params % cpp % length status = fio_eval_field ( P % M3D_C1_ne , x ( 1 ), & prtcls % ne ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % ne ( pp ) = 0 else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is CYCLE end if status = fio_eval_field ( P % M3D_C1_te , x ( 1 ), & prtcls % te ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % te ( pp ) = 0 end if status = fio_eval_field ( P % M3D_C1_zeff , x ( 1 ), & prtcls % Zeff ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % Zeff ( pp ) = 1 end if end if end do !$OMP END PARALLEL DO end if end subroutine get_m3d_c1_profile subroutine get_m3d_c1_profile_p ( params , P , Y_R , Y_PHI , Y_Z , & n_e , T_e , flag , hint ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: n_e , T_e INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ) :: netmp =- 1._rp , Tetmp =- 1._rp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !write(6,*) P%M3D_C1_ne,x status = fio_eval_field ( P % M3D_C1_ne , x ( 1 ), & netmp , hint ( pp )) if ( status . eq . FIO_SUCCESS ) then n_e ( pp ) = netmp / params % cpp % density else if ( status . eq . FIO_NO_DATA ) then flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is CYCLE end if status = fio_eval_field ( P % M3D_C1_te , x ( 1 ), & Tetmp , hint ( pp )) if ( status . eq . FIO_SUCCESS ) then T_e ( pp ) = Tetmp / ( params % cpp % temperature / C_E ) end if !          write(6,*) E_R,E_PHI,E_Z end if end do end subroutine get_m3d_c1_profile_p #endif end module korc_interp","tags":"","loc":"sourcefile/korc_interp.f90.html"},{"title":"korc_avalanche.f90 – KORC-Full Orbit","text":"Contents Modules korc_avalanche Source Code korc_avalanche.f90 Source Code MODULE korc_avalanche USE korc_types USE korc_constants USE korc_HDF5 USE korc_hpc USE korc_fields USE korc_profiles USE korc_coords USE korc_input IMPLICIT NONE TYPE , PRIVATE :: AVALANCHE_PDF_PARAMS REAL ( rp ) :: max_pitch_angle !! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle !! Minimum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_energy !! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_energy !! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_p !! Minimum momentum of sampled PDF REAL ( rp ) :: max_p !! Maximum momentum of sampled PDF REAL ( rp ) :: ne !! Background electron density in m&#94;-3 REAL ( rp ) :: Zeff !! Effective atomic number of ions REAL ( rp ) :: Ec !! Critical electric field in V/m REAL ( rp ) :: Epar !! Parallel electric field in V/m REAL ( rp ) :: Ebar !! Epar/Ec REAL ( rp ) :: Te !! Background electron temperature in eV REAL ( rp ) :: lD !! Debye length REAL ( rp ) :: bmin !! Maximum approach radius REAL ( rp ) :: CoulombLog !! Coulomb Logarithm REAL ( rp ) :: Tau !! Collisional time REAL ( rp ) :: dth !! Variance of sampling normal variate for pitch angle REAL ( rp ) :: dp !! Variance of sampling normal variate for momentum REAL ( rp ) :: dR !! Variance of sampling normal variate for R location REAL ( rp ) :: dZ !! Variance of sampling normal variate for Z location REAL ( rp ) :: fo REAL ( rp ) :: alpha REAL ( rp ) :: cz REAL ( rp ) :: C1 REAL ( rp ) :: C2 END TYPE AVALANCHE_PDF_PARAMS TYPE ( AVALANCHE_PDF_PARAMS ), PRIVATE :: aval_params REAL ( rp ), PRIVATE , PARAMETER :: minmax_buffer_size = 1 0.0_rp PUBLIC :: get_avalanche_distribution ,& get_Avalanche_4D PRIVATE :: initialize_avalanche_params ,& save_avalanche_params ,& fRE ,& sample_distribution ,& indicator ,& PSI_ROT ,& random_norm ,& update_avalanche_params ,& Avalanche_4D CONTAINS SUBROUTINE get_avalanche_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao call initialize_avalanche_params ( params ) call save_avalanche_params ( params ) call sample_distribution ( params , g , eta , go , etao ) END SUBROUTINE get_avalanche_distribution SUBROUTINE get_Avalanche_4D ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. call initialize_avalanche_params ( params ) call save_avalanche_params ( params ) call Avalanche_4D ( params , spp , P , F ) END SUBROUTINE get_Avalanche_4D SUBROUTINE initialize_avalanche_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) :: max_pitch_angle !REAL(rp) :: min_pitch_angle !REAL(rp) :: max_energy !REAL(rp) :: min_energy !REAL(rp) :: ne !REAL(rp) :: Zeff !REAL(rp) :: Epar !REAL(rp) :: Te !REAL(rp) :: dth !REAL(rp) :: dp !REAL(rp) :: dR !REAL(rp) :: dZ !NAMELIST /AvalancheGenerationPDF/ max_pitch_angle,min_pitch_angle, & !     max_energy,min_energy,ne,Zeff,Epar,Te,dth,dp,dR,dZ !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=AvalancheGenerationPDF) !close(default_unit_open) aval_params % dth = dth_aval aval_params % dp = dp_aval aval_params % dR = dR_aval / params % cpp % length aval_params % dZ = dZ_aval / params % cpp % length aval_params % max_pitch_angle = max_pitch_angle_aval aval_params % min_pitch_angle = min_pitch_angle_aval aval_params % max_energy = max_energy_aval * C_E ! In Joules aval_params % ne = ne_aval aval_params % Zeff = Zeff_aval aval_params % Te = Te_aval * C_E ! In Joules aval_params % lD = SQRT ( C_E0 * aval_params % Te / ( aval_params % ne * C_E ** 2 )) aval_params % bmin = aval_params % Zeff / ( 1 2.0_rp * C_PI * aval_params % ne * & aval_params % lD ** 2 ) aval_params % CoulombLog = LOG ( aval_params % lD / aval_params % bmin ) aval_params % Tau = 1.0_rp / ( 4.0_rp * C_PI * C_C * C_RE ** 2 * aval_params % ne * & aval_params % CoulombLog ) aval_params % Ec = C_ME * C_C / ( C_E * aval_params % Tau ) aval_params % Epar = Epar_aval aval_params % Ebar = aval_params % Epar / aval_params % Ec if ( min_energy_aval . EQ . 0.0_rp ) then aval_params % max_p = SQRT (( aval_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 & - 1.0_rp ) ! In units of mec&#94;2 aval_params % min_p = SQRT ( aval_params % Ebar - 1.0_rp ) ! In units of mec&#94;2 aval_params % min_energy = SQRT ( 1.0_rp + aval_params % min_p ** 2 ) * C_ME * C_C ** 2 else aval_params % min_energy = min_energy_aval * C_E ! In Joules aval_params % max_p = SQRT (( aval_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mec&#94;2 aval_params % min_p = SQRT (( aval_params % min_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mec&#94;2 end if aval_params % alpha = ( aval_params % Ebar - 1.0_rp ) / ( 1.0_rp + aval_params % Zeff ) aval_params % cz = SQRT ( 3.0_rp * ( aval_params % Zeff + 5.0_rp ) / C_PI ) * & aval_params % CoulombLog aval_params % fo = aval_params % alpha / aval_params % cz aval_params % C1 = 0.5_rp * aval_params % alpha aval_params % C2 = 1.0_rp / aval_params % cz - aval_params % C1 END SUBROUTINE initialize_avalanche_params FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad FUNCTION fRE ( x , p ) REAL ( rp ), INTENT ( IN ) :: x ! x = cos(pitch) REAL ( rp ), INTENT ( IN ) :: p ! momentum REAL ( rp ) :: fRE fRE = aval_params % fo * p * EXP ( - p * ( aval_params % C2 * x + aval_params % C1 / x )) / x END FUNCTION fRE FUNCTION log10fRE ( x , p ) REAL ( rp ), INTENT ( IN ) :: x ! x = cos(pitch) REAL ( rp ), INTENT ( IN ) :: p ! momentum REAL ( rp ) :: log10fRE log10fRE = LOG ( fRE ( x , p )) END FUNCTION log10fRE SUBROUTINE sample_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: chi , chi_test REAL ( rp ) :: p_buffer , p_test REAL ( rp ) :: eta_buffer , eta_test REAL ( rp ) :: ratio , rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_tmp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax , min_p , max_p , min_pitch_angle , max_pitch_angle REAL ( 4 ), DIMENSION ( 2 ) :: tarray REAL ( 4 ) :: time_elapsed REAL ( rp ) :: deta REAL ( rp ) :: dp LOGICAL :: lp , leta INTEGER :: num_accepted INTEGER :: ii , jj , ppp , nsamples INTEGER :: mpierr ppp = SIZE ( g ) nsamples = ppp * params % mpi_params % nmpi ALLOCATE ( p ( ppp )) deta = ( aval_params % max_pitch_angle - aval_params % min_pitch_angle ) / 10 0.0_rp dp = ( aval_params % max_p - aval_params % min_p ) / 10 0.0_rp do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_p - REAL ( jj , rp ) * dp if ( minmax . GT . 0.0_rp ) then min_p = minmax end if end do max_p = aval_params % max_p + minmax_buffer_size * dp if ( aval_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = aval_params % min_pitch_angle end if do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax else max_pitch_angle = aval_params % max_pitch_angle EXIT end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( p_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( p_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_buffer = aval_params % min_pitch_angle + ( aval_params % max_pitch_angle & - aval_params % min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) p_buffer = aval_params % min_p + ( aval_params % max_p - aval_params % min_p ) * & rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . aval_params % max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . aval_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) end do chi_test = COS ( deg2rad ( eta_test )) chi = COS ( deg2rad ( eta_buffer )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . aval_params % min_p ). OR .( p_test . GT . aval_params % max_p )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( chi_test , p_test ) / fRE ( chi , p_buffer ) if ( ratio . GE . 1.0_rp ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef end if end if end do ! Transient ! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_tmp ( 1 ) = eta_buffer p_tmp ( 1 ) = p_buffer num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR .( ABS ( eta_test ) & . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) end do chi_test = COS ( deg2rad ( eta_test )) chi = COS ( deg2rad ( eta_tmp ( ii - 1 ))) p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . min_p ). OR .( p_test . GT . max_p )) p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( chi_test , p_test ) / fRE ( chi , p_tmp ( ii - 1 )) if ( ratio . GE . 1.0_rp ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) lp = ( p_tmp ( ii ). LE . aval_params % max_p ). AND .( p_tmp ( ii ). GE . & aval_params % min_p ) leta = ( eta_tmp ( ii ). LE . aval_params % max_pitch_angle ). AND . & ( eta_tmp ( ii ). GE . aval_params % min_pitch_angle ) if ( lp . AND . leta ) then num_accepted = num_accepted + 1_idef p_samples ( num_accepted ) = p_tmp ( ii ) eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do eta_tmp ( 1 ) = eta_tmp ( ii ) p_tmp ( 1 ) = p_tmp ( ii ) end do go = SUM ( SQRT ( 1.0_rp + p_samples ** 2 )) / nsamples etao = SUM ( eta_samples ) / nsamples end if CALL MPI_SCATTER ( p_samples , ppp , MPI_REAL8 , p , ppp , MPI_REAL8 , 0 , & MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , ppp , MPI_REAL8 , eta , ppp , MPI_REAL8 , & 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( go , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( etao , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) g = SQRT ( 1.0_rp + p ** 2 ) DEALLOCATE ( p ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( p_samples ) DEALLOCATE ( eta_samples ) end if END SUBROUTINE sample_distribution FUNCTION PSI_ROT ( R , R0 , sigR , Z , Z0 , sigZ , theta ) !! Calculates value of argument of 2D Gaussian spatial distribution with !! with counter-clockwise rotation. REAL ( rp ), INTENT ( IN ) :: R !! R-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: R0 !! R-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigR !! Variance of first dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: Z !! Z-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: Z0 !! Z-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigZ !! Variance of second dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: theta !! Angle of counter-clockwise rotation (in radians), of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: PSI_ROT !! Argument of exponential comprising 2D Gaussian distribution PSI_ROT = ( R - R0 ) ** 2 * (( cos ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( sin ( theta )) ** 2 / & ( 2 * sigZ ** 2 )) + 2 * ( R - R0 ) * ( Z - Z0 ) * cos ( theta ) * sin ( theta ) * ( 1 / & ( 2 * sigR ** 2 ) - 1 / ( 2 * sigZ ** 2 )) + ( Z - Z0 ) ** 2 * (( sin ( theta )) ** 2 / & ( 2 * sigR ** 2 ) + ( cos ( theta )) ** 2 / ( 2 * sigZ ** 2 )) END FUNCTION PSI_ROT FUNCTION indicator ( psi , psi_max ) !! Compares argument psi to chosen psi_max, returning step function. REAL ( rp ), INTENT ( IN ) :: psi REAL ( rp ), INTENT ( IN ) :: psi_max REAL ( rp ) :: indicator IF ( psi . LT . psi_max ) THEN indicator = 1 ELSE indicator = 0 END IF END FUNCTION indicator FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = mean + sigma * SQRT ( - 2.0_rp * LOG ( rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm SUBROUTINE update_avalanche_params ( params , prtcls ) !! Updates the avalanche parameters aval_params% at each step !! in the MCMC after the profiles are interpolated at the sampled !! R,Z location. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( IN ) :: prtcls !! An instance of PARTICLES containing the variables of a !! given species. Call to this subroutine generally passes spp%vars. aval_params % ne = prtcls % ne ( 1 ) * params % cpp % density aval_params % Zeff = prtcls % Zeff ( 1 ) aval_params % Te = prtcls % Te ( 1 ) * params % cpp % temperature ! In Joules aval_params % lD = SQRT ( C_E0 * aval_params % Te / ( aval_params % ne * C_E ** 2 )) aval_params % bmin = aval_params % Zeff / ( 1 2.0_rp * C_PI * aval_params % ne * & aval_params % lD ** 2 ) aval_params % CoulombLog = LOG ( aval_params % lD / aval_params % bmin ) aval_params % Tau = 1.0_rp / ( 4.0_rp * C_PI * C_C * C_RE ** 2 * aval_params % ne * & aval_params % CoulombLog ) aval_params % Ec = C_ME * C_C / ( C_E * aval_params % Tau ) aval_params % Ebar = aval_params % Epar / aval_params % Ec aval_params % alpha = ( aval_params % Ebar - 1.0_rp ) / ( 1.0_rp + & aval_params % Zeff ) aval_params % cz = SQRT ( 3.0_rp * ( aval_params % Zeff + 5.0_rp ) / C_PI ) * & aval_params % CoulombLog aval_params % fo = aval_params % alpha / aval_params % cz aval_params % C1 = 0.5_rp * aval_params % alpha aval_params % C2 = 1.0_rp / aval_params % cz - aval_params % C1 END SUBROUTINE update_avalanche_params subroutine Avalanche_4D ( params , spp , P , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: P_samples !! Magnitude of momentum of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: T_samples !! Pitch angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: mom !! Magnitude of momentum of samples on individual mpi process REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers REAL ( rp ) :: max_p !! Maximum domain for momentum sampling including buffer REAL ( rp ) :: min_p !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: P_buffer !! Previous sample of momentum REAL ( rp ) :: T_buffer !! Previous sample of pitch angle REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: P_test !! Present sample of momentum REAL ( rp ) :: T_test !! Present sample of pitch angle REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: fRE0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: fRE1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator ALLOCATE ( mom ( spp % ppp )) nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.1_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp ! buffer at minimum p boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_p - REAL ( ii , rp ) * ( aval_params % max_p - & aval_params % min_p ) / 100_rp if ( minmax . GT . 0.0_rp ) then min_p = minmax end if end do ! buffer at maximum p boundary max_p = aval_params % max_p + minmax_buffer_size * ( aval_params % max_p - & aval_params % min_p ) / 100_rp ! buffer at minimum pitch angle boundary if ( aval_params % min_pitch_angle . GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_pitch_angle - REAL ( ii , rp ) * & ( aval_params % max_pitch_angle - aval_params % min_pitch_angle ) / 100_rp if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = aval_params % min_pitch_angle end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % max_pitch_angle + REAL ( ii , rp ) * & ( aval_params % max_pitch_angle - aval_params % min_pitch_angle ) / 100_rp if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( P_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( T_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo call RANDOM_NUMBER ( rand_unif ) T_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) P_buffer = min_p + ( max_p - min_p ) * rand_unif !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length ii = 1_idef do while ( ii . LE . 1000_idef ) !        write(output_unit_write,'(\"burn:\",I15)') ii R_test = R_buffer + random_norm ( 0.0_rp , aval_params % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , aval_params % dZ ) P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) ! Test that pitch angle and momentum are within chosen boundary do while (( T_test . GT . aval_params % max_pitch_angle ). OR . & ( T_test . LT . aval_params % min_pitch_angle )) T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) end do do while (( P_test . LT . aval_params % min_p ). OR . & ( P_test . GT . aval_params % max_p )) P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) ! Repetedly put location of sample into first entry of spp%vars%Y, ! beacause spp%vas%X isn't filled until the end of this subrouting. ! This allows us to use the machinery for calling PSPLINES ! interpolation routines here also. spp % vars % Y ( 1 , 1 ) = R_buffer spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_buffer call get_profiles ( params , spp % vars , P , F ) !           write(output_unit_write,'(\"ne\",E17.10)') spp%vars%ne(1) !           write(output_unit_write,'(\"Te\",E17.10)') spp%vars%Te(1) !           write(output_unit_write,'(\"Zeff\",E17.10)') spp%vars%Zeff(1) ! Update avalanche parameters with interpolated fields to be used ! in call to avalanche distribution function call update_avalanche_params ( params , spp % vars ) fRE0 = fRE ( cos ( deg2rad ( T_buffer )), P_buffer ) else psi0 = psi1 fRE0 = fRE1 end if psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test call get_profiles ( params , spp % vars , P , F ) call update_avalanche_params ( params , spp % vars ) fRE1 = fRE ( COS ( deg2rad ( T_test )), P_test ) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator ( psi1 , spp % psi_max ) * R_test * EXP ( - psi1 ) * & sin ( deg2rad ( T_test )) * fRE1 / ( R_buffer * EXP ( - psi0 ) * & sin ( deg2rad ( T_buffer )) * fRE0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , 10000 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if R_test = R_buffer + random_norm ( 0.0_rp , aval_params % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , aval_params % dZ ) P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) ! Selection boundary is set with buffer region do while (( T_test . GT . max_pitch_angle ). OR . & ( T_test . LT . min_pitch_angle )) if ( T_test . lt . 0 ) then T_test = abs ( T_test ) exit end if T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) end do do while (( P_test . LT . min_p ). OR .( P_test . GT . max_p )) if ( P_test . lt . 0 ) then P_test = abs ( P_test ) exit end if P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) end do psi0 = psi1 fRE0 = fRE1 psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test call get_profiles ( params , spp % vars , P , F ) call update_avalanche_params ( params , spp % vars ) fRE1 = fRE ( COS ( deg2rad ( T_test )), P_test ) ratio = indicator ( psi1 , psi_max_buff ) * R_test * EXP ( - psi1 ) * & sin ( deg2rad ( T_test )) * fRE1 / ( R_buffer * EXP ( - psi0 ) * & sin ( deg2rad ( T_buffer )) * fRE0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test end if end if ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator ( psi1 , spp % psi_max )). EQ . 1 ). AND . & ( P_buffer . LE . aval_params % max_p ). AND . & ( P_buffer . GE . aval_params % min_p ). AND . & ( T_buffer . LE . aval_params % max_pitch_angle ). AND . & ( T_buffer . GE . aval_params % min_pitch_angle )) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer P_samples ( ii ) = P_buffer T_samples ( ii ) = T_buffer ! Sample phi location uniformly call RANDOM_NUMBER ( rand_unif ) PHI_samples ( ii ) = 2.0_rp * C_PI * rand_unif ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length end if CALL MPI_SCATTER ( R_samples * cos ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( R_samples * sin ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( P_samples , spp % ppp , MPI_REAL8 , & mom , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( T_samples , spp % ppp , MPI_REAL8 , & spp % vars % eta , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum spp % vars % g = SQRT ( 1.0_rp + mom ** 2 ) if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' DEALLOCATE ( mom ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( P_samples ) DEALLOCATE ( T_samples ) end if end subroutine Avalanche_4D SUBROUTINE save_avalanche_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"avalanche_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , aval_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , aval_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * aval_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * aval_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , aval_params % max_p , attr ) dset = TRIM ( gname ) // \"/min_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , aval_params % min_p , attr ) dset = TRIM ( gname ) // \"/ne\" attr = \"Background electron density (m&#94;-3)\" call save_to_hdf5 ( h5file_id , dset , aval_params % ne , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , aval_params % Zeff , attr ) dset = TRIM ( gname ) // \"/Ec\" attr = \"Critical electric field in (V/m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % Ec , attr ) dset = TRIM ( gname ) // \"/Epar\" attr = \"Parallel electric field in (V/m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % Epar , attr ) dset = TRIM ( gname ) // \"/Te\" attr = \"Background electron temperature (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * aval_params % Te , attr ) dset = TRIM ( gname ) // \"/lambda_D\" attr = \"Debye length (m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % lD , attr ) dset = TRIM ( gname ) // \"/bmin\" attr = \"Maximum approach radius (m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % bmin , attr ) dset = TRIM ( gname ) // \"/Clog\" attr = \"Coulomb logarithm\" call save_to_hdf5 ( h5file_id , dset , aval_params % CoulombLog , attr ) dset = TRIM ( gname ) // \"/Tau\" attr = \"Collision time (s)\" call save_to_hdf5 ( h5file_id , dset , aval_params % Tau , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_avalanche_params END MODULE korc_avalanche","tags":"","loc":"sourcefile/korc_avalanche.f90.html"},{"title":"korc_units.f90 – KORC-Full Orbit","text":"Contents Modules korc_units Source Code korc_units.f90 Source Code module korc_units !! @note Module with subroutines that calculate the characteristic !! scales in the simulation used in the normalization and !! nondimensionalization of the simulation variables. @endnote use korc_types use korc_constants use korc_input IMPLICIT NONE PUBLIC :: compute_charcs_plasma_params ,& normalize_variables CONTAINS subroutine compute_charcs_plasma_params ( params , spp , F ) !! @note Subroutine that calculates characteristic scales of !! the current KORC simulation. @endnote !! Normalization and non-dimensionalization of the variables and equations !! of motion allows us to solve them more accurately by reducing truncation !! erros when performing operations that combine small and large numbers. !! !! For normalizing and obtaining the non-dimensional form of the variables !! and equations solved in KORC we use characteristic scales calculated with !! the input data of each KORC simulation. !! <table cellspacing=\"10\"> !! <caption id=\"multi_row\">Characteristic scales in KORC</caption> !! <tr><th>Characteristic scale</th>\t<th>Symbol</th>\t        <th>Value</th>\t\t\t<th>Description</th></tr> !! <tr><td rowspan=\"1\">Velocity \t<td>v_{ch}\t\t<td>c\t\t\t<td> Speed of light !! <tr><td rowspan=\"1\">Time \t\t<td>t_{ch}\t\t<td>\\Omega&#94;{-1} = m_{ch}/q_{ch}B_{ch} \t<td> Inverse of electron cyclotron frequency !! <tr><td rowspan=\"1\">Relativistic time <td>t_{r,ch}\t<td>\\Omega_r&#94;{-1} = \\gamma m_{ch}/q_{ch}B_{ch} \t<td> Inverse of relativistic electron cyclotron frequency !! <tr><td rowspan=\"1\">Length \t<td>l_{ch}\t\t<td>v_{ch}t_{ch}\t\t<td>-- !! <tr><td rowspan=\"1\">Mass \t\t<td>m_{ch}\t\t<td>m_e\t\t\t<td> Electron mass !! <tr><td rowspan=\"1\">Charge \t<td>q_{ch}\t\t<td>e\t\t\t<td> Absolute value of electron charge !! <tr><td rowspan=\"1\">Momentum       <td>p_{ch}\t        <td>m_{ch}v_{ch} \t        <td> -- !! <tr><td rowspan=\"1\">Magnetic field <td>B_{ch}\t\t<td>B_0\t\t        <td> Magnetic field at the magnetic axis !! <tr><td rowspan=\"1\">Electric field <td>E_{ch}\t\t<td>v_{ch}B_{ch}\t\t<td> -- !! <tr><td rowspan=\"1\">Energy \t<td>\\mathcal{E}_{ch}<td>m_{ch}v_{ch}&#94;2\t\t<td>-- !! <tr><td rowspan=\"1\">Temperature \t<td>T_{ch}\t\t<td>m_{ch}v_{ch}&#94;2\t\t<td> Temperature given in Joules. !! <tr><td rowspan=\"1\">Density \t<td>n_{ch}\t\t<td>l_{ch}&#94;{-3}\t\t<td>-- !! <tr><td rowspan=\"1\">Magnetic moment \t<td>\\mu_{ch}<td>m_{ch}v_{ch}&#94;2/B_{ch}\t<td>-- !! <tr><td rowspan=\"1\">Pressure \t<td>P_{ch}\t\t<td>--\t\t                <td>-- !! </table> !! With these characteristic scales we can write the dimensionless !! form of all the equations. For example, the Lorentz force for a !! charged particle q, mass m, and momentum !! \\mathbf{p}=\\gamma m \\mathbf{v} can be written as: !! !! \\frac{d \\mathbf{p}'}{dt'} = q'\\left[ \\mathbf{E}' + !! \\frac{\\mathbf{p}'}{\\gamma m'}\\times \\mathbf{B}' \\right], !! !! where \\mathbf{p}' = \\mathbf{p}/p_{ch}, t' = t/t_{ch}, !! q' = q/q_{ch}, m' = m/m_{ch}, \\mathbf{E}' = \\mathbf{E}/E_{ch}, !! and \\mathbf{B}'=\\mathbf{B}/B_{ch}. !! @todo Characteristic pressure needs to be defined. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the !! information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the !! information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. INTEGER :: ii !! Index of the spp array containing the mass, electric charge !! and corresponding cyclotron frequency used to derived some characteristic scales. params % cpp % velocity = C_C params % cpp % Bo = ABS ( F % Bo ) params % cpp % Eo = ABS ( params % cpp % velocity * params % cpp % Bo ) ! Non-relativistic cyclotron frequency spp (:)% wc = ( ABS ( spp (:)% q ) / spp (:)% m ) * params % cpp % Bo ! Relativistic cyclotron frequency spp (:)% wc_r = ABS ( spp (:)% q ) * params % cpp % Bo / ( spp (:)% go * spp (:)% m ) ii = MAXLOC ( spp (:)% wc , 1 ) ! Index to maximum cyclotron frequency params % cpp % time = 1.0_rp / spp ( ii )% wc ii = MAXLOC ( spp (:)% wc_r , 1 ) ! Index to maximum relativistic cyclotron frequency params % cpp % time_r = 1.0_rp / spp ( ii )% wc_r params % cpp % mass = C_ME params % cpp % charge = C_E params % cpp % length = params % cpp % velocity * params % cpp % time params % cpp % energy = params % cpp % mass * params % cpp % velocity ** 2 params % cpp % density = 1.0_rp / params % cpp % length ** 3 params % cpp % pressure = 0.0_rp params % cpp % temperature = params % cpp % energy end subroutine compute_charcs_plasma_params subroutine normalize_variables ( params , spp , F , P ) !! @note Subroutine that normalizes the simulation variables with !! the previously computed characteristic scales. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! @param[in,out] F An instance of KORC's derived type FIELDS !! containing all the information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! @param[in,out] P An instance of KORC's derived type PROFILES containing all the information about the plasma profiles used in !! the simulation. See korc_types.f90 and korc_profiles.f90. INTEGER :: ii !! @param ii Interator of spp array. !\tNormalize params variables params % dt = params % dt / params % cpp % time params % simulation_time = params % simulation_time / params % cpp % time params % snapshot_frequency = params % snapshot_frequency / params % cpp % time params % minimum_particle_energy = params % minimum_particle_energy / params % cpp % energy params % init_time = params % init_time / params % cpp % time !\tNormalize particle variables do ii = 1_idef , size ( spp ) spp ( ii )% q = spp ( ii )% q / params % cpp % charge spp ( ii )% m = spp ( ii )% m / params % cpp % mass spp ( ii )% Eo = spp ( ii )% Eo / params % cpp % energy spp ( ii )% Eo_lims = spp ( ii )% Eo_lims / params % cpp % energy spp ( ii )% wc = spp ( ii )% wc * params % cpp % time spp ( ii )% wc_r = spp ( ii )% wc_r * params % cpp % time spp ( ii )% vars % X = spp ( ii )% vars % X / params % cpp % length spp ( ii )% vars % V = spp ( ii )% vars % V / params % cpp % velocity spp ( ii )% vars % Rgc = spp ( ii )% vars % Rgc / params % cpp % length spp ( ii )% Ro = spp ( ii )% Ro / params % cpp % length spp ( ii )% Zo = spp ( ii )% Zo / params % cpp % length spp ( ii )% r_inner = spp ( ii )% r_inner / params % cpp % length spp ( ii )% r_outter = spp ( ii )% r_outter / params % cpp % length spp ( ii )% sigmaR = spp ( ii )% sigmaR / params % cpp % length spp ( ii )% sigmaZ = spp ( ii )% sigmaZ / params % cpp % length spp ( ii )% falloff_rate = spp ( ii )% falloff_rate * params % cpp % length spp ( ii )% Xtrace = spp ( ii )% Xtrace / params % cpp % length spp ( ii )% Spong_b = spp ( ii )% Spong_b / params % cpp % length spp ( ii )% Spong_w = spp ( ii )% Spong_w / params % cpp % length spp ( ii )% dR = spp ( ii )% dR / params % cpp % length spp ( ii )% dZ = spp ( ii )% dZ / params % cpp % length end do !\tNormalize electromagnetic fields and profiles F % Bo = F % Bo / params % cpp % Bo F % Eo = F % Eo / params % cpp % Eo F % Ro = F % Ro / params % cpp % length F % Zo = F % Zo / params % cpp % length F % E_dyn = F % E_dyn / params % cpp % Eo F % E_pulse = F % E_pulse / params % cpp % time F % E_width = F % E_width / params % cpp % time F % t0_2x1t = F % t0_2x1t / params % cpp % time P % a = P % a / params % cpp % length P % R0 = P % R0 / params % cpp % length P % Z0 = P % Z0 / params % cpp % length P % R0_RE = P % R0_RE / params % cpp % length P % Z0_RE = P % Z0_RE / params % cpp % length P % neo = P % neo / params % cpp % density P % n_ne = P % n_ne / params % cpp % density P % n_shelf = P % n_shelf / params % cpp % density P % Teo = P % Teo / params % cpp % temperature P % n_REr0 = P % n_REr0 / params % cpp % length P % n_tauion = P % n_tauion / params % cpp % time P % n_tauin = P % n_tauin / params % cpp % time P % n_tauout = P % n_tauout / params % cpp % time P % n_shelfdelay = P % n_shelfdelay / params % cpp % time P % n_lamfront = P % n_lamfront / params % cpp % length P % n_lamback = P % n_lamback / params % cpp % length P % n_lamshelf = P % n_lamshelf / params % cpp % length if ( params % profile_model . EQ . 'ANALYTICAL' ) then if ( params % field_eval . eq . 'interp' ) then if ( ALLOCATED ( P % X % R )) P % X % R = P % X % R / params % cpp % length if ( ALLOCATED ( P % X % Z )) P % X % Z = P % X % Z / params % cpp % length if ( ALLOCATED ( P % ne_2D )) P % ne_2D = P % ne_2D / params % cpp % density if ( ALLOCATED ( P % Te_2D )) P % Te_2D = P % Te_2D / params % cpp % temperature end if else if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( ALLOCATED ( P % X % R )) P % X % R = P % X % R / params % cpp % length if ( ALLOCATED ( P % X % Z )) P % X % Z = P % X % Z / params % cpp % length if ( ALLOCATED ( P % ne_2D )) P % ne_2D = P % ne_2D / params % cpp % density if ( ALLOCATED ( P % Te_2D )) P % Te_2D = P % Te_2D / params % cpp % temperature if ( ALLOCATED ( P % ne_3D )) P % ne_3D = P % ne_3D / params % cpp % density if ( ALLOCATED ( P % Te_3D )) P % Te_3D = P % Te_3D / params % cpp % temperature end if if ( params % field_model ( 1 : 10 ) . EQ . 'ANALYTICAL' ) then F % AB % Bo = F % AB % Bo / params % cpp % Bo F % AB % a = F % AB % a / params % cpp % length F % AB % Ro = F % AB % Ro / params % cpp % length F % AB % lambda = F % AB % lambda / params % cpp % length F % AB % Bpo = F % AB % Bpo / params % cpp % Bo if ( params % field_eval . eq . 'interp' ) then if ( ALLOCATED ( F % B_2D % R )) F % B_2D % R = F % B_2D % R / params % cpp % Bo if ( ALLOCATED ( F % B_2D % PHI )) F % B_2D % PHI = F % B_2D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_2D % Z )) F % B_2D % Z = F % B_2D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_2D % R )) F % E_2D % R = F % E_2D % R / params % cpp % Eo if ( ALLOCATED ( F % E_2D % PHI )) F % E_2D % PHI = F % E_2D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_2D % Z )) F % E_2D % Z = F % E_2D % Z / params % cpp % Eo if ( ALLOCATED ( F % B_3D % R )) F % B_3D % R = F % B_3D % R / params % cpp % Bo if ( ALLOCATED ( F % B_3D % PHI )) F % B_3D % PHI = F % B_3D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_3D % Z )) F % B_3D % Z = F % B_3D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_3D % R )) F % E_3D % R = F % E_3D % R / params % cpp % Eo if ( ALLOCATED ( F % E_3D % PHI )) F % E_3D % PHI = F % E_3D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_3D % Z )) F % E_3D % Z = F % E_3D % Z / params % cpp % Eo if ( ALLOCATED ( F % PSIp )) F % PSIp = F % PSIp / & ( params % cpp % Bo * params % cpp % length ** 2 ) F % PSIP_min = F % PSIP_min / & ( params % cpp % Bo * params % cpp % length ** 2 ) if (. not . params % field_model . eq . 'M3D_C1' ) then F % PSIp_lim = F % PSIp_lim / & ( params % cpp % Bo * params % cpp % length ** 2 ) end if F % X % R = F % X % R / params % cpp % length ! Nothing to do for the PHI component F % X % Z = F % X % Z / params % cpp % length if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then if ( ALLOCATED ( F % gradB_2D % R )) F % gradB_2D % R = F % gradB_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % PHI )) F % gradB_2D % PHI = F % gradB_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % Z )) F % gradB_2D % Z = F % gradB_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % R )) F % curlb_2D % R = F % curlb_2D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % PHI )) F % curlb_2D % PHI = F % curlb_2D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % Z )) F % curlb_2D % Z = F % curlb_2D % Z / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % R )) F % gradB_3D % R = F % gradB_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % PHI )) F % gradB_3D % PHI = F % gradB_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % Z )) F % gradB_3D % Z = F % gradB_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % R )) F % curlb_3D % R = F % curlb_3D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % PHI )) F % curlb_3D % PHI = F % curlb_3D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % Z )) F % curlb_3D % Z = F % curlb_3D % Z / & ( 1. / params % cpp % length ) end if end if else if ( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( ALLOCATED ( F % B_3D % R )) F % B_3D % R = F % B_3D % R / params % cpp % Bo if ( ALLOCATED ( F % B_3D % PHI )) F % B_3D % PHI = F % B_3D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_3D % Z )) F % B_3D % Z = F % B_3D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_3D % R )) F % E_3D % R = F % E_3D % R / params % cpp % Eo if ( ALLOCATED ( F % E_3D % PHI )) F % E_3D % PHI = F % E_3D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_3D % Z )) F % E_3D % Z = F % E_3D % Z / params % cpp % Eo if ( ALLOCATED ( F % PSIp )) F % PSIp = F % PSIp / ( params % cpp % Bo * params % cpp % length ** 2 ) if ( ALLOCATED ( F % PSIp3D )) F % PSIp3D = F % PSIp3D / & ( params % cpp % Bo * params % cpp % length ** 2 ) F % PSIP_min = F % PSIP_min / ( params % cpp % Bo * params % cpp % length ** 2 ) F % PSIp_lim = F % PSIp_lim / ( params % cpp % Bo * params % cpp % length ** 2 ) if ( ALLOCATED ( F % B_2D % R )) F % B_2D % R = F % B_2D % R / params % cpp % Bo if ( ALLOCATED ( F % B_2D % PHI )) F % B_2D % PHI = F % B_2D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_2D % Z )) F % B_2D % Z = F % B_2D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_2D % R )) F % E_2D % R = F % E_2D % R / params % cpp % Eo if ( ALLOCATED ( F % E_2D % PHI )) F % E_2D % PHI = F % E_2D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_2D % Z )) F % E_2D % Z = F % E_2D % Z / params % cpp % Eo if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then if ( ALLOCATED ( F % gradB_2D % R )) F % gradB_2D % R = F % gradB_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % PHI )) F % gradB_2D % PHI = F % gradB_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % Z )) F % gradB_2D % Z = F % gradB_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % R )) F % curlb_2D % R = F % curlb_2D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % PHI )) F % curlb_2D % PHI = F % curlb_2D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % Z )) F % curlb_2D % Z = F % curlb_2D % Z / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % R )) F % gradB_3D % R = F % gradB_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % PHI )) F % gradB_3D % PHI = F % gradB_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % Z )) F % gradB_3D % Z = F % gradB_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % R )) F % curlb_3D % R = F % curlb_3D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % PHI )) F % curlb_3D % PHI = F % curlb_3D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % Z )) F % curlb_3D % Z = F % curlb_3D % Z / & ( 1. / params % cpp % length ) end if if ( F % dBfield ) then if ( ALLOCATED ( F % dBdR_2D % R )) F % dBdR_2D % R = F % dBdR_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_2D % PHI )) F % dBdR_2D % PHI = F % dBdR_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_2D % Z )) F % dBdR_2D % Z = F % dBdR_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_2D % R )) F % dBdPHI_2D % R = F % dBdPHI_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_2D % PHI )) F % dBdPHI_2D % PHI = F % dBdPHI_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_2D % Z )) F % dBdPHI_2D % Z = F % dBdPHI_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_2D % R )) F % dBdZ_2D % R = F % dBdZ_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_2D % PHI )) F % dBdZ_2D % PHI = F % dBdZ_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_2D % Z )) F % dBdZ_2D % Z = F % dBdZ_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_3D % R )) F % dBdR_3D % R = F % dBdR_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_3D % PHI )) F % dBdR_3D % PHI = F % dBdR_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_3D % Z )) F % dBdR_3D % Z = F % dBdR_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_3D % R )) F % dBdPHI_3D % R = F % dBdPHI_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_3D % PHI )) F % dBdPHI_3D % PHI = F % dBdPHI_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_3D % Z )) F % dBdPHI_3D % Z = F % dBdPHI_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_3D % R )) F % dBdZ_3D % R = F % dBdZ_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_3D % PHI )) F % dBdZ_3D % PHI = F % dBdZ_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_3D % Z )) F % dBdZ_3D % Z = F % dBdZ_3D % Z / & ( params % cpp % Bo / params % cpp % length ) end if F % X % R = F % X % R / params % cpp % length ! Nothing to do for the PHI component F % X % Z = F % X % Z / params % cpp % length if ( F % Dim2x1t ) then F % X % PHI = F % X % PHI / params % cpp % time end if !     end if end if end subroutine normalize_variables end module korc_units","tags":"","loc":"sourcefile/korc_units.f90.html"},{"title":"korc_initialize.f90 – KORC-Full Orbit","text":"Contents Modules korc_initialize Source Code korc_initialize.f90 Source Code module korc_initialize !! @note Module with subroutines to load simulation parameters !! and to define the time step in the simulation.@endnote use korc_types use korc_constants use korc_hpc use korc_HDF5 use korc_fields use korc_rnd_numbers use korc_spatial_distribution use korc_velocity_distribution use korc_coords use korc_input IMPLICIT NONE PRIVATE :: set_paths ,& load_korc_params PUBLIC :: initialize_korc_parameters ,& initialize_particles ,& define_time_step CONTAINS ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! ! ** SUBROUTINES FOR INITIALIZING KORC PARAMETERS ** ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! subroutine load_korc_params ( params ) !! @note Subroutine that loads the simulation parameters from the !! file specified in params\\%path_to_inputs @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. !LOGICAL \t\t\t\t:: restart !! Flag to indicate if the simulations restarts (restart=T) or not !! (restart=F). Restart simulation that exited before simulation_time !! reached. !LOGICAL \t\t\t\t:: proceed !! Flag to indicate if the simulations proceeds (proceed=T) or not !! (proceed=F). Append simulation results after previous simulation_time !! reached. !LOGICAL  :: reinit !! Flag to begin a new simulation, reinitializing from restart file state !REAL(rp) \t\t\t\t:: simulation_time !! Total simulation time in seconds. !REAL(rp) \t\t\t\t:: snapshot_frequency !! Time between snapshots in time of the simulation. !REAL(rp) \t\t\t\t:: restart_overwrite_frequency !! Time between overwrites of restart file in time of the simulation. !REAL(rp) \t\t\t\t:: dt !! Time step in the simulation as a fraction of the relativistic !! electron gyro-period @f$\\tau_e = 2\\pi\\gamma m_e/eB_0@f$ !REAL(rp) \t\t\t\t:: minimum_particle_energy !! Minimum allowed relativistic factor @f$\\gamma@f$ of simulated electrons. !LOGICAL \t\t\t\t:: radiation !! Flag to indicate if synchrotron radiation losses are included !! (radiation=T) or not (radiation=F). !LOGICAL \t\t\t\t:: collisions !! Flag to indicate if collisionsare included (collisions=T) or not !! (collisions=F). !CHARACTER(MAX_STRING_LENGTH) \t\t:: GC_rad_model !CHARACTER(MAX_STRING_LENGTH) \t\t:: collisions_model !! String with the name of the collisions model to be used in the simulation. !CHARACTER(MAX_STRING_LENGTH) \t\t:: bound_electron_model !CHARACTER(MAX_STRING_LENGTH) \t\t:: profile_model !! String with the name of the model for the plasma profiles. !CHARACTER(MAX_STRING_LENGTH) \t\t:: field_model !! String with the name of the model for the field profiles. !CHARACTER(MAX_STRING_LENGTH) \t\t:: magnetic_field_filename !! String with the name of the model for the fields and plasma profiles. !CHARACTER(MAX_STRING_LENGTH) \t\t:: outputs_list !! List of electron variables to include in the outputs. !INTEGER \t\t\t\t:: num_species !! Number of different populations of simulated relativistic electrons !! in KORC. INTEGER :: imax !! Auxiliary variable used to parse the output_list INTEGER :: imin !! Auxiliary variable used to parse the output_list INTEGER :: ii !! Iterator used to parse the output_list INTEGER :: jj !! Iterator used to parse the output_list INTEGER :: num_outputs !! Auxiliary variable used to parse the output_list INTEGER , DIMENSION ( 2 ) :: indices !! Auxiliary variable used to parse the output_list !LOGICAL \t\t\t\t:: HDF5_error_handling !! Flag for HDF5 error handling !LOGICAL \t\t:: FO_GC_compare !CHARACTER(MAX_STRING_LENGTH) \t\t:: orbit_model !! String with the name of the orbit model ('FO' or 'GC'). !CHARACTER(MAX_STRING_LENGTH) :: field_eval !! String with the name of the field evaluation method for !! analytical fields ('interp' or 'eqn') !LOGICAL \t\t\t\t:: FokPlan !! Flag to decouple spatial-dependence of evolution !LOGICAL :: SameRandSeed !LOGICAL :: SC_E !LOGICAL :: SC_E_add !INTEGER                           :: time_slice !REAL(rp)                          :: rmax,rmin,zmax,zmin !INTEGER                           :: pchunk !NAMELIST /input_parameters/ restart,field_model,magnetic_field_filename, & !     simulation_time,snapshot_frequency,dt,num_species,radiation, & !     collisions,collisions_model,outputs_list,minimum_particle_energy, & !     HDF5_error_handling,orbit_model,field_eval,proceed,profile_model, & !     restart_overwrite_frequency,FokPlan,GC_rad_model, & !     bound_electron_model,FO_GC_compare,SameRandSeed,SC_E,reinit, & !     SC_E_add,time_slice,rmax,rmin,zmax,zmin,pchunk !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=input_parameters) !close(default_unit_open) params % restart = restart params % proceed = proceed params % reinit = reinit params % simulation_time = simulation_time params % snapshot_frequency = snapshot_frequency params % restart_overwrite_frequency = restart_overwrite_frequency params % dt = dt params % num_species = num_species params % profile_model = TRIM ( profile_model ) params % field_model = TRIM ( field_model ) params % magnetic_field_filename = TRIM ( magnetic_field_filename ) params % time_slice = time_slice params % rmax = rmax params % rmin = rmin params % zmax = zmax params % zmin = zmin params % minimum_particle_energy = minimum_particle_energy * C_E params % minimum_particle_g = 1.0_rp + params % minimum_particle_energy / & ( C_ME * C_C ** 2 ) ! Minimum value of relativistic gamma factor params % radiation = radiation params % collisions = collisions params % collisions_model = TRIM ( collisions_model ) params % bound_electron_model = TRIM ( bound_electron_model ) params % GC_rad_model = TRIM ( GC_rad_model ) if ( HDF5_error_handling ) then params % HDF5_error_handling = 1_idef else params % HDF5_error_handling = 0_idef end if params % orbit_model = orbit_model params % FO_GC_compare = FO_GC_compare params % field_eval = field_eval params % GC_coords = . FALSE . params % FokPlan = FokPlan params % SameRandSeed = SameRandSeed params % SC_E = SC_E params % SC_E_add = SC_E_add params % pchunk = pchunk ! Loading list of output parameters (parsing) imin = SCAN ( outputs_list , '{' ) imax = SCAN ( outputs_list , '}' ) ii = 1_idef jj = 1_idef num_outputs = 1_idef do while ( ii . NE . 0 ) ii = SCAN ( outputs_list ( jj :), \",\" ) if ( ii . NE . 0 ) then jj = jj + ii num_outputs = num_outputs + 1_idef end if end do ALLOCATE ( params % outputs_list ( num_outputs )) if ( num_outputs . GT . 1_idef ) then indices = 0_idef indices ( 2 ) = SCAN ( outputs_list , \",\" ) params % outputs_list ( 1 ) = TRIM ( outputs_list ( imin + 1_idef : indices ( 2 ) - 1_idef )) indices ( 1 ) = indices ( 1 ) + indices ( 2 ) + 1_idef do ii = 2_idef , num_outputs indices ( 2 ) = SCAN ( outputs_list ( indices ( 1 ):), \",\" ) if ( indices ( 2 ). EQ . 0_idef ) then params % outputs_list ( ii ) = TRIM ( outputs_list ( indices ( 1 ): imax - 1_idef )) else params % outputs_list ( ii ) = TRIM ( outputs_list ( indices ( 1 ): indices ( 1 ) + indices ( 2 ) - 2_idef )) indices ( 1 ) = indices ( 1 ) + indices ( 2 ) end if end do else params % outputs_list ( 1 ) = TRIM ( outputs_list ( imin + 1_idef : imax - 1_idef )) end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * SIMULATION PARAMETERS * * * * *\")' ) write ( output_unit_write , '(\"Restarting simulation: \",L1)' ) params % restart write ( output_unit_write , '(\"Continuing simulation: \",L1)' ) params % proceed write ( output_unit_write , '(\"Number of electron populations: \",I16)' ) params % num_species write ( output_unit_write , * ) 'Orbit model: ' , TRIM ( params % orbit_model ) write ( output_unit_write , * ) 'Magnetic field model: ' , TRIM ( params % field_model ) write ( output_unit_write , * ) 'Magnetic field evaluation: ' , TRIM ( params % field_eval ) if ( TRIM ( params % field_model ). EQ . 'EXTERNAL' ) then write ( output_unit_write , * ) 'Magnetic field file: ' , TRIM ( params % magnetic_field_filename ) end if write ( output_unit_write , '(\"Radiation losses included: \",L1)' ) params % radiation if ( params % radiation . and .( params % orbit_model ( 1 : 2 ). eq . 'GC' )) then write ( output_unit_write , * ) 'Radiation model: ' , TRIM ( params % GC_rad_model ) end if write ( output_unit_write , '(\"Collisions losses included: \",L1)' ) params % collisions if ( params % collisions ) then write ( output_unit_write , * ) 'Collision model: ' , TRIM ( params % collisions_model ) write ( output_unit_write , * ) & 'Bound electron model: ' , TRIM ( params % bound_electron_model ) end if write ( output_unit_write , '(\"Self-consistent E included: \",L1)' ) params % SC_E write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine load_korc_params subroutine initialize_korc_parameters ( params ) !! @note Interface for calling initialization subroutines @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: mpierr !! MPI error status. call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call read_namelist ( params , params % path_to_inputs ,. true ., params % path_to_outputs ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call load_korc_params ( params ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) end subroutine initialize_korc_parameters subroutine define_time_step ( params ) !! @note Subroutine that defines or loads from restart file the time !! stepping parameters. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. if ( params % restart ) then call load_time_stepping_params ( params ) else if ( params % proceed ) then call load_prev_time ( params ) params % ito = 1_ip params % dt = params % dt * ( 2.0_rp * C_PI * params % cpp % time_r ) params % t_steps = CEILING (( params % simulation_time - params % init_time ) / & params % dt , ip ) params % output_cadence = FLOOR ( params % snapshot_frequency / params % dt , ip ) if ( params % output_cadence . EQ . 0_ip ) params % output_cadence = 1_ip params % num_snapshots = params % t_steps / params % output_cadence params % restart_output_cadence = FLOOR ( params % restart_overwrite_frequency / & params % dt , ip ) params % t_skip = min ( params % t_steps , params % output_cadence ) params % t_skip = max ( 1_ip , params % t_skip ) else params % ito = 1_ip params % dt = params % dt * ( 2.0_rp * C_PI * params % cpp % time_r ) params % t_steps = CEILING ( params % simulation_time / params % dt , ip ) params % output_cadence = FLOOR ( params % snapshot_frequency / params % dt , ip ) if ( params % output_cadence . EQ . 0_ip ) params % output_cadence = 1_ip params % num_snapshots = params % t_steps / params % output_cadence params % restart_output_cadence = FLOOR ( params % restart_overwrite_frequency / & params % dt , ip ) params % t_skip = min ( params % t_steps , params % output_cadence ) params % t_skip = max ( 1_ip , params % t_skip ) end if !    write(output_unit_write,*) 'dt',params%dt,'t_skip',params%t_skip if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * TIME STEPPING PARAMETERS * * * * *\")' ) write ( output_unit_write , '(\"Simulation time: \",E17.10,\" s\")' ) params % simulation_time write ( output_unit_write , '(\"Initial time: \",E17.10,\" s\")' ) params % init_time write ( output_unit_write , '(\"Output frequency: \",E17.10,\" s\")' ) params % snapshot_frequency write ( output_unit_write , '(\"Relativistic gyro-period: \",E17.10)' ) 2.0_rp * C_PI * & params % cpp % time_r write ( output_unit_write , '(\"Time step: \",E17.10)' ) params % dt write ( output_unit_write , '(\"Number of time steps: \",I16)' ) params % t_steps write ( output_unit_write , '(\"Starting simulation at time step: \",I16)' ) params % ito write ( output_unit_write , '(\"Output cadence: \",I16)' ) params % output_cadence write ( output_unit_write , '(\"Restart cadence: \",I16)' ) params % restart_output_cadence write ( output_unit_write , '(\"Number of outputs: \",I16)' ) params % num_snapshots write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine define_time_step ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! ! * * * SUBROUTINES FOR INITIALIZING PARTICLES * * * ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! subroutine initialize_particles ( params , F , P , spp ) !! @note Subroutine that loads the information of the initial condition !! of the different particle species. This subroutine calls !! the subroutine that generates the initial energy and pitch angle !! distribution functions. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. See [[korc_types]] !!and [[korc_fields]]. TYPE ( PROFILES ), INTENT ( INOUT ) :: P TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the information !! of different electron species. See [[korc_types]]. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: ppp !! Number of computational particles per MPI process !! used to simulate each electron species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: q !! Charge of each species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: m !! Mass of each species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Eo !! Initial energy of each electron species in case of !! using an initial mono-energetic distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: etao !! Initial pitch-angle of each electron species in case of !! using an initial mono-pitch-angle distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Eo_lims !! Minimum and maximum energy limits of a given initial !! non-mono-energetic distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: etao_lims !! Minimum and maximum pitch-angle limits of a given initial !! non-mono-pitch-angle distribution. !LOGICAL, DIMENSION(:), ALLOCATABLE \t\t\t\t:: runaway !! Flag to decide whether a given electron is a runaway (runaway=T) !! or not (runaway=F). !CHARACTER(MAX_STRING_LENGTH),DIMENSION(:),ALLOCATABLE  :: spatial_distribution !! String describing the type of initial spatial distribution for !! each electron species. !CHARACTER(MAX_STRING_LENGTH), DIMENSION(:), ALLOCATABLE :: energy_distribution !! String describing the type of initial energy distribution for each !! electron species. !CHARACTER(MAX_STRING_LENGTH), DIMENSION(:), ALLOCATABLE :: pitch_distribution !! String describing the type of initial pitch-angle distribution !! for each electron species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Ro !! Radial position of the center of the electrons' initial !! spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: PHIo !! Azimuthal position of the electrons' initial spatial distribution, !! in case of using a disk at a certain poloidal section. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Zo !! Height of the center of the electrons' initial spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: r_inner !! Minimum minor radius of the electrons' initial spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: r_outter !! Maximum minor radius of the electrons' initial spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: falloff_rate !! Exponential falloff or standard deviation of a non-uniform radial !! distribution of electrons. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: shear_factor !! Shear factor used to generate an initial spatial !! distribution with an elliptic poloidal cross section. !! See <em>Carbajal and del-Castillo-Negrete, Nuclear Fusion, !! submitted (2018)</em>. !REAL(rp), DIMENSION(:), ALLOCATABLE                           :: sigmaR !! Variance of the first dimension of a 2D Gaussian, spatial !! distribution function !REAL(rp), DIMENSION(:), ALLOCATABLE                           :: sigmaZ !! Variance of the second dimension of a 2D Gaussian, spatial !! distribution function !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: theta_gauss !! Angle of counter-clockwise rotation (in degrees) of 2D Gaussian !! distribution relative to R,Z !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: psi_max !! Maximum value of the argument of the 2D gaussian exponential, used for an !! indicator function that limits the region of MH sampling !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: Spong_b !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: Spong_w !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: Spong_dlam !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: dth,dgam !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: dR !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: dZ INTEGER :: ii !! Iterator of spp structure. INTEGER :: mpierr !! MPI error status. !REAL(rp), DIMENSION(:), ALLOCATABLE :: Xtrace !NAMELIST /plasma_species/ ppp,q,m,Eo,etao,Eo_lims,etao_lims,runaway, & !     spatial_distribution,energy_distribution,pitch_distribution,Ro, & !     PHIo,Zo,r_inner,r_outter,falloff_rate,shear_factor,sigmaR,sigmaZ, & !     theta_gauss,psi_max,Xtrace,Spong_b,Spong_w,Spong_dlam,dth,dR,dZ,dgam ! Allocate array containing variables of particles for each species ALLOCATE ( spp ( params % num_species )) !ALLOCATE(ppp(params%num_species)) !ALLOCATE(q(params%num_species)) !ALLOCATE(m(params%num_species)) !ALLOCATE(Eo(params%num_species)) !ALLOCATE(etao(params%num_species)) !ALLOCATE(Eo_lims(2_idef*params%num_species)) !ALLOCATE(etao_lims(2_idef*params%num_species)) !ALLOCATE(runaway(params%num_species)) !ALLOCATE(spatial_distribution(params%num_species)) !ALLOCATE(energy_distribution(params%num_species)) !ALLOCATE(pitch_distribution(params%num_species)) !ALLOCATE(Ro(params%num_species)) !ALLOCATE(PHIo(params%num_species)) !ALLOCATE(Zo(params%num_species)) !ALLOCATE(r_inner(params%num_species)) !ALLOCATE(r_outter(params%num_species)) !ALLOCATE(falloff_rate(params%num_species)) !ALLOCATE(shear_factor(params%num_species)) !ALLOCATE(sigmaR(params%num_species)) !ALLOCATE(sigmaZ(params%num_species)) !ALLOCATE(theta_gauss(params%num_species)) !ALLOCATE(psi_max(params%num_species)) !ALLOCATE(Spong_b(params%num_species)) !ALLOCATE(Spong_w(params%num_species)) !ALLOCATE(Spong_dlam(params%num_species)) !ALLOCATE(dth(params%num_species)) !ALLOCATE(dgam(params%num_species)) !ALLOCATE(dR(params%num_species)) !ALLOCATE(dZ(params%num_species)) !ALLOCATE(Xtrace(3_idef*params%num_species)) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasma_species) !close(default_unit_open) do ii = 1_idef , params % num_species spp ( ii )% runaway = runaway ( ii ) spp ( ii )% spatial_distribution = TRIM ( spatial_distribution ( ii )) spp ( ii )% energy_distribution = TRIM ( energy_distribution ( ii )) spp ( ii )% pitch_distribution = TRIM ( pitch_distribution ( ii )) spp ( ii )% q = q ( ii ) * C_E spp ( ii )% m = m ( ii ) * C_ME spp ( ii )% ppp = ppp ( ii ) spp ( ii )% Ro = Ro ( ii ) spp ( ii )% PHIo = C_PI * PHIo ( ii ) / 18 0.0_rp spp ( ii )% Zo = Zo ( ii ) spp ( ii )% r_inner = r_inner ( ii ) spp ( ii )% r_outter = r_outter ( ii ) spp ( ii )% falloff_rate = falloff_rate ( ii ) spp ( ii )% shear_factor = shear_factor ( ii ) spp ( ii )% sigmaR = sigmaR ( ii ) spp ( ii )% sigmaZ = sigmaZ ( ii ) spp ( ii )% theta_gauss = theta_gauss ( ii ) spp ( ii )% psi_max = psi_max ( ii ) spp ( ii )% Spong_w = Spong_w ( ii ) spp ( ii )% Spong_b = Spong_b ( ii ) spp ( ii )% Spong_dlam = Spong_dlam ( ii ) spp ( ii )% dth = dth ( ii ) spp ( ii )% dgam = dgam ( ii ) spp ( ii )% dR = dR ( ii ) spp ( ii )% dZ = dZ ( ii ) ! * * These values can change in initial_energy_pitch_dist * * ! spp ( ii )% Eo = Eno ( ii ) * C_E spp ( ii )% Eo_lims = Eo_lims (( ii - 1_idef ) * 2_idef + 1_idef : 2_idef * ii ) * C_E spp ( ii )% etao = etao ( ii ) spp ( ii )% etao_lims = etao_lims (( ii - 1_idef ) * 2_idef + 1_idef : 2_idef * ii ) ! * * These values can change in initial_energy_pitch_dist * * ! if ( spp ( ii )% spatial_distribution . eq . 'TRACER' ) & spp ( ii )% Xtrace = Xtrace (( ii - 1_idef ) * 3_idef + 1_idef : 3_idef * ii ) ALLOCATE ( spp ( ii )% vars % X ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % V ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % Rgc ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % Y ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % E ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % B ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % PSI_P ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % ne ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Te ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Zeff ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % g ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % eta ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % mu ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Prad ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Pin ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % flagCon ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % flagCol ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % wt ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % hint ( spp ( ii )% ppp )) !     write(output_unit_write,'(\"0 size of PSI_P: \",I16)') size(spp(ii)%vars%PSI_P) spp ( ii )% vars % X = 0.0_rp spp ( ii )% vars % V = 0.0_rp spp ( ii )% vars % Rgc = 0.0_rp spp ( ii )% vars % Y = 0.0_rp spp ( ii )% vars % E = 0.0_rp spp ( ii )% vars % B = 0.0_rp spp ( ii )% vars % PSI_P = 0.0_rp spp ( ii )% vars % ne = 0.0_rp spp ( ii )% vars % Te = 0.0_rp spp ( ii )% vars % Zeff = 0.0_rp spp ( ii )% vars % g = 0.0_rp spp ( ii )% vars % eta = 0.0_rp spp ( ii )% vars % mu = 0.0_rp spp ( ii )% vars % Prad = 0.0_rp spp ( ii )% vars % Pin = 0.0_rp spp ( ii )% vars % flagCon = 1_is spp ( ii )% vars % flagCol = 1_is spp ( ii )% vars % wt = 0.0_rp if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then ALLOCATE ( spp ( ii )% vars % Y0 ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % V0 ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % k1 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k2 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k3 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k4 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k5 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k6 ( spp ( ii )% ppp , 4 ) ) if ( params % orbit_model ( 3 : 5 ) == 'pre' . or . params % field_model == 'M3D_C1' ) then ALLOCATE ( spp ( ii )% vars % gradB ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % curlb ( spp ( ii )% ppp , 3 ) ) spp ( ii )% vars % gradB = 0.0_rp spp ( ii )% vars % curlb = 0.0_rp else if ( params % orbit_model ( 3 : 6 ) == 'grad' ) then ALLOCATE ( spp ( ii )% vars % BR ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % BPHI ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % BZ ( spp ( ii )% ppp , 3 ) ) spp ( ii )% vars % BR = 0.0_rp spp ( ii )% vars % BPHI = 0.0_rp spp ( ii )% vars % BZ = 0.0_rp end if ALLOCATE ( spp ( ii )% vars % RHS ( spp ( ii )% ppp , 5 ) ) spp ( ii )% vars % Y0 = 0.0_rp spp ( ii )% vars % V0 = 0.0_rp spp ( ii )% vars % k1 = 0.0_rp spp ( ii )% vars % k2 = 0.0_rp spp ( ii )% vars % k3 = 0.0_rp spp ( ii )% vars % k4 = 0.0_rp spp ( ii )% vars % k5 = 0.0_rp spp ( ii )% vars % k6 = 0.0_rp spp ( ii )% vars % RHS = 0.0_rp end if end do P % R0_RE = spp ( 1 )% Ro P % Z0_RE = spp ( 1 )% Zo P % n_REr0 = max ( sqrt ( spp ( 1 )% psi_max * 2 * spp ( 1 )% sigmaR ** 2 ), & sqrt ( spp ( 1 )% psi_max * 2 * spp ( 1 )% sigmaZ ** 2 )) call initial_energy_pitch_dist ( params , spp ) DEALLOCATE ( ppp ) DEALLOCATE ( q ) DEALLOCATE ( m ) DEALLOCATE ( Eno ) DEALLOCATE ( etao ) DEALLOCATE ( Eo_lims ) DEALLOCATE ( etao_lims ) DEALLOCATE ( runaway ) DEALLOCATE ( spatial_distribution ) DEALLOCATE ( energy_distribution ) DEALLOCATE ( pitch_distribution ) DEALLOCATE ( Ro ) DEALLOCATE ( PHIo ) DEALLOCATE ( Zo ) DEALLOCATE ( r_inner ) DEALLOCATE ( r_outter ) DEALLOCATE ( falloff_rate ) DEALLOCATE ( shear_factor ) DEALLOCATE ( sigmaR ) DEALLOCATE ( sigmaZ ) DEALLOCATE ( theta_gauss ) DEALLOCATE ( psi_max ) DEALLOCATE ( Spong_b ) DEALLOCATE ( Spong_w ) DEALLOCATE ( Spong_dlam ) DEALLOCATE ( dth ) DEALLOCATE ( dgam ) DEALLOCATE ( dR ) DEALLOCATE ( dZ ) DEALLOCATE ( Xtrace ) end subroutine initialize_particles subroutine set_up_particles_ic ( params , F , spp , P ) !! @note Subroutine with calls to subroutines to load particles' !! information if it is a restarting simulation, or to initialize the !! spatial and velocity distribution of each species if it is a new !! simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of KORC's derived type FIELDS containing all !! the information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information of different electron species. See [[korc_types]]. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. INTEGER :: ii !! Species iterator. if ( params % restart . OR . params % proceed . or . params % reinit ) then call load_particles_ic ( params , spp , F ) call init_random_seed () else if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING SPATIAL DISTRIBUTION * * * *\")' ) end if call intitial_spatial_distribution ( params , spp , P , F ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING VELOCITY COMPONENTS * * * *\")' ) end if call initial_gyro_distribution ( params , F , spp ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end if end subroutine set_up_particles_ic end module korc_initialize","tags":"","loc":"sourcefile/korc_initialize.f90.html"},{"title":"korc_hpc.f90 – KORC-Full Orbit","text":"Contents Modules korc_hpc Source Code korc_hpc.f90 Source Code module korc_hpc !! @note KORC module containing subroutines to initilize, control, !! and to finalize parallel communications. @endnote use korc_types use omp_lib use mpi IMPLICIT NONE LOGICAL , PRIVATE :: timed_already = . FALSE . !! Flag to determine if a first call to WMPI_TIME() was made already. REAL ( rp ), PRIVATE :: t1 !! Variable to be used in timing a parallel section of KORC. REAL ( rp ), PRIVATE :: t2 !! Variable to be used in timing a parallel section of KORC. PUBLIC :: korc_abort ,& initialize_mpi ,& finalize_mpi ,& initialize_communications ,& timing_KORC CONTAINS subroutine korc_abort () !! @note Subroutine that terminates the simulation. @endnote INTEGER :: mpierr !! MPI error status call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call MPI_ABORT ( MPI_COMM_WORLD , - 2000 , mpierr ) end subroutine korc_abort subroutine set_paths ( params ) !! @note Subroutine that sets the input/output paths.@endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: argn , read_stat , exei !! Number of command line inputs. The default value is !! two: the input files path and the outputs path. CHARACTER ( MAX_STRING_LENGTH ) :: ctmp argn = command_argument_count () if ( argn . EQ . 2_idef ) then call get_command_argument ( 1 , params % path_to_inputs ) call get_command_argument ( 2 , params % path_to_outputs ) else call korc_abort () end if !write(6,*) TRIM(params%path_to_outputs) !write(6,*) TRIM(params%path_to_inputs) if ( params % mpi_params % rank . EQ . 0 ) then OPEN ( UNIT = output_unit_write , & FILE = TRIM ( params % path_to_outputs ) // \"output.korc\" , & STATUS = 'UNKNOWN' , FORM = 'FORMATTED' , POSITION = 'REWIND' ) write ( output_unit_write , '(/,\"* * * * * PATHS * * * * *\")' ) write ( output_unit_write , * ) 'The input file is: ' ,& TRIM ( params % path_to_inputs ) write ( output_unit_write , '(/)' ) write ( output_unit_write , * ) 'The output folder is: ' ,& TRIM ( params % path_to_outputs ) write ( output_unit_write , '(\"* * * * * * * * * * * * *\",/)' ) write ( output_unit_write , '(/,\"* * * * * * * GIT INFO * * * * * * *\")' ) #ifdef MAC call execute_command_line ( \"/Users/21b/Desktop/KORC/src/get_git_details.sh\" , & exitstat = exei ) #elif CORI call execute_command_line ( \"/global/u1/m/mbeidler/KORC/src/get_git_details.sh\" , & exitstat = exei ) #endif IF ( exei /= 0 ) then write ( 6 , * ) 'Error executing get_git_details.sh' call korc_abort end if OPEN ( UNIT = default_unit_open , FILE = 'git_hash.txt' , & STATUS = 'OLD' , POSITION = 'REWIND' ) READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = read_stat ) ctmp IF ( read_stat /= 0 ) then write ( 6 , * ) 'Error reading git_hash.txt' call korc_abort end if write ( output_unit_write , * ) 'Git hash of most recent commit is: ' , & TRIM ( ctmp ) write ( output_unit_write , '(/)' ) CLOSE ( default_unit_open ) OPEN ( UNIT = default_unit_open , FILE = 'git_diff.txt' , & STATUS = 'OLD' , POSITION = 'REWIND' ) write ( output_unit_write , * ) 'Git diff of HEAD and most recent commit is:' DO READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = read_stat ) ctmp IF ( read_stat . gt . 0 ) then write ( 6 , * ) 'Error reading git_diff.txt' call korc_abort else if ( read_stat . lt . 0 ) then CLOSE ( default_unit_open ) write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * *\",/)' ) RETURN end if write ( output_unit_write , * ) TRIM ( ctmp ) END DO end if end subroutine set_paths subroutine initialize_mpi ( params ) !! @note Subroutine that initialize MPI communications.@endnote !! Through this subroutine the default MPI communicator MPI_COMM_WORLD !! is initialized. Also, a Cartesian TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: mpierr !! MPI error status. INTEGER , PARAMETER :: NDIMS = 1 !! Number of dimensions of non-standard topology. !! NDIMS=1 for a 1-D MPI topology, NDIMS=2 for a 2-D MPI topology, !! and NDIMS=3 for a 3-D MPI topology. INTEGER , DIMENSION (:), ALLOCATABLE :: DIMS !! Dimension of the non-standard MPI topology params::mpi_params::mpi_topo. !! This is equal to the number of MPI processes in KORC. LOGICAL :: all_mpis_initialized = . FALSE . !! Flag to determine if all the MPI processes were initialized correctly. LOGICAL :: mpi_process_initialized = . FALSE . !! Flag to determine if a given MPI process was initialized correctly. LOGICAL , PARAMETER :: REORDER = . FALSE . !! Flag to determine if the new MPI topology params::mpi_params::mpi_topo !! needs to be re-ordered. LOGICAL , DIMENSION (:), ALLOCATABLE :: PERIODS !< Something here !! Array of logicals determining what dimensions of the new MPI !! topology params::mpi_params::mpi_topo are periodic (T) or not (F). INTEGER :: ii !! Variable to iterate over different MPI processes. call MPI_INIT ( mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Initializing MPI. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if call MPI_INITIALIZED ( mpi_process_initialized , mpierr ) call MPI_REDUCE ( mpi_process_initialized , all_mpis_initialized , 1 , & MPI_LOGICAL , MPI_LAND , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BCAST ( all_mpis_initialized , 1 , & MPI_LOGICAL , 0 , MPI_COMM_WORLD , mpierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , params % mpi_params % nmpi , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Obtaining size of communicator. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if ! * * * Getting the rank of the MPI process in the WORLD COMMON communicator * * * ! call MPI_COMM_RANK ( MPI_COMM_WORLD , params % mpi_params % rank , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Obtaining MPI rank. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if ! * * * Here a Cartesian topology for MPI is created * * * ! ALLOCATE ( DIMS ( NDIMS )) ALLOCATE ( PERIODS ( NDIMS )) ! This loop isn't necessary but helps to do things more general in the future do ii = 1_idef , NDIMS DIMS ( ii ) = params % mpi_params % nmpi PERIODS ( ii ) = . TRUE . end do ! * * * Here a periodic topology for MPI is created * * * ! call MPI_CART_CREATE ( MPI_COMM_WORLD , NDIMS , DIMS , PERIODS , REORDER , & params % mpi_params % mpi_topo , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Creating new MPI topology. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if ! * * * Getting the rank of the MPI process in the new topology * * * ! call MPI_COMM_RANK ( params % mpi_params % mpi_topo , params % mpi_params % rank_topo , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Obtaining new MPI topology ranks. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if DEALLOCATE ( DIMS ) DEALLOCATE ( PERIODS ) if ( all_mpis_initialized ) then call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call set_paths ( params ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * COMMUNICATIONS  * * * * *\")' ) write ( output_unit_write , '(/,\"  MPI communications initialized!  \")' ) write ( output_unit_write , '(/,\"  Number of MPI processes: \",I5)' ) params % mpi_params % nmpi write ( output_unit_write , '(/,\"* * * * * * * * * * * * * * * * * *\")' ) end if else if ( params % mpi_params % rank . EQ . 0 ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: MPI not initialized. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if end if !... end subroutine initialize_mpi subroutine timing_KORC ( params ) !! @note Subroutine for timing the execution of any parallel !! section of KORC. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ) :: individual_runtime !! Execution time of each MPI process. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: runtime !! Execution time of KORC defined as the average of the !! execution times of all MPI processes. INTEGER :: mpierr !! MPI error status. if ( timed_already ) then t2 = MPI_WTIME () ALLOCATE ( runtime ( params % mpi_params % nmpi )) individual_runtime = t2 - t1 call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call MPI_GATHER ( individual_runtime , 1 , MPI_DOUBLE_PRECISION , runtime , & 1 , MPI_DOUBLE_PRECISION , 0_idef , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , '(\"Timing: \",F30.16,\" s\")' ) & SUM ( runtime ) / REAL ( params % mpi_params % nmpi , rp ) end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) DEALLOCATE ( runtime ) timed_already = . FALSE . end if t1 = MPI_WTIME () timed_already = . TRUE . end subroutine timing_KORC !> @brief Subroutine for finalizing MPI communications. !! @details This subroutine finalizes all the MPI communications and looks for errors durignt this procces. !! !! @param[in] params Core KORC simulation parameters. !! @param mpi_process_finalized Flag indicating whether an individual MPI process was finalized correctly. !! @param mpierr MPI error status. subroutine finalize_mpi ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params LOGICAL :: mpi_process_finalized = . FALSE . INTEGER :: mpierr call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call MPI_FINALIZE ( mpierr ) call MPI_FINALIZED ( mpi_process_finalized , mpierr ) if (. NOT . mpi_process_finalized ) then write ( output_unit_write , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( output_unit_write , '(/,\" ERROR: MPI not finalized well. MPI process: \",I5)' ) params % mpi_params % rank write ( output_unit_write , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) end if end subroutine finalize_mpi ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! ! ** SUBROUTINES FOR INITIALIZING COMMUNICATIONS  ** ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! !! @note Subroutine for initializing MPI and open MP communications. @endnote !! This subroutine initializes MPI and open MP communications and looks for !! errors durignt this procces. The system environment !! variables, which are modified by the user at the moment of !! running/submitting a KORC simulation, are used to determine the !! open MP configuration. Some open MP parameters are displayed on the !! screen/output file. !! !! @param[in] params Core KORC simulation parameters. !! @param mpi_process_finalized Flag indicating whether an individual MPI process was finalized correctly. !! @param mpierr MPI error status. subroutine initialize_communications ( params ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: string call initialize_mpi ( params ) !$OMP PARALLEL SHARED(params) params % num_omp_threads = OMP_GET_NUM_THREADS () !$OMP END PARALLEL if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * * * OMP SET-UP * * * * * * *\")' ) !$OMP PARALLEL !$OMP MASTER write ( output_unit_write , '(/,\"OMP threads per MPI process: \",I3)' ) OMP_GET_NUM_THREADS () write ( output_unit_write , '(/,\"Cores available per MPI process: \",I3)' ) OMP_GET_NUM_PROCS () !$OMP END MASTER !$OMP END PARALLEL #ifdef GNU call GET_ENVIRONMENT_VARIABLE ( \"OMP_PLACES\" , string ) write ( output_unit_write , '(/,\"OMP places: \",A30)' ) TRIM ( string ) call GET_ENVIRONMENT_VARIABLE ( \"GOMP_CPU_AFFINITY\" , string ) write ( output_unit_write , '(/,\"OMP CPU affinity: \",A30)' ) TRIM ( string ) #endif write ( output_unit_write , '(\"* * * * * * * * * * * *  * * * * * * *\",/)' ) end if end subroutine initialize_communications end module korc_hpc","tags":"","loc":"sourcefile/korc_hpc.f90.html"},{"title":"korc_finalize.f90 – KORC-Full Orbit","text":"Contents Modules korc_finalize Source Code korc_finalize.f90 Source Code module korc_finalize !! @note Module containing subroutines to terminate parallel !! communications and free memory. use korc_types use korc_fields use korc_hpc IMPLICIT NONE PUBLIC :: finalize_communications ,& deallocate_variables CONTAINS subroutine finalize_communications ( params ) !! @note Interface to function that finalizes MPI communications. !! See [[korc_hpc]]. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. call finalize_mpi ( params ) end subroutine finalize_communications subroutine deallocate_variables ( params , F , spp ) !! @note Subroutine to free allocatable simulation variables. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of KORC's derived type FIELDS containing all the !! information about the fields used in the simulation. See !! [[korc_types]] and [[korc_fields]]. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the !! information of different electron species. See [[korc_types]]. INTEGER :: ii !! Iterator of the spp array DEALLOCATE ( params % outputs_list ) do ii = 1_idef , params % num_species DEALLOCATE ( spp ( ii )% vars % X ) DEALLOCATE ( spp ( ii )% vars % V ) DEALLOCATE ( spp ( ii )% vars % Rgc ) DEALLOCATE ( spp ( ii )% vars % Y ) DEALLOCATE ( spp ( ii )% vars % E ) DEALLOCATE ( spp ( ii )% vars % B ) DEALLOCATE ( spp ( ii )% vars % PSI_P ) DEALLOCATE ( spp ( ii )% vars % ne ) DEALLOCATE ( spp ( ii )% vars % Te ) DEALLOCATE ( spp ( ii )% vars % Zeff ) DEALLOCATE ( spp ( ii )% vars % g ) DEALLOCATE ( spp ( ii )% vars % eta ) DEALLOCATE ( spp ( ii )% vars % mu ) DEALLOCATE ( spp ( ii )% vars % Prad ) DEALLOCATE ( spp ( ii )% vars % flagCon ) DEALLOCATE ( spp ( ii )% vars % flagCol ) DEALLOCATE ( spp ( ii )% vars % wt ) if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then DEALLOCATE ( spp ( ii )% vars % Y0 ) DEALLOCATE ( spp ( ii )% vars % V0 ) DEALLOCATE ( spp ( ii )% vars % k1 ) DEALLOCATE ( spp ( ii )% vars % k2 ) DEALLOCATE ( spp ( ii )% vars % k3 ) DEALLOCATE ( spp ( ii )% vars % k4 ) DEALLOCATE ( spp ( ii )% vars % RHS ) end if end do DEALLOCATE ( spp ) call DEALLOCATE_FIELDS_ARRAYS ( F ) end subroutine deallocate_variables end module korc_finalize","tags":"","loc":"sourcefile/korc_finalize.f90.html"},{"title":"korc_input.f90 – KORC-Full Orbit","text":"Contents Modules korc_input Source Code korc_input.f90 Source Code module korc_input !! @note Module with subroutines to read in all namelists in supplied !! input file and broadcast to all mpi processes. USE korc_types USE korc_hpc IMPLICIT NONE !! Default values for all inputs !! ----------------------------------------------- !! input_parameters !! ----------------------------------------------- LOGICAL :: restart = . FALSE . ! Restart simulation that exited before simulation_time reached LOGICAL :: proceed = . FALSE . ! Append simulation results after previous simulation_time reached LOGICAL :: reinit = . FALSE . ! Begin a new simulation, reinitializing from restart file state REAL ( rp ) :: simulation_time = 1.E-3 ! Total aimed simulation time in seconds ! Run 10 mu s If transients exist put 5 extra mu s. REAL ( rp ) :: snapshot_frequency = 1.E-5 ! Time between snapshots in seconds REAL ( rp ) :: restart_overwrite_frequency = 1.E-1 ! Time between overwritting of restart file in seconds REAL ( rp ) :: dt = 1.E0 ! Time step as fraction of relativistic gyro-period INTEGER :: num_species = 1 REAL ( rp ) :: minimum_particle_energy = 1.0E5 ! Minimum energy of simulated particles in eV LOGICAL :: radiation = . FALSE . CHARACTER ( 30 ) :: GC_rad_model = 'SDE' LOGICAL :: collisions = . FALSE . CHARACTER ( 30 ) :: collisions_model = 'SINGLE_SPECIES' ! Options are: 'NONE','SINGLE_SPECIES' and 'MULTIPLE_SPECIES' CHARACTER ( 30 ) :: bound_electron_model = 'HESSLOW' ! Options are: 'NO_BOUND', 'HESSLOW', and 'ROSENBLUTH' CHARACTER ( 30 ) :: field_model = 'M3D_C1' CHARACTER ( 30 ) :: profile_model = 'M3D_C1' ! The two options for this parameter are 'ANALYTICAL' or 'EXTERNAL'. ! For 'ANALYTICAL', the magnetic field is calculated based on ! the parameters given in the \"analytic_mag_field_params\" section. ! For 'EXTERNAL', the magnetic field is loaded from the file ! specified in \"filename\". ! 'UNIFORM' A uniform magnetic field used to advance only electrons' ! velocity. CHARACTER ( 30 ) :: magnetic_field_filename = 'C1.h5' !  magnetic_field_filename = 'JFIT_D3D_164409_1405ms.h5' INTEGER :: time_slice = 000 REAL ( rp ) :: rmax = 1.60 REAL ( rp ) :: rmin = 0.15 REAL ( rp ) :: zmax = 1.65 REAL ( rp ) :: zmin = - 1.65 CHARACTER ( 50 ) :: outputs_list = '{X,Y,V,B,E,g,eta,flagCon,flagCol,PSIp,ne}' ! List of outputs !'{X,Y,V,E,B,g,mu,eta,Prad,Pin,flagCon,flagCol,gradB,curlb,ne,Te,Zeff,PSIp}' LOGICAL :: HDF5_error_handling = . TRUE . LOGICAL :: FO_GC_compare = . FALSE . CHARACTER ( 30 ) :: orbit_model = 'GC' ! 'FO' for full orbit, 'GCpre' for guiding center with pre-computed ! auxiliary fields, 'GCgrad' for guiding center with auxiliary ! fields computed with PSPLINE. CHARACTER ( 30 ) :: field_eval = 'interp' ! Set for plasma_model='ANALYTICAL'. Can be 'interp' or 'eqn', ! where 'eqn' evaluates particle fields at particle positions and ! 'interp' interpolates precomputed fields. LOGICAL :: FokPlan = . FALSE . LOGICAL :: SameRandSeed = . FALSE . LOGICAL :: SC_E = . FALSE . LOGICAL :: SC_E_add = . FALSE . INTEGER :: pchunk = 1 !! ----------------------------------------------- !! plasma_species !! As these inputs are vectors with dimension given by the number of species !! indicate default values for num_species=1 below, after the input_parameter !! namelist is read !! ----------------------------------------------- LOGICAL , DIMENSION (:), ALLOCATABLE :: runaway !! Flag to decide whether a given electron is a runaway (runaway=T) !! or not (runaway=F). INTEGER , DIMENSION (:), ALLOCATABLE :: ppp ! Number of particles per process (mpi) REAL ( rp ), DIMENSION (:), ALLOCATABLE :: q ! Electric charge REAL ( rp ), DIMENSION (:), ALLOCATABLE :: m ! In units of electron mass CHARACTER ( 30 ), DIMENSION (:), ALLOCATABLE :: spatial_distribution !! String describing the type of initial spatial distribution for !! each electron species. ! Options are: 'UNIFORM', 'DISK', 'TORUS', 'EXPONENTIAL-TORUS', ! 'GAUSSIAN-TORUS', 'ELLIPTIC-TORUS', 'EXPONENTIAL-ELLIPTIC-TORUS', ! 'GAUSSIAN-ELLIPTICAL-TORUS', '2D-GAUSSIAN-ELLIPTIC-TORUS-MH', ! 'AVALANCHE-4D','TRACER','SPONG-3D','HOLLMANN-3D','HOLLMANN-3D-PSI', ! 'MH_psi' REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Ro !! Radial position of the center of the electrons' initial !! spatial distribution. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHIo !! Azimuthal position of the electrons' initial spatial distribution, !! in case of using a disk at a certain poloidal section. ! In degrees REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zo !! Height of the center of the electrons' initial spatial distribution. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r_inner REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r_outter REAL ( rp ), DIMENSION (:), ALLOCATABLE :: shear_factor REAL ( rp ), DIMENSION (:), ALLOCATABLE :: sigmaR REAL ( rp ), DIMENSION (:), ALLOCATABLE :: sigmaZ REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta_gauss REAL ( rp ), DIMENSION (:), ALLOCATABLE :: psi_max !! Maximum value of the argument of the 2D gaussian exponential, used for an !! indicator function that limits the region of MH sampling ! goes as R&#94;2 for HOLLMANN-3D, is psiN_max for HOLLMANN-3D-PSI REAL ( rp ), DIMENSION (:), ALLOCATABLE :: falloff_rate CHARACTER ( 30 ), DIMENSION (:), ALLOCATABLE :: energy_distribution ! Options are: 'MONOENERGETIC', 'THERMAL', 'AVALANCHE', ! 'EXPERIMENTAL', and 'UNIFORM' CHARACTER ( 30 ), DIMENSION (:), ALLOCATABLE :: pitch_distribution ! Options are: 'MONOPITCH', 'AVALANCHE', 'EXPERIMENTAL', and 'UNIFORM'. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Eno ! Initial energy in eV REAL ( rp ), DIMENSION (:), ALLOCATABLE :: etao ! Initial pitch angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Eo_lims ! Lower and upper limit of simulated energy range, in eV. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: etao_lims ! Lower and upper limit of simulated pitch-angle range, in degrees. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Xtrace ! Initial position of tracer particle for debugging with ! spatial_distribution='TRACER' REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Spong_b REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Spong_w REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Spong_dlam REAL ( rp ), DIMENSION (:), ALLOCATABLE :: dth ! Variance of sampling normal variate for pitch angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: dgam ! Variance of sampling normal variate for pitch angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: dR ! Variance of sampling normal variate for R location REAL ( rp ), DIMENSION (:), ALLOCATABLE :: dZ ! Variance of sampling normal variate for Z location !! ----------------------------------------------- !! analytical_fields_params !! ----------------------------------------------- REAL ( rp ) :: Eo = 0. ! In V/m CHARACTER ( 30 ) :: current_direction = 'ANTI-PARALLEL' ! 'PARALLEL' or 'ANTI-PARALLEL' REAL ( rp ) :: Bo = 2.2 ! In Teslas. ITER: 5.42 DIII-D: 2.19 REAL ( rp ) :: minor_radius = 0.7 ! Minor radius in meters. ITER: 1.5 DIII-D: 0.5 REAL ( rp ) :: major_radius = 1.7 ! Major radius in meters. ITER: 6.5 DIII-D: 1.6 REAL ( rp ) :: qa = 5 ! Safety factor at the separatrix (r=a) REAL ( rp ) :: qo = 1.5 ! Safety factor at the separatrix (r=a) REAL ( rp ) :: nR = 50 ! Mesh points in R for analytical interpolation mesh REAL ( rp ) :: nZ = 50 ! Mesh points in Z for analytical interpolation mesh REAL ( rp ) :: nPHI = 50 ! Mesh points in PHI for analytical interpolation mesh REAL ( rp ) :: E_dyn = 0. REAL ( rp ) :: E_pulse = 5.E-2 REAL ( rp ) :: E_width = 2.5E-2 !! ----------------------------------------------- !! externalPlasmaModel !! ----------------------------------------------- LOGICAL :: Bfield = . FALSE . LOGICAL :: dBfield = . FALSE . LOGICAL :: axisymmetric_fields = . FALSE . LOGICAL :: Bflux = . FALSE . LOGICAL :: Bflux3D = . FALSE . LOGICAL :: Efield = . FALSE . LOGICAL :: Dim2x1t = . FALSE . LOGICAL :: E_2x1t = . FALSE . REAL ( rp ) :: t0_2x1t = 1.405 INTEGER :: ind0_2x1t = 11 LOGICAL :: ReInterp_2x1t = . FALSE . INTEGER :: res_double = 0 INTEGER :: dim_1D = 50 REAL ( rp ) :: dt_E_SC = 1.E-7 REAL ( rp ) :: Ip_exp = 2E5 REAL ( rp ) :: PSIp_lim = 0.8446 REAL ( rp ) :: PSIp_0 = 0.6 !! ----------------------------------------------- !! plasmaProfiles !! ----------------------------------------------- LOGICAL :: axisymmetric = . TRUE . CHARACTER ( 30 ) :: filename = 'JFIT_D3D_157576_t1580_1.h5' ! REAL ( rp ) :: radius_profile = 0.6 CHARACTER ( 30 ) :: ne_profile = 'RE-EVO-PSIP-G' ! Options are 'FLAT','POLYNOMIAL','RE-EVO','RE-EVO1','RE-EVO-PSI' REAL ( rp ) :: neo = 4.E20 ! In m&#94;-3 REAL ( rp ) :: n_ne = 2.5E19 ! REAL ( rp ) :: n_shelf = 2.5E19 ! REAL ( rp ), DIMENSION ( 4 ) :: a_ne = ( / 0.99713 , 0.047037 , 0.40023 , - 1.0466 / ) REAL ( rp ) :: n_REr0 = 0.4 REAL ( rp ) :: n_tauion = 1.5e-2 REAL ( rp ) :: n_tauin = 7.5e-3 REAL ( rp ) :: n_tauout = 1.25e-2 REAL ( rp ) :: n_shelfdelay = 4.e-2 REAL ( rp ) :: n_lamfront = 0.005 REAL ( rp ) :: n_lamback = 0.005 REAL ( rp ) :: n_lamshelf = 0.225 REAL ( rp ) :: psiN_0 = 0.8 CHARACTER ( 30 ) :: Te_profile = 'FLAT' ! Options are 'FLAT' and 'POLYNOMIAL' REAL ( rp ) :: Teo = 1.5 ! In eV REAL ( rp ) :: n_Te = 0.1 ! REAL ( rp ), DIMENSION ( 4 ) :: a_Te = ( / 1.0046 , - 0.076652 , - 2.6429 , 1.7415 / ) CHARACTER ( 30 ) :: Zeff_profile = 'FLAT' ! Options are 'FLAT' and 'POLYNOMIAL' REAL ( rp ) :: Zeffo = 1. ! In m&#94;-3 REAL ( rp ) :: n_Zeff = 3.0 ! REAL ( rp ), DIMENSION ( 4 ) :: a_Zeff = ( / 1.0065 , - 0.12081 , 0.02834 , - 0.11796 / ) !! ----------------------------------------------- !! CollisionParamsSingleSpecies !! ----------------------------------------------- REAL ( rp ) :: Te_sing = 2.0 ! Background electron temperature in eV REAL ( rp ) :: Ti_sing = 2.0 ! Background ion temperature in eV REAL ( rp ) :: ne_sing = 4.E20 ! Background electron density in m&#94;-3 REAL ( rp ) :: Zeff_sing = 1. ! Effective atomic number REAL ( rp ) :: dTau_sing = 5.E-2 ! Subcycling time step in collisional time units (Tau) !! ----------------------------------------------- !! CollisionParamsMultipleSpecies !! ----------------------------------------------- INTEGER :: num_impurity_species = 1 REAL ( rp ) :: Te_mult = 2.0 ! Background electron temperature in eV REAL ( rp ) :: ne_mult = 4.E20 ! Background electron density in 1/m&#94;3 REAL ( rp ), DIMENSION ( 10 ) :: Zo_mult = 1 0.0 ! Full nuclear charge of each impurity: Z=1 for D, Z=10 for Ne, Z=18 for Ar REAL ( rp ), DIMENSION ( 10 ) :: Zj_mult = 1.0 ! Average charge state of each impurity REAL ( rp ), DIMENSION ( 10 ) :: nz_mult = 4.E20 ! Impurity densities REAL ( rp ), DIMENSION ( 10 ) :: IZj_mult = 1 5.7596 ! Ionization energy of impurity in eV !! ----------------------------------------------- !! AvalancheGenerationPDF !! ----------------------------------------------- REAL ( rp ) :: max_pitch_angle_aval = 1 0.0 ! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle_aval = 0.0 ! REAL ( rp ) :: dth_aval = 1.0 ! Variance of sampling normal variate for pitch angle REAL ( rp ) :: dp_aval = 1 0.0 ! Variance of sampling normal variate for momentum REAL ( rp ) :: dR_aval = 0.05 ! Variance of sampling normal variate for R location REAL ( rp ) :: dZ_aval = 0.05 ! Variance of sampling normal variate for Z location REAL ( rp ) :: max_energy_aval = 6 0E6 ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_energy_aval = 7.0E6 ! REAL ( rp ) :: ne_aval = 8.5E18 ! Background electron density in m&#94;-3 REAL ( rp ) :: Zeff_aval = 1.0 ! Effective atomic number of ions REAL ( rp ) :: Epar_aval = 0.7427 ! Parallel electric field in V/m REAL ( rp ) :: Te_aval = 1.0 ! Background electron temperature in eV !! ----------------------------------------------- !! ExperimentalPDF !! ----------------------------------------------- REAL ( rp ) :: E_expt = 7.67042 ! Parallel electric field in units of Ec REAL ( rp ) :: Zeff_expt = 1.36632 ! Effective atomic number REAL ( rp ) :: max_pitch_angle_expt = 17 6.257 ! In degrees REAL ( rp ) :: min_pitch_angle_expt = 15 8.25 ! In degrees REAL ( rp ) :: min_energy_expt = 9.54997E6 ! In eV REAL ( rp ) :: max_energy_expt = 4 4.3241E6 ! In eV REAL ( rp ) :: k_expt = 1 1.89 ! Shape factor of Gamma distribution for energy REAL ( rp ) :: t_expt = 0.65 ! Scale factor of Gamma distribution for energy REAL ( rp ) :: Bo_expt = 2.2 ! Characteristic magnetic field REAL ( rp ) :: lambda_expt = 4.0E-6 ! Characteristic wavelength REAL ( rp ) :: A_fact_expt = 1. !! ----------------------------------------------- !! HollmannPDF !! ----------------------------------------------- CHARACTER ( 30 ) :: filename_Hollmann = 'Hollmann_PDF_HR.h5' ! REAL ( rp ) :: Eo_Hollmann = 2 4.56 ! Toroidal electric field from experimental diagnostics before SPI in ! physical units REAL ( rp ) :: E_Hollmann = 1 1. ! Parallel electric field in units of Ec REAL ( rp ) :: sigma_E_Hollmann = . 2 REAL ( rp ) :: Zeff_Hollmann = 5. ! Effective atomic number REAL ( rp ) :: sigma_Z_Hollmann = 1 0. REAL ( rp ) :: max_pitch_angle_Hollmann = 4 0. ! In degrees REAL ( rp ) :: min_pitch_angle_Hollmann = 0. ! In degrees REAL ( rp ) :: min_energy_Hollmann = 1.E6 ! In eV REAL ( rp ) :: max_energy_Hollmann = 6 0.E6 ! For Hollmann_PDF_HR.h5, needs to be less than 80 MeV ! In eV CHARACTER ( 30 ) :: current_direction_Hollmann = 'ANTICLOCKWISE' REAL ( rp ) :: Bo_Hollmann = 2.2 ! Characteristic magnetic field REAL ( rp ) :: lambda_Hollmann = 4.0E-6 ! Characteristic wavelengt REAL ( rp ) :: A_fact_Hollmann = 1. !! ----------------------------------------------- !! EnergyGammaPDF !! ----------------------------------------------- REAL ( rp ) :: min_energy_gamma = 1.0E6 ! In eV REAL ( rp ) :: max_energy_gamma = 3 0.0E6 ! In eV REAL ( rp ) :: k_gamma = 1 1.89 ! Shape factor of Gamma distribution for energy REAL ( rp ) :: t_gamma = 0.65 ! Scale factor of Gamma distribution for energy !! ----------------------------------------------- !! SimpleEquilibriumPDF !! ----------------------------------------------- REAL ( rp ) :: E_simple = 4.5 ! Parallel electric field in units of Ec REAL ( rp ) :: Zeff_simple = 4.0 ! Effective atomic number REAL ( rp ) :: max_pitch_angle_simple = 6 0.0 ! In degrees REAL ( rp ) :: min_pitch_angle_simple = 0.0 ! In degrees REAL ( rp ) :: Bo_simple = 2.0 ! Characteristic magnetic field REAL ( rp ) :: lambda_simple = 89 0.0E-9 ! Characteristic wavelength CONTAINS subroutine read_namelist ( params , infile , echo_in , outdir ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( * ), INTENT ( IN ) :: infile , outdir LOGICAL , INTENT ( IN ) :: echo_in INTEGER :: read_stat , nc INTEGER :: number_of_namelists = 0 , il , inst INTEGER , DIMENSION ( 20 ) :: namel_order = 0 CHARACTER ( 20 ) :: tempfile CHARACTER ( 128 ) :: ctmp CHARACTER ( 128 ) :: outfile LOGICAL :: reading INTEGER :: mpierr INTEGER :: tmp !! Namelist declarations NAMELIST / input_parameters / restart , field_model , magnetic_field_filename , & simulation_time , snapshot_frequency , dt , num_species , radiation , & collisions , collisions_model , outputs_list , minimum_particle_energy , & HDF5_error_handling , orbit_model , field_eval , proceed , profile_model , & restart_overwrite_frequency , FokPlan , GC_rad_model , bound_electron_model ,& FO_GC_compare , SameRandSeed , SC_E , reinit , SC_E_add , time_slice , rmax , & rmin , zmax , zmin , pchunk NAMELIST / plasma_species / ppp , q , m , Eno , etao , Eo_lims , etao_lims , runaway , & spatial_distribution , energy_distribution , pitch_distribution , Ro , & PHIo , Zo , r_inner , r_outter , falloff_rate , shear_factor , sigmaR , sigmaZ , & theta_gauss , psi_max , Xtrace , Spong_b , Spong_w , Spong_dlam , dth , dR , dZ , dgam NAMELIST / analytical_fields_params / Bo , minor_radius , major_radius ,& qa , qo , Eo , current_direction , nR , nZ , nPHI , dim_1D , dt_E_SC , Ip_exp , & E_dyn , E_pulse , E_width NAMELIST / externalPlasmaModel / Efield , Bfield , Bflux , Bflux3D , dBfield , & axisymmetric_fields , Eo , E_dyn , E_pulse , E_width , res_double , & dim_1D , dt_E_SC , Ip_exp , PSIp_lim , Dim2x1t , t0_2x1t , E_2x1t , ReInterp_2x1t , & ind0_2x1t , PSIp_0 NAMELIST / plasmaProfiles / radius_profile , ne_profile , neo , n_ne , a_ne , & Te_profile , Teo , n_Te , a_Te , n_REr0 , n_tauion , n_lamfront , n_lamback , & Zeff_profile , Zeffo , n_Zeff , a_Zeff , filename , axisymmetric , & n_lamshelf , n_shelfdelay , n_tauin , n_tauout , n_shelf , psiN_0 NAMELIST / CollisionParamsSingleSpecies / Te_sing , Ti_sing , ne_sing , & Zeff_sing , dTau_sing NAMELIST / CollisionParamsMultipleSpecies / num_impurity_species , Te_mult , & ne_mult , Zo_mult , Zj_mult , nz_mult , IZj_mult NAMELIST / AvalancheGenerationPDF / max_pitch_angle_aval , & min_pitch_angle_aval , max_energy_aval , min_energy_aval , ne_aval , & Zeff_aval , Epar_aval , Te_aval , dth_aval , dp_aval , dR_aval , dZ_aval NAMELIST / ExperimentalPDF / max_pitch_angle_expt , min_pitch_angle_expt , & max_energy_expt , min_energy_expt , Zeff_expt , E_expt , k_expt , t_expt , & Bo_expt , lambda_expt , A_fact_expt NAMELIST / HollmannPDF / E_Hollmann , Zeff_Hollmann , max_pitch_angle_Hollmann , & min_pitch_angle_Hollmann , max_energy_Hollmann , & min_energy_Hollmann , filename_Hollmann , Bo_Hollmann , lambda_Hollmann , & current_direction_Hollmann , A_fact_Hollmann , sigma_E_Hollmann , & sigma_Z_Hollmann , Eo_Hollmann NAMELIST / SimpleEquilibriumPDF / max_pitch_angle_simple , & min_pitch_angle_simple , Zeff_simple , E_simple , & Bo_simple , lambda_simple NAMELIST / EnergyGammaPDF / max_energy_gamma , min_energy_gamma , k_gamma , t_gamma !!----------------------------------------------------------------------- !!     open input file. !!     Remove comments from input file and put into temporary file. !!----------------------------------------------------------------------- tempfile = 'tempinput.korc' if ( params % mpi_params % rank . eq . 0 ) then CALL rmcoment ( infile , tempfile ) end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) OPEN ( UNIT = default_unit_open , FILE = tempfile , STATUS = 'OLD' , POSITION = 'REWIND' ) !!----------------------------------------------------------------------- !!    check namelist file for namelist order and number. !!----------------------------------------------------------------------- DO READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = read_stat ) ctmp IF ( read_stat /= 0 ) EXIT nc = LEN_TRIM ( ctmp ) IF ( nc < 1 ) CYCLE ctmp = ADJUSTL ( ctmp ) reading = . false . IF ( ctmp ( 1 : 1 ) == '&' ) THEN number_of_namelists = number_of_namelists + 1 !!----------------------------------------------------------------------- !!         trim all but the namelist name. !!----------------------------------------------------------------------- DO il = 2 , nc + 1 IF ( ctmp ( il : il ) /= ' ' ) THEN IF (. NOT . reading ) inst = il reading = . true . CYCLE ENDIF IF ( ctmp ( il : il ) == ' ' . AND . reading ) THEN ctmp = ctmp ( inst : il - 1 ) EXIT ENDIF ENDDO BACKSPACE ( default_unit_open ) !!----------------------------------------------------------------------- !!         select and read namelist. !!----------------------------------------------------------------------- SELECT CASE ( TRIM ( ctmp )) CASE ( 'input_parameters' ) !write(6,*) 'reading input_parameters namelist' READ ( UNIT = default_unit_open , NML = input_parameters , IOSTAT = read_stat ) CASE ( 'plasma_species' ) !write(6,*) 'reading plasma_species namelist' ALLOCATE ( runaway ( num_species )) ALLOCATE ( ppp ( num_species )) ALLOCATE ( q ( num_species )) ALLOCATE ( m ( num_species )) ALLOCATE ( spatial_distribution ( num_species )) ALLOCATE ( Ro ( num_species )) ALLOCATE ( PHIo ( num_species )) ALLOCATE ( Zo ( num_species )) ALLOCATE ( r_inner ( num_species )) ALLOCATE ( r_outter ( num_species )) ALLOCATE ( shear_factor ( num_species )) ALLOCATE ( sigmaR ( num_species )) ALLOCATE ( sigmaZ ( num_species )) ALLOCATE ( theta_gauss ( num_species )) ALLOCATE ( psi_max ( num_species )) ALLOCATE ( falloff_rate ( num_species )) ALLOCATE ( energy_distribution ( num_species )) ALLOCATE ( pitch_distribution ( num_species )) ALLOCATE ( Eno ( num_species )) ALLOCATE ( etao ( num_species )) ALLOCATE ( Eo_lims ( 2_idef * num_species )) ALLOCATE ( etao_lims ( 2_idef * num_species )) ALLOCATE ( Xtrace ( 3_idef * num_species )) ALLOCATE ( Spong_b ( num_species )) ALLOCATE ( Spong_w ( num_species )) ALLOCATE ( Spong_dlam ( num_species )) ALLOCATE ( dth ( num_species )) ALLOCATE ( dgam ( num_species )) ALLOCATE ( dR ( num_species )) ALLOCATE ( dZ ( num_species )) if ( num_species . eq . 1 ) then runaway = . FALSE . ppp = 1E0 q = - 1.0 m = 1.0 spatial_distribution = 'TRACER' Ro = 1.1 PHIo = 0.0 Zo = - 0.05 r_inner = 0.0 r_outter = 0.6 shear_factor = 0.35 sigmaR = 1.e6 sigmaZ = 0.2 theta_gauss = 0.0 psi_max = . 8446 falloff_rate = 0.0 energy_distribution = 'MONOENERGETIC' pitch_distribution = 'MONOPITCH' Eno = 1 0.0E6 etao = 1.0 Eo_lims = ( / 1.0E6 , 5 0.0E6 / ) etao_lims = ( / 0.0 , 2 0.0 / ) Xtrace = ( / 1.1 , 0.0 , 0.0 / ) Spong_b = 0.2 Spong_w = 0.1 Spong_dlam = 0.1 dth = 3. dgam = 3. dR = 0.1 dZ = 0.1 else if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Need to supply all inputs for num_species .gt. 1\")' ) end if end if READ ( UNIT = default_unit_open , NML = plasma_species , IOSTAT = read_stat ) CASE ( 'analytical_fields_params' ) READ ( UNIT = default_unit_open , NML = analytical_fields_params , IOSTAT = read_stat ) CASE ( 'externalPlasmaModel' ) READ ( UNIT = default_unit_open , NML = externalPlasmaModel , IOSTAT = read_stat ) CASE ( 'plasmaProfiles' ) READ ( UNIT = default_unit_open , NML = plasmaProfiles , IOSTAT = read_stat ) CASE ( 'CollisionParamsSingleSpecies' ) READ ( UNIT = default_unit_open , NML = CollisionParamsSingleSpecies , IOSTAT = read_stat ) CASE ( 'CollisionParamsMultipleSpecies' ) READ ( UNIT = default_unit_open , NML = CollisionParamsMultipleSpecies , IOSTAT = read_stat ) CASE ( 'AvalancheGenerationPDF' ) READ ( UNIT = default_unit_open , NML = AvalancheGenerationPDF , IOSTAT = read_stat ) CASE ( 'ExperimentalPDF' ) READ ( UNIT = default_unit_open , NML = ExperimentalPDF , IOSTAT = read_stat ) CASE ( 'HollmannPDF' ) READ ( UNIT = default_unit_open , NML = HollmannPDF , IOSTAT = read_stat ) CASE ( 'EnergyGammaPDF' ) READ ( UNIT = default_unit_open , NML = EnergyGammaPDF , IOSTAT = read_stat ) CASE ( 'SimpleEquilibriumPDF' ) READ ( UNIT = default_unit_open , NML = SimpleEquilibriumPDF , IOSTAT = read_stat ) CASE DEFAULT write ( output_unit_write , * ) ( TRIM ( ctmp ) // ' is an unrecognized namelist.' ) call korc_abort END SELECT IF ( read_stat /= 0 ) then write ( output_unit_write , * ) ( 'Error reading namelist ' // TRIM ( ctmp ) // '.' ) call korc_abort end if ENDIF ENDDO !!----------------------------------------------------------------------- !!     close input file. !!       Delete it since it is the temporary file !!----------------------------------------------------------------------- if ( params % mpi_params % rank . ne . 0 ) then CLOSE ( default_unit_open ) end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . eq . 0 ) then CLOSE ( default_unit_open , STATUS = 'DELETE' ) end if !!----------------------------------------------------------------------- !!     echo the input parameters to the output file. !!----------------------------------------------------------------------- IF ( echo_in ) THEN if ( params % mpi_params % rank . EQ . 0 ) then WRITE ( output_unit_write , '(a,/)' ) 'VALUE OF ALL INPUTS:' WRITE ( UNIT = output_unit_write , NML = input_parameters ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = plasma_species ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = analytical_fields_params ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = externalPlasmaModel ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = plasmaProfiles ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = CollisionParamsSingleSpecies ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = CollisionParamsMultipleSpecies ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = AvalancheGenerationPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = ExperimentalPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = HollmannPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = EnergyGammaPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = SimpleEquilibriumPDF ) WRITE ( output_unit_write , '(/)' ) end if end if !!--------------------------------------------------------- !!     some tests !!--------------------------------------------------------- !write(6,*) TRIM(outputs_list),len(TRIM(outputs_list)) tmp = len ( TRIM ( outputs_list )) if ( outputs_list ( tmp : tmp ). ne . '}' ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) & 'Check that enough characters are allocated for outputs list!' end if call korc_abort end if end subroutine read_namelist SUBROUTINE rmcoment ( fileold , filenew ) CHARACTER ( * ), INTENT ( IN ) :: fileold , filenew CHARACTER ( 128 ) :: line INTEGER , PARAMETER :: nold = 55 , nnew = 56 INTEGER cmax , ios LOGICAL :: file_exist !!----------------------------------------------------------------------- !!     Open files, but make sure the old one exists first. !!----------------------------------------------------------------------- INQUIRE ( FILE = fileold , EXIST = file_exist ) IF (. NOT . file_exist ) THEN PRINT * , 'The file \"' , fileold , '\" could not be found.' STOP ENDIF OPEN ( UNIT = default_unit_open , FILE = fileold , status = \"OLD\" , form = 'formatted' ) OPEN ( UNIT = default_unit_write , FILE = filenew , status = 'REPLACE' ) !!----------------------------------------------------------------------- !!     Strip comments.     Note: line lengths limited to 127 characters !!----------------------------------------------------------------------- DO READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = ios ) line IF ( ios /= 0 ) EXIT cmax = 1 DO WHILE ( line ( cmax : cmax ). NE . '!' . AND . cmax . LE . 127 ) cmax = cmax + 1 ENDDO IF ( cmax . GT . 1 ) WRITE ( default_unit_write , '(a)' ) line ( 1 : cmax - 1 ) ENDDO !!----------------------------------------------------------------------- !!     Close files and exit !!----------------------------------------------------------------------- CLOSE ( default_unit_open ) CLOSE ( default_unit_write ) END SUBROUTINE rmcoment end module korc_input","tags":"","loc":"sourcefile/korc_input.f90.html"},{"title":"korc_types.f90 – KORC-Full Orbit","text":"Contents Modules korc_types Source Code korc_types.f90 Source Code module korc_types !! @note Module containing the definition of KORC derived types and !! KORC variables, the building blocks of the code. @endnote #ifdef M3D_C1 USE , INTRINSIC :: iso_c_binding #endif implicit none ! * * * * * * * * * * * * * * * * * * * * ! ! * * * Real and integer precisions * * * ! ! * * * * * * * * * * * * * * * * * * * * ! INTEGER , PUBLIC , PARAMETER :: is = KIND ( INT ( 1 , 1 )) !! Definition of 1 Byte (8 bits) Fortran KORC integer type. INTEGER , PUBLIC , PARAMETER :: ip = KIND ( INT ( 1 , 8 )) !! Definition of 8 Bytes (64 bits) Fortran KORC integer type. INTEGER , PUBLIC , PARAMETER :: idef = KIND ( 1 ) !! Definition of the default KORC integer type on the system where !! KORC is compiled. INTEGER , PUBLIC , PARAMETER :: rdef = KIND ( 1.0 ) !! Definition of the default KORC real type on the system where !! KORC is compiled. #ifdef DOUBLE_PRECISION INTEGER , PUBLIC , PARAMETER :: rp = KIND ( 0.d0 ) !! Definition of the KORC double precision real type. #elif SINGLE_PRECISION INTEGER , PUBLIC , PARAMETER :: rp = KIND ( 1.0 ) !! Definition of the KORC single precision real type. #endif REAL ( rp ), PUBLIC , PARAMETER :: korc_zero = 1.0E-15 !! Definition of the zero in KORC. ! * * * * * * * * * * * * * * * * * * * * ! ! * * * Real and integer precisions * * * ! ! * * * * * * * * * * * * * * * * * * * * ! INTEGER , PUBLIC , PARAMETER :: MAX_STRING_LENGTH = 1000 !! Default length of a KORC_STRING variable. INTEGER , PUBLIC , PARAMETER :: default_unit_open = 101 !! Default file unit for opening and reading from an external text file. INTEGER , PUBLIC , PARAMETER :: default_unit_write = 201 !! Default file unit for opening and writing to external an external text file. INTEGER , PUBLIC , PARAMETER :: output_unit_write = 202 !! Default file unit for opening and writing to external an external text file. !> @note KORC string type of length MAX_STRING_LENGTH. @endnote TYPE , PUBLIC :: KORC_STRING CHARACTER ( MAX_STRING_LENGTH ) :: str END TYPE KORC_STRING ! * * * * * * * * * * * * * * * * * * * * ! ! * * * Basic korc array structures * * * ! ! * * * * * * * * * * * * * * * * * * * * ! TYPE , PUBLIC :: V_FIELD_3D !! @note KORC 3-D vector field type @endnote !! This KORC type represents a 3-D vector field varible in !! cylindrical coordinates. For example, this could be the 3-D magnetic !! field, which can be written as \\mathbf{B}(R,\\phi,Z) = B_R(R,\\phi,Z) !! \\hat{R} + B_\\phi(R,\\phi,Z) \\hat{\\phi} + B_Z(R,\\phi,Z) \\hat{Z}. !! All the members (components) of the V_FIELD_3D type follow the !! following index convention: !! (R index,\\phi index, Z index) REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: R !! R component of the vector field variable. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: PHI !! \\phi component of the vector field variable. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Z !! Z component of the vector field variable. END TYPE V_FIELD_3D TYPE , PUBLIC :: V_FIELD_2D !! @note KORC 2-D vector field type @endnote !! This KORC type represents a 2-D vector field varible in cylindrical !! coordinates. For example, this could be the magnetic !! field in an axisymmetric plasma, which can be written as !! \\mathbf{B}(R,Z) = B_R(R,Z) \\hat{R} + B_\\phi(R,Z) \\hat{\\phi} + B_Z(R,Z) !! \\hat{Z}. !! All the members (components) of the V_FIELD_2D type follow the !! following index convention: !! (R index,Z index). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: R !! R  component of the vector field variable. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: PHI !! \\phi  component of the vector field variable. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Z !! Z  component of the vector field variable. END TYPE V_FIELD_2D TYPE , PUBLIC :: V_FIELD_1D !! @note KORC 1-D vector field type @endnote !! This KORC type represents a 1-D vector field varible in cylindrical !! coordinates. For example, this could be the magnetic !! field in an axisymmetric plasma, which can be written as !! \\mathbf{B}(r) = B_R(r) \\hat{R} + B_\\phi(r) \\hat{\\phi} + B_Z(r) !! \\hat{Z}. !! All the members (components) of the V_FIELD_1D type follow the !! following index convention: !! (r index). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R !! R  component of the vector field variable. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI !! \\phi  component of the vector field variable. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z !! Z  component of the vector field variable. END TYPE V_FIELD_1D ! * * * * * * * * * * * * * * * * * * * * ! ! * * * Basic korc array structures * * * ! ! * * * * * * * * * * * * * * * * * * * * ! TYPE , PRIVATE :: KORC_MPI !! @note KORC derived type to keep relevant MPI parameters. @endnote INTEGER :: nmpi !! Number of MPI processes. INTEGER :: rank !! Rank in WORLD COMMON communicator. INTEGER :: rank_topo !! Rank in mpi_topo communicator INTEGER :: mpi_topo !! MPI communicator for a certain topology. END TYPE KORC_MPI TYPE , PUBLIC :: CHARCS_PARAMS !! @note KORC derived type containing characteristic scales used in the normalization of KORC variables. @endnote !! These characteristic scales are problem-dependent quantities. They are calculated in [[korc_units(module)]] using the input !! parameters of a given KORC simulation. REAL ( rp ) :: time !! @note Characteristic non-relativistic time scale given by 1/\\omega_{ce}, where \\omega_{ce}=e B_0/m_e is the !! largest electron cyclotron frequency in the simulation. @endnote REAL ( rp ) :: time_r !! @note Characteristic relativistic time scale given by 1/\\omega_{ce}, where \\omega_{ce}=e B_0/\\gamma m_e is the !! largest relativistic electron cyclotron frequency in the simulation. @endnote REAL ( rp ) :: velocity !! Characteristic velocity. This is fixed to the speed of c. REAL ( rp ) :: length !! Characteristic length scale calculated as c times the relativistic time scale. REAL ( rp ) :: mass !! Characteristic particle mass. This is equal to the electron mass m_e. REAL ( rp ) :: charge !! Characteristic particle charge. This is equal to the electron charge q_e. REAL ( rp ) :: density !! Characteristic particle density. This is equal to 1/l&#94;3, with l the characteristic length. REAL ( rp ) :: Eo !! Characteristic electric field E_0. Usually E_0 at the magnetic axis. REAL ( rp ) :: Bo !! Characteristic magnetic field B_0. Usually B_0 at the magnetic axis. REAL ( rp ) :: energy !! Characteristic energy. This is equal to m_e c&#94;2. REAL ( rp ) :: pressure !! Characteristic pressure. @todo This needs to be defined. REAL ( rp ) :: temperature !! Characteristic plasma temperature (Joules). This is equal to m_e c&#94;2. END TYPE CHARCS_PARAMS TYPE , PUBLIC :: KORC_PARAMS !! @note Core KORC parameters. @endnote !!  This KORC derived type contains the variables that control KORC's !! core behavior. CHARACTER ( MAX_STRING_LENGTH ) :: path_to_inputs !! Absolute path to KORC's input file. CHARACTER ( MAX_STRING_LENGTH ) :: path_to_outputs !! Absolute path to the outputs' folder. INTEGER :: num_omp_threads !! Number of open MP threads per MPI process used in the simulation. LOGICAL :: restart !! Flag to indicate if the simulations proceeds (restart=T) or not !! (restart=F). Restart simulation that exited before simulation_time !! reached. LOGICAL :: proceed !! Flag to indicate if the simulations continues (proceed=T) or not !! (proceed=F). Append simulation results after previous simulation_time !! reached. LOGICAL :: reinit !! Flag to begin a new simulation, reinitializing from restart file state REAL ( rp ) :: simulation_time !! Total simulation time in seconds. REAL ( rp ) :: snapshot_frequency !! Time between snapshots in time of the simulation. REAL ( rp ) :: restart_overwrite_frequency !! Time between overwrites of restart file in time of the simulation. REAL ( rp ) :: dt !! Time step in the simulation as a fraction of the relativistic electron !! gyro-period \\tau_e = 2\\pi\\gamma m_e/eB_0. REAL ( rp ) :: time = 0.0_rp !! Current physical time in the simulation. INTEGER ( ip ) :: ito = 0_ip !! Initial time iteration in the simulation, this is different from zero !! in case is a restarting simulation. INTEGER ( ip ) :: it = 0_ip !! Current time iteration in the simulation, this is different from zero !! in case is a restarting simulation. REAL ( rp ) :: init_time = 0.0_rp !! Time at the beginning of a run with proceed=T INTEGER ( ip ) :: t_steps INTEGER ( ip ) :: prev_iter_2x1t !! Number of time steps needed for evolving the electrons up to !! \"simulation_time\". INTEGER ( ip ) :: t_skip INTEGER ( ip ) :: t_it_SC = 1_ip INTEGER ( ip ) :: output_cadence !! Time iteration offset used to decide when the outputs are generated. INTEGER ( ip ) :: restart_output_cadence !! Time iteration offset used to decide when the restart files are !! generated. INTEGER ( ip ) :: num_snapshots !! Number of snapshots in time for generating the output files. INTEGER :: num_species !! Number of different populations of simulated relativistic electrons !! in KORC. REAL ( rp ) :: minimum_particle_energy !! Minimum allowed energy of simulated electrons. !! @todo To improve the criterium to decide when an electron will not !! be followed anymore in the simulation. REAL ( rp ) :: minimum_particle_g !! Minimum allowed relativistic factor \\gamma of simulated electrons. LOGICAL :: radiation !! Flag to indicate if synchrotron radiation losses are included !! (radiation=T) or not (radiation=F). LOGICAL :: collisions !! Flag to indicate if collisionsare included (collisions=T) or not !! (collisions=F). CHARACTER ( MAX_STRING_LENGTH ) :: GC_rad_model CHARACTER ( MAX_STRING_LENGTH ) :: collisions_model !! String with the name of the collisions model to be used in the !! simulation. CHARACTER ( MAX_STRING_LENGTH ) :: bound_electron_model CHARACTER ( MAX_STRING_LENGTH ) :: field_model CHARACTER ( MAX_STRING_LENGTH ) :: profile_model !! String with the name of the model for the fields and plasma profiles. CHARACTER ( MAX_STRING_LENGTH ) :: magnetic_field_filename !! String with the name of the model for the fields and plasma profiles. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: outputs_list !! List of electron variables to include in the outputs. INTEGER :: HDF5_error_handling !! Flag to indicate whether we allow HDF5 to show warnings !! during runtime (HDF5_error_handling=1) or not (HDF5_error_handling=0) TYPE ( KORC_MPI ) :: mpi_params !! An instance of the KORC_MPI derived type. TYPE ( CHARCS_PARAMS ) :: cpp !! An instance of the CHARCS_PARAMS derived type. LOGICAL :: FO_GC_compare CHARACTER ( MAX_STRING_LENGTH ) :: orbit_model !! String with the name of the orbit model ('FO' or 'GC'). CHARACTER ( MAX_STRING_LENGTH ) :: field_eval !! String with the name of the field evaluation method for !! analytical fields ('interp' or 'eqn') LOGICAL :: GC_coords !! Flag to [[get_fields]] to control whether cartesian to cylindrical !! coordinate transformation needs to be performed LOGICAL :: FokPlan !! Flag to decouple spatial-dependence of evolution LOGICAL :: SameRandSeed LOGICAL :: SC_E LOGICAL :: SC_E_add INTEGER :: time_slice !< M3D-C1 time slice to use. REAL ( rp ) :: rmax !< Maximum r for M3D-C1 fields. REAL ( rp ) :: rmin !< Minimum r for M3D-C1 fields. REAL ( rp ) :: zmax !< Maximum z for M3D-C1 fields. REAL ( rp ) :: zmin !< Minimum z for M3D-C1 fields. INTEGER :: pchunk !! number of particles per vectorized chunk END TYPE KORC_PARAMS TYPE , PUBLIC :: PARTICLES !! @note Derived type containing all the electrons' variables !!in the simulation. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: X !! Cartesian coordinates of the electrons' position. !! dim(X) = (3,SPECIES::ppp). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: V !! Cartesian components of the electrons' velocity. dim(V) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Rgc !! Cartesian coordinates of the electrons' guiding-center position. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Y !! Coordinates of the electrons' position in cylindrical or toroidal !! coordinates. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Y0 !! Placeholder coordinates of the electrons' position in cylindrical !! coordinates for GC orbit model. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V0 !! Placeholder of the electrons' parallel momentum for the GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: E !! Cartesian components of the electric field felt by each electron. !! dim(E) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: B !! Cartesian components of the magnetic field felt by each electron. !! dim(B) = dim(X). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PSI_P REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: BR !! Cartesian components of the gradient of the R-component of the !! magnetic field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: BPHI !! Cartesian components of the gradient of the PHI-component of the !! magnetic field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: BZ !! Cartesian components of the gradient of the Z-component of the !! magnetic field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: gradB !! Cylindrical components of the gradient of magnitude of magnetic !! field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: curlb !! Cylindrical components of the curl of the magnetic field unit !! vector felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: RHS !! RHS of equations of motion for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k1 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k2 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k3 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k4 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k5 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k6 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ne !! Electron density seen by each electron. dim(ne) = (1,SPECIES::ppp). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Te !! Electron temperature seen by each electron. dim(Te) = (1,SPECIES::ppp). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zeff !! Zeff seen by each electron. dim(Zeff) = (1,SPECIES::ppp). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g !! Instantaneous relativistic \\gamma = 1/\\sqrt{1 - v&#94;2/c&#94;2} factor !! of each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta !! Instantaneous pitch angle of each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: mu !! Magnetic moment of each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Prad !! Instantaneous radiated power by each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Pin !! Instantaneous input power of each electron due to the electric !! field acceleration. INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: flagCon INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: flagCol !! Flag for each particle to decide whether it is being followed !! (flag=T) or not (flag=F). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: AUX !! An auxiliary scalar variable for each electron. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: wt !! Weight of each electron. This is used when sampling weighted !! PDFs and in the synthetic camera diagnostic. TYPE ( C_PTR ), DIMENSION (:), ALLOCATABLE :: hint !! Hint for M3D_C1 interpolation. LOGICAL :: cart END TYPE PARTICLES TYPE , PUBLIC :: SPECIES !! @note Derived type containing the initial parameters of each electron !! ensemble followed in a KORC simulation. @endnote TYPE ( PARTICLES ) :: vars !! An instance of the PARTICLES derived type. LOGICAL :: runaway !! Flag to decide whether a given electron is a runaway (runaway=T) !! or not (runaway=F). CHARACTER ( MAX_STRING_LENGTH ) :: spatial_distribution !! String describing the type of initial spatial distribution for !! each electron species. CHARACTER ( MAX_STRING_LENGTH ) :: energy_distribution !! String describing the type of initial energy distribution for !! each electron species. CHARACTER ( MAX_STRING_LENGTH ) :: pitch_distribution !! String describing the type of initial pitch-angle distribution for !! each electron species. REAL ( rp ) :: Eo !! Initial energy of each electron species in case of using an initial !! mono-energetic distribution. REAL ( rp ) :: go !! Corresponding relativisitc factor of each electron species in case !! of using an initial mono-energetic distribution. REAL ( rp ) :: etao !! Initial pitch-angle of each electron species in case of using an !! initial mono-pitch-angle distribution. REAL ( rp ), DIMENSION ( 2 ) :: Eo_lims !! Minimum and maximum energy limits of a given initial !! non-mono-energetic distribution. REAL ( rp ), DIMENSION ( 2 ) :: etao_lims !! Minimum and maximum pitch-angle limits of a given initial !! non-mono-pitch-angle distribution. REAL ( rp ) :: wc !! The mean electron cyclotron frequency of each electron species. REAL ( rp ) :: wc_r !! The mean relativistic electron cyclotron frequency of each electron !! species. REAL ( rp ) :: q !! Charge of each species. @note This was left explicit to allow !! KORC to follow electrons and ions in the future. @endnote REAL ( rp ) :: m !! Mass of each species. @note This was left explicit to allow KORC !! to follow electrons and ions in the future. @endnote INTEGER :: ppp !! Number of computational particles used to simulate each electron !! species. REAL ( rp ) :: Ro !! Radial position of the center of the electrons' initial spatial !! distribution. REAL ( rp ) :: PHIo !! Azimuthal position of the electrons' initial spatial !! distribution, in case of using a disk at a certain poloidal section. REAL ( rp ) :: Zo !! Height of the center of the electrons' initial spatial distribution. REAL ( rp ) :: r_inner !! Minimum minor radius of the electrons' initial spatial distribution. REAL ( rp ) :: r_outter !! Maximum minor radius of the electrons' initial spatial distribution. REAL ( rp ) :: falloff_rate !! Exponential falloff or standard deviation of a non-uniform radial !! distribution of electrons. REAL ( rp ) :: shear_factor !! Shear factor used to generate an initial spatial distribution with an !! elliptic poloidal cross section. !! @note See <em>Carbajal and del-Castillo-Negrete, Nuclear Fusion, !! submitted (2018)</em>. @endnote REAL ( rp ) :: sigmaR !! Variance of the first dimension of a 2D Gaussian, spatial !! distribution function REAL ( rp ) :: sigmaZ !! Variance of the second dimension of a 2D Gaussian, spatial !! distribution function REAL ( rp ) :: theta_gauss !! Angle of counter-clockwise rotation (in degrees) of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: psi_max !! Maximum value of the argument of the 2D gaussian exponential, used !! for an indicator function that limits the region of MH sampling REAL ( rp ) :: Spong_b REAL ( rp ) :: Spong_w REAL ( rp ) :: Spong_dlam REAL ( rp ) :: dth REAL ( rp ) :: dgam REAL ( rp ) :: dR REAL ( rp ) :: dZ REAL ( rp ), DIMENSION ( 3 ) :: Xtrace !! Initial position in Cartesian coordinates for tracer particle END TYPE SPECIES TYPE , PRIVATE :: A_FIELD !! @note Derived type having all the parameters of the analytical !! magnetic field included in KORC. @endnote !! The analytical magnetic field is given by: !! \\mathbf{B}(r,\\vartheta) = \\frac{1}{1 + \\eta \\cos{\\vartheta}} !! \\left[ B_0 \\hat{e}_\\zeta  + B_\\vartheta(r) \\hat{e}_\\vartheta \\right], !! where \\eta = r/R_0 is the aspect ratio, the constant B_0 !! denotes the magnitude of the toroidal magnetic field, !! and B_\\vartheta(r) = \\eta B_0/q(r) is the poloidal magnetic !! field with safety factor !! q(r) = q_0\\left( 1 + \\frac{r&#94;2}{\\lambda&#94;2} \\right). The !! constant q_0 is the safety factor at !! the magnetic axis and the constant \\lambda is obtained from !! the values of q_0 and q(r) !! at the plasma edge r=r_{edge}. REAL ( rp ) :: Bo !! Magnitude of the toroidal magnetic field B_0. REAL ( rp ) :: a !! Plasma edge r_{edge} as measured from the magnetic axis. REAL ( rp ) :: Ro !! Radial position of the magnetic axis R_0 REAL ( rp ) :: qa !! Safety factor at the plasma edge. REAL ( rp ) :: qo !! Safety factor at the magnetic axis q_0. REAL ( rp ) :: lambda !! \\lambda parameter of q(r). REAL ( rp ) :: Bpo !! @deprecated Parameter not used anymore. @todo Delete parameter. REAL ( rp ) :: Bp_sign !! Sign of B_\\vartheta(r). This depends on current_direction, !! Bp_sign=1 for !! current_direction='PARALLEL', and Bp_sign=-1 for !! current_direction='ANTI-PARALLEL'. CHARACTER ( MAX_STRING_LENGTH ) :: current_direction !! Direction of plasma current: PARALLEL or ANTI-PARALLEL to the !! toroidal magnetic field. END TYPE A_FIELD TYPE , PRIVATE :: MESH !! Derived type with the cylindrical coordinates of the grid nodes !! at which the pre-computed plasma profiles and fields are known. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R !! Radial grid. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI !! Azimuthal grid. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z !! Z grid. END TYPE MESH TYPE , PUBLIC :: FIELDS !! @note Derived type with all the variables and data of analytical !! and pre-computed electric and magnetic fields. @endnote TYPE ( A_FIELD ) :: AB !! An instance of the KORC derived data type A_FIELD. TYPE ( V_FIELD_3D ) :: E_3D !! KORC 3-D vector field of the pre-computed electric field. TYPE ( V_FIELD_3D ) :: B_3D TYPE ( V_FIELD_3D ) :: dBdR_3D TYPE ( V_FIELD_3D ) :: dBdPHI_3D TYPE ( V_FIELD_3D ) :: dBdZ_3D !! KORC 3-D vector field of the pre-computed magnetic field. TYPE ( V_FIELD_2D ) :: E_2D !! KORC 2-D vector field of the pre-computed electric field. TYPE ( V_FIELD_2D ) :: B_2D TYPE ( V_FIELD_2D ) :: dBdR_2D TYPE ( V_FIELD_2D ) :: dBdPHI_2D TYPE ( V_FIELD_2D ) :: dBdZ_2D !! KORC 3-D vector field of the pre-computed magnetic field. TYPE ( V_FIELD_2D ) :: gradB_2D TYPE ( V_FIELD_3D ) :: gradB_3D !! KORC 3-D vector field of the gradient of the magnitude of the !! pre-computed magnetic field. TYPE ( V_FIELD_2D ) :: curlb_2D TYPE ( V_FIELD_3D ) :: curlb_3D !! KORC 3-D vector field of the curl of the unit vector in the !! direction of the pre-computed magnetic field. TYPE ( V_FIELD_1D ) :: E_SC_1D TYPE ( V_FIELD_1D ) :: J0_SC_1D TYPE ( V_FIELD_1D ) :: J1_SC_1D TYPE ( V_FIELD_1D ) :: J2_SC_1D TYPE ( V_FIELD_1D ) :: J3_SC_1D TYPE ( V_FIELD_1D ) :: A1_SC_1D TYPE ( V_FIELD_1D ) :: A2_SC_1D TYPE ( V_FIELD_1D ) :: A3_SC_1D REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r_1D REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PSIP_1D REAL ( rp ), DIMENSION (:), ALLOCATABLE :: dMagPsiSqdPsiP REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ddMagPsiSqdPsiPSq TYPE ( MESH ) :: X !! An instance of the KORC derived type MESH. CHARACTER ( MAX_STRING_LENGTH ) :: E_model !! Name for dynamical, analytic, electric field model to be added to REAL ( rp ) :: E_dyn REAL ( rp ) :: E_pulse REAL ( rp ) :: E_width REAL ( rp ) :: PSIP_min REAL ( rp ) :: PSIp_lim , PSIp_0 !! interpolated E field INTEGER :: res_double INTEGER , DIMENSION ( 3 ) :: dims !! Dimensions of the KORC vector field. dims=(number of grid !! nodes along R, number of grid nodes along \\phi, !! number of grid nodes along Z). INTEGER :: dim_1D INTEGER :: subcycle_E_SC REAL ( rp ) :: dt_E_SC , Ip_exp , Ip0 REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: PSIp REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: PSIp_FS REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: PSIp3D !! 2-D array for storing the data of the poloidal magnetic flux. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: FLAG2D !! 2-D array defining the simulation domain where pre-computed data exist. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: FLAG3D !! 3-D array defining the simulation domain where pre-computed data exist. REAL ( rp ) :: Eo !! Characteristic electric field. REAL ( rp ) :: Bo !! Characteristic magnetic field. REAL ( rp ) :: Ro !! Radial position of the magnetic axis. REAL ( rp ) :: Zo !! Z position of the magnetic axis. LOGICAL :: Bfield !! Flag to indicate whether a pre-computed magnetic field will be !! used (Bfield=T) or not (Bfield=F). LOGICAL :: dBfield !! Flag to indicate whether a pre-computed magnetic field will be !! used (Bfield=T) or not (Bfield=F). LOGICAL :: Bflux LOGICAL :: Bflux3D !! Flag to indicate whether a pre-computed poloidal magnetic flux will !! be used (Bflux=T) or not (Bflux=F). LOGICAL :: Efield !! Flag to indicate whether a pre-computed electric field will be used !! (Efield=T) or not (Efield=F). LOGICAL :: Bfield_in_file !! Flag to indicate if a pre-computed magnetic field is in the input file. LOGICAL :: dBfield_in_file !! Flag to indicate if a pre-computed magnetic field is in the input file. LOGICAL :: Bflux_in_file !! Flag to indicate if a pre-computed poloidal magnetic flux is in the !! input file. LOGICAL :: Efield_in_file !! Flag to indicate if a pre-computed electric field is in the input file. LOGICAL :: axisymmetric_fields !! Flag to indicate if the pre-computed fields are axisymmetric. LOGICAL :: Dim2x1t LOGICAL :: E_2x1t , ReInterp_2x1t REAL ( rp ) :: t0_2x1t INTEGER :: ind0_2x1t , ind_2x1t #ifdef M3D_C1 INTEGER ( C_INT ) :: M3D_C1_B !! An M3D-C1 magnetic field. INTEGER ( C_INT ) :: M3D_C1_E !! An M3D-C1 Electric field. INTEGER ( C_INT ) :: M3D_C1_A !! An M3D-C1 vector potential. #endif END TYPE FIELDS TYPE , PUBLIC :: PROFILES !! @note KORC derived data type having information about the plasma !! profiles. !! See [[korc_profiles.f90(\"file\")]] for more information. @endnote !! KORC can run using either analytical and pre-computed plasma profiles. !! Pre-computed plasma profiles, !! as in the case of pre-computed electric or magnetic fields, are !! interpolated !! to electrons' position in [[korc_profiles]]. !! !! There are two types of analytical plsama profiles that can be used !! in KORC: !! 3rd degree polynomial radial plasma profiles, !! f(r) = a_3r&#94;3 + a_2r&#94;2 +a_1r + a_0, !! and radial plasma profiles with a \\tanh(r) dependency: !! f(r) = f_0\\left[1 - \\tanh&#94;n\\left(\\frac{2r}{a}\\right)\\right], !! where f_0 is a given plasma parameter at the magnetic axis, !! and a is !! the plasma radius as measured !! from the magnetic axis to the last closed flux surface. Notice that the !! larger n is, the more uniform the radial profiles are. TYPE ( MESH ) :: X !! An instance of the KORC derived data type MESH. REAL ( rp ) :: a !! Plasma radius as measured from the magnetic axis REAL ( rp ) :: R0 REAL ( rp ) :: Z0 REAL ( rp ) :: R0_RE REAL ( rp ) :: Z0_RE INTEGER , DIMENSION ( 3 ) :: dims !! Dimensions of the arrays containing the pre-computed profiles data. dims=(number of grid nodes along R, !! number of grid nodes along \\phi, number of grid nodes along Z). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: FLAG2D !! 2-D array defining the simulation domain where pre-computed data exist. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: FLAG3D !! 3-D array defining the simulation domain where pre-computed data exist. REAL ( rp ) :: n_ne !! n used in \\tanh&#94;n(r) of the electron density profile. REAL ( rp ) :: n_Te !! n used in \\tanh&#94;n(r) of the electron temperature profile. REAL ( rp ) :: n_Zeff !! n used in \\tanh&#94;n(r) of the Z_{eff} profile. REAL ( rp ) :: n_REr0 = 0._rp REAL ( rp ) :: n_tauion = 0._rp REAL ( rp ) :: n_tauin = 0._rp REAL ( rp ) :: n_tauout = 0._rp REAL ( rp ) :: n_shelfdelay = 0._rp REAL ( rp ) :: n_lamfront = 0._rp REAL ( rp ) :: n_lamback = 0._rp REAL ( rp ) :: n_lamshelf = 0._rp REAL ( rp ) :: n_shelf = 0._rp REAL ( rp ) :: psiN_0 = 1._rp REAL ( rp ), DIMENSION ( 4 ) :: a_ne !! Coefficients of the polynomial electron density profile. !! See detailed description above, a_ne=(a_{0},a_{2},a_{3},a_{4}). REAL ( rp ), DIMENSION ( 4 ) :: a_Te !! Coefficients of the polynomial electron temperature profile. !! See detailed description above, a_ne=(a_{0},a_{2},a_{3},a_{4}). REAL ( rp ), DIMENSION ( 4 ) :: a_Zeff !! Coefficients of the Z_{eff} profile. !! See detailed description above, a_ne=(a_{0},a_{2},a_{3},a_{4}). ! Zeff CHARACTER ( MAX_STRING_LENGTH ) :: Zeff_profile !! String containing the type of Z_{eff} profile to be used in the simulation. REAL ( rp ) :: Zeffo !! Z_{eff} at the magnetic axis. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Zeff_3D !! 3-D array for keeping the pre-computed data of the Z_{eff} profile. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Zeff_2D !! 2-D array for keeping the pre-computed data of the Z_{eff} profile. ! Density CHARACTER ( MAX_STRING_LENGTH ) :: ne_profile !! String containing the type of electron density profile to be used in the simulation. REAL ( rp ) :: neo !! Electron density at the magnetic axis REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: ne_3D !! 3-D array for keeping the pre-computed data of the electron density profile. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: ne_2D !! 2-D array for keeping the pre-computed data of the electron density profile. !Temperature CHARACTER ( MAX_STRING_LENGTH ) :: Te_profile !! String containing the type of electron temperature profile to be used in the simulation. REAL ( rp ) :: Teo !! Electron temperature at the magnetic axis REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Te_3D !! 3-D array for keeping the pre-computed data of the electron density profile. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Te_2D !! 2-D array for keeping the pre-computed data of the electron density profile. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! Full path to the HDF5 file containing the pre-computed plasma profiles. LOGICAL :: axisymmetric !! Flag to indicate if the plasma profiles are axisymmetric. #ifdef M3D_C1 INTEGER ( C_INT ) :: M3D_C1_ne INTEGER ( C_INT ) :: M3D_C1_te INTEGER ( C_INT ) :: M3D_C1_zeff #endif END TYPE PROFILES end module korc_types","tags":"","loc":"sourcefile/korc_types.f90.html"},{"title":"korc_experimental_pdf.f90 – KORC-Full Orbit","text":"Contents Modules korc_experimental_pdf Source Code korc_experimental_pdf.f90 Source Code MODULE korc_experimental_pdf USE korc_types USE korc_constants USE korc_HDF5 USE korc_hpc USE special_functions use korc_coords use korc_rnd_numbers use korc_random use korc_fields use korc_input IMPLICIT NONE TYPE , PRIVATE :: PARAMS REAL ( rp ) :: E ! Parallel electric field normalized using the critical electric field REAL ( rp ) :: Zeff ! Effective atomic number of impurities REAL ( rp ) :: max_pitch_angle ! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle ! Minimum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_energy ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_energy ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_p ! Minimum momentum of sampled PDF REAL ( rp ) :: max_p ! Maximum momentum of sampled PDF REAL ( rp ) :: k ! Shape factor of Gamma distribution REAL ( rp ) :: t ! Scale factor of Gamma distribution REAL ( rp ) :: fGo ! Normalization factor of Gamma distribution REAL ( rp ) :: Bo REAL ( rp ) :: lambda REAL ( rp ) :: A_fact ! Multiplication factor for A in distributon. END TYPE PARAMS TYPE , PRIVATE :: HOLLMANN_PARAMS CHARACTER ( MAX_STRING_LENGTH ) :: filename REAL ( rp ) :: E REAL ( rp ) :: Eo REAL ( rp ) :: sigma_E REAL ( rp ) :: Zeff REAL ( rp ) :: sigma_Z REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: min_sampling_energy ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_sampling_energy ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_sampling_g ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_sampling_g ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_energy ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_energy ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_g ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_g ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_pitch ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_pitch ! Maximum energy of sampled PDF in MeV INTEGER :: N REAL ( rp ), DIMENSION (:), ALLOCATABLE :: E_axis REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE :: fRE_E REAL ( rp ), DIMENSION (:), ALLOCATABLE :: fRE_pitch CHARACTER ( MAX_STRING_LENGTH ) :: current_direction REAL ( rp ) :: Bo REAL ( rp ) :: lambda REAL ( rp ) :: A_fact ! Multiplication factor for A in distributon. END TYPE HOLLMANN_PARAMS TYPE ( PARAMS ), PRIVATE :: pdf_params TYPE ( HOLLMANN_PARAMS ), PRIVATE :: h_params REAL ( rp ), PRIVATE , PARAMETER :: xo = ( C_ME * C_C ** 2 / C_E ) / 1.0E6 REAL ( rp ), PRIVATE , PARAMETER :: Tol = 1.0E-5_rp REAL ( rp ), PRIVATE , PARAMETER :: minmax_buffer_size = 1 0.0_rp PUBLIC :: get_experimentalG_distribution ,& get_Hollmann_distribution ,& get_Hollmann_distribution_3D ,& get_Hollmann_distribution_3D_psi ,& initialize_Hollmann_params ,& sample_Hollmann_distribution PRIVATE :: initialize_params ,& save_params ,& sample_distribution ,& deg2rad ,& rad2deg ,& fRE ,& fRExPR ,& random_norm ,& fGamma ,& PR ,& P_integral ,& IntK ,& IntBesselK ,& IntGamma ,& fRE_H ,& fRE_pitch CONTAINS SUBROUTINE get_experimentalG_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao call initialize_params ( params ) call save_params ( params ) call sample_distribution ( params , g , eta , go , etao ) END SUBROUTINE get_experimentalG_distribution SUBROUTINE initialize_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) :: max_pitch_angle !REAL(rp) :: min_pitch_angle !REAL(rp) :: max_energy !REAL(rp) :: min_energy !REAL(rp) :: Zeff !REAL(rp) :: E !REAL(rp) :: k !REAL(rp) :: t !REAL(rp) :: Bo !REAL(rp) :: lambda !REAL(rp) :: A_fact !NAMELIST /ExperimentalPDF/ max_pitch_angle,min_pitch_angle,max_energy, & !     min_energy,Zeff,E,k,t,Bo,lambda,A_fact !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=ExperimentalPDF) !close(default_unit_open) pdf_params % max_pitch_angle = max_pitch_angle_expt pdf_params % min_pitch_angle = min_pitch_angle_expt pdf_params % min_energy = min_energy_expt * C_E ! In Joules pdf_params % max_energy = max_energy_expt * C_E ! In Joules pdf_params % Zeff = Zeff_expt pdf_params % E = E_expt pdf_params % k = k_expt pdf_params % t = t_expt pdf_params % Bo = Bo_expt pdf_params % lambda = lambda_expt pdf_params % max_p = SQRT (( pdf_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc pdf_params % min_p = SQRT (( pdf_params % min_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc pdf_params % fGo = & IntGamma ( SQRT ( pdf_params % min_p ** 2.0_rp + 1.0_rp ), SQRT ( pdf_params % max_p ** 2.0_rp + 1.0_rp ), pdf_params % k , pdf_params % t / xo ) pdf_params % A_fact = A_fact_expt END SUBROUTINE initialize_params FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad FUNCTION rad2deg ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: rad2deg rad2deg = 18 0.0_rp * x / C_PI END FUNCTION rad2deg FUNCTION fGamma ( x , k , t ) REAL ( rp ), INTENT ( IN ) :: x ! Independent variable REAL ( rp ), INTENT ( IN ) :: k ! Shape factor REAL ( rp ), INTENT ( IN ) :: t ! Scale factor REAL ( rp ) :: fGamma fGamma = x ** ( k - 1.0_rp ) * EXP ( - x / t ) / ( GAMMA ( k ) * t ** k ) END FUNCTION fGamma FUNCTION fRE ( eta , p ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRE REAL ( rp ) :: fE REAL ( rp ) :: feta REAL ( rp ) :: A REAL ( rp ) :: Eo Eo = SQRT ( p ** 2.0_rp + 1.0_rp ) A = ( 2.0_rp * pdf_params % E / ( pdf_params % Zeff + 1.0_rp )) * ( p ** 2 / SQRT ( p ** 2.0_rp + 1.0_rp )) A = A * pdf_params % A_fact feta = 0.5_rp * A * EXP ( A * COS ( deg2rad ( eta ))) / SINH ( A ) fE = fGamma ( Eo , pdf_params % k , pdf_params % t / xo ) / pdf_params % fGo fRE = fE * feta END FUNCTION fRE FUNCTION fRExPR ( eta , p ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRExPR REAL ( rp ) :: A REAL ( rp ) :: Eo fRExPR = fRE ( eta , p ) * PR ( eta , p , pdf_params % Bo , pdf_params % lambda ) END FUNCTION fRExPR FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = mean + sigma * SQRT ( - 2.0_rp * LOG ( rand1 )) * COS ( 2.0_rp * C_PI * rand2 ) END FUNCTION random_norm FUNCTION IntK ( v , x ) REAL ( rp ) :: IntK REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: x IntK = ( C_PI / SQRT ( 2.0_rp )) * ( 1.0_rp - 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp )) * ERFC ( SQRT ( x ))& + 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp ) * SQRT ( 0.5_rp * C_PI / x ) * EXP ( - x ) END FUNCTION IntK FUNCTION besselk ( v , x ) REAL ( rp ) :: besselk REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ), INTENT ( IN ) :: v REAL ( 4 ) :: ri , rk , rip , rkp call bessik ( REAL ( x , 4 ), REAL ( v , 4 ), ri , rk , rip , rkp ) besselk = REAL ( rk , rp ) END FUNCTION besselk !> @brief Extended trapezoidal rule for integrating the Gamma PDF. See Sec. 4.2 of Numerical Recipies in Fortran 77. FUNCTION IntGamma ( a , b , k , t ) REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ), INTENT ( IN ) :: k ! shape factor REAL ( rp ), INTENT ( IN ) :: t ! scale factor REAL ( rp ) :: IntGamma REAL ( rp ) :: Iold REAL ( rp ) :: Inew REAL ( rp ) :: rerr REAL ( rp ) :: sum_f REAL ( rp ) :: h , z INTEGER :: ii , jj , npoints LOGICAL :: flag h = b - a sum_f = 0.5 * ( fGamma ( a , k , t ) + fGamma ( b , k , t )) Iold = 0.0_rp Inew = sum_f * h ii = 1_idef flag = . TRUE . do while ( flag ) Iold = Inew ii = ii + 1_idef npoints = 2_idef ** ( ii - 2_idef ) h = 0.5_rp * ( b - a ) / REAL ( npoints , rp ) sum_f = 0.0_rp do jj = 1_idef , npoints z = a + h + 2.0_rp * ( REAL ( jj , rp ) - 1.0_rp ) * h sum_f = sum_f + fGamma ( z , k , t ) end do Inew = 0.5_rp * Iold + sum_f * h rerr = ABS (( Inew - Iold ) / Iold ) flag = . NOT .( rerr . LT . Tol ) end do IntGamma = Inew END FUNCTION IntGamma !> @brief Extended trapezoidal rule for integrating the modified Bessel function of second kind. See Sec. 4.2 of Numerical Recipies in Fortran 77. FUNCTION IntBesselK ( a , b ) REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ) :: IntBesselK REAL ( rp ) :: Iold REAL ( rp ) :: Inew REAL ( rp ) :: rerr REAL ( rp ) :: sum_f REAL ( rp ) :: v , h , z INTEGER :: ii , jj , npoints LOGICAL :: flag v = 5.0_rp / 3.0_rp h = b - a sum_f = 0.5 * ( besselk ( v , a ) + besselk ( v , b )) Iold = 0.0_rp Inew = sum_f * h ii = 1_idef flag = . TRUE . do while ( flag ) Iold = Inew ii = ii + 1_idef npoints = 2_idef ** ( ii - 2_idef ) h = 0.5_rp * ( b - a ) / REAL ( npoints , rp ) sum_f = 0.0_rp do jj = 1_idef , npoints z = a + h + 2.0_rp * ( REAL ( jj , rp ) - 1.0_rp ) * h sum_f = sum_f + besselk ( v , z ) end do Inew = 0.5_rp * Iold + sum_f * h rerr = ABS (( Inew - Iold ) / Iold ) flag = . NOT .( rerr . LT . Tol ) end do IntBesselK = Inew END FUNCTION IntBesselK SUBROUTINE P_integral ( z , P ) REAL ( rp ), INTENT ( OUT ) :: P REAL ( rp ), INTENT ( IN ) :: z REAL ( rp ) :: a P = 0.0_rp IF ( z . LT . 0.5_rp ) THEN a = ( 2.16_rp / 2.0_rp ** ( 2.0_rp / 3.0_rp )) * z ** ( 1.0_rp / 3.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE IF (( z . GE . 0.5_rp ). AND .( z . LT . 2.5_rp )) THEN a = 0.72_rp * ( z + 1.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE P = IntK ( 5.0_rp / 3.0_rp , z ) END IF END SUBROUTINE P_integral FUNCTION PR ( eta , p , Bo , l ) REAL ( rp ), INTENT ( IN ) :: eta ! in radians REAL ( rp ), INTENT ( IN ) :: p ! dimensionless (in units of mc) REAL ( rp ), INTENT ( IN ) :: Bo REAL ( rp ), INTENT ( IN ) :: l REAL ( rp ) :: PR REAL ( rp ) :: g REAL ( rp ) :: v REAL ( rp ) :: k REAL ( rp ) :: lc REAL ( rp ) :: z REAL ( rp ) :: Pi g = SQRT ( p ** 2 + 1.0_rp ) v = C_C * SQRT ( 1.0_rp - 1.0_rp / g ** 2 ) k = C_E * Bo * SIN ( deg2rad ( eta )) / ( g * C_ME * v ) lc = ( 4.0_rp * C_PI / 3.0_rp ) / ( k * g ** 3 ) ! Critical wavelength z = lc / l call P_integral ( z , Pi ) PR = ( C_C * C_E ** 2 ) * Pi / ( SQRT ( 3.0_rp ) * C_E0 * g ** 2 * l ** 3 ) END FUNCTION PR SUBROUTINE sample_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao REAL ( rp ) :: go_root REAL ( rp ) :: etao_root REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: p_buffer REAL ( rp ) :: p_test REAL ( rp ) :: eta_buffer REAL ( rp ) :: eta_test REAL ( rp ) :: ratio REAL ( rp ) :: rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_tmp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax REAL ( rp ) :: min_p REAL ( rp ) :: max_p REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: deta REAL ( rp ) :: dp LOGICAL :: lp LOGICAL :: leta INTEGER :: num_accepted INTEGER :: ii INTEGER :: jj INTEGER :: ppp INTEGER :: nsamples INTEGER :: mpierr ppp = SIZE ( g ) nsamples = ppp * params % mpi_params % nmpi ALLOCATE ( p ( ppp )) deta = ( pdf_params % max_pitch_angle - & pdf_params % min_pitch_angle ) / 10 0.0_rp dp = ( pdf_params % max_p - pdf_params % min_p ) / 10 0.0_rp do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % min_p - REAL ( jj , rp ) * dp if ( minmax . GT . 0.0_rp ) then min_p = minmax end if end do max_p = pdf_params % max_p + minmax_buffer_size * dp if ( pdf_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = 0.0_rp end if do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax else max_pitch_angle = pdf_params % max_pitch_angle EXIT end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( p_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( p_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes !* * * Transient * * *! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_buffer = pdf_params % min_pitch_angle + & ( pdf_params % max_pitch_angle - pdf_params % min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) p_buffer = pdf_params % min_p + ( pdf_params % max_p - & pdf_params % min_p ) * rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . pdf_params % max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . pdf_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) end do p_test = p_buffer + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . pdf_params % min_p ). OR .( p_test . GT . & pdf_params % max_p )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( eta_test , p_test ) / fRE ( eta_buffer , p_buffer ) if ( ratio . GE . 1.0_rp ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef end if end if end do !* * * Transient * * *! eta_tmp ( 1 ) = eta_buffer p_tmp ( 1 ) = p_buffer num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) end do p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . min_p ). OR .( p_test . GT . max_p )) p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( eta_test , p_test ) / fRE ( eta_tmp ( ii - 1 ), p_tmp ( ii - 1 )) if ( ratio . GE . 1.0_rp ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) lp = ( p_tmp ( ii ). LE . pdf_params % max_p ). AND .( p_tmp ( ii ). GE . & pdf_params % min_p ) leta = ( eta_tmp ( ii ). LE . pdf_params % max_pitch_angle ). AND . & ( eta_tmp ( ii ). GE . pdf_params % min_pitch_angle ) if ( lp . AND . leta ) then num_accepted = num_accepted + 1_idef p_samples ( num_accepted ) = p_tmp ( ii ) eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do end do go = SUM ( SQRT ( 1.0_rp + p_samples ** 2 )) / nsamples etao = SUM ( eta_samples ) / nsamples end if CALL MPI_SCATTER ( p_samples , ppp , MPI_REAL8 , p , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , ppp , MPI_REAL8 , eta , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( go , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( etao , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) g = SQRT ( 1.0_rp + p ** 2 ) DEALLOCATE ( p ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( p_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( p_tmp ) DEALLOCATE ( eta_tmp ) end if END SUBROUTINE sample_distribution SUBROUTINE get_Hollmann_distribution ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: g !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: eta !    REAL(rp), INTENT(OUT) :: go !    REAL(rp), INTENT(OUT) :: etao INTEGER :: mpierr if ( spp % ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) 'num_samples need to be atleast 10 but is only: ' , & spp % ppp * params % mpi_params % nmpi end if call korc_abort end if call initialize_Hollmann_params ( params ) call save_Hollmann_params ( params ) call sample_Hollmann_distribution ( params , spp ) END SUBROUTINE get_Hollmann_distribution SUBROUTINE get_Hollmann_distribution_3D ( params , spp , F ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp INTEGER :: mpierr if ( spp % ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) 'num_samples need to be atleast 10 but is only: ' , & spp % ppp * params % mpi_params % nmpi end if call korc_abort end if call initialize_Hollmann_params ( params ) call save_Hollmann_params ( params ) call normalize_Hollmann_params ( params ) call sample_Hollmann_distribution_3D ( params , spp , F ) END SUBROUTINE get_Hollmann_distribution_3D SUBROUTINE get_Hollmann_distribution_3D_psi ( params , spp , F ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp INTEGER :: mpierr if ( spp % ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) 'num_samples need to be atleast 10 but is only: ' , & spp % ppp * params % mpi_params % nmpi end if call korc_abort end if call initialize_Hollmann_params ( params ) call save_Hollmann_params ( params ) call normalize_Hollmann_params ( params ) call sample_Hollmann_distribution_3D_psi ( params , spp , F ) END SUBROUTINE get_Hollmann_distribution_3D_psi SUBROUTINE initialize_Hollmann_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: current_direction REAL ( rp ) :: E , sigma_E , Eo REAL ( rp ) :: Zeff , sigma_Z REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: max_energy REAL ( rp ) :: min_energy REAL ( rp ) :: Bo REAL ( rp ) :: lambda REAL ( rp ) :: A_fact !NAMELIST /HollmannPDF/ E,Zeff,max_pitch_angle,min_pitch_angle,max_energy, & !     min_energy,filename,Bo,lambda,current_direction,A_fact,sigma_E, & !     sigma_Z,Eo !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=HollmannPDF) !close(default_unit_open) h_params % filename = TRIM ( filename_Hollmann ) h_params % E = E_Hollmann h_params % Eo = Eo_Hollmann h_params % sigma_E = sigma_E_Hollmann h_params % Zeff = Zeff_Hollmann h_params % sigma_Z = sigma_Z_Hollmann h_params % max_pitch_angle = max_pitch_angle_Hollmann h_params % min_pitch_angle = min_pitch_angle_Hollmann h_params % min_sampling_energy = min_energy_Hollmann * C_E ! In Joules h_params % min_sampling_g = 1.0_rp + h_params % min_sampling_energy / & ( C_ME * C_C ** 2 ) h_params % max_sampling_energy = max_energy_Hollmann * C_E ! In Joules. h_params % max_sampling_g = 1.0_rp + h_params % max_sampling_energy / & ( C_ME * C_C ** 2 ) call load_data_from_hdf5 () ! loads h_params%E_axis 1D energy range, h_params%fRE_E ! energy distribution as a function of h_params%E_axis, ! and h_params%fRE_pitch pitch angle distribution as a ! function of h_params%E_axis ALLOCATE ( h_params % g ( h_params % N )) h_params % g = 1.0_rp + h_params % E_axis / ( C_ME * C_C ** 2 ) ! 1D range of gamma based on energy range from Hollmann input file h_params % max_g = MAXVAL ( h_params % g ) h_params % min_g = MINVAL ( h_params % g ) h_params % current_direction = TRIM ( current_direction_Hollmann ) h_params % Bo = Bo_Hollmann h_params % lambda = lambda_Hollmann h_params % A_fact = A_fact_Hollmann END SUBROUTINE initialize_Hollmann_params subroutine normalize_Hollmann_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params h_params % sigma_E = h_params % sigma_E / params % cpp % length h_params % sigma_Z = h_params % sigma_Z / params % cpp % length end subroutine normalize_Hollmann_params SUBROUTINE load_data_from_hdf5 () CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id REAL ( rp ) :: rdatum INTEGER :: h5error filename = TRIM ( h_params % filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_data_from_hdf5 (korc_experimental) --> h5fopen_f\")' ) end if dset = \"/N\" call load_from_hdf5 ( h5file_id , dset , rdatum ) h_params % N = INT ( rdatum ) ALLOCATE ( h_params % E_axis ( h_params % N )) ALLOCATE ( h_params % fRE_E ( h_params % N )) ALLOCATE ( h_params % fRE_pitch ( h_params % N )) dset = \"/E\" call load_array_from_hdf5 ( h5file_id , dset , h_params % E_axis ) h_params % E_axis = h_params % E_axis * C_E dset = \"/fRE_E\" call load_array_from_hdf5 ( h5file_id , dset , h_params % fRE_E ) dset = \"/fRE_pitch\" call load_array_from_hdf5 ( h5file_id , dset , h_params % fRE_pitch ) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_data_from_hdf5 (korc_experimental) --> h5fclose_f\")' ) end if END SUBROUTINE load_data_from_hdf5 FUNCTION fRE_H ( eta , g ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: g ! Relativistic gamma factor REAL ( rp ) :: fRE_H REAL ( rp ) :: D REAL ( rp ) :: g0 REAL ( rp ) :: g1 REAL ( rp ) :: f0 REAL ( rp ) :: f1 REAL ( rp ) :: m REAL ( rp ) :: feta REAL ( rp ) :: A INTEGER :: index index = MINLOC ( ABS ( h_params % g - g ), 1 ) ! index of gamma supplied to function in Hollmann input gamma range D = h_params % g ( index ) - g ! linear interpolation of Hollmann input gamma range to gamma supplied ! to function if ( D . GT . 0 ) then f0 = h_params % fRE_E ( index - 1 ) g0 = h_params % g ( index - 1 ) f1 = h_params % fRE_E ( index ) g1 = h_params % g ( index ) else f0 = h_params % fRE_E ( index ) g0 = h_params % g ( index ) f1 = h_params % fRE_E ( index + 1 ) g1 = h_params % g ( index + 1 ) end if m = ( f1 - f0 ) / ( g1 - g0 ) fRE_H = f0 + m * ( g - g0 ) ! end of linear interpolation, fRE_H is evaluation of input Hollmann energy ! distribution PDF at gamma supplied to function A = ( 2.0_rp * h_params % E / ( h_params % Zeff + 1.0_rp )) * ( g ** 2 - 1.0_rp ) / g A = A * h_params % A_fact feta = A * EXP ( - A * ( 1.0_rp - COS ( deg2rad ( eta )))) / ( 1.0_rp - EXP ( - 2.0_rp * A )) ! MRC !\tfeta = 0.5_rp*A*EXP(A*COS(deg2rad(eta)))/SINH(A)                            ! MRC fRE_H = fRE_H * feta END FUNCTION fRE_H FUNCTION fRE_H_3D ( F , eta , g , R , Z , R0 , Z0 ) TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: g ! Relativistic gamma factor REAL ( rp ), INTENT ( IN ) :: R , Z , R0 , Z0 REAL ( rp ) :: fRE_H_3D REAL ( rp ) :: D REAL ( rp ) :: g0 REAL ( rp ) :: g1 REAL ( rp ) :: f0 REAL ( rp ) :: f1 REAL ( rp ) :: m REAL ( rp ) :: feta REAL ( rp ) :: A REAL ( rp ) :: rm , E_G , Z_G INTEGER :: index index = MINLOC ( ABS ( h_params % g - g ), 1 ) ! index of gamma supplied to function in Hollmann input gamma range D = h_params % g ( index ) - g ! linear interpolation of Hollmann input gamma range to gamma supplied ! to function if ( D . GT . 0 ) then f0 = h_params % fRE_E ( index - 1 ) g0 = h_params % g ( index - 1 ) f1 = h_params % fRE_E ( index ) g1 = h_params % g ( index ) else f0 = h_params % fRE_E ( index ) g0 = h_params % g ( index ) f1 = h_params % fRE_E ( index + 1 ) g1 = h_params % g ( index + 1 ) end if m = ( f1 - f0 ) / ( g1 - g0 ) fRE_H_3D = f0 + m * ( g - g0 ) ! end of linear interpolation, fRE_H is evaluation of input Hollman energy ! distribution PDF at gamma supplied to function rm = sqrt (( R - R0 ) ** 2 + ( Z - Z0 ) ** 2 ) E_G = F % Ro * h_params % Eo / R !    E_G=h_params%E*exp(-(rm/h_params%sigma_E)**2/2) Z_G = h_params % Zeff * exp ( - ( rm / h_params % sigma_Z ) ** 2 / 2 ) !    write(output_unit_write,'(\"rm: \",E17.10)') rm A = ( 2.0_rp * E_G / ( Z_G + 1.0_rp )) * ( g ** 2 - 1.0_rp ) / g A = A * h_params % A_fact feta = A * EXP ( - A * ( 1.0_rp - COS ( deg2rad ( eta )))) / ( 1.0_rp - EXP ( - 2.0_rp * A )) ! MRC !\tfeta = 0.5_rp*A*EXP(A*COS(deg2rad(eta)))/SINH(A)                            ! MRC fRE_H_3D = fRE_H_3D * feta END FUNCTION fRE_H_3D FUNCTION fRE_HxPR ( eta , g ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: g ! gamma factor REAL ( rp ) :: fRE_HxPR fRE_HxPR = fRE_H ( eta , g ) * PR ( eta , SQRT ( g ** 2 - 1.0_rp ), h_params % Bo , h_params % lambda ) END FUNCTION fRE_HxPR FUNCTION fRE_pitch ( g ) REAL ( rp ), INTENT ( IN ) :: g ! Relativistic gamma factor REAL ( rp ) :: fRE_pitch REAL ( rp ) :: D REAL ( rp ) :: g0 , g1 , f0 , f1 , m INTEGER :: index index = MINLOC ( ABS ( h_params % g - g ), 1 ) D = h_params % g ( index ) - g if ( D . GT . 0 ) then f0 = h_params % fRE_pitch ( index - 1 ) g0 = h_params % g ( index - 1 ) f1 = h_params % fRE_pitch ( index ) g1 = h_params % g ( index ) else f0 = h_params % fRE_pitch ( index ) g0 = h_params % g ( index ) f1 = h_params % fRE_pitch ( index + 1 ) g1 = h_params % g ( index + 1 ) end if m = ( f1 - f0 ) / ( g1 - g0 ) fRE_pitch = f0 + m * ( g - g0 ) fRE_pitch = 18 0.0_rp - fRE_pitch END FUNCTION fRE_pitch SUBROUTINE sample_Hollmann_distribution ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) \t:: g !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) \t:: eta !    REAL(rp), INTENT(OUT) \t\t\t\t:: go !    REAL(rp), INTENT(OUT) \t\t\t\t:: etao REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: g_buffer REAL ( rp ) :: g_test REAL ( rp ) :: eta_buffer REAL ( rp ) :: eta_test REAL ( rp ) :: ratio REAL ( rp ) :: rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g_tmp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax REAL ( rp ) :: min_g REAL ( rp ) :: max_g REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: dg REAL ( rp ) :: deta LOGICAL :: lp INTEGER :: index_i INTEGER :: index_f INTEGER :: num_accepted INTEGER :: ii INTEGER :: jj INTEGER :: ppp INTEGER :: nsamples INTEGER :: mpierr INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) nsamples = spp % ppp * params % mpi_params % nmpi index_i = MINLOC ( ABS ( h_params % g - h_params % min_sampling_g ), 1 ) !index of minimum gamma range desired index_f = MINLOC ( ABS ( h_params % g - h_params % max_sampling_g ), 1 ) !index of maximum gamma range desired deta = ( h_params % max_pitch_angle - h_params % min_pitch_angle ) / 10 0.0_rp dg = ( h_params % max_sampling_g - h_params % min_sampling_g ) / 10 0.0_rp ! buffer at minimum gamma boundary do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_sampling_g - REAL ( jj , rp ) * dg if ( minmax . GT . h_params % min_g ) then min_g = minmax end if ! buffer at maximum gamma boundary minmax = h_params % max_sampling_g + REAL ( jj , rp ) * dg if ( minmax . LT . h_params % max_g ) then max_g = minmax end if end do ! buffer at minimum pitch angle boundary if ( h_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = 0.0_rp end if ! buffer at maximum pitch angle boundary do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax else max_pitch_angle = h_params % max_pitch_angle EXIT end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then !! MCMC and MH algorithm perfomred on single MPI process !! to sample distribution function fRE_H ALLOCATE ( g_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( g_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes !Transient! if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( rand_unif ) !       rand_unif=get_random_U() eta_buffer = h_params % min_pitch_angle + ( h_params % max_pitch_angle & - h_params % min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) !       rand_unif=get_random_U() g_buffer = h_params % min_sampling_g + ( h_params % max_sampling_g - & h_params % min_sampling_g ) * rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , spp % dth ) !          eta_test = eta_buffer + get_random_N()*spp%dth do while (( ABS ( eta_test ) . GT . h_params % max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . h_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , spp % dth ) !             eta_test = eta_buffer + get_random_N()*spp%dth end do g_test = g_buffer + random_norm ( 0.0_rp , spp % dgam ) !          g_test = g_buffer + get_random_N()*spp%dgam do while (( g_test . LT . h_params % min_sampling_g ). OR . & ( g_test . GT . h_params % max_sampling_g )) g_test = g_buffer + random_norm ( 0.0_rp , spp % dgam ) !             g_test = g_buffer + get_random_N()*spp%dgam end do ratio = fRE_H ( eta_test , g_test ) * sin ( deg2rad ( eta_test )) / & ( fRE_H ( eta_buffer , g_buffer ) * & sin ( deg2rad ( eta_buffer ))) !ratio = fRE_H(eta_test,g_test)/fRE_H(eta_buffer,g_buffer) !ratio = fRE_HxPR(eta_test,g_test)/fRE_HxPR(eta_buffer,g_buffer) if ( ratio . GE . 1.0_rp ) then g_buffer = g_test eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) !             rand_unif=get_random_U() if ( rand_unif . LT . ratio ) then g_buffer = g_test eta_buffer = eta_test ii = ii + 1_idef end if end if end do !Transient! eta_tmp ( 1 ) = eta_buffer g_tmp ( 1 ) = g_buffer num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !             write(output_unit_write,'(\"iisample\",I16)') ii eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dth ) !eta_test = eta_tmp(ii-1) + get_random_N()*spp%dth !             write(output_unit_write,'(\"max_pitch_angle: \",E17.10)') max_pitch_angle !             write(output_unit_write,'(\"min_pitch_angle: \",E17.10)') min_pitch_angle do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dth ) !                eta_test = eta_tmp(ii-1) + get_random_N()*spp%dth !                write(output_unit_write,'(\"eta_test: \",E17.10)') eta_test end do g_test = g_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dgam ) !g_test = g_tmp(ii-1) + get_random_N()*spp%dgam !             write(output_unit_write,'(\"max_g: \",E17.10)') max_g !             write(output_unit_write,'(\"min_g: \",E17.10)') min_g do while (( g_test . LT . min_g ). OR .( g_test . GT . max_g )) g_test = g_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dgam ) !                g_test = g_tmp(ii-1) + get_random_N()*spp%dgam !                write(output_unit_write,'(\"g_test: \",E17.10)') g_test end do ratio = fRE_H ( eta_test , g_test ) * sin ( deg2rad ( eta_test )) / & ( fRE_H ( eta_tmp ( ii - 1 ), g_tmp ( ii - 1 )) * & sin ( deg2rad ( eta_tmp ( ii - 1 )))) !             ratio = fRE_H(eta_test,g_test)/fRE_H(eta_tmp(ii-1),g_tmp(ii-1)) !ratio = fRE_HxPR(eta_test,g_test)/fRE_HxPR(eta_tmp(ii-1),g_tmp(ii-1)) !             write(output_unit_write,'(\"ratio: \",E17.10)') ratio if ( ratio . GE . 1.0_rp ) then g_tmp ( ii ) = g_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) !                rand_unif=get_random_U() if ( rand_unif . LT . ratio ) then g_tmp ( ii ) = g_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) !             write(output_unit_write,'(\"iiaccept\",I16)') ii lp = ( g_tmp ( ii ). LE . h_params % max_sampling_g ). AND . & ( g_tmp ( ii ). GE . h_params % min_sampling_g ). AND . & ( eta_tmp ( ii ). LE . h_params % max_pitch_angle ). AND . & ( eta_tmp ( ii ). GE . h_params % min_pitch_angle ) if ( lp ) then num_accepted = num_accepted + 1_idef g_samples ( num_accepted ) = g_tmp ( ii ) eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do end do !\t\tif (TRIM(h_params%current_direction) .EQ. 'ANTICLOCKWISE') then !\t\t\teta_samples = 180.0_rp - eta_samples !\t\tend if !       go = SUM(g_samples)/nsamples !       etao = SUM(eta_samples)/nsamples end if !MCMC computed on single MPI process CALL MPI_SCATTER ( g_samples , spp % ppp , MPI_REAL8 , spp % vars % g , spp % ppp , MPI_REAL8 , & 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , spp % ppp , MPI_REAL8 , spp % vars % eta , spp % ppp , MPI_REAL8 , & 0 , MPI_COMM_WORLD , mpierr ) !    CALL MPI_BCAST(go,1,MPI_REAL8,0,MPI_COMM_WORLD,mpierr) !    CALL MPI_BCAST(etao,1,MPI_REAL8,0,MPI_COMM_WORLD,mpierr) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( g_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( g_tmp ) DEALLOCATE ( eta_tmp ) end if !   write(output_unit_write,'(\"sampled eta: \",E17.10)') eta END SUBROUTINE sample_Hollmann_distribution FUNCTION PSI_ROT_exp ( R , R0 , sigR , Z , Z0 , sigZ , theta ) REAL ( rp ), INTENT ( IN ) :: R !! R-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: R0 !! R-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigR !! Variance of first dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: Z !! Z-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: Z0 !! Z-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigZ !! Variance of second dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: theta !! Angle of counter-clockwise rotation (in radians), of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: PSI_ROT_exp !! Argument of exponential comprising 2D Gaussian distribution PSI_ROT_exp = ( R - R0 ) ** 2 * (( cos ( theta )) ** 2 / ( 2 * sigR ** 2 ) + & ( sin ( theta )) ** 2 / ( 2 * sigZ ** 2 )) + & 2 * ( R - R0 ) * ( Z - Z0 ) * cos ( theta ) * sin ( theta ) * ( 1 / ( 2 * sigR ** 2 ) - 1 / ( 2 * sigZ ** 2 )) + & ( Z - Z0 ) ** 2 * (( sin ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( cos ( theta )) ** 2 / ( 2 * sigZ ** 2 )) END FUNCTION PSI_ROT_exp FUNCTION indicator_exp ( psi , psi_max ) REAL ( rp ), INTENT ( IN ) :: psi REAL ( rp ), INTENT ( IN ) :: psi_max REAL ( rp ) :: indicator_exp IF ( psi . LT . psi_max ) THEN indicator_exp = 1 ELSE indicator_exp = 0 END IF END FUNCTION indicator_exp subroutine sample_Hollmann_distribution_3D ( params , spp , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples , X_samples , Y_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: G_samples !! Gamma of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples !! Pitch angle of all samples REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: min_g , max_g REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: eta_buffer !! Previous sample of pitch REAL ( rp ) :: G_buffer REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: eta_test !! Present sample of pitch angle REAL ( rp ) :: G_test REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: f0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: f1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator REAL ( rp ) :: dg , deta LOGICAL :: accepted INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 2._rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp deta = ( h_params % max_pitch_angle - h_params % min_pitch_angle ) / 10 0.0_rp dg = ( h_params % max_sampling_g - h_params % min_sampling_g ) / 10 0.0_rp ! buffer at minimum gamma boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_sampling_g - REAL ( ii , rp ) * dg if ( minmax . GT . h_params % min_g ) then min_g = minmax end if ! buffer at maximum gamma boundary minmax = h_params % max_sampling_g + REAL ( ii , rp ) * dg if ( minmax . LT . h_params % max_g ) then max_g = minmax end if end do ! buffer at minimum pitch angle boundary if ( h_params % min_pitch_angle . GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_pitch_angle - REAL ( ii , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = h_params % min_pitch_angle end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % max_pitch_angle + REAL ( ii , rp ) * deta if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ALLOCATE ( X_samples ( nsamples )) ALLOCATE ( Y_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( G_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if !     call RANDOM_NUMBER(rand_unif) !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*rand_unif !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*get_random_mkl_U() eta_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * get_random_U () !     call RANDOM_NUMBER(rand_unif) !     G_buffer = min_g + (max_g - min_g)*rand_unif !     G_buffer = min_g + (max_g - min_g)*get_random_mkl_U() G_buffer = min_g + ( max_g - min_g ) * get_random_U () !     write(output_unit_write,*) 'R_buffer',R_buffer !     write(output_unit_write,*) 'Z_buffer',Z_buffer !     write(output_unit_write,*) 'eta_buffer',eta_buffer !     write(output_unit_write,*) 'G_buffer',G_buffer !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length accepted = . false . ii = 1_idef do while ( ii . LE . 1000_idef ) !        write(output_unit_write,'(\"burn:\",I15)') ii !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then psi0 = PSI_ROT_exp ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) f0 = fRE_H_3D ( F , eta_buffer , G_buffer , R_buffer , Z_buffer , spp % Ro , spp % Zo ) !           f0=fRE_H(eta_buffer,G_buffer) end if if ( accepted ) then psi0 = psi1 f0 = f1 end if psi1 = PSI_ROT_exp ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 !        write(output_unit_write,'(\"f0: \",E17.10)') f0 !        write(output_unit_write,'(\"f1: \",E17.10)') f1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator_exp ( psi1 , spp % psi_max ) * & R_test * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = indicator_exp(psi1,spp%psi_max)* & !             R_test*EXP(-psi1)*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*EXP(-psi0)*f0*sin(deg2rad(eta_buffer))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef else !           call RANDOM_NUMBER(rand_unif) !           if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do if ( accepted ) then psi0 = psi1 f0 = f1 end if psi1 = PSI_ROT_exp ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) !        write(output_unit_write,'(\"R: \",E17.10)') R_test !        write(output_unit_write,'(\"R0: \",E17.10)') spp%Ro !        write(output_unit_write,'(\"sigma_R: \",E17.10)') spp%sigmaR !        write(output_unit_write,'(\"dR: \",E17.10)') spp%dR !        write(output_unit_write,'(\"N_dR: \",E17.10)') random_norm(0.0_rp,spp%dR) !        write(output_unit_write,'(\"Z: \",E17.10)') Z_test !        write(output_unit_write,'(\"Z0: \",E17.10)') spp%Zo !        write(output_unit_write,'(\"sigma_Z: \",E17.10)') spp%sigmaZ !        write(output_unit_write,'(\"dZ: \",E17.10)') spp%dZ !        write(output_unit_write,'(\"N_dR: \",Z17.10)') random_norm(0.0_rp,spp%dZ) f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) ratio = indicator_exp ( psi1 , psi_max_buff ) * & R_test * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = indicator_exp(psi1,psi_max_buff)* & !             R_test*EXP(-psi1)*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*EXP(-psi0)*f0*sin(deg2rad(eta_buffer))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test else !call RANDOM_NUMBER(rand_unif) !if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test end if end if !        write(output_unit_write,'(\"R: \",E17.10)') R_buffer !        write(output_unit_write,'(\"Z: \",E17.10)') Z_buffer ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator_exp ( psi1 , spp % psi_max )). EQ . 1 ). AND . & ( G_buffer . LE . h_params % max_sampling_g ). AND . & ( G_buffer . GE . h_params % min_sampling_g ). AND . & ( eta_buffer . LE . h_params % max_pitch_angle ). AND . & ( eta_buffer . GE . h_params % min_pitch_angle ). AND . & ACCEPTED ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer eta_samples ( ii ) = eta_buffer G_samples ( ii ) = G_buffer !           write(output_unit_write,*) 'RS',R_buffer ! Sample phi location uniformly !call RANDOM_NUMBER(rand_unif) !PHI_samples(ii) = 2.0_rp*C_PI*rand_unif !PHI_samples(ii) = 2.0_rp*C_PI*get_random_mkl_U() PHI_samples ( ii ) = 2.0_rp * C_PI * get_random_U () ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length X_samples = R_samples * cos ( PHI_samples ) Y_samples = R_samples * sin ( PHI_samples ) !     write(output_unit_write,*) 'R_samples',R_samples !     write(output_unit_write,*) 'PHI_samples',PHI_samples !     write(output_unit_write,*) 'Z_samples',Z_samples !     write(output_unit_write,*) 'G_samples',G_samples !     write(output_unit_write,*) 'eta_samples',eta_samples end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( X_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Y_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , spp % ppp , MPI_REAL8 , & spp % vars % eta , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( G_samples , spp % ppp , MPI_REAL8 , & spp % vars % g , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varY',spp%vars%X(:,2) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varR',spp%vars%Y(:,1) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_PHI: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_Z: \",E17.10)') spp%vars%Y(:,3)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( X_samples ) DEALLOCATE ( Y_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( G_samples ) end if end subroutine sample_Hollmann_distribution_3D subroutine sample_Hollmann_distribution_3D_psi ( params , spp , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples , X_samples , Y_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: G_samples !! Gamma of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples !! Pitch angle of all samples REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: min_g , max_g REAL ( rp ) :: min_R , max_R REAL ( rp ) :: min_Z , max_Z REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: eta_buffer !! Previous sample of pitch REAL ( rp ) :: G_buffer REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: eta_test !! Present sample of pitch angle REAL ( rp ) :: G_test REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: PSIp_lim , PSIP0 , PSIN , PSIN0 , PSIN1 , sigma REAL ( rp ) :: f0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: f1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator REAL ( rp ) :: dg , deta LOGICAL :: accepted INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.25_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp params % GC_coords = . TRUE . PSIp_lim = F % PSIp_lim PSIp0 = F % PSIP_min if ( params % field_model . eq . 'M3D_C1' ) then min_R = params % rmin / params % cpp % length max_R = params % rmax / params % cpp % length min_Z = params % zmin / params % cpp % length max_Z = params % zmax / params % cpp % length else min_R = minval ( F % X % R ) max_R = maxval ( F % X % R ) min_Z = minval ( F % X % Z ) max_Z = maxval ( F % X % Z ) end if sigma = spp % sigmaR * params % cpp % length !write(output_unit_write,*) min_R,max_R !write(output_unit_write,*) min_Z,max_Z deta = ( h_params % max_pitch_angle - h_params % min_pitch_angle ) / 10 0.0_rp dg = ( h_params % max_sampling_g - h_params % min_sampling_g ) / 10 0.0_rp ! buffer at minimum gamma boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_sampling_g - REAL ( ii , rp ) * dg if ( minmax . GT . h_params % min_g ) then min_g = minmax end if ! buffer at maximum gamma boundary minmax = h_params % max_sampling_g + REAL ( ii , rp ) * dg if ( minmax . LT . h_params % max_g ) then max_g = minmax end if end do ! buffer at minimum pitch angle boundary if ( h_params % min_pitch_angle . GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_pitch_angle - REAL ( ii , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = h_params % min_pitch_angle end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % max_pitch_angle + REAL ( ii , rp ) * deta if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ALLOCATE ( X_samples ( nsamples )) ALLOCATE ( Y_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( G_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if !     call RANDOM_NUMBER(rand_unif) !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*rand_unif !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*get_random_mkl_U() eta_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * get_random_U () !     call RANDOM_NUMBER(rand_unif) !     G_buffer = min_g + (max_g - min_g)*rand_unif !     G_buffer = min_g + (max_g - min_g)*get_random_mkl_U() G_buffer = min_g + ( max_g - min_g ) * get_random_U () !     write(output_unit_write,*) 'R_buffer',R_buffer !     write(output_unit_write,*) 'Z_buffer',Z_buffer !     write(output_unit_write,*) 'eta_buffer',eta_buffer !     write(output_unit_write,*) 'G_buffer',G_buffer !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length accepted = . false . ii = 1_idef do while ( ii . LE . 1000_idef ) if ( modulo ( ii , 100 ). eq . 0 ) then write ( output_unit_write , '(\"Burn: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then !           psi0=PSI_ROT_exp(R_buffer,spp%Ro,spp%sigmaR,Z_buffer,spp%Zo, & !                spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_buffer spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_buffer write ( output_unit_write , * ) 'R' , R_buffer write ( output_unit_write , * ) 'Z' , Z_buffer call get_fields ( params , spp % vars , F ) psi0 = spp % vars % PSI_P ( 1 ) PSIN0 = ( psi0 - PSIP0 ) / ( PSIp_lim - PSIP0 ) f0 = fRE_H_3D ( F , eta_buffer , G_buffer , R_buffer , Z_buffer , spp % Ro , spp % Zo ) !           f0=fRE_H(eta_buffer,G_buffer) end if if ( accepted ) then !psi0=psi1 PSIN0 = PSIN1 f0 = f1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0._rp spp % vars % Y ( 1 , 3 ) = Z_test call get_fields ( params , spp % vars , F ) psi1 = spp % vars % PSI_P ( 1 ) PSIN1 = ( psi1 - PSIP0 ) / ( PSIp_lim - PSIP0 ) write ( output_unit_write , * ) 'R' , R_test write ( output_unit_write , * ) 'Z' , Z_test write ( output_unit_write , * ) 'PSI' , psi1 write ( output_unit_write , * ) 'PSIN' , PSIN f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 !        write(output_unit_write,'(\"f0: \",E17.10)') f0 !        write(output_unit_write,'(\"f1: \",E17.10)') f1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. !        ratio = indicator_exp(PSIN,spp%psi_max)* & !             R_test*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*f0*sin(deg2rad(eta_buffer))) ratio = indicator_exp ( PSIN1 , spp % psi_max ) * & R_test * EXP ( - PSIN1 / sigma ) * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * EXP ( - PSIN0 / sigma ) * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef else !           call RANDOM_NUMBER(rand_unif) !           if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do if ( accepted ) then PSIN0 = PSIN1 f0 = f1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test call get_fields ( params , spp % vars , F ) psi1 = spp % vars % PSI_P ( 1 ) PSIN1 = ( psi1 - PSIP0 ) / ( PSIp_lim - PSIP0 ) !        write(output_unit_write,'(\"R: \",E17.10)') R_test !        write(output_unit_write,'(\"R0: \",E17.10)') spp%Ro !        write(output_unit_write,'(\"sigma_R: \",E17.10)') spp%sigmaR !        write(output_unit_write,'(\"dR: \",E17.10)') spp%dR !        write(output_unit_write,'(\"N_dR: \",E17.10)') random_norm(0.0_rp,spp%dR) !        write(output_unit_write,'(\"Z: \",E17.10)') Z_test !        write(output_unit_write,'(\"Z0: \",E17.10)') spp%Zo !        write(output_unit_write,'(\"sigma_Z: \",E17.10)') spp%sigmaZ !        write(output_unit_write,'(\"dZ: \",E17.10)') spp%dZ !        write(output_unit_write,'(\"N_dR: \",Z17.10)') random_norm(0.0_rp,spp%dZ) f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) !        ratio = indicator_exp(PSIN,psi_max_buff)* & !             R_test*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*f0*sin(deg2rad(eta_buffer))) ratio = indicator_exp ( PSIN1 , psi_max_buff ) * & R_test * EXP ( - PSIN1 / sigma ) * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * EXP ( - PSIN0 / sigma ) * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test else !call RANDOM_NUMBER(rand_unif) !if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test end if end if !        write(output_unit_write,'(\"R: \",E17.10)') R_buffer !        write(output_unit_write,'(\"Z: \",E17.10)') Z_buffer ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator_exp ( PSIN1 , spp % psi_max )). EQ . 1 ). AND . & ( G_buffer . LE . h_params % max_sampling_g ). AND . & ( G_buffer . GE . h_params % min_sampling_g ). AND . & ( eta_buffer . LE . h_params % max_pitch_angle ). AND . & ( eta_buffer . GE . h_params % min_pitch_angle ). AND . & ACCEPTED ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer eta_samples ( ii ) = eta_buffer G_samples ( ii ) = G_buffer !           write(output_unit_write,*) 'RS',R_buffer ! Sample phi location uniformly !call RANDOM_NUMBER(rand_unif) !PHI_samples(ii) = 2.0_rp*C_PI*rand_unif !PHI_samples(ii) = 2.0_rp*C_PI*get_random_mkl_U() PHI_samples ( ii ) = 2.0_rp * C_PI * get_random_U () ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length X_samples = R_samples * cos ( PHI_samples ) Y_samples = R_samples * sin ( PHI_samples ) !     write(output_unit_write,*) 'R_samples',R_samples !     write(output_unit_write,*) 'PHI_samples',PHI_samples !     write(output_unit_write,*) 'Z_samples',Z_samples !     write(output_unit_write,*) 'G_samples',G_samples !     write(output_unit_write,*) 'eta_samples',eta_samples end if params % GC_coords = . FALSE . call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( X_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Y_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , spp % ppp , MPI_REAL8 , & spp % vars % eta , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( G_samples , spp % ppp , MPI_REAL8 , & spp % vars % g , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varY',spp%vars%X(:,2) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varR',spp%vars%Y(:,1) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_PHI: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_Z: \",E17.10)') spp%vars%Y(:,3)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( X_samples ) DEALLOCATE ( Y_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( G_samples ) end if end subroutine sample_Hollmann_distribution_3D_psi SUBROUTINE save_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"experimental_distribution_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * pdf_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * pdf_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_p\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % max_p , attr ) dset = TRIM ( gname ) // \"/min_p\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % min_p , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Zeff , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % E , attr ) dset = TRIM ( gname ) // \"/k\" attr = \"Shape factor\" call save_to_hdf5 ( h5file_id , dset , pdf_params % k , attr ) dset = TRIM ( gname ) // \"/t\" attr = \"Scale factor\" call save_to_hdf5 ( h5file_id , dset , pdf_params % t , attr ) dset = TRIM ( gname ) // \"/fGo\" attr = \"Normalization of Gamma function\" call save_to_hdf5 ( h5file_id , dset , pdf_params % fGo , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Wavelength used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % lambda , attr ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Magnetic field used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Bo , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_params SUBROUTINE save_Hollmann_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"experimental_distribution_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , h_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , h_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * h_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * h_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % max_g , attr ) dset = TRIM ( gname ) // \"/min_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % min_g , attr ) dset = TRIM ( gname ) // \"/max_sampling_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % max_sampling_g , attr ) dset = TRIM ( gname ) // \"/min_sampling_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % min_sampling_g , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , h_params % Zeff , attr ) dset = TRIM ( gname ) // \"/sigmaZeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , h_params % sigma_Z , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , h_params % E , attr ) dset = TRIM ( gname ) // \"/sigmaE\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , h_params % sigma_E , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Wavelength used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , h_params % lambda , attr ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Magnetic field used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , h_params % Bo , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_Hollmann_params END MODULE korc_experimental_pdf","tags":"","loc":"sourcefile/korc_experimental_pdf.f90.html"},{"title":"korc_fields.f90 – KORC-Full Orbit","text":"Contents Modules korc_fields Source Code korc_fields.f90 Source Code module korc_fields !! @note Module containing subroutines to initialize externally !! generated fields, and to calculate the electric and magnetic !! fields when using an analytical model. @endnote use korc_types use korc_hpc use korc_coords use korc_interp use korc_HDF5 use korc_input IMPLICIT NONE PUBLIC :: mean_F_field ,& get_fields ,& add_analytical_E_p ,& analytical_fields_GC_p ,& analytical_fields_Bmag_p ,& analytical_fields_p ,& initialize_fields ,& load_field_data_from_hdf5 ,& load_dim_data_from_hdf5 ,& ALLOCATE_2D_FIELDS_ARRAYS ,& ALLOCATE_3D_FIELDS_ARRAYS ,& DEALLOCATE_FIELDS_ARRAYS ,& calculate_SC_E1D ,& calculate_SC_p ,& init_SC_E1D ,& reinit_SC_E1D ,& calculate_SC_E1D_FS ,& calculate_SC_p_FS ,& init_SC_E1D_FS ,& reinit_SC_E1D_FS ,& define_SC_time_step PRIVATE :: get_analytical_fields ,& analytical_fields ,& analytical_fields_GC_init ,& analytical_fields_GC ,& uniform_magnetic_field ,& uniform_electric_field ,& uniform_fields ,& cross ,& analytical_electric_field_cyl ,& ALLOCATE_V_FIELD_2D ,& ALLOCATE_V_FIELD_3D ,& initialize_GC_fields ,& initialize_GC_fields_3D CONTAINS subroutine analytical_fields ( F , Y , E , B , flag ) !! @note Subroutine that calculates and returns the analytic electric and !! magnetic field for each particle in the simulation. @endnote !! The analytical magnetic field is given by: !! !! \\mathbf{B}(r,\\vartheta) = \\frac{1}{1 + \\eta \\cos{\\vartheta}} !! \\left[ B_0 \\hat{e}_\\zeta + B_\\vartheta(r) \\hat{e}_\\vartheta \\right], !! !! where \\eta = r/R_0 is the aspect ratio, the constant B_0 !! denotes the magnitude of the toroidal magnetic field, !! and B_\\vartheta(r) = \\eta B_0/q(r) is the poloidal magnetic !! field with !! safety factor q(r) = q_0\\left( 1 + \\frac{r&#94;2}{\\lambda&#94;2} \\right). !! The constant q_0 is the safety factor at the magnetic axis and !! the constant \\lambda is obtained from the values of q_0 !! and q(r) at the plasma edge r=r_{edge}. On the other hand, !! the analytical electric fields is given by: !! !! \\mathbf{E}(r,\\vartheta) = \\frac{1}{1 + \\eta \\cos{\\vartheta}} !! E_0 \\hat{e}_\\zeta, !! !! where E_0 is the electric field as measured at the mangetic axis. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Toroidal coordinates of each particle in the simulation; !! Y(1,:) = r, Y(2,:) = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in Cartesian coordinates; !! B(1,:) = B_x, B(2,:) = B_y, B(3,:) = B_z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in Cartesian coordinates; !! E(1,:) = E_x, E(2,:) = E_y, E(3,:) = E_z INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ) :: eta !! Aspect ratio \\eta. REAL ( rp ) :: q !! Safety profile q(r). INTEGER ( ip ) :: pp ! Iterator(s) !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,Ezeta,Bp,Bzeta,eta,q) & !$OMP& SHARED(F,Y,E,B,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then eta = Y ( pp , 1 ) / F % Ro q = F % AB % qo * ( 1.0_rp + ( Y ( pp , 1 ) / F % AB % lambda ) ** 2 ) Bp = F % AB % Bp_sign * eta * F % AB % Bo / ( q * ( 1.0_rp + eta * COS ( Y ( pp , 2 )))) Bzeta = F % AB % Bo / ( 1.0_rp + eta * COS ( Y ( pp , 2 )) ) B ( pp , 1 ) = Bzeta * COS ( Y ( pp , 3 )) - Bp * SIN ( Y ( pp , 2 )) * SIN ( Y ( pp , 3 )) B ( pp , 2 ) = - Bzeta * SIN ( Y ( pp , 3 )) - Bp * SIN ( Y ( pp , 2 )) * COS ( Y ( pp , 3 )) B ( pp , 3 ) = Bp * COS ( Y ( pp , 2 )) if ( abs ( F % Eo ) > 0 ) then Ezeta = - F % Eo / ( 1.0_rp + eta * COS ( Y ( pp , 2 )) ) E ( pp , 1 ) = Ezeta * COS ( Y ( pp , 3 )) E ( pp , 2 ) = - Ezeta * SIN ( Y ( pp , 3 )) E ( pp , 3 ) = 0.0_rp end if end if end do !$OMP END PARALLEL DO end subroutine analytical_fields subroutine analytical_fields_p ( pchunk , B0 , E0 , R0 , q0 , lam , ar , X_X , X_Y , X_Z , & B_X , B_Y , B_Z , E_X , E_Y , E_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: R0 , B0 , lam , q0 , E0 , ar REAL ( rp ), INTENT ( IN ), DIMENSION ( pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: E_X , E_Y , E_Z INTEGER ( is ), INTENT ( INOUT ), DIMENSION ( pchunk ) :: flag_cache REAL ( rp ), DIMENSION ( pchunk ) :: T_R , T_T , T_Z REAL ( rp ), DIMENSION ( pchunk ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ), DIMENSION ( pchunk ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ), DIMENSION ( pchunk ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ), DIMENSION ( pchunk ) :: eta !! Aspect ratio \\eta. REAL ( rp ), DIMENSION ( pchunk ) :: q !! Safety profile q(r). REAL ( rp ), DIMENSION ( pchunk ) :: cT , sT , cZ , sZ INTEGER :: cc !! Particle chunk iterator. call cart_to_tor_check_if_confined_p ( pchunk , ar , R0 , X_X , X_Y , X_Z , & T_R , T_T , T_Z , flag_cache ) !$OMP SIMD !    !$OMP& aligned(cT,sT,cZ,sZ,eta,q,Bp,Bzeta,B_X,B_Y,B_Z, & !    !$OMP& Ezeta,E_X,E_Y,E_Z,T_T,T_Z,T_R) do cc = 1_idef , pchunk cT ( cc ) = cos ( T_T ( cc )) sT ( cc ) = sin ( T_T ( cc )) cZ ( cc ) = cos ( T_Z ( cc )) sZ ( cc ) = sin ( T_Z ( cc )) eta ( cc ) = T_R ( cc ) / R0 q ( cc ) = q0 * ( 1.0_rp + ( T_R ( cc ) * T_R ( cc ) / ( lam * lam ))) Bp ( cc ) = - eta ( cc ) * B0 / ( q ( cc ) * ( 1.0_rp + eta ( cc ) * cT ( cc ))) Bzeta ( cc ) = B0 / ( 1.0_rp + eta ( cc ) * cT ( cc )) B_X ( cc ) = Bzeta ( cc ) * cZ ( cc ) - Bp ( cc ) * sT ( cc ) * sZ ( cc ) B_Y ( cc ) = - Bzeta ( cc ) * sZ ( cc ) - Bp ( cc ) * sT ( cc ) * cZ ( cc ) B_Z ( cc ) = Bp ( cc ) * cT ( cc ) Ezeta ( cc ) = - E0 / ( 1.0_rp + eta ( cc ) * cT ( cc )) E_X ( cc ) = Ezeta ( cc ) * cZ ( cc ) E_Y ( cc ) = - Ezeta ( cc ) * sZ ( cc ) E_Z ( cc ) = 0.0_rp end do !$OMP END SIMD end subroutine analytical_fields_p subroutine analytical_fields_GC_init ( params , F , Y , E , B , gradB , curlb , flag , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Cylindrical coordinates of each particle in the simulation; !! Y(1,:) = r, Y(2,:) = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION ( 3 ) :: Btmp !! Placeholder for magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: gradB !! Gradient of magnitude of magnetic field in cylindrical coordinates; !! gradB(1,:) = \\nabla_R B, B(2,:) = \\nabla_\\phi B_, !! B(3,:) = \\nabla_Z B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: curlB !! Curl of magnetic field unit vector in cylindrical coordinates REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in cylindricalcoordinates; !! E(1,:) = E_R, E(2,:) = E_\\phi, E(3,:) = E_Z REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: PSIp INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ) :: eta !! Aspect ratio \\eta. REAL ( rp ) :: q !! Safety profile q(r). INTEGER ( ip ) :: pp ! Iterator(s) !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. REAL ( rp ) :: dRBR REAL ( rp ) :: dRBPHI REAL ( rp ) :: dRBZ REAL ( rp ) :: dZBR REAL ( rp ) :: dZBPHI REAL ( rp ) :: dZBZ REAL ( rp ) :: Bmag REAL ( rp ) :: dRbhatPHI REAL ( rp ) :: dRbhatZ REAL ( rp ) :: dZbhatR REAL ( rp ) :: dZbhatPHI REAL ( rp ) :: qprof REAL ( rp ) :: rm , theta !    write(output_unit_write,'(\"Y: \",E17.10)') Y ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,rm,Btmp,qprof,dRBR,dRBPHI, & !$OMP dRBZ,dZBR,dZBPHI,dZBZ,Bmag,dRbhatPHI,dRbhatZ,dZbhatR,dZbhatPHI, & !$OMP theta,PSIp) & !$OMP& SHARED(F,Y,E,B,gradB,curlb,flag) do pp = 1_idef , ss !       if ( flag(pp) .EQ. 1_is ) then rm = sqrt (( Y ( pp , 1 ) - F % AB % Ro ) ** 2 + Y ( pp , 3 ) ** 2 ) theta = atan2 ( Y ( pp , 3 ),( Y ( pp , 1 ) - F % AB % Ro )) qprof = 1.0_rp + ( rm / F % AB % lambda ) ** 2 PSIp ( pp ) = Y ( pp , 1 ) * F % AB % lambda ** 2 * F % Bo / & ( 2 * F % AB % qo * ( F % AB % Ro + rm * cos ( theta ))) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) Btmp ( 1 ) = F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) Btmp ( 2 ) =- F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) Btmp ( 3 ) =- F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * qprof * Y ( pp , 1 )) B ( pp , 1 ) = Btmp ( 1 ) * COS ( Y ( pp , 2 )) - Btmp ( 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = Btmp ( 1 ) * SIN ( Y ( pp , 2 )) + Btmp ( 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = Btmp ( 3 ) dRBR =- F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1. / Y ( pp , 1 ) + & 2 * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % lambda ** 2 * qprof )) dRBPHI = F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) ** 2 dRBZ = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( - F % AB % Ro / Y ( pp , 1 ) + 2 * ( Y ( pp , 1 ) - & F % AB % Ro ) ** 2 / ( F % AB % lambda ** 2 * qprof )) dZBR = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1 - 2 * Y ( pp , 3 ) * Y ( pp , 3 ) / & ( F % AB % lambda ** 2 * qprof )) dZBPHI = 0._rp dZBZ = F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * Y ( pp , 1 )) * 2 * Y ( pp , 3 ) / & (( F % AB % lambda * qprof ) ** 2 ) Bmag = sqrt ( B ( pp , 1 ) * B ( pp , 1 ) + B ( pp , 2 ) * B ( pp , 2 ) + B ( pp , 3 ) * B ( pp , 3 )) gradB ( pp , 1 ) = ( B ( pp , 1 ) * dRBR + B ( pp , 2 ) * dRBPHI + B ( pp , 3 ) * dRBZ ) / Bmag gradB ( pp , 2 ) = 0._rp gradB ( pp , 3 ) = ( B ( pp , 1 ) * dZBR + B ( pp , 2 ) * dZBPHI + B ( pp , 3 ) * dZBZ ) / Bmag dRbhatPHI = ( Bmag * dRBPHI - B ( pp , 2 ) * gradB ( pp , 1 )) / Bmag ** 2 dRbhatZ = ( Bmag * dRBZ - B ( pp , 3 ) * gradB ( pp , 1 )) / Bmag ** 2 dZbhatR = ( Bmag * dZBR - B ( pp , 1 ) * gradB ( pp , 3 )) / Bmag ** 2 dZbhatPHI = ( Bmag * dZBPHI - B ( pp , 2 ) * gradB ( pp , 3 )) / Bmag ** 2 curlb ( pp , 1 ) =- dZbhatPHI curlb ( pp , 2 ) = dZbhatR - dRbhatZ curlb ( pp , 3 ) = B ( pp , 2 ) / ( Bmag * Y ( pp , 1 )) + dRbhatPHI !          if (abs(F%Eo) > 0) then E ( pp , 1 ) = 0.0_rp E ( pp , 2 ) = F % Eo * F % AB % Ro / Y ( pp , 1 ) E ( pp , 3 ) = 0.0_rp !         end if !      end if end do !$OMP END PARALLEL DO end subroutine analytical_fields_GC_init subroutine analytical_fields_GC ( params , F , Y , E , B , gradB , curlb , flag , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Cylindrical coordinates of each particle in the simulation; !! Y(1,:) = r, Y(2,:) = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION ( 3 ) :: Btmp !! Placeholder for magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: gradB !! Gradient of magnitude of magnetic field in cylindrical coordinates; !! gradB(1,:) = \\nabla_R B, B(2,:) = \\nabla_\\phi B_, !! B(3,:) = \\nabla_Z B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: curlB !! Curl of magnetic field unit vector in cylindrical coordinates REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in cylindricalcoordinates; !! E(1,:) = E_R, E(2,:) = E_\\phi, E(3,:) = E_Z REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: PSIp INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ) :: eta !! Aspect ratio \\eta. REAL ( rp ) :: q !! Safety profile q(r). INTEGER ( ip ) :: pp ! Iterator(s) !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. REAL ( rp ) :: dRBR REAL ( rp ) :: dRBPHI REAL ( rp ) :: dRBZ REAL ( rp ) :: dZBR REAL ( rp ) :: dZBPHI REAL ( rp ) :: dZBZ REAL ( rp ) :: Bmag REAL ( rp ) :: dRbhatPHI REAL ( rp ) :: dRbhatZ REAL ( rp ) :: dZbhatR REAL ( rp ) :: dZbhatPHI REAL ( rp ) :: qprof REAL ( rp ) :: rm , theta ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,rm,Btmp,qprof,dRBR,dRBPHI, & !$OMP dRBZ,dZBR,dZBPHI,dZBZ,Bmag,dRbhatPHI,dRbhatZ,dZbhatR,dZbhatPHI, & !$OMP theta) & !$OMP& SHARED(F,Y,E,B,gradB,curlb,flag,PSIp) do pp = 1_idef , ss !       if ( flag(pp) .EQ. 1_is ) then rm = sqrt (( Y ( pp , 1 ) - F % AB % Ro ) ** 2 + Y ( pp , 3 ) ** 2 ) theta = atan2 ( Y ( pp , 3 ),( Y ( pp , 1 ) - F % AB % Ro )) qprof = 1.0_rp + ( rm / F % AB % lambda ) ** 2 !       write(output_unit_write,*) 'rm: ',rm !       write(output_unit_write,*) 'R0: ',F%AB%Ro !       write(output_unit_write,*) 'Y_R: ',Y(pp,1) !       write(output_unit_write,*) 'theta: ',theta PSIp ( pp ) = Y ( pp , 1 ) * F % AB % lambda ** 2 * F % Bo / & ( 2 * F % AB % qo * ( F % AB % Ro + rm * cos ( theta ))) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) !       write(output_unit_write,*) 'PSIp: ',PSIp(pp) Btmp ( 1 ) = F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) Btmp ( 2 ) =- F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) Btmp ( 3 ) =- F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * qprof * Y ( pp , 1 )) B ( pp , 1 ) = Btmp ( 1 ) B ( pp , 2 ) = Btmp ( 2 ) B ( pp , 3 ) = Btmp ( 3 ) dRBR =- F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1. / Y ( pp , 1 ) + & 2 * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % lambda ** 2 * qprof )) dRBPHI = F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) ** 2 dRBZ = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( - F % AB % Ro / Y ( pp , 1 ) + 2 * ( Y ( pp , 1 ) - & F % AB % Ro ) ** 2 / ( F % AB % lambda ** 2 * qprof )) dZBR = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1 - 2 * Y ( pp , 3 ) * Y ( pp , 3 ) / & ( F % AB % lambda ** 2 * qprof )) dZBPHI = 0._rp dZBZ = F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * Y ( pp , 1 )) * 2 * Y ( pp , 3 ) / & (( F % AB % lambda * qprof ) ** 2 ) Bmag = sqrt ( B ( pp , 1 ) * B ( pp , 1 ) + B ( pp , 2 ) * B ( pp , 2 ) + B ( pp , 3 ) * B ( pp , 3 )) gradB ( pp , 1 ) = ( B ( pp , 1 ) * dRBR + B ( pp , 2 ) * dRBPHI + B ( pp , 3 ) * dRBZ ) / Bmag gradB ( pp , 2 ) = 0._rp gradB ( pp , 3 ) = ( B ( pp , 1 ) * dZBR + B ( pp , 2 ) * dZBPHI + B ( pp , 3 ) * dZBZ ) / Bmag dRbhatPHI = ( Bmag * dRBPHI - B ( pp , 2 ) * gradB ( pp , 1 )) / Bmag ** 2 dRbhatZ = ( Bmag * dRBZ - B ( pp , 3 ) * gradB ( pp , 1 )) / Bmag ** 2 dZbhatR = ( Bmag * dZBR - B ( pp , 1 ) * gradB ( pp , 3 )) / Bmag ** 2 dZbhatPHI = ( Bmag * dZBPHI - B ( pp , 2 ) * gradB ( pp , 3 )) / Bmag ** 2 curlb ( pp , 1 ) =- dZbhatPHI curlb ( pp , 2 ) = dZbhatR - dRbhatZ curlb ( pp , 3 ) = B ( pp , 2 ) / ( Bmag * Y ( pp , 1 )) + dRbhatPHI !          if (abs(F%Eo) > 0) then E ( pp , 1 ) = 0.0_rp E ( pp , 2 ) = F % Eo * F % AB % Ro / Y ( pp , 1 ) E ( pp , 3 ) = 0.0_rp !         end if !      end if end do !$OMP END PARALLEL DO !    write(output_unit_write,*) 'PSIp: ',PSIp(:) !    write(output_unit_write,*) 'B_PHI: ',B(:,2) end subroutine analytical_fields_GC subroutine analytical_fields_Bmag_p ( pchunk , F , Y_R , Y_PHI , Y_Z , Bmag , E_PHI ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: R0 , B0 , lam , q0 , EF0 REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ) :: B_R , B_PHI , B_Z , rm , qprof REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Bmag , E_PHI integer ( ip ) :: cc B0 = F % Bo EF0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,rm,qprof,Bmag) do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) * ( Y_R ( cc ) - R0 ) + Y_Z ( cc ) * Y_Z ( cc )) qprof ( cc ) = 1.0_rp + ( rm ( cc ) * rm ( cc ) / ( lam * lam )) B_R ( cc ) = B0 * Y_Z ( cc ) / ( q0 * qprof ( cc ) * Y_R ( cc )) B_PHI ( cc ) =- B0 * R0 / Y_R ( cc ) B_Z ( cc ) =- B0 * ( Y_R ( cc ) - R0 ) / ( q0 * qprof ( cc ) * Y_R ( cc )) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) E_PHI ( cc ) = EF0 * R0 / Y_R ( cc ) end do !$OMP END SIMD end subroutine analytical_fields_Bmag_p subroutine add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ) :: E_dyn , E_pulse , E_width , time , arg , arg1 , R0 REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R integer ( ip ) :: cc , pchunk pchunk = params % pchunk time = params % init_time + ( params % it - 1 + tt ) * params % dt E_dyn = F % E_dyn E_pulse = F % E_pulse E_width = F % E_width R0 = F % Ro !write(output_unit_write,*) E_dyn,E_pulse,E_width,R0 !$OMP SIMD !    !$OMP& aligned(E_PHI) do cc = 1_idef , pchunk arg = ( time - E_pulse ) ** 2 / ( 2._rp * E_width ** 2 ) arg1 = 1 0._rp * ( time - E_pulse ) / ( sqrt ( 2._rp ) * E_width ) E_PHI ( cc ) = E_PHI ( cc ) + R0 * E_dyn / Y_R ( cc ) * exp ( - arg ) * ( 1._rp + erf ( - arg1 )) / 2._rp end do !$OMP END SIMD !write(output_unit_write,*) arg,arg1 end subroutine add_analytical_E_p subroutine analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , PSIp ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlB_R , curlB_PHI , curlB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: dRBR , dRBPHI , dRBZ , dZBR , dZBPHI , dZBZ , Bmag , dRbhatPHI REAL ( rp ), DIMENSION ( pchunk ) :: dRbhatZ , dZbhatR , dZbhatPHI , qprof , rm , theta REAL ( rp ) :: B0 , E0 , lam , R0 , q0 integer ( ip ) :: cc B0 = F % Bo E0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlB_R,curlB_PHI,curlB_Z,E_R,E_PHI,E_Z,PSIp) do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) * ( Y_R ( cc ) - R0 ) + Y_Z ( cc ) * Y_Z ( cc )) theta ( cc ) = atan2 ( Y_Z ( cc ),( Y_R ( cc ) - R0 )) qprof ( cc ) = 1.0_rp + ( rm ( cc ) * rm ( cc ) / ( lam * lam )) PSIp ( cc ) = Y_R ( cc ) * lam ** 2 * B0 / & ( 2 * q0 * ( R0 + rm ( cc ) * cos ( theta ( cc )))) * & log ( 1 + ( rm ( cc ) / lam ) ** 2 ) B_R ( cc ) = B0 * Y_Z ( cc ) / ( q0 * qprof ( cc ) * Y_R ( cc )) B_PHI ( cc ) =- B0 * R0 / Y_R ( cc ) B_Z ( cc ) =- B0 * ( Y_R ( cc ) - R0 ) / ( q0 * qprof ( cc ) * Y_R ( cc )) dRBR ( cc ) =- B0 * Y_Z ( cc ) / ( q0 * qprof ( cc ) * Y_R ( cc )) * ( 1. / Y_R ( cc ) + & 2 * ( Y_R ( cc ) - R0 ) / ( lam * lam * qprof ( cc ))) dRBPHI ( cc ) = B0 * R0 / ( Y_R ( cc ) * Y_R ( cc )) dRBZ ( cc ) = B0 / ( q0 * qprof ( cc ) * Y_R ( cc )) * ( - R0 / Y_R ( cc ) + 2 * ( Y_R ( cc ) - & R0 ) * ( Y_R ( cc ) - R0 ) / ( lam * lam * qprof ( cc ))) dZBR ( cc ) = B0 / ( q0 * qprof ( cc ) * Y_R ( cc )) * ( 1 - 2 * Y_Z ( cc ) * Y_Z ( cc ) / & ( lam * lam * qprof ( cc ))) dZBPHI ( cc ) = 0._rp dZBZ ( cc ) = B0 * ( Y_R ( cc ) - R0 ) / ( q0 * Y_R ( cc )) * 2 * Y_Z ( cc ) / & ( lam * lam * qprof ( cc ) * qprof ( cc )) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dRBR ( cc ) + B_PHI ( cc ) * dRBPHI ( cc ) + B_Z ( cc ) * dRBZ ( cc )) / & Bmag ( cc ) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * dZBR ( cc ) + B_PHI ( cc ) * dZBPHI ( cc ) + B_Z ( cc ) * dZBZ ( cc )) / & Bmag ( cc ) dRbhatPHI ( cc ) = ( Bmag ( cc ) * dRBPHI ( cc ) - B_PHI ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) dRbhatZ ( cc ) = ( Bmag ( cc ) * dRBZ ( cc ) - B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) dZbhatR ( cc ) = ( Bmag ( cc ) * dZBR ( cc ) - B_R ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) dZbhatPHI ( cc ) = ( Bmag ( cc ) * dZBPHI ( cc ) - B_PHI ( cc ) * gradB_Z ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_R ( cc ) =- dZbhatPHI ( cc ) curlb_PHI ( cc ) = dZbhatR ( cc ) - dRbhatZ ( cc ) curlb_Z ( cc ) = B_PHI ( cc ) / ( Bmag ( cc ) * Y_R ( cc )) + dRbhatPHI ( cc ) E_R ( cc ) = 0.0_rp E_PHI ( cc ) = E0 * R0 / Y_R ( cc ) E_Z ( cc ) = 0.0_rp end do !$OMP END SIMD end subroutine analytical_fields_GC_p subroutine uniform_magnetic_field ( F , B ) !! @note Subroutine that returns the value of a uniform magnetic !! field. @endnote !! This subroutine is used only when the simulation is ran for a !! 'UNIFORM' plasma. As a convention, in a uniform plasma we !! set \\mathbf{B} = B_0 \\hat{x}. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in Cartesian coordinates; !! B(1,:) = B_x, B(2,:) = B_y, B(3,:) = B_z B (:, 1 ) = F % Bo B (:, 2 : 3 ) = 0.0_rp end subroutine uniform_magnetic_field subroutine uniform_electric_field ( F , E ) !! @note Subroutine that returns the value of a uniform electric !! field. @endnote !! This subroutie is used only when the simulation is ran for a !! 'UNIFORM' plasma. As a convention, in a uniform plasma we set !! \\mathbf{E} = E_0 \\hat{x}. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in Cartesian coordinates; !! E(1,:) = E_x, E(2,:) = E_y, E(3,:) = E_z E (:, 1 ) = F % Eo E (:, 2 : 3 ) = 0.0_rp end subroutine uniform_electric_field subroutine analytical_electric_field_cyl ( F , Y , E , flag ) !! @note Subrotuine that calculates and returns the electric field using the !! same analytical model of the 'analytical_fields' subroutine. @endnote TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Cylindrical coordinates of each particle in the simulation; !! Y(1,:) = R, Y(2,:) = \\phi, Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in Cartesian coordinates; !!  E(1,:) = E_x, E(2,:) = E_y, E(3,:) = E_z INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ephi !! Azimuthal electric field. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. if ( abs ( F % Eo ) > 0 ) then ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,Ephi) SHARED(F,Y,E,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then Ephi = F % Eo * F % Ro / Y ( pp , 1 ) E ( pp , 1 ) = - Ephi * SIN ( Y ( pp , 2 )) E ( pp , 2 ) = Ephi * COS ( Y ( pp , 2 )) E ( pp , 3 ) = 0.0_rp end if end do !$OMP END PARALLEL DO end if end subroutine analytical_electric_field_cyl subroutine mean_F_field ( F , Fo , op_field ) !! @note Subroutine that calculates the mean electric or magnetic field in !! case external fields are being used. @endnote TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), INTENT ( OUT ) :: Fo !! Mean electric or magnetic field. TYPE ( KORC_STRING ), INTENT ( IN ) :: op_field !!String that specifies what mean field will be calculated. !! Its value can be 'B' or 'E'. if ( TRIM ( op_field % str ) . EQ . 'B' ) then if ( ALLOCATED ( F % B_3D % R )) then ! 3D field Fo = SUM ( SQRT ( F % B_3D % R ** 2 + F % B_3D % PHI ** 2 + F % B_3D % Z ** 2 ) ) / & SIZE ( F % B_3D % R ) else if ( ALLOCATED ( F % B_2D % R )) then ! Axisymmetric 2D field Fo = SUM ( SQRT ( F % B_2D % R ** 2 + F % B_2D % PHI ** 2 + F % B_2D % Z ** 2 ) ) / & SIZE ( F % B_2D % R ) end if else if ( TRIM ( op_field % str ) . EQ . 'E' ) then if ( ALLOCATED ( F % E_3D % R )) then ! 3D field Fo = SUM ( SQRT ( F % E_3D % R ** 2 + F % E_3D % PHI ** 2 + F % E_3D % Z ** 2 ) ) / & SIZE ( F % E_3D % R ) else if ( ALLOCATED ( F % E_2D % R )) then ! Axisymmetric 2D field Fo = SUM ( SQRT ( F % E_2D % R ** 2 + F % E_2D % PHI ** 2 + F % E_2D % Z ** 2 ) ) / & SIZE ( F % E_2D % R ) end if else write ( output_unit_write , '(\"KORC ERROR: Please enter a valid field: mean_F_field\")' ) call korc_abort () end if end subroutine mean_F_field subroutine get_analytical_fields ( params , vars , F ) !! @note Interface for calculating the analytical electric and magnetic !! fields for each particle in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of the KORC derived type PARTICLES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. if ( params % orbit_model ( 1 : 2 ). eq . 'FO' ) then call cart_to_tor_check_if_confined ( vars % X , F , vars % Y , vars % flagCon ) call analytical_fields ( F , vars % Y , vars % E , vars % B , vars % flagCon ) !       call cart_to_cyl(vars%X,vars%Y) elseif ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then if (. not . params % GC_coords ) then call cart_to_cyl ( vars % X , vars % Y ) call cyl_check_if_confined ( F , vars % Y , vars % flagCon ) call analytical_fields_GC_init ( params , F , vars % Y , vars % E , vars % B , & vars % gradB , vars % curlb , vars % flagCon , vars % PSI_P ) else call cyl_check_if_confined ( F , vars % Y , vars % flagCon ) call analytical_fields_GC ( params , F , vars % Y , vars % E , vars % B , & vars % gradB , vars % curlb , vars % flagCon , vars % PSI_P ) end if endif end subroutine get_analytical_fields subroutine uniform_fields ( vars , F ) !! @note Interface for calculating the uniform electric and magnetic !! fields for each particle in the simulation. @endnote TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of the KORC derived type PARTICLES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. call uniform_magnetic_field ( F , vars % B ) call uniform_electric_field ( F , vars % E ) end subroutine uniform_fields pure function cross ( a , b ) !! @note Function that calculates the cross product of the two !! vectors \\mathbf{a} and \\mathbf{b}. @endnote REAL ( rp ), DIMENSION ( 3 ) :: cross !! Cross product \\mathbf{a}\\times \\mathbf{b} REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: a !!  Vector \\mathbf{a}. REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: b !!  Vector \\mathbf{b}. cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross subroutine unitVectors ( params , Xo , F , b1 , b2 , b3 , flag , cart , hint ) !! @note Subrotuine that calculates an orthonormal basis using information !! of the (local) magnetic field at position \\mathbf{X}_0. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Xo !! Array with the position of the simulated particles. TYPE ( FIELDS ), INTENT ( IN ) :: F !! F An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: b1 !! Basis vector pointing along the local magnetic field, !! that is, along \\mathbf{b} = \\mathbf{B}/B. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: b2 !!  Basis vector perpendicular to b1 REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: b3 !! Basis vector perpendicular to b1 and b2. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: flag !! Flag for each particle to decide whether it is being !! followed (flag=T) or not (flag=F). TYPE ( C_PTR ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: hint !! Flag for each particle to decide whether it is being !! followed (flag=T) or not (flag=F). TYPE ( PARTICLES ) :: vars !! A temporary instance of the KORC derived type PARTICLES. INTEGER :: ii !! Iterator. INTEGER :: ppp !! Number of particles. LOGICAL :: cart !    write(output_unit_write,*) 'in unitVector' ppp = SIZE ( Xo , 1 ) ! Number of particles ALLOCATE ( vars % X ( ppp , 3 ) ) ALLOCATE ( vars % Y ( ppp , 3 ) ) ALLOCATE ( vars % B ( ppp , 3 ) ) ALLOCATE ( vars % gradB ( ppp , 3 ) ) ALLOCATE ( vars % curlb ( ppp , 3 ) ) ALLOCATE ( vars % PSI_P ( ppp ) ) ALLOCATE ( vars % E ( ppp , 3 ) ) ALLOCATE ( vars % flagCon ( ppp ) ) ALLOCATE ( vars % hint ( ppp ) ) vars % X = Xo vars % hint = hint vars % flagCon = 1_idef vars % B = 0._rp vars % PSI_P = 0._rp vars % cart = . false . !write(output_unit_write,*) 'before init_random_seed' call init_random_seed () ! write(output_unit_write,*) 'before get_fields' call get_fields ( params , vars , F ) !    write(output_unit_write,'(\"Bx: \",E17.10)') vars%B(:,1) !    write(output_unit_write,'(\"By: \",E17.10)') vars%B(:,2) !    write(output_unit_write,'(\"Bz: \",E17.10)') vars%B(:,3) !write(output_unit_write,*) 'before b1,b2,b3 calculation' do ii = 1_idef , ppp if ( vars % flagCon ( ii ) . EQ . 1_idef ) then b1 ( ii ,:) = vars % B ( ii ,:) / sqrt ( vars % B ( ii , 1 ) * vars % B ( ii , 1 ) + & vars % B ( ii , 2 ) * vars % B ( ii , 2 ) + vars % B ( ii , 3 ) * vars % B ( ii , 3 )) b2 ( ii ,:) = cross ( b1 ( ii ,:),( / 0.0_rp , 0.0_rp , 1.0_rp / )) b2 ( ii ,:) = b2 ( ii ,:) / sqrt ( b2 ( ii , 1 ) * b2 ( ii , 1 ) + b2 ( ii , 2 ) * b2 ( ii , 2 ) + & b2 ( ii , 3 ) * b2 ( ii , 3 )) b3 ( ii ,:) = cross ( b1 ( ii ,:), b2 ( ii ,:)) b3 ( ii ,:) = b3 ( ii ,:) / sqrt ( b3 ( ii , 1 ) * b3 ( ii , 1 ) + b3 ( ii , 2 ) * b3 ( ii , 2 ) + & b3 ( ii , 3 ) * b3 ( ii , 3 )) end if end do !write(output_unit_write,*) 'before copying hint and flag' hint = vars % hint if ( PRESENT ( flag )) then flag = vars % flagCon end if DEALLOCATE ( vars % X ) DEALLOCATE ( vars % Y ) DEALLOCATE ( vars % B ) DEALLOCATE ( vars % PSI_P ) DEALLOCATE ( vars % gradB ) DEALLOCATE ( vars % curlb ) DEALLOCATE ( vars % E ) DEALLOCATE ( vars % flagCon ) DEALLOCATE ( vars % hint ) !write(output_unit_write,*) 'out unitVectors' end subroutine unitVectors subroutine get_fields ( params , vars , F ) !! @note Inferface with calls to subroutines for calculating the electric !! and magnetic field for each particle in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !!  An instance of the KORC derived type PARTICLES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then !SELECT CASE (TRIM(params%field_model)) !CASE('ANALYTICAL') if ( params % field_eval . eq . 'eqn' ) then call get_analytical_fields ( params , vars , F ) else call interp_fields ( params , vars , F ) end if else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then !       write(output_unit_write,'(\"2 size of PSI_P: \",I16)') size(vars%PSI_P) call interp_fields ( params , vars , F ) !       write(output_unit_write,'(\"get_fields\")') !       write(output_unit_write,'(\"B_X: \",E17.10)') vars%B(:,1) !       write(output_unit_write,'(\"B_Z: \",E17.10)') vars%B(:,2) !       write(output_unit_write,'(\"B_Y: \",E17.10)') vars%B(:,3) !if (F%Efield.AND..NOT.F%Efield_in_file) then !   call analytical_electric_field_cyl(F,vars%Y,vars%E,vars%flagCon) !end if else if ( params % field_model . eq . 'M3D_C1' ) then call interp_fields ( params , vars , F ) else if ( params % field_model . eq . 'UNIFORM' ) then call uniform_fields ( vars , F ) end if end subroutine get_fields subroutine calculate_SC_E1D ( params , F , Vden ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ), intent ( in ) :: Vden real ( rp ), dimension ( F % dim_1D ) :: Jsamone , Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r real ( rp ) :: dr , bet integer :: ii INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) Jsamone = C_E * Vden ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( Jsamone , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !write(output_unit_write,*) 'Jsam: ',Jsamall(1:5) Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = F % J2_SC_1D % PHI F % J2_SC_1D % PHI = F % J1_SC_1D % PHI F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3 * F % J1_SC_1D % PHI - 4 * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2 * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve a = 0._rp b =- 2._rp c = 0._rp u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = 2 * dr ** 2 * C_MU * dJdt do ii = 2_idef , F % dim_1D a ( ii ) = ( REAL ( ii ) - 2._rp ) / ( REAL ( ii ) - 1._rp ) c ( ii ) = REAL ( ii ) / ( REAL ( ii ) - 1._rp ) end do bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = ( 4 * u ( 2 ) - u ( 3 )) / 3._rp ! Writing over F%A* data !    F%A3_SC_1D%PHI=F%A2_SC_1D%PHI !    F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    F%A1_SC_1D%PHI=u !    if (init) then !       F%A3_SC_1D%PHI=F%A1_SC_1D%PHI !       F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    end if !    write(output_unit_write,*) params%mpi_params%rank,'A1(1)',F%A1_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A2(1)',F%A2_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A3(1)',F%A3_SC_1D%PHI(1) ! Calculating inductive E_phi !    F%E_SC_1D%PHI=-(3*F%A1_SC_1D%PHI-4*F%A2_SC_1D%PHI+F%A3_SC_1D%PHI)/ & !         (2*F%dt_E_SC) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(2)' , F % J1_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J2(2)' , F % J2_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J3(2)' , F % J3_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant ( params , F ) end subroutine calculate_SC_E1D subroutine calculate_SC_E1D_FS ( params , F , dintJphidPSIP ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ), intent ( in ) :: dintJphidPSIP real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , alpha , beta , gamma real ( rp ) :: dPSIP , bet integer :: ii INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if !write(output_unit_write,*) 'dintJphidPSIP',dintJphidPSIP(F%dim_1D) dPSIP = F % PSIP_1D ( 2 ) - F % PSIP_1D ( 1 ) ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( dintJphidPSIP , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !write(output_unit_write,*) 'JSamAll',Jsamall(F%dim_1D) !write(output_unit_write,*) 'Jsam: ',Jsamall(1:5) Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = F % J2_SC_1D % PHI F % J2_SC_1D % PHI = F % J1_SC_1D % PHI F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3 * F % J1_SC_1D % PHI - 4 * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2 * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve alpha = F % ddMagPsiSqdPsiPSq beta = F % dMagPsiSqdPsiP gamma = C_MU * dJdt a =- alpha * dPSIP / 2._rp + beta b =- 2._rp * beta c = alpha * dPSIP / 2._rp + beta u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = dPSIP ** 2 * gamma c ( 2 ) = c ( 2 ) - a ( 2 ) * a ( 1 ) / c ( 1 ) b ( 2 ) = b ( 2 ) - a ( 2 ) * b ( 1 ) / c ( 1 ) r ( 2 ) = r ( 2 ) - a ( 2 ) * r ( 1 ) / c ( 1 ) bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = 2 * u ( 2 ) - u ( 3 ) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(1)' , F % J1_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J2(1)' , F % J2_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J3(1)' , F % J3_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant_FS ( params , F ) end subroutine calculate_SC_E1D_FS subroutine calculate_SC_p ( params , F , B_R , B_PHI , B_Z , Y_R , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , Vden ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( params % pchunk ), intent ( in ) :: Y_R , Y_Z real ( rp ), dimension ( params % pchunk ), intent ( in ) :: B_R , B_PHI , B_Z real ( rp ), dimension ( params % pchunk ), intent ( in ) :: V_PLL , V_MU real ( rp ), intent ( in ) :: m_cache integer ( is ), dimension ( params % pchunk ), intent ( in ) :: flagCon , flagCol real ( rp ), dimension ( params % pchunk ) :: rm , Bmag , gam , vpll real ( rp ), dimension ( F % dim_1D ), intent ( out ) :: Vden real ( rp ), dimension ( F % dim_1D ) :: Vpart , Ai real ( rp ), dimension ( F % dim_1D ) :: r_1D real ( rp ) :: dr , sigr , ar , arg , arg1 , arg2 , arg3 integer :: cc , ii , rind , pchunk pchunk = params % pchunk dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) r_1D = F % r_1D sigr = dr Vpart = 0._rp do cc = 1_idef , pchunk ! 1D nearest grid point weighting in minor radius !    RR=spp%vars%Y(:,1) !    ZZ=spp%vars%Y(:,3) rm ( cc ) = sqrt (( Y_R ( cc ) - F % Ro ) ** 2 + ( Y_Z ( cc ) - F % Zo ) ** 2 ) * & params % cpp % length !    write (output_unit_write,*) params%mpi_params%rank,'RR',RR !    write (output_unit_write,*) params%mpi_params%rank,'ZZ',spp%vars%Y(:,3) write ( output_unit_write , * ) 'rm' , rm ( cc ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) gam ( cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc ) * m_cache ) vpll ( cc ) = V_PLL ( cc ) / gam ( cc ) ! Weighting parallel velocity !    write (output_unit_write,*) params%mpi_params%rank,'vpll',vpll !   do pp=1_idef,spp%ppp ! NGP weighting rind = FLOOR (( rm ( cc ) - dr / 2 ) / dr ) + 2_ip Vpart ( rind ) = Vpart ( rind ) + real ( flagCon ( cc )) * real ( flagCol ( cc )) * vpll ( cc ) ! First-order weighting !       rind=FLOOR(rm(cc)/dr)+1_ip !       Vpart(rind)=Vpart(rind)+ & !            vpll(cc)*(r_1D(rind+1)-rm(cc))/dr !       Vpart(rind+1)=Vpart(rind+1)+ & !            vpll(cc)*(rm(cc)-r_1D(rind))/dr ! Gaussian weighting !       do ii=1_idef,F%dim_1D !          arg=MIN((r_1D(ii)-rm(cc))**2._rp/(2._rp*sigr**2._rp),100._rp) !          Vpart(ii)=Vpart(ii)+1/sqrt(2._rp*C_PI*sigr**2._rp)* & !               exp(-arg)*vpll(cc) !       end do end do ar = F % AB % a ! Calculating density of minor radial annulus do ii = 1_idef , F % dim_1D ! NGP weighting if ( ii . eq . 1 ) then Vden ( ii ) = Vpart ( ii ) / ( C_PI * dr ** 2 / 4 ) else Vden ( ii ) = Vpart ( ii ) / ( 2 * C_PI * dr ** 2 * ( ii - 1 )) end if ! First-order weighting !       if(ii.eq.1) then !          Vden(ii)=Vpart(ii)/(C_PI*dr**2/3) !       else !          Vden(ii)=Vpart(ii)/(2*C_PI*dr**2*(ii-1)) !       end if ! Gaussian weighting !       arg=MIN(r_1D(ii)**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg1=MIN((ar-r_1D(ii))**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg2=MIN((ar-r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       arg3=MIN((r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       Ai(ii)=sqrt(C_PI*sigr)*(sqrt(2._rp)*sigr*(exp(-arg)- & !            exp(-arg1))+r_1D(ii)*sqrt(C_PI)* & !            (erf(arg2)-erf(-arg3))) !       Vden(ii)=Vpart(ii)/Ai(ii) end do end subroutine calculate_SC_p subroutine calculate_SC_p_FS ( params , F , B_R , B_PHI , B_Z , PSIp , & V_PLL , V_MU , m_cache , flagCon , flagCol , dintJphidPSIP ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( params % pchunk ), intent ( in ) :: PSIp real ( rp ), dimension ( params % pchunk ), intent ( in ) :: B_R , B_PHI , B_Z real ( rp ), dimension ( params % pchunk ), intent ( in ) :: V_PLL , V_MU real ( rp ), intent ( in ) :: m_cache integer ( is ), dimension ( params % pchunk ), intent ( in ) :: flagCon , flagCol real ( rp ), dimension ( params % pchunk ) :: Bmag , gam , vpll , PSIp_cache real ( rp ), dimension ( F % dim_1D ), intent ( out ) :: dintJphidPSIP real ( rp ), dimension ( F % dim_1D ) :: PSIP_1D real ( rp ) :: dPSIP , ar , arg , arg1 , arg2 , arg3 , PSIP_lim , sigPSIP integer :: cc , ii , PSIPind , pchunk pchunk = params % pchunk PSIP_1D = F % PSIP_1D dPSIP = PSIP_1D ( 2 ) - PSIP_1D ( 1 ) PSIp_cache = PSIp * ( params % cpp % Bo * params % cpp % length ** 2 ) sigPSIP = dPSIP dintJphidPSIP = 0._rp do cc = 1_idef , pchunk ! 1D Riemann sum !write (output_unit_write,*) 'rm',rm(cc) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) gam ( cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc ) * m_cache ) vpll ( cc ) = V_PLL ( cc ) / gam ( cc ) !       write(output_unit_write,*) PSIp_cache(cc) if ( PSIp_cache ( cc ). lt . 0._rp ) PSIp_cache ( cc ) = 0._rp PSIPind = FLOOR ( PSIp_cache ( cc ) / dPSIP ) + 1_ip ! NGP weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+vpll(cc) ! First-order weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+ & !            vpll(cc)*(PSIP_1D(PSIPind+1)-PSIP_cache(cc))/dPSIP !       dintJphidPSIP(PSIPind+1)=dintJphidPSIP(PSIPind+1)+ & !            vpll(cc)*(PSIP_cache(cc)-PSIP_1D(PSIPind))/dPSIP ! Gaussian weighting do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_1D ( ii ) - PSIP_cache ( cc )) ** 2._rp / & ( 2._rp * sigPSIP ** 2._rp ), 10 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) + & exp ( - arg ) * vpll ( cc ) * real ( flagCon ( cc )) * real ( flagCol ( cc )) end do end do ! First-order weighting !    dintJphidPSIP(1)=2*dintJphidPSIP(1) ! Gaussian weighting PSIP_lim = PSIP_1D ( F % dim_1D ) do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_lim - PSIP_1D ( ii )) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) arg1 = MIN ( PSIP_1D ( ii ) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) / & ( erf ( arg ) - erf ( - arg1 )) end do end subroutine calculate_SC_p_FS subroutine init_SC_E1D ( params , F , spp ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( IN ) :: spp real ( rp ), dimension ( F % dim_1D ) :: Vpart real ( rp ), dimension ( spp % ppp ) :: RR , ZZ , rm , vpll real ( rp ), dimension ( F % dim_1D ) :: Vden , Jsamone , Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , r_1D , Ai real ( rp ) :: dr , Isam , bet , sigr , ar , arg , arg1 , arg2 , arg3 integer :: pp , ii , rind INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if ! 1D nearest grid point weighting in minor radius RR = spp % vars % Y (:, 1 ) ZZ = spp % vars % Y (:, 3 ) rm = sqrt (( RR - F % Ro ) ** 2._rp + ( ZZ - F % Zo ) ** 2._rp ) * params % cpp % length !    write (output_unit_write,*) params%mpi_params%rank,'RR',RR !    write (output_unit_write,*) params%mpi_params%rank,'ZZ',spp%vars%Y(:,3) write ( output_unit_write , * ) 'rm' , rm dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) vpll = spp % vars % V (:, 1 ) / spp % vars % g ! Weighting parallel velocity !    write (output_unit_write,*) 'vpll',vpll Vpart = 0._rp r_1D = F % r_1D sigr = dr do pp = 1_idef , spp % ppp ! NGP weighting rind = FLOOR (( rm ( pp ) - dr / 2 ) / dr ) + 2_ip Vpart ( rind ) = Vpart ( rind ) + vpll ( pp ) ! First-order weighting !       rind=FLOOR(rm(pp)/dr)+1_ip !       Vpart(rind)=Vpart(rind)+vpll(pp)*(F%r_1D(rind+1)-rm(pp))/dr !       Vpart(rind+1)=Vpart(rind+1)+vpll(pp)*(rm(pp)-F%r_1D(rind))/dr ! Gaussian weighting !       do ii=1_idef,F%dim_1D !          arg=MIN((r_1D(ii)-rm(pp))**2._rp/(2._rp*sigr**2._rp),100._rp) !          Vpart(ii)=Vpart(ii)+1/sqrt(2._rp*C_PI*sigr**2._rp)* & !               exp(-arg) !       end do end do ! Calculating density of minor radial annulus ar = F % AB % a do ii = 1_idef , F % dim_1D ! NGP weighting if ( ii . eq . 1 ) then Vden ( ii ) = Vpart ( ii ) / ( C_PI * dr ** 2 / 4 ) else Vden ( ii ) = Vpart ( ii ) / ( 2 * C_PI * dr ** 2 * ( ii - 1 )) end if ! First-order weighting !       if(ii.eq.1) then !          Vden(ii)=Vpart(ii)/(C_PI*dr**2/3) !       else !          Vden(ii)=Vpart(ii)/(2*C_PI*dr**2*(ii-1)) !       end if ! Gaussian weighting !       arg=MIN(r_1D(ii)**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg1=MIN((ar-r_1D(ii))**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg2=MIN((ar-r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       arg3=MIN((r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       Ai(ii)=sqrt(C_PI*sigr)*(sqrt(2._rp)*sigr*(exp(-arg)- & !            exp(-arg1))+r_1D(ii)*sqrt(C_PI)* & !            (erf(arg2)-erf(-arg3))) !       Vden(ii)=Vpart(ii)/Ai(ii) end do Jsamone = C_E * Vden ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( Jsamone , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !    write(output_unit_write,*) 'Jsam: ',Jsamall(1:10) ! Integrating current density to scale total current to ! experimentally determined total current Isam = 0._rp do ii = 1_idef , F % dim_1D if (( ii . eq . 1 ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) end if end do Isam = 2._rp * C_PI * Isam * dr !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve a = 0._rp b =- 2._rp c = 0._rp u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = 2 * dr ** 2 * C_MU * dJdt do ii = 2_idef , F % dim_1D a ( ii ) = ( REAL ( ii ) - 2._rp ) / ( REAL ( ii ) - 1._rp ) c ( ii ) = REAL ( ii ) / ( REAL ( ii ) - 1._rp ) end do bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = ( 4._rp * u ( 2 ) - u ( 3 )) / 3._rp ! Writing over F%A* data !    F%A3_SC_1D%PHI=F%A2_SC_1D%PHI !    F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    F%A1_SC_1D%PHI=u !    if (init) then !       F%A3_SC_1D%PHI=F%A1_SC_1D%PHI !       F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    end if !    write(output_unit_write,*) params%mpi_params%rank,'A1(1)',F%A1_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A2(1)',F%A2_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A3(1)',F%A3_SC_1D%PHI(1) ! Calculating inductive E_phi !    F%E_SC_1D%PHI=-(3*F%A1_SC_1D%PHI-4*F%A2_SC_1D%PHI+F%A3_SC_1D%PHI)/ & !         (2*F%dt_E_SC) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(2)' , F % J1_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J2(2)' , F % J2_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J3(2)' , F % J3_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant ( params , F ) end subroutine init_SC_E1D subroutine init_SC_E1D_FS ( params , F , spp ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( IN ) :: spp real ( rp ), dimension ( F % dim_1D ) :: dintJphidPSIP , PSIP_1D real ( rp ), dimension ( spp % ppp ) :: PSIP , vpll real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , alpha , beta , gamma real ( rp ) :: dPSIP , Isam , bet , arg , arg1 , PSIP_lim , sigPSIP integer :: pp , ii , PSIPind INTEGER :: mpierr PSIP_1D = F % PSIP_1D dPSIP = PSIP_1D ( 2 ) - PSIP_1D ( 1 ) PSIP = spp % vars % PSI_P * ( params % cpp % Bo * params % cpp % length ** 2 ) sigPSIP = dPSIP vpll = spp % vars % V (:, 1 ) / spp % vars % g dintJphidPSIP = 0._rp do pp = 1_idef , spp % ppp if ( PSIP ( pp ). lt . 0._rp ) PSIP ( pp ) = 0._rp PSIPind = FLOOR ( PSIP ( pp ) / dPSIP ) + 1_ip ! NGP weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+vpll(pp) ! First-order weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+ & !            vpll(pp)*(PSIP_1D(PSIPind+1)-PSIP(pp))/dPSIP !       dintJphidPSIP(PSIPind+1)=dintJphidPSIP(PSIPind+1)+ & !            vpll(pp)*(PSIP(pp)-PSIP_1D(PSIPind))/dPSIP !       write(output_unit_write,*) PSIP(pp),PSIP_1D(PSIPind),dPSIP ! Gaussian weighting do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_1D ( ii ) - PSIP ( pp )) ** 2._rp / & ( 2._rp * sigPSIP ** 2._rp ), 10 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) + & vpll ( pp ) * exp ( - arg ) end do end do ! First-order weighting !    dintJphidPSIP(1)=2*dintJphidPSIP(1) ! Gaussian weighting PSIP_lim = PSIP_1D ( F % dim_1D ) do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_lim - PSIP_1D ( ii )) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) arg1 = MIN ( PSIP_1D ( ii ) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) / & ( erf ( arg ) - erf ( - arg1 )) end do ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( dintJphidPSIP , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !    write(output_unit_write,*) 'Jsam: ',Jsamall(1:10) ! Integrating current density to scale total current to ! experimentally determined total current Isam = 0._rp do ii = 1_idef , F % dim_1D if (( ii . eq . 1 ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) end if end do Isam = Isam * dPSIP !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve alpha = F % ddMagPsiSqdPsiPSq beta = F % dMagPsiSqdPsiP gamma = C_MU * dJdt a =- alpha * dPSIP / 2._rp + beta b =- 2._rp * beta c = alpha * dPSIP / 2._rp + beta u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = dPSIP ** 2 * gamma c ( 2 ) = c ( 2 ) - a ( 2 ) * a ( 1 ) / c ( 1 ) b ( 2 ) = b ( 2 ) - a ( 2 ) * b ( 1 ) / c ( 1 ) r ( 2 ) = r ( 2 ) - a ( 2 ) * r ( 1 ) / c ( 1 ) bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = 2 * u ( 2 ) - u ( 3 ) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(1)' , F % J1_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J2(1)' , F % J2_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J3(1)' , F % J3_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant_FS ( params , F ) end subroutine init_SC_E1D_FS subroutine reinit_SC_E1D ( params , F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , r_1D , Ai real ( rp ) :: dr , Isam , bet , sigr , ar , arg , arg1 , arg2 , arg3 integer :: pp , ii , rind INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) r_1D = F % r_1D Jsamall = F % J0_SC_1D % PHI !    write(output_unit_write,*) Jsamall Isam = 0._rp do ii = 1_idef , F % dim_1D !       write(output_unit_write,*) Isam !       write(output_unit_write,*) ii !       write(output_unit_write,*) Jsamall(ii) !       write(output_unit_write,*) (ii) if (( ii . eq . 1_idef ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) end if end do Isam = 2._rp * C_PI * Isam * dr !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve a = 0._rp b =- 2._rp c = 0._rp u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = 2 * dr ** 2 * C_MU * dJdt do ii = 2_idef , F % dim_1D a ( ii ) = ( REAL ( ii ) - 2._rp ) / ( REAL ( ii ) - 1._rp ) c ( ii ) = REAL ( ii ) / ( REAL ( ii ) - 1._rp ) end do bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = ( 4._rp * u ( 2 ) - u ( 3 )) / 3._rp ! Writing over F%A* data !    F%A3_SC_1D%PHI=F%A2_SC_1D%PHI !    F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    F%A1_SC_1D%PHI=u !    if (init) then !       F%A3_SC_1D%PHI=F%A1_SC_1D%PHI !       F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    end if !    write(output_unit_write,*) params%mpi_params%rank,'A1(1)',F%A1_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A2(1)',F%A2_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A3(1)',F%A3_SC_1D%PHI(1) ! Calculating inductive E_phi !    F%E_SC_1D%PHI=-(3*F%A1_SC_1D%PHI-4*F%A2_SC_1D%PHI+F%A3_SC_1D%PHI)/ & !         (2*F%dt_E_SC) F % E_SC_1D % PHI = u !    if (params%mpi_params%rank.eq.0) then !       write(output_unit_write,*) 'J1(1)',F%J1_SC_1D%PHI(1) !       write(output_unit_write,*) 'J2(1)',F%J2_SC_1D%PHI(1) !       write(output_unit_write,*) 'J3(1)',F%J3_SC_1D%PHI(1) !       write(output_unit_write,*) 'E(1)',F%E_SC_1D%PHI(1) !    end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant ( params , F ) end subroutine reinit_SC_E1D subroutine reinit_SC_E1D_FS ( params , F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt , PSIP_1D real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , alpha , beta , gamma real ( rp ) :: dPSIP , Isam , bet integer :: pp , ii , PSIPind INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if PSIP_1D = F % PSIP_1D dPSIP = PSIP_1D ( 2 ) - PSIP_1D ( 1 ) Jsamall = F % J0_SC_1D % PHI Isam = 0._rp do ii = 1_idef , F % dim_1D if (( ii . eq . 1 ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) end if end do Isam = Isam * dPSIP !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve alpha = F % ddMagPsiSqdPsiPSq beta = F % dMagPsiSqdPsiP gamma = C_MU * dJdt a =- alpha * dPSIP / 2._rp + beta b =- 2._rp * beta c = alpha * dPSIP / 2._rp + beta u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = dPSIP ** 2 * gamma c ( 2 ) = c ( 2 ) - a ( 2 ) * a ( 1 ) / c ( 1 ) b ( 2 ) = b ( 2 ) - a ( 2 ) * b ( 1 ) / c ( 1 ) r ( 2 ) = r ( 2 ) - a ( 2 ) * r ( 1 ) / c ( 1 ) bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = 2 * u ( 2 ) - u ( 3 ) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(1)' , F % J1_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J2(1)' , F % J2_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J3(1)' , F % J3_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant_FS ( params , F ) end subroutine reinit_SC_E1D_FS ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! ! * * *  SUBROUTINES FOR INITIALIZING FIELDS   * * * ! ! * * * * * * * * * * * *  * * * * * * * * * * * * * ! subroutine initialize_fields ( params , F ) !! @note Subroutine that initializes the analytical or externally !! calculated electric and magnetic fields. @endnote !! In this subroutine we load the parameters of the electric and !! magnetic fields from the namelists 'analytical_fields_params' and !! 'externalPlasmaModel' in the input file. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( OUT ) :: F !! An instance of the KORC derived type FIELDS. !REAL(rp)                       :: Bo !! Magnetic field at magnetic axis for an 'ANALYTICAL' magnetic field, !! or the magnitude of the magnetic field for a 'UNFIROM' plasma. !REAL(rp)                       :: minor_radius !! Plasma edge r_{edge} as measured from the magnetic axis. !REAL(rp)                       :: major_radius !! Radial position of the magnetic axis R_0 !REAL(rp)                       :: qa !! Safety factor at the plasma edge. !REAL(rp)                       :: qo !! Safety factor at the magnetic axis q_0. !CHARACTER(MAX_STRING_LENGTH)   :: current_direction !! String with information about the direction of the plasma current, !! 'PARALLEL'  or 'ANTI-PARALLEL' to the toroidal magnetic field. !CHARACTER(MAX_STRING_LENGTH)   :: E_model !REAL(rp)                       :: Eo,E_dyn,E_pulse,E_width !! Electric field at the magnetic axis. !LOGICAL                        :: Efield !! Logical variable that specifies if the electric field is !! going to be used on in a given simulation. !LOGICAL                        :: dBfield !LOGICAL                        :: Bfield !! Logical variable that specifies if the magnetic field is !! going to be used on in a given simulation. !LOGICAL                        :: Bflux !LOGICAL                        :: Bflux3D !LOGICAL                        :: Dim2x1t !LOGICAL                        :: E_2x1t,ReInterp_2x1t !! Logical variable that specifies if the poloidal magnetic !! flux is going to be used on in a given simulation. !LOGICAL                        :: axisymmetric_fields !! Logical variable that specifies if the plasma is axisymmetric. INTEGER :: ii !! Iterators for creating mesh for GC model with analytic fields INTEGER :: kk !! Iterators for creating mesh for GC model with analytic fields !INTEGER                        :: nR !! Number of mesh points in R for grid in GC model of analytical field !INTEGER                        :: nZ,nPHI !! Number of mesh points in Z for grid in GC model of analytical field real ( rp ) :: rm !! Minor radius at each position in the grid for !! GC model of analytical field real ( rp ) :: qr !! Safety factor at each position in the grid for !! GC model of analytical field real ( rp ) :: theta !! Poloidal angle at each position in the grid for !! GC model of analytical field logical :: test !integer :: res_double real ( rp ) :: RMAX , RMIN , ZMAX , ZMIN !integer :: dim_1D,ind0_2x1t !real(rp) :: dt_E_SC,Ip_exp,PSIp_lim,PSIp_0 !real(rp) :: t0_2x1t !NAMELIST /analytical_fields_params/ Bo,minor_radius,major_radius,& !     qa,qo,Eo,current_direction,nR,nZ,nPHI,dim_1D,dt_E_SC,Ip_exp, & !     E_dyn,E_pulse,E_width !NAMELIST /externalPlasmaModel/ Efield, Bfield, Bflux,Bflux3D,dBfield, & !     axisymmetric_fields, Eo,E_dyn,E_pulse,E_width,res_double, & !     dim_1D,dt_E_SC,Ip_exp,PSIp_lim,Dim2x1t,t0_2x1t,E_2x1t,ReInterp_2x1t, & !     ind0_2x1t,PSIp_0 #ifdef M3D_C1 F % M3D_C1_B = - 1 F % M3D_C1_E = - 1 #endif if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * * * * INITIALIZING FIELDS * * * * * * * *\")' ) end if !    SELECT CASE (TRIM(params%field_model)) if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then !    CASE('ANALYTICAL') ! Load the parameters of the analytical magnetic field !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=analytical_fields_params) !close(default_unit_open) F % AB % Bo = Bo F % AB % a = minor_radius F % AB % Ro = major_radius F % Ro = major_radius F % Zo = 0.0_rp F % AB % qa = qa F % AB % qo = qo F % AB % lambda = F % AB % a / SQRT ( qa / qo - 1.0_rp ) F % AB % Bpo = F % AB % lambda * F % AB % Bo / ( F % AB % qo * F % AB % Ro ) F % AB % current_direction = TRIM ( current_direction ) SELECT CASE ( TRIM ( F % AB % current_direction )) CASE ( 'PARALLEL' ) F % AB % Bp_sign = 1.0_rp CASE ( 'ANTI-PARALLEL' ) F % AB % Bp_sign = - 1.0_rp CASE DEFAULT END SELECT F % Eo = Eo F % Bo = F % AB % Bo F % E_dyn = E_dyn F % E_pulse = E_pulse F % E_width = E_width F % PSIp_lim = PSIp_lim !write(output_unit_write,*) E_dyn,E_pulse,E_width F % res_double = res_double if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"ANALYTIC\")' ) write ( output_unit_write , '(\"Magnetic field: \",E17.10)' ) F % Bo write ( output_unit_write , '(\"Electric field: \",E17.10)' ) F % Eo end if if ( params % field_eval . eq . 'interp' ) then F % dims ( 1 ) = nR F % dims ( 2 ) = nPHI F % dims ( 3 ) = nZ if ( params % field_model ( 12 : 14 ). eq . 'PSI' ) then F % axisymmetric_fields = . TRUE . F % Bfield = . TRUE . F % Efield = . TRUE . F % Bflux = . TRUE . call ALLOCATE_2D_FIELDS_ARRAYS ( params , F , F % Bfield , F % Bflux , & . false ., F % Efield ) do ii = 1_idef , F % dims ( 1 ) F % X % R ( ii ) = ( F % Ro - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 1 ) - 1 ) end do do ii = 1_idef , F % dims ( 3 ) F % X % Z ( ii ) = ( F % Zo - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 3 ) - 1 ) end do !write(6,*) F%X%R !write(6,*) F%X%Z do ii = 1_idef , F % dims ( 1 ) do kk = 1_idef , F % dims ( 3 ) rm = sqrt (( F % X % R ( ii ) - F % Ro ) ** 2 + ( F % X % Z ( kk ) - F % Zo ) ** 2 ) qr = F % AB % qo * ( 1 + ( rm / F % AB % lambda ) ** 2 ) theta = atan2 ( F % X % Z ( kk ) - F % Zo , F % X % R ( ii ) - F % Ro ) F % B_2D % R ( ii , kk ) = ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * sin ( theta ) F % B_2D % PHI ( ii , kk ) =- ( F % Ro / F % X % R ( ii )) * F % AB % Bo F % B_2D % Z ( ii , kk ) =- ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * cos ( theta ) F % E_2D % R ( ii , kk ) = 0.0_rp F % E_2D % PHI ( ii , kk ) =- ( F % Ro / F % X % R ( ii )) * F % Eo F % E_2D % Z ( ii , kk ) = 0.0_rp F % PSIp ( ii , kk ) = F % X % R ( ii ) * F % AB % lambda ** 2 * F % Bo / & ( 2 * F % AB % qo * ( F % Ro + rm * cos ( theta ))) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) !! Sign convention in analytical fields corresponds to !! DIII-D fields with B_\\phi<0 and B_\\theta<0. F % FLAG2D = 1. end do end do F % FLAG2D ( 1 : 2 ,:) = 0. F % FLAG2D ( F % dims ( 1 ) - 1 : F % dims ( 1 ),:) = 0. F % FLAG2D (:, 1 : 2 ) = 0. F % FLAG2D (:, F % dims ( 3 ) - 1 : F % dims ( 3 )) = 0. if ( F % Bflux ) F % PSIP_min = minval ( F % PSIp ) F % Bfield = . FALSE . else if ( params % field_model ( 12 : 13 ). eq . '3D' ) then F % axisymmetric_fields = . FALSE . F % Bfield = . TRUE . F % Efield = . TRUE . call ALLOCATE_3D_FIELDS_ARRAYS ( params , F , F % Bfield , F % Efield ,. false .) do ii = 1_idef , F % dims ( 1 ) F % X % R ( ii ) = ( F % Ro - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 1 ) - 1 ) end do do ii = 1_idef , F % dims ( 2 ) F % X % PHI ( ii ) = 0._rp + ( ii - 1 ) * 2 * C_PI / ( F % dims ( 1 ) - 1 ) end do do ii = 1_idef , F % dims ( 3 ) F % X % Z ( ii ) = ( F % Zo - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 3 ) - 1 ) end do !write(output_unit_write,*) size(F%B_3D%R) do ii = 1_idef , F % dims ( 1 ) do kk = 1_idef , F % dims ( 3 ) !write(output_unit_write,*) ii,kk rm = sqrt (( F % X % R ( ii ) - F % Ro ) ** 2 + ( F % X % Z ( kk ) - F % Zo ) ** 2 ) qr = F % AB % qo * ( 1 + ( rm / F % AB % lambda ) ** 2 ) theta = atan2 ( F % X % Z ( kk ) - F % Zo , F % X % R ( ii ) - F % Ro ) F % B_3D % R ( ii ,:, kk ) = ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * sin ( theta ) F % B_3D % PHI ( ii ,:, kk ) =- ( F % Ro / F % X % R ( ii )) * F % AB % Bo !write(output_unit_write,*) F%B_3D%PHI(ii,1,kk) F % B_3D % Z ( ii ,:, kk ) =- ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * cos ( theta ) F % E_3D % R ( ii ,:, kk ) = 0.0_rp F % E_3D % PHI ( ii ,:, kk ) =- ( F % Ro / F % X % R ( ii )) * F % Eo F % E_3D % Z ( ii ,:, kk ) = 0.0_rp !! Sign convention in analytical fields corresponds to !! DIII-D fields with B_\\phi<0 and B_\\theta<0. F % FLAG3D = 1. end do end do F % FLAG3D ( 1 : 2 ,:,:) = 0. F % FLAG3D ( F % dims ( 1 ) - 1 : F % dims ( 1 ),:,:) = 0. F % FLAG3D (:,:, 1 : 2 ) = 0. F % FLAG3D (:,:, F % dims ( 3 ) - 1 : F % dims ( 3 )) = 0. end if if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Initializing GC fields from analytic EM fields\")' ) end if if ( params % field_model ( 12 : 13 ). eq . '2D' ) then call initialize_GC_fields ( F ) else if ( params % field_model ( 12 : 13 ). eq . '3D' ) then call initialize_GC_fields_3D ( F ) end if end if !F%Bfield= .FALSE. !F%axisymmetric_fields = .TRUE. !F%Bflux=.TRUE. !F%Efield=.FALSE. end if if ( params % SC_E ) then F % dim_1D = dim_1D F % dt_E_SC = dt_E_SC F % Ip_exp = Ip_exp ALLOCATE ( F % E_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % A1_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % A2_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % A3_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % J1_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % J2_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % J3_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % r_1D ( F % dim_1D )) F % E_SC_1D % PHI = 0._rp F % A1_SC_1D % PHI = 0._rp F % A2_SC_1D % PHI = 0._rp F % A3_SC_1D % PHI = 0._rp F % J1_SC_1D % PHI = 0._rp F % J2_SC_1D % PHI = 0._rp F % J3_SC_1D % PHI = 0._rp F % r_1D = 0._rp do ii = 1_idef , F % dim_1D F % r_1D ( ii ) = ( ii - 1 ) * F % AB % a / ( F % dim_1D - 1 ) end do end if !    CASE('EXTERNAL') else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then ! Load the magnetic field from an external HDF5 file !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=externalPlasmaModel) !close(default_unit_open) F % Bfield = Bfield F % dBfield = dBfield F % Bflux = Bflux F % Bflux3D = Bflux3D F % Efield = Efield F % axisymmetric_fields = axisymmetric_fields F % Dim2x1t = Dim2x1t F % ReInterp_2x1t = ReInterp_2x1t F % t0_2x1t = t0_2x1t F % ind0_2x1t = ind0_2x1t if ( params % proceed ) then call load_prev_iter ( params ) F % ind_2x1t = params % prev_iter_2x1t else F % ind_2x1t = F % ind0_2x1t end if F % E_2x1t = E_2x1t F % E_dyn = E_dyn F % E_pulse = E_pulse F % E_width = E_width F % PSIp_lim = PSIp_lim F % res_double = res_double !       write(output_unit_write,'(\"E_dyn: \",E17.10)') E_dyn !       write(output_unit_write,'(\"E_pulse: \",E17.10)') E_pulse !       write(output_unit_write,'(\"E_width: \",E17.10)') E_width call load_dim_data_from_hdf5 ( params , F ) !sets F%dims for 2D or 3D data !write(output_unit_write,*) F%dims call which_fields_in_file ( params , F % Bfield_in_file , F % Efield_in_file , & F % Bflux_in_file , F % dBfield_in_file ) if ( F % Bflux . AND .. NOT . F % Bflux_in_file ) then write ( output_unit_write , '(\"ERROR: Magnetic flux to be used but no data in file!\")' ) call KORC_ABORT () end if if ( F % Bfield . AND .. NOT . F % Bfield_in_file ) then write ( output_unit_write , '(\"ERROR: Magnetic field to be used but no data in file!\")' ) call KORC_ABORT () end if if ( F % dBfield . AND .. NOT . F % dBfield_in_file ) then write ( output_unit_write , '(\"ERROR: differential Magnetic field to be used & but no data in file!\")' ) !          call KORC_ABORT() end if if ( F % Efield . AND .. NOT . F % Efield_in_file ) then if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , '(/,\"* * * * * * * * * *  FIELDS  * * * * * * * * * *\")' ) write ( output_unit_write , '(\"MESSAGE: Analytical electric field will be used.\")' ) write ( output_unit_write , '(\"* * * * * * * * * * * * ** * * * * * * * * * * *\",/)' ) end if end if if ( F % axisymmetric_fields ) then if ( F % Dim2x1t ) then call ALLOCATE_2D_FIELDS_ARRAYS ( params , F , F % Bfield , & F % Bflux , F % dBfield , F % Efield . AND . F % Efield_in_file ) call ALLOCATE_3D_FIELDS_ARRAYS ( params , F , F % Bfield , & F % Efield , F % dBfield ) else F % Efield_in_file = . TRUE . call ALLOCATE_2D_FIELDS_ARRAYS ( params , F , F % Bfield , & F % Bflux , F % dBfield , F % Efield . AND . F % Efield_in_file ) F % Efield_in_file = . FALSE . end if else call ALLOCATE_3D_FIELDS_ARRAYS ( params , F , F % Bfield , F % Efield , F % dBfield ) end if !allocates 2D or 3D data arrays (fields and spatial) call load_field_data_from_hdf5 ( params , F ) !       write(output_unit_write,*) F%PSIp !write(output_unit_write,*) F%E_3D%PHI(:,F%ind0_2x1t,:) !       end if if ( F % Bflux ) then F % PSIP_min = minval ( F % PSIp ) else if ( F % Bflux3D ) then F % PSIP_min = minval ( F % PSIp3D (:, 1 ,:)) end if if ((. not . F % Efield_in_file ). and .(. not . F % Dim2x1t )) then F % Eo = Eo if ( F % axisymmetric_fields ) then F % E_2D % R = 0._rp do ii = 1_idef , F % dims ( 1 ) F % E_2D % PHI ( ii ,:) = F % Eo * F % Ro / F % X % R ( ii ) end do F % E_2D % Z = 0._rp else F % E_3D % R = 0._rp do ii = 1_idef , F % dims ( 1 ) F % E_3D % PHI ( ii ,:,:) = F % Eo * F % Ro / F % X % R ( ii ) end do F % E_3D % Z = 0._rp end if end if if ( F % dBfield . and .. not . F % dBfield_in_file ) then if ( F % axisymmetric_fields ) then F % dBdR_2D % R = 0._rp F % dBdR_2D % PHI = 0._rp F % dBdR_2D % Z = 0._rp F % dBdPHI_2D % R = 0._rp F % dBdPHI_2D % PHI = 0._rp F % dBdPHI_2D % Z = 0._rp F % dBdZ_2D % R = 0._rp F % dBdZ_2D % PHI = 0._rp F % dBdZ_2D % Z = 0._rp else F % dBdR_3D % R = 0._rp F % dBdR_3D % PHI = 0._rp F % dBdR_3D % Z = 0._rp F % dBdPHI_3D % R = 0._rp F % dBdPHI_3D % PHI = 0._rp F % dBdPHI_3D % Z = 0._rp F % dBdZ_3D % R = 0._rp F % dBdZ_3D % PHI = 0._rp F % dBdZ_3D % Z = 0._rp end if end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"EXTERNAL\")' ) write ( output_unit_write , '(\"Magnetic field: \",E17.10)' ) F % Bo write ( output_unit_write , '(\"Electric field: \",E17.10)' ) F % Eo end if if ( params % SC_E ) then F % dim_1D = dim_1D F % dt_E_SC = dt_E_SC F % Ip_exp = Ip_exp write ( output_unit_write , * ) 'dt_E_SC' , F % dt_E_SC , 'Ip_exp' , Ip_exp call allocate_1D_FS_arrays ( params , F ) call load_1D_FS_from_hdf5 ( params , F ) !          write(output_unit_write,*) F%PSIP_1D end if !       test=.true. !       if (F%Bflux.and.(.not.test)) then !          call initialize_fields_interpolant(params,F) !          F%Bfield=.TRUE. !          F%Efield=.TRUE. !          F%Efield_in_file=.TRUE. !          RMIN=F%X%R(1) !          RMAX=F%X%R(F%dims(1)) !          ZMIN=F%X%Z(1) !          ZMAX=F%X%Z(F%dims(3)) !          do ii=1_idef,res_double !             F%dims(1)=2*F%dims(1)-1 !             F%dims(3)=2*F%dims(3)-1 !          end do !          if (res_double>0) then !             DEALLOCATE(F%X%R) !             DEALLOCATE(F%X%Z) !             DEALLOCATE(F%PSIp) !          end if !          call ALLOCATE_2D_FIELDS_ARRAYS(params,F,F%Bfield, & !               F%Bflux,F%Efield.AND.F%Efield_in_file) !          do ii=1_idef,F%dims(1) !             F%X%R(ii)=RMIN+REAL(ii-1)/REAL(F%dims(1)-1)*(RMAX-RMIN) !          end do !          do ii=1_idef,F%dims(3) !             F%X%Z(ii)=ZMIN+REAL(ii-1)/REAL(F%dims(3)-1)*(ZMAX-ZMIN) !          end do !          call calculate_initial_magnetic_field(F) !          F%E_2D%R=0._rp !          do ii=1_idef,F%dims(1) !             F%E_2D%PHI(ii,:)=F%Eo*F%Ro/F%X%R(ii) !          end do !          F%E_2D%Z=0._rp !       end if !       if (F%Bflux.and.test) then !          F%Bfield=.TRUE. !          F%Efield=.TRUE. !          F%Efield_in_file=.TRUE. !          call ALLOCATE_2D_FIELDS_ARRAYS(params,F,F%Bfield, & !               F%Bflux,F%Efield.AND.F%Efield_in_file) ! B ! edge nodes at minimum R,Z !          F%B_2D%Z(1,:)=-(F%PSIp(2,:)-F%PSIp(1,:))/(F%X%R(2)-F%X%R(1))/F%X%R(1) !          F%B_2D%R(:,1)=(F%PSIp(:,2)-F%PSIp(:,1))/(F%X%Z(2)-F%X%Z(1))/F%X%R(:) ! edge nodes at maximum R,Z !          F%B_2D%Z(F%dims(1),:)=-(F%PSIp(F%dims(1),:)-F%PSIp(F%dims(1)-1,:))/ & !               (F%X%R(F%dims(1))-F%X%R(F%dims(1)-1))/F%X%R(F%dims(1)) !          F%B_2D%R(:,F%dims(3))=(F%PSIp(:,F%dims(3))-F%PSIp(:,F%dims(3)-1))/ & !               (F%X%Z(F%dims(3))-F%X%Z(F%dims(3)-1))/F%X%R(:) !          do ii=2_idef,F%dims(1)-1 ! central difference over R for interior nodes for BZ !             F%B_2D%Z(ii,:)=-(F%PSIp(ii+1,:)-F%PSIp(ii-1,:))/ & !                  (F%X%R(ii+1)-F%X%R(ii-1))/F%X%R(ii) !          end do !          do ii=2_idef,F%dims(3)-1 ! central difference over Z for interior nodes for BR !             F%B_2D%R(:,ii)=(F%PSIp(:,ii+1)-F%PSIp(:,ii-1))/ & !                  (F%X%Z(ii+1)-F%X%Z(ii-1))/F%X%R(:) !          end do !          do ii=1_idef,F%dims(1) !             F%B_2D%PHI(ii,:)=-F%Bo*F%Ro/F%X%R(ii) !          end do !          F%E_2D%R=0._rp !          do ii=1_idef,F%dims(1) !             F%E_2D%PHI(ii,:)=F%Eo*F%Ro/F%X%R(ii) !          end do !          F%E_2D%Z=0._rp !          F%Bfield=.FALSE. if ( params % mpi_params % rank . EQ . 0 ) then if ( F % axisymmetric_fields ) then if ( F % Bflux ) then write ( output_unit_write , '(\"PSIp(r=0)\",E17.10)' ) F % PSIp ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"BPHI(r=0)\",E17.10)' ) F % Bo write ( output_unit_write , '(\"EPHI(r=0)\",E17.10)' ) F % Eo else if ( F % Bflux3D ) then write ( output_unit_write , '(\"PSIp(r=0)\",E17.10)' ) F % PSIp3D ( F % dims ( 1 ) / 2 , 1 , F % dims ( 3 ) / 2 ) else write ( output_unit_write , '(\"BR(r=0)\",E17.10)' ) F % B_2D % R ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"BPHI(r=0)\",E17.10)' ) & F % B_2D % PHI ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"BZ(r=0)\",E17.10)' ) F % B_2D % Z ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"EPHI(r=0)\",E17.10)' ) & F % E_2D % PHI ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) end if end if end if if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , '(\"Initializing GC fields from external EM fields\")' ) end if if ( params % field_model ( 10 : 12 ). eq . '2DB' ) then if ( F % axisymmetric_fields ) then call initialize_GC_fields ( F ) else call initialize_GC_fields_3D ( F ) end if end if end if !       write(output_unit_write,'(\"gradBR\",E17.10)') F%gradB_2D%R(F%dims(1)/2,F%dims(3)/2) !       write(output_unit_write,'(\"gradBPHI\",E17.10)') F%gradB_2D%PHI(F%dims(1)/2,F%dims(3)/2) !       write(output_unit_write,'(\"gradBZ\",E17.10)') F%gradB_2D%Z(F%dims(1)/2,F%dims(3)/2) end if if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine initialize_fields subroutine initialize_GC_fields ( F ) !! Computes the auxiliary fields \\nabla|{\\bf B}| and !! \\nabla\\times\\hat{b} that are used in the RHS of the !! evolution equations for the GC orbit model. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. INTEGER :: ii !! Iterator across F%dim REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Bmag !! Magnetic field magnitude REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: bhat !! Magnetic field unit vector Bmag = SQRT ( F % B_2D % R ** 2 + F % B_2D % PHI ** 2 + F % B_2D % Z ** 2 ) ALLOCATE ( bhat ( F % dims ( 1 ), F % dims ( 3 ), 3 )) bhat (:,:, 1 ) = F % B_2D % R / Bmag bhat (:,:, 2 ) = F % B_2D % PHI / Bmag bhat (:,:, 3 ) = F % B_2D % Z / Bmag F % gradB_2D % PHI = 0. ! No variation in phi direction ! Single-sided difference for axiliary fields at edge nodes ! Differential over R on first index, differential over Z ! on second index. ! gradB ! edge nodes at minimum R,Z F % gradB_2D % R ( 1 ,:) = ( Bmag ( 2 ,:) - Bmag ( 1 ,:)) / ( F % X % R ( 2 ) - F % X % R ( 1 )) F % gradB_2D % Z (:, 1 ) = ( Bmag (:, 2 ) - Bmag (:, 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! edge nodes at maximum R,Z F % gradB_2D % R ( F % dims ( 1 ),:) = ( Bmag ( F % dims ( 1 ),:) - Bmag ( F % dims ( 1 ) - 1 ,:)) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) F % gradB_2D % Z (:, F % dims ( 3 )) = ( Bmag (:, F % dims ( 3 )) - Bmag (:, F % dims ( 3 ) - 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! curlb ! edge nodes at minimum R,Z ! R component has differential over Z F % curlb_2D % R (:, 1 ) =- ( bhat (:, 2 , 2 ) - bhat (:, 1 , 2 )) / & ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! PHI component has differentials over R and Z F % curlb_2D % PHI ( 1 ,:) =- ( bhat ( 2 ,:, 3 ) - bhat ( 1 ,:, 3 )) / & ( F % X % R ( 2 ) - F % X % R ( 1 )) F % curlb_2D % PHI (:, 1 ) = F % curlb_2D % PHI (:, 1 ) + & (( bhat (:, 2 , 1 ) - bhat (:, 1 , 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 ))) ! Z component has differentials over R F % curlb_2D % Z ( 1 ,:) = (( bhat ( 2 ,:, 2 ) * F % X % R ( 2 ) - & bhat ( 1 ,:, 2 ) * F % X % R ( 1 )) / ( F % X % R ( 2 ) - F % X % R ( 1 ))) / F % X % R ( 1 ) ! edge nodes at minimum R,Z ! R component has differential over Z F % curlb_2D % R (:, F % dims ( 3 )) =- ( bhat (:, F % dims ( 3 ), 2 ) - & bhat (:, F % dims ( 3 ) - 1 , 2 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! PHI component has differentials over R and Z F % curlb_2D % PHI ( F % dims ( 1 ),:) = F % curlb_2D % PHI ( F % dims ( 1 ),:) - & ( bhat ( F % dims ( 1 ),:, 3 ) - bhat ( F % dims ( 1 ) - 1 ,:, 3 )) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) F % curlb_2D % PHI (:, F % dims ( 3 )) = F % curlb_2D % PHI (:, F % dims ( 3 )) + & (( bhat (:, F % dims ( 3 ), 1 ) - bhat (:, F % dims ( 3 ) - 1 , 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 ))) ! Z component has differentials over R F % curlb_2D % Z ( F % dims ( 1 ),:) = (( bhat ( F % dims ( 1 ),:, 2 ) * F % X % R ( F % dims ( 1 )) - & bhat ( F % dims ( 1 ) - 1 ,:, 2 ) * F % X % R ( F % dims ( 1 ) - 1 )) / ( F % X % R ( F % dims ( 1 )) - & F % X % R ( F % dims ( 1 ) - 1 ))) / F % X % R ( F % dims ( 1 )) do ii = 2_idef , F % dims ( 1 ) - 1 ! central difference over R for interior nodes F % gradB_2D % R ( ii ,:) = ( Bmag ( ii + 1 ,:) - Bmag ( ii - 1 ,:)) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) F % curlb_2D % Z ( ii ,:) = (( bhat ( ii + 1 ,:, 2 ) * F % X % R ( ii + 1 ) - & bhat ( ii - 1 ,:, 2 ) * F % X % R ( ii - 1 )) / ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 ))) / & F % X % R ( ii ) F % curlb_2D % PHI ( ii ,:) = F % curlb_2D % PHI ( ii ,:) - & ( bhat ( ii + 1 ,:, 3 ) - bhat ( ii - 1 ,:, 3 )) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) end do do ii = 2_idef , F % dims ( 3 ) - 1 ! central difference over Z for interior nodes F % gradB_2D % Z (:, ii ) = ( Bmag (:, ii + 1 ) - Bmag (:, ii - 1 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_2D % R (:, ii ) =- ( bhat (:, ii + 1 , 2 ) - bhat (:, ii - 1 , 2 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_2D % PHI (:, ii ) = F % curlb_2D % PHI (:, ii ) + & (( bhat (:, ii + 1 , 1 ) - bhat (:, ii - 1 , 1 )) / ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 ))) end do DEALLOCATE ( Bmag ) DEALLOCATE ( bhat ) end subroutine initialize_GC_fields subroutine initialize_GC_fields_3D ( F ) !! Computes the auxiliary fields \\nabla|{\\bf B}| and !! \\nabla\\times\\hat{b} that are used in the RHS of the !! evolution equations for the GC orbit model. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. INTEGER :: ii , jj !! Iterator across F%dim REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Bmag !! Magnetic field magnitude REAL ( rp ), DIMENSION (:,:,:,:), ALLOCATABLE :: bhat !! Magnetic field unit vector Bmag = SQRT ( F % B_3D % R ** 2 + F % B_3D % PHI ** 2 + F % B_3D % Z ** 2 ) ALLOCATE ( bhat ( F % dims ( 1 ), F % dims ( 2 ), F % dims ( 3 ), 3 )) bhat (:,:,:, 1 ) = F % B_3D % R / Bmag bhat (:,:,:, 2 ) = F % B_3D % PHI / Bmag bhat (:,:,:, 3 ) = F % B_3D % Z / Bmag ! Single-sided difference for axiliary fields at edge nodes ! Differential over R on first index, differential over Z ! on second index. F % gradB_3D % R = 0._rp F % gradB_3D % PHI = 0._rp F % gradB_3D % Z = 0._rp F % curlb_3D % R = 0._rp F % curlb_3D % PHI = 0._rp F % curlb_3D % Z = 0._rp ! gradB ! edge nodes at minimum R,Z F % gradB_3D % R ( 1 ,:,:) = F % gradB_3D % R ( 1 ,:,:) + & ( Bmag ( 2 ,:,:) - Bmag ( 1 ,:,:)) / ( F % X % R ( 2 ) - F % X % R ( 1 )) do ii = 1_idef , F % dims ( 1 ) F % gradB_3D % PHI ( ii , 1 ,:) = F % gradB_3D % PHI ( ii , 1 ,:) + & ( Bmag ( ii , 2 ,:) - Bmag ( ii , F % dims ( 2 ),:)) / & ( F % X % R ( ii ) * ( F % X % PHI ( 2 ) - F % X % PHI ( F % dims ( 2 )))) end do F % gradB_3D % Z (:,:, 1 ) = F % gradB_3D % Z (:,:, 1 ) + & ( Bmag (:,:, 2 ) - Bmag (:,:, 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! edge nodes at maximum R,Z F % gradB_3D % R ( F % dims ( 1 ),:,:) = F % gradB_3D % R ( F % dims ( 1 ),:,:) + & ( Bmag ( F % dims ( 1 ),:,:) - Bmag ( F % dims ( 1 ) - 1 ,:,:)) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) do ii = 1_idef , F % dims ( 1 ) F % gradB_3D % PHI ( ii , F % dims ( 2 ),:) = F % gradB_3D % PHI ( ii , F % dims ( 2 ),:) + & ( Bmag ( ii , 1 ,:) - Bmag ( ii , F % dims ( 2 ) - 1 ,:)) / & ( F % X % R ( ii ) * ( F % X % PHI ( 1 ) - F % X % PHI ( F % dims ( 2 ) - 1 ))) end do F % gradB_3D % Z (:,:, F % dims ( 3 )) = F % gradB_3D % Z (:,:, F % dims ( 3 )) + & ( Bmag (:,:, F % dims ( 3 )) - Bmag (:,:, F % dims ( 3 ) - 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! curlb ! edge nodes at minimum R,PHI,Z ! R component has differential over PHI and Z do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % R ( ii , 1 ,:) = F % curlb_3D % R ( ii , 1 ,:) + & ( bhat ( ii , 2 ,:, 3 ) - bhat ( ii , F % dims ( 2 ),:, 3 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 2 ) - F % X % PHI ( F % dims ( 2 )))) end do F % curlb_3D % R (:,:, 1 ) = F % curlb_3D % R (:,:, 1 ) - & ( bhat (:,:, 2 , 2 ) - bhat (:,:, 1 , 2 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! PHI component has differentials over R and Z F % curlb_3D % PHI ( 1 ,:,:) = F % curlb_3D % PHI ( 1 ,:,:) - & ( bhat ( 2 ,:,:, 3 ) - bhat ( 1 ,:,:, 3 )) / & ( F % X % R ( 2 ) - F % X % R ( 1 )) F % curlb_3D % PHI (:,:, 1 ) = F % curlb_3D % PHI (:,:, 1 ) + & (( bhat (:,:, 2 , 1 ) - bhat (:,:, 1 , 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 ))) ! Z component has differentials over R and PHI F % curlb_3D % Z ( 1 ,:,:) = F % curlb_3D % Z ( 1 ,:,:) + & (( bhat ( 2 ,:,:, 2 ) * F % X % R ( 2 ) - & bhat ( 1 ,:,:, 2 ) * F % X % R ( 1 )) / ( F % X % R ( 2 ) - F % X % R ( 1 ))) / F % X % R ( 1 ) do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % Z ( ii , 1 ,:) = F % curlb_3D % Z ( ii , 1 ,:) - & ( bhat ( ii , 2 ,:, 1 ) - bhat ( ii , F % dims ( 2 ),:, 1 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 2 ) - F % X % PHI ( F % dims ( 2 )))) end do ! edge nodes at maximum R,PHI,Z ! R component has differential over PHI and Z do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % R ( ii , F % dims ( 2 ),:) = F % curlb_3D % R ( ii , F % dims ( 2 ),:) + & ( bhat ( ii , 1 ,:, 3 ) - bhat ( ii , F % dims ( 2 ) - 1 ,:, 3 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 1 ) - F % X % PHI ( F % dims ( 2 ) - 1 ))) end do F % curlb_3D % R (:,:, F % dims ( 3 )) = F % curlb_3D % R (:,:, F % dims ( 3 )) & - ( bhat (:,:, F % dims ( 3 ), 2 ) - bhat (:,:, F % dims ( 3 ) - 1 , 2 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! PHI component has differentials over R and Z F % curlb_3D % PHI ( F % dims ( 1 ),:,:) = F % curlb_3D % PHI ( F % dims ( 1 ),:,:) - & ( bhat ( F % dims ( 1 ),:,:, 3 ) - bhat ( F % dims ( 1 ) - 1 ,:,:, 3 )) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) F % curlb_3D % PHI (:,:, F % dims ( 3 )) = F % curlb_3D % PHI (:,:, F % dims ( 3 )) + & (( bhat (:,:, F % dims ( 3 ), 1 ) - bhat (:,:, F % dims ( 3 ) - 1 , 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 ))) ! Z component has differentials over R and PHI F % curlb_3D % Z ( F % dims ( 1 ),:,:) = F % curlb_3D % Z ( F % dims ( 1 ),:,:) + & (( bhat ( F % dims ( 1 ),:,:, 2 ) * F % X % R ( F % dims ( 1 )) - & bhat ( F % dims ( 1 ) - 1 ,:,:, 2 ) * F % X % R ( F % dims ( 1 ) - 1 )) / ( F % X % R ( F % dims ( 1 )) - & F % X % R ( F % dims ( 1 ) - 1 ))) / F % X % R ( F % dims ( 1 )) do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % Z ( ii , F % dims ( 2 ),:) = F % curlb_3D % Z ( ii , F % dims ( 2 ),:) - & ( bhat ( ii , 1 ,:, 1 ) - bhat ( ii , F % dims ( 2 ) - 1 ,:, 1 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 1 ) - F % X % PHI ( F % dims ( 2 ) - 1 ))) end do do ii = 2_idef , F % dims ( 1 ) - 1 ! central difference over R for interior nodes F % gradB_3D % R ( ii ,:,:) = F % gradB_3D % R ( ii ,:,:) + & ( Bmag ( ii + 1 ,:,:) - Bmag ( ii - 1 ,:,:)) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) F % curlb_3D % Z ( ii ,:,:) = F % curlb_3D % Z ( ii ,:,:) + & (( bhat ( ii + 1 ,:,:, 2 ) * F % X % R ( ii + 1 ) - & bhat ( ii - 1 ,:,:, 2 ) * F % X % R ( ii - 1 )) / ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 ))) / & F % X % R ( ii ) F % curlb_3D % PHI ( ii ,:,:) = F % curlb_3D % PHI ( ii ,:,:) - & ( bhat ( ii + 1 ,:,:, 3 ) - bhat ( ii - 1 ,:,:, 3 )) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) end do do ii = 2_idef , F % dims ( 2 ) - 1 ! central difference over PHI for interior nodes do jj = 1_idef , F % dims ( 1 ) F % gradB_3D % PHI ( jj , ii ,:) = F % gradB_3D % PHI ( jj , ii ,:) + & ( Bmag ( jj , ii + 1 ,:) - Bmag ( jj , ii - 1 ,:)) / & ( F % X % R ( jj ) * ( F % X % PHI ( ii + 1 ) - F % X % PHI ( ii - 1 ))) F % curlb_3D % Z ( jj , ii ,:) = F % curlb_3D % Z ( jj , ii ,:) - & ( bhat ( jj , ii + 1 ,:, 1 ) - bhat ( jj , ii - 1 ,:, 1 )) / & ( F % X % R ( jj ) * ( F % X % PHI ( ii + 1 ) - F % X % PHI ( ii - 1 ))) F % curlb_3D % R ( jj , ii ,:) = F % curlb_3D % R ( jj , ii ,:) + & ( bhat ( jj , ii + 1 ,:, 3 ) - bhat ( jj , ii - 1 ,:, 3 )) / & ( F % X % R ( jj ) * ( F % X % PHI ( ii + 1 ) - F % X % PHI ( ii - 1 ))) end do end do do ii = 2_idef , F % dims ( 3 ) - 1 ! central difference over Z for interior nodes F % gradB_3D % Z (:,:, ii ) = F % gradB_3D % Z (:,:, ii ) + & ( Bmag (:,:, ii + 1 ) - Bmag (:,:, ii - 1 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_3D % R (:,:, ii ) = F % curlb_3D % R (:,:, ii ) - & ( bhat (:,:, ii + 1 , 2 ) - bhat (:,:, ii - 1 , 2 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_3D % PHI (:,:, ii ) = F % curlb_3D % PHI (:,:, ii ) + & (( bhat (:,:, ii + 1 , 1 ) - bhat (:,:, ii - 1 , 1 )) / ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 ))) end do DEALLOCATE ( Bmag ) DEALLOCATE ( bhat ) end subroutine initialize_GC_fields_3D subroutine define_SC_time_step ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F integer :: sub_E_SC F % subcycle_E_SC = FLOOR ( F % dt_E_SC / params % dt , ip ) sub_E_SC = F % subcycle_E_SC params % t_it_SC = params % t_skip / F % subcycle_E_SC params % t_skip = F % subcycle_E_SC F % dt_E_SC = params % t_skip * params % dt !    write(output_unit_write,*) 'dt_E_SC',F%dt_E_SC,'dt',params%dt,'subcycle_E_SC', & !         F%subcycle_E_SC,'t_skip',params%t_skip, & !         't_it_SC',params%t_it_SC if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * SC_E1D SUBCYCLING * * * * *\")' ) write ( output_unit_write , * ) \"SC_E1D sybcycling iterations: \" , F % subcycle_E_SC write ( output_unit_write , * ) \"Updated number of outputs: \" , & params % t_steps / ( params % t_skip * params % t_it_SC ) write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine define_SC_time_step ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ! Subroutines for getting the fields data from HDF5 files ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * !> @brief Subroutine that loads the size of the arrays having the electric and magnetic field data. !! @details All the information of externally calculated fields must be given in a rectangular, equally spaced mesh in the (R,\\phi,Z) space of cylindrical coordinates. !! If the fields are axisymmetric, then the fields must be in a rectangular mesh on the RZ-plane. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] F An instance of the KORC derived type FIELDS. !! @param filename String containing the name of the HDF5 file. !! @param gname String containing the group name of a parameter in the HDF5 file. !! @param subgname String containing the subgroup name of a parameter in the HDF5 file. !! @param dset Name of data set to read from file. !! @param h5file_id HDF5 file identifier. !! @param group_id HDF5 group identifier. !! @param subgroup_id HDF5 subgroup identifier. !! @dims Array containing the size of the mesh with the data of the electric and magnetic fields. dims(1) = dimension along the R coordinate, !! dims(2) = dimension along the \\phi coordinate, and dims(3) = dimension along the Z coordinate. !! @param h5error HDF5 error status. !! @param rdamum Temporary variable keeping the read data. subroutine load_dim_data_from_hdf5 ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER :: h5error REAL ( rp ) :: rdatum filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_dim_data_from_hdf5 --> h5fopen_f\")' ) end if if ( F % Bflux . OR . F % axisymmetric_fields ) then dset = \"/NR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 1 ) = INT ( rdatum ) F % dims ( 2 ) = 0 dset = \"/NZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 3 ) = INT ( rdatum ) if ( params % SC_E ) then dset = \"/OSNR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 1 ) = INT ( rdatum ) dset = \"/OSNZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 3 ) = INT ( rdatum ) end if if ( F % Dim2x1t ) then dset = \"/NPHI\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 2 ) = INT ( rdatum ) end if else dset = \"/NR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 1 ) = INT ( rdatum ) dset = \"/NPHI\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 2 ) = INT ( rdatum ) dset = \"/NZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 3 ) = INT ( rdatum ) end if call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_dim_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_dim_data_from_hdf5 !> @brief Subroutine that queries the HDF5 file what data are present in the HDF5 input file (sanity check). !! !! @param[in] params Core KORC simulation parameters. !! @param Bfield Logical variable that specifies if the magnetic field is present in the HDF5 file. !! @param Efield Logical variable that specifies if the electric field is present in the HDF5 file. !! @param Bflux Logical variable that specifies if the poloidal magnetic flux is present in the HDF5 file. !! @param filename String containing the name of the HDF5 file. !! @param gname String containing the group name of a parameter in the HDF5 file. !! @param subgname String containing the subgroup name of a parameter in the HDF5 file. !! @param dset Name of data set to read from file. !! @param h5file_id HDF5 file identifier. !! @param group_id HDF5 group identifier. !! @param subgroup_id HDF5 subgroup identifier. !! @param h5error HDF5 error status. subroutine which_fields_in_file ( params , Bfield , Efield , Bflux , dBfield ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params LOGICAL , INTENT ( OUT ) :: Bfield LOGICAL , INTENT ( OUT ) :: dBfield LOGICAL , INTENT ( OUT ) :: Efield LOGICAL , INTENT ( OUT ) :: Bflux CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER :: h5error filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if gname = \"BR\" call h5lexists_f ( h5file_id , TRIM ( gname ), Bfield , h5error ) gname = \"dBRdR\" call h5lexists_f ( h5file_id , TRIM ( gname ), dBfield , h5error ) gname = \"ER\" call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) gname = \"PSIp\" call h5lexists_f ( h5file_id , TRIM ( gname ), Bflux , h5error ) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine which_fields_in_file !> @brief Subroutine that loads the fields data from the HDF5 input file. !! !! @param[in] params Core KORC simulation parameters. !! @param[in,out] F An instance of the KORC derived type FIELDS. In this variable we keep the loaded data. !! @param filename String containing the name of the HDF5 file. !! @param gname String containing the group name of a parameter in the HDF5 file. !! @param subgname String containing the subgroup name of a parameter in the HDF5 file. !! @param dset Name of data set to read from file. !! @param h5file_id HDF5 file identifier. !! @param group_id HDF5 group identifier. !! @param subgroup_id HDF5 subgroup identifier. !! @param h5error HDF5 error status. subroutine load_field_data_from_hdf5 ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER :: h5error LOGICAL :: Efield filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if if (((. NOT . F % Bflux ). AND .(. NOT . F % axisymmetric_fields )). OR . & F % Dim2x1t ) then dset = \"/PHI\" call load_array_from_hdf5 ( h5file_id , dset , F % X % PHI ) end if if ( params % SC_E ) then dset = \"/OSR\" call load_array_from_hdf5 ( h5file_id , dset , F % X % R ) dset = \"/OSZ\" call load_array_from_hdf5 ( h5file_id , dset , F % X % Z ) else dset = \"/R\" call load_array_from_hdf5 ( h5file_id , dset , F % X % R ) dset = \"/Z\" call load_array_from_hdf5 ( h5file_id , dset , F % X % Z ) end if dset = '/Bo' call load_from_hdf5 ( h5file_id , dset , F % Bo ) if ( F % Efield ) then dset = '/Eo' gname = 'Eo' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_from_hdf5 ( h5file_id , dset , F % Eo ) else F % Eo = 0.0_rp end if else F % Eo = 0.0_rp end if dset = '/Ro' call load_from_hdf5 ( h5file_id , dset , F % Ro ) dset = '/Zo' call load_from_hdf5 ( h5file_id , dset , F % Zo ) if (( F % Bflux . OR . F % axisymmetric_fields ). AND .(. NOT . F % Dim2x1t )) then if ( params % SC_E ) then dset = \"/OSFLAG\" call load_array_from_hdf5 ( h5file_id , dset , F % FLAG2D ) else dset = \"/FLAG\" call load_array_from_hdf5 ( h5file_id , dset , F % FLAG2D ) end if else dset = \"/FLAG\" call load_array_from_hdf5 ( h5file_id , dset , F % FLAG3D ) end if if ( F % Bflux ) then if ( params % SC_E ) then dset = \"/OSPSIp\" gname = 'OSPSIp' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_array_from_hdf5 ( h5file_id , dset , F % PSIp ) else F % PSIp = 0.0_rp end if else dset = \"/PSIp\" gname = 'PSIp' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_array_from_hdf5 ( h5file_id , dset , F % PSIp ) else F % PSIp = 0.0_rp end if !          F%PSIp=2*C_PI*(F%PSIp-minval(F%PSIp)) end if end if if ( F % Bflux3D ) then dset = \"/PSIp\" gname = 'PSIp' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_array_from_hdf5 ( h5file_id , dset , F % PSIp3D ) else F % PSIp3D = 0.0_rp end if !       F%PSIp3D=2*C_PI*(F%PSIp3D-minval(F%PSIp3D)) end if if ( F % Bfield ) then if ( F % axisymmetric_fields ) then dset = \"/BR\" call load_array_from_hdf5 ( h5file_id , dset , F % B_2D % R ) dset = \"/BPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % B_2D % PHI ) dset = \"/BZ\" call load_array_from_hdf5 ( h5file_id , dset , F % B_2D % Z ) else dset = \"/BR\" call load_array_from_hdf5 ( h5file_id , dset , F % B_3D % R ) dset = \"/BPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % B_3D % PHI ) dset = \"/BZ\" call load_array_from_hdf5 ( h5file_id , dset , F % B_3D % Z ) end if end if if ( F % dBfield . and . F % dBfield_in_file ) then if ( F % axisymmetric_fields ) then dset = \"/dBRdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_2D % R ) dset = \"/dBPHIdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_2D % PHI ) dset = \"/dBZdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_2D % Z ) dset = \"/dBRdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_2D % R ) dset = \"/dBPHIdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_2D % PHI ) dset = \"/dBZdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_2D % Z ) dset = \"/dBRdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_2D % R ) dset = \"/dBPHIdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_2D % PHI ) dset = \"/dBZdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_2D % Z ) else dset = \"/dBRdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_3D % R ) dset = \"/dBPHIdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_3D % PHI ) dset = \"/dBZdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_3D % Z ) dset = \"/dBRdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_3D % R ) dset = \"/dBPHIdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_3D % PHI ) dset = \"/dBZdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_3D % Z ) dset = \"/dBRdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_3D % R ) dset = \"/dBPHIdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_3D % PHI ) dset = \"/dBZdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_3D % Z ) end if end if if ( F % Efield . AND . F % Efield_in_file ) then if ( F % axisymmetric_fields . and .(. not . F % ReInterp_2x1t )) then dset = \"/ER\" call load_array_from_hdf5 ( h5file_id , dset , F % E_2D % R ) dset = \"/EPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % E_2D % PHI ) dset = \"/EZ\" call load_array_from_hdf5 ( h5file_id , dset , F % E_2D % Z ) else dset = \"/ER\" call load_array_from_hdf5 ( h5file_id , dset , F % E_3D % R ) dset = \"/EPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % E_3D % PHI ) dset = \"/EZ\" call load_array_from_hdf5 ( h5file_id , dset , F % E_3D % Z ) end if end if call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_field_data_from_hdf5 subroutine load_1D_FS_from_hdf5 ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER :: h5error filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if dset = \"/PSIP1D\" call load_array_from_hdf5 ( h5file_id , dset , F % PSIP_1D ) dset = \"/dMagPsiSqdPsiP\" call load_array_from_hdf5 ( h5file_id , dset , F % dMagPsiSqdPsiP ) dset = \"/ddMagPsiSqdPsiPSq\" call load_array_from_hdf5 ( h5file_id , dset , F % ddMagPsiSqdPsiPSq ) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_1D_FS_from_hdf5 subroutine allocate_1D_FS_arrays ( params , F ) !! @note Subroutine that allocates the variables keeping the axisymmetric !! fields data. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. In this variable we keep !! the loaded data. CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER :: h5error CHARACTER ( MAX_STRING_LENGTH ) :: filename filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if dset = \"/N1D\" call load_from_hdf5 ( h5file_id , dset , F % dim_1D ) ALLOCATE ( F % PSIP_1D ( F % dim_1D )) ALLOCATE ( F % dMagPsiSqdPsiP ( F % dim_1D )) ALLOCATE ( F % ddMagPsiSqdPsiPSq ( F % dim_1D )) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine ALLOCATE_1D_FS_ARRAYS subroutine ALLOCATE_2D_FIELDS_ARRAYS ( params , F , bfield , bflux , dbfield , efield ) !! @note Subroutine that allocates the variables keeping the axisymmetric !! fields data. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. In this variable we keep !! the loaded data. LOGICAL , INTENT ( IN ) :: bfield LOGICAL , INTENT ( IN ) :: dbfield !! Logical variable that specifies if the variables that keep the magnetic !! field data is allocated (bfield=T) or not (bfield=F). LOGICAL , INTENT ( IN ) :: bflux !! Logical variable that specifies if the variables that keep the poloidal !! magnetic flux data is allocated (bflux=T) or not (bflux=F). LOGICAL , INTENT ( IN ) :: efield !! Logical variable that specifies if the variables that keep the electric !! field data is allocated (efield=T) or not (efield=F). if ( bfield . and .(. not . ALLOCATED ( F % B_2D % R ))) then call ALLOCATE_V_FIELD_2D ( F % B_2D , F % dims ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then call ALLOCATE_V_FIELD_2D ( F % curlb_2D , F % dims ) call ALLOCATE_V_FIELD_2D ( F % gradB_2D , F % dims ) end if end if if ( bflux . and .(. not . ALLOCATED ( F % PSIp ))) then ALLOCATE ( F % PSIp ( F % dims ( 1 ), F % dims ( 3 ))) end if if ( dbfield . and .(. not . ALLOCATED ( F % dBdR_2D % R ))) then call ALLOCATE_V_FIELD_2D ( F % dBdR_2D , F % dims ) call ALLOCATE_V_FIELD_2D ( F % dBdPHI_2D , F % dims ) call ALLOCATE_V_FIELD_2D ( F % dBdZ_2D , F % dims ) end if if ( efield . and .(. not . ALLOCATED ( F % E_2D % R ))) then call ALLOCATE_V_FIELD_2D ( F % E_2D , F % dims ) end if if (. NOT . ALLOCATED ( F % FLAG2D )) ALLOCATE ( F % FLAG2D ( F % dims ( 1 ), F % dims ( 3 ))) if (. NOT . ALLOCATED ( F % X % R )) ALLOCATE ( F % X % R ( F % dims ( 1 ))) if (. NOT . ALLOCATED ( F % X % Z )) ALLOCATE ( F % X % Z ( F % dims ( 3 ))) end subroutine ALLOCATE_2D_FIELDS_ARRAYS !> @brief Subroutine that allocates the variables keeping the 3-D fields data. !! !! @param[in,out] F An instance of the KORC derived type FIELDS. In this variable we keep the loaded data. !! @param[in] bfield Logical variable that specifies if the variables that keep the magnetic field data is allocated (bfield=T) or not (bfield=F). !! @param[in] efield Logical variable that specifies if the variables that keep the electric field data is allocated (efield=T) or not (efield=F). subroutine ALLOCATE_3D_FIELDS_ARRAYS ( params , F , bfield , efield , dbfield ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F LOGICAL , INTENT ( IN ) :: bfield LOGICAL , INTENT ( IN ) :: dbfield LOGICAL , INTENT ( IN ) :: efield if ( bfield ) then call ALLOCATE_V_FIELD_3D ( F % B_3D , F % dims ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then call ALLOCATE_V_FIELD_3D ( F % curlb_3D , F % dims ) call ALLOCATE_V_FIELD_3D ( F % gradB_3D , F % dims ) end if end if if ( F % Bflux3D . and .(. not . ALLOCATED ( F % PSIp3D ))) then ALLOCATE ( F % PSIp3D ( F % dims ( 1 ), F % dims ( 2 ), F % dims ( 3 ))) end if if ( dbfield . and .(. not . ALLOCATED ( F % dBdR_3D % R ))) then call ALLOCATE_V_FIELD_3D ( F % dBdR_3D , F % dims ) call ALLOCATE_V_FIELD_3D ( F % dBdPHI_3D , F % dims ) call ALLOCATE_V_FIELD_3D ( F % dBdZ_3D , F % dims ) end if if ( efield ) then call ALLOCATE_V_FIELD_3D ( F % E_3D , F % dims ) end if if (. NOT . ALLOCATED ( F % FLAG3D )) ALLOCATE ( F % FLAG3D ( F % dims ( 1 ), F % dims ( 2 ), F % dims ( 3 ))) if (. NOT . ALLOCATED ( F % X % R )) ALLOCATE ( F % X % R ( F % dims ( 1 ))) if (. NOT . ALLOCATED ( F % X % PHI )) ALLOCATE ( F % X % PHI ( F % dims ( 2 ))) if (. NOT . ALLOCATED ( F % X % Z )) ALLOCATE ( F % X % Z ( F % dims ( 3 ))) end subroutine ALLOCATE_3D_FIELDS_ARRAYS !> @brief Subroutine that allocates the cylindrical components of an axisymmetric field. !! !! @param[in,out] F Vector field to be allocated. !! @param[in] dims Dimension of the mesh containing the field data. subroutine ALLOCATE_V_FIELD_2D ( F , dims ) TYPE ( V_FIELD_2D ), INTENT ( INOUT ) :: F INTEGER , DIMENSION ( 3 ), INTENT ( IN ) :: dims ALLOCATE ( F % R ( dims ( 1 ), dims ( 3 ))) ALLOCATE ( F % PHI ( dims ( 1 ), dims ( 3 ))) ALLOCATE ( F % Z ( dims ( 1 ), dims ( 3 ))) end subroutine ALLOCATE_V_FIELD_2D !> @brief Subroutine that allocates the cylindrical components of a 3-D field. !! !! @param[in,out] F Vector field to be allocated. !! @param[in] dims Dimension of the mesh containing the field data. subroutine ALLOCATE_V_FIELD_3D ( F , dims ) TYPE ( V_FIELD_3D ), INTENT ( INOUT ) :: F INTEGER , DIMENSION ( 3 ), INTENT ( IN ) :: dims ALLOCATE ( F % R ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) ALLOCATE ( F % PHI ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) ALLOCATE ( F % Z ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) end subroutine ALLOCATE_V_FIELD_3D !> @brief Subroutine that deallocates all the variables of the electric and magnetic fields. !! !! @param[in,out] F An instance of the KORC derived type FIELDS. subroutine DEALLOCATE_FIELDS_ARRAYS ( F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F if ( ALLOCATED ( F % PSIp )) DEALLOCATE ( F % PSIp ) if ( ALLOCATED ( F % B_2D % R )) DEALLOCATE ( F % B_2D % R ) if ( ALLOCATED ( F % B_2D % PHI )) DEALLOCATE ( F % B_2D % PHI ) if ( ALLOCATED ( F % B_2D % Z )) DEALLOCATE ( F % B_2D % Z ) if ( ALLOCATED ( F % gradB_2D % R )) DEALLOCATE ( F % gradB_2D % R ) if ( ALLOCATED ( F % gradB_2D % PHI )) DEALLOCATE ( F % gradB_2D % PHI ) if ( ALLOCATED ( F % gradB_2D % Z )) DEALLOCATE ( F % gradB_2D % Z ) if ( ALLOCATED ( F % curlb_2D % R )) DEALLOCATE ( F % curlb_2D % R ) if ( ALLOCATED ( F % curlb_2D % PHI )) DEALLOCATE ( F % curlb_2D % PHI ) if ( ALLOCATED ( F % curlb_2D % Z )) DEALLOCATE ( F % curlb_2D % Z ) if ( ALLOCATED ( F % B_3D % R )) DEALLOCATE ( F % B_3D % R ) if ( ALLOCATED ( F % B_3D % PHI )) DEALLOCATE ( F % B_3D % PHI ) if ( ALLOCATED ( F % B_3D % Z )) DEALLOCATE ( F % B_3D % Z ) if ( ALLOCATED ( F % E_2D % R )) DEALLOCATE ( F % E_2D % R ) if ( ALLOCATED ( F % E_2D % PHI )) DEALLOCATE ( F % E_2D % PHI ) if ( ALLOCATED ( F % E_2D % Z )) DEALLOCATE ( F % E_2D % Z ) if ( ALLOCATED ( F % E_3D % R )) DEALLOCATE ( F % E_3D % R ) if ( ALLOCATED ( F % E_3D % PHI )) DEALLOCATE ( F % E_3D % PHI ) if ( ALLOCATED ( F % E_3D % Z )) DEALLOCATE ( F % E_3D % Z ) if ( ALLOCATED ( F % E_SC_1D % PHI )) DEALLOCATE ( F % E_SC_1D % PHI ) if ( ALLOCATED ( F % J1_SC_1D % PHI )) DEALLOCATE ( F % J1_SC_1D % PHI ) if ( ALLOCATED ( F % J2_SC_1D % PHI )) DEALLOCATE ( F % J2_SC_1D % PHI ) if ( ALLOCATED ( F % J3_SC_1D % PHI )) DEALLOCATE ( F % J3_SC_1D % PHI ) if ( ALLOCATED ( F % A1_SC_1D % PHI )) DEALLOCATE ( F % A1_SC_1D % PHI ) if ( ALLOCATED ( F % A2_SC_1D % PHI )) DEALLOCATE ( F % A2_SC_1D % PHI ) if ( ALLOCATED ( F % A3_SC_1D % PHI )) DEALLOCATE ( F % A3_SC_1D % PHI ) if ( ALLOCATED ( F % X % R )) DEALLOCATE ( F % X % R ) if ( ALLOCATED ( F % X % PHI )) DEALLOCATE ( F % X % PHI ) if ( ALLOCATED ( F % X % Z )) DEALLOCATE ( F % X % Z ) if ( ALLOCATED ( F % FLAG2D )) DEALLOCATE ( F % FLAG2D ) if ( ALLOCATED ( F % FLAG3D )) DEALLOCATE ( F % FLAG3D ) end subroutine DEALLOCATE_FIELDS_ARRAYS end module korc_fields","tags":"","loc":"sourcefile/korc_fields.f90.html"},{"title":"main.f90 – KORC-Full Orbit","text":"Contents Programs main Source Code main.f90 Source Code program main !! @note  Main function of KORC. @endnote !! The main program contains the calls to the main functions and subroutines. !! Also, it contains the variables that control !! the behavior of the core of KORC and all other external/optional modules. use korc_types use korc_units use korc_hpc use korc_HDF5 use korc_fields use korc_ppusher use korc_interp use korc_collisions use korc_initialize use korc_finalize use korc_profiles use korc_input implicit none TYPE ( KORC_PARAMS ) :: params !! Contains the parameters that control the core of KORC: !! time steping, output list, etc. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE :: spp !! Contains the initial parameters of each species, which !! can be different electrons with different !! distribution functions. TYPE ( FIELDS ) :: F !! F: Contains the parameters of the analytical magnetic !! and electric fields, or in the case of using !! external fields it contains the data used in the interpolations. !!See [[korc_fields(module)]] for details. TYPE ( PROFILES ) :: P !! P: Contains the parameters of the analytical plasma profiles, !! or in the case of using external !! fields it contains the data used in the interpolations. !! See [[korc_profiles(module)]] for details. INTEGER ( ip ) :: it !! Time iteration INTEGER :: mpierr call initialize_communications ( params ) !!<h2>Order of KORC operations</h2> !! !!<h3>Communication and Timing</h3> !! <h4>1\\. Parallel Communications</h4> !! !! Subroutine [[initialize_communications]] in [[korc_hpc]] that !! initializes MPI and OpenMP communications. call timing_KORC ( params ) !! <h4>2\\. Timers</h4> !! !! Subroutine [[timing_KORC]] in [[korc_hpc]] that times the !! execution of any parallel sections of KORC. ! * * * INITIALIZATION STAGE * * *! call initialize_HDF5 () !!<h3>Initialization</h3> !! !! <h4>1\\. HDF5</h4> !! !! Subroutine [[initialize_HDF5]] in [[korc_HDF5]] that initializes !! HDF5 library. call initialize_korc_parameters ( params ) !! <h4>2\\. Initialize korc parameters</h4> !! !! Subroutine [[initialize_korc_parameters]] in [[korc_initialize]] that !! initializes paths and KORC parameters through [[load_korc_params]] !! on MPI processes. call initialize_fields ( params , F ) !! <h4>3\\. Initialize fields</h4> !! !! Subroutine [[initialize_fields]] in [[korc_fields]] that initializes !! parameters of the EM fields, either analytically or from an external HDF5 !! file. Reads in &amp;analytical_fields_params and !! &amp;externalPlasmaModel namelists from input file. call initialize_profiles ( params , P , F ) !! <h4>4\\. Initialize Profiles</h4> !! !! Subroutine [[initialize_profiles]] in [[korc_profiles]] that initializes !! parameters of the plasma profiles, either analytically or from an !! external HDF5 !! file. Reads in &amp;plasmaProfiles namelist from input file. !! Only initialized if collisions (params%collisions==T) are call initialize_particles ( params , F , P , spp ) ! Initialize particles !! <h4>5\\. Initialize Particle Velocity Phase Space</h4> !! !! Subroutine [[initialize_particles]] in [[korc_initialize]] that !! initializes particle parameters from &amplasma_species namelist, !! allocates arrays for individual particles, including location, velocity, !! local EM fields and plasma profiles, etc., and !! calls [[initial_energy_pitch_dist]] to assign particles' energy and pitch !! angle according to the chosen distribution. !  write(output_unit_write,'(\"init eta: \",E17.10)') spp(1)%vars%eta #ifdef M3D_C1 if ( TRIM ( params % field_model ) . eq . 'M3D_C1' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) \"* * * * INITIALIZING M3D-C1 INTERFACE * * * *\" endif call initialize_m3d_c1 ( params , F , P , spp ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) \"* * * * * * * * * * * * * * * * * * * * * * *\" endif endif #endif call compute_charcs_plasma_params ( params , spp , F ) !! <h4>9\\. Compute Characteristic Plasma Parameters</h4> !! !! Subroutine [[compute_charcs_plasma_params]] in [[korc_units]] calculates !! the characteristic plasma parameters params%cpp that are used for normalizations. !! Also finds the maximum non-relativistic and relativistic cyclotron frequencies !! to be used for setting the timstep for the time-evolution algorithms. call initialize_collision_params ( params ) !! <h4>6\\. Initialize Collision Parameters</h4> !! !! Subroutine [[initialize_collision_params]] in [[korc_collisions]] that !! initializes collision parameters for the SS (single-species) and MS !! (multiple-species) data types, reading in namefiles from the KORC input file. !! MS reads in namelist &CollisionParamsMultipleSpecies while SS reads in !! namelist &CollisionParamsSingleSpecies. call define_time_step ( params ) !! <h4>10\\. Define Time Step</h4> !! !! Subroutine [[define_time_step]] in [[korc_initialize]] either loads !! time-stepping parameters for a restart, or defines new parameters based !! on a maximum timestep !! set by the inverse of the relativistic cyclotron frequency. call initialize_particle_pusher ( params ) !! <h4>11\\. Initialize Particle Pusher</h4> if ( params % SC_E ) then call define_SC_time_step ( params , F ) end if call normalize_variables ( params , spp , F , P ) !! <h4>12\\. Normalize Variables</h4> !! !! Subroutine [[normalize_variables]] in [[korc_units]] normalizes !! variables consistent with characteristic plasma parameters !! calculated in [[compute_charcs_plasma_params]]. call normalize_collisions_params ( params ) !! <h4>13\\. Normalize Collision Parameters </h4> !! !! Subroutine [[normalize_collisions_params]] in [[korc_collisions]] that !! normalizes collision parameters for the SS (single-species) and MS !! (multiple-species) data types. call define_collisions_time_step ( params ) !! <h4>14\\. Define Collision Time Step</h4> !! !! Subroutine [[define_collisions_time_step]] in [[korc_collisions]] that !! sets subcycling iteration number for collisions based off of the collision !! frequency model used. ! *** *** *** *** *** ***   *** *** *** *** *** *** *** ! *** BEYOND THIS POINT VARIABLES ARE DIMENSIONLESS *** ! *** *** *** *** *** ***   *** *** *** *** *** *** *** call initialize_fields_interpolant ( params , F ) !! <h4>15\\. Initialize Fields Interpolant</h4> !! !! Subroutine [[initialize_fields_interpolant]] in [[korc_interp]] calls !! EZspline !! subroutines EZspline_init for memory allocation and boundary condition !! setup !! and EZspline_setup to compute the necessary cubic coefficients needed !! for subsequent !! field interpolations. The magnetic field can be defined in terms of an !! axisymmetric !! scalar flux function, axisymmetric field, or 3D field, while the !! electric field !! can be defined as an axisymmetric or 3D field. call initialize_profiles_interpolant ( params , P ) !! <h4>16\\. Initialize Profiles Interpolant</h4> !! !! Subroutine [[initialize_profiles_interpolant]] in [[korc_interp]] !! calls EZspline !! subroutines EZlinear_init for axisymmetric (flux-surface quantities) or !! EZspline_init for 3D profiles for memory allocation and boundary !! condition setup !! and EZspline_setup to compute the necessary cubic coefficients needed !! for subsequent !! field interpolations. !! Only initialized if collisions (params%collisions==T) are present for !! ne, Te, Zeff if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING INITIAL CONDITIONS * * * *\",/)' ) end if call set_up_particles_ic ( params , F , spp , P ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if !  write(output_unit_write,'(\"post ic eta: \",E17.10)') spp(1)%vars%eta !! <h4>17\\. Set Particle Initial Conditions</h4> !! !! Subroutine [[set_up_particles_ic]] in [[korc_initialize]] calls !! subroutines to prescribe initial conditions or load them !! from file for a restart. Initial spatial values are prescribed with !! [[intitial_spatial_distribution]] in [[korc_spatial_distribution]] and !! initial velocity values are prescribed with [[initial_gyro_distribution]] !! in [[korc_velocity_distribution]]. !  if (minval(spp(1)%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with init' ! * * * INITIALIZATION STAGE * * * !  write(output_unit_write,'(\"GC init eta: \",E17.10)') spp(1)%vars%eta if (. NOT .( params % restart . OR . params % proceed . or . params % reinit )) then if ( params % orbit_model ( 1 : 2 ). eq . 'FO' ) then call FO_init ( params , F , spp ,. true .,. false .) else if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then call GC_init ( params , F , spp ) end if if ( params % SC_E ) then if ( params % field_model ( 1 : 1 ). eq . 'A' ) then call init_SC_E1D ( params , F , spp ( 1 )) else if ( params % field_model ( 1 : 1 ). eq . 'E' ) then call init_SC_E1D_FS ( params , F , spp ( 1 )) end if end if else call get_fields ( params , spp ( 1 )% vars , F ) if ( params % SC_E ) then if ( params % field_model ( 1 : 1 ). eq . 'A' ) then call reinit_SC_E1D ( params , F ) else if ( params % field_model ( 1 : 1 ). eq . 'E' ) then call reinit_SC_E1D_FS ( params , F ) end if end if end if ! * * * SAVING INITIAL CONDITION AND VARIOUS SIMULATION PARAMETERS * * * ! call save_simulation_parameters ( params , spp , F , P ) call save_collision_params ( params ) !! <h4>18\\. Save Simulation and Collision Parameters</h4> !! !! Subroutines [[save_simulation_parameters]] in [[korc_HDF5]] and !! [[save_collision_params]] in [[korc_collisions]] call !! subroutines to save simulation and collision parameters. if (. NOT .( params % restart . OR . params % proceed )) then call save_simulation_outputs ( params , spp , F ) ! Save initial condition end if ! * * * SAVING INITIAL CONDITION AND VARIOUS SIMULATION PARAMETERS * * * ! !  write(output_unit_write,'(\"pre ppusher loop eta: \",E17.10)') spp(1)%vars%eta call timing_KORC ( params ) if ( params % orbit_model ( 1 : 2 ). eq . 'FO' . and . params % field_model ( 1 : 3 ). eq . 'ANA' ) then call FO_init ( params , F , spp ,. false .,. true .) ! Initial half-time particle push do it = params % ito , params % t_steps , params % t_skip call adv_FOeqn_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'FO' . and . params % field_model ( 1 : 3 ). eq . 'EXT' ) then call FO_init ( params , F , spp ,. false .,. true .) ! Initial half-time particle push do it = params % ito , params % t_steps , params % t_skip call adv_FOinterp_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'FO' . and . params % field_model . eq . 'M3D_C1' ) then call FO_init ( params , F , spp ,. false .,. true .) ! Initial half-time particle push do it = params % ito , params % t_steps , params % t_skip call adv_FOm3dc1_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'eqn' . and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip * params % t_it_SC call adv_GCeqn_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip * params % t_it_SC , rp ) * params % dt params % it = it - 1_ip + params % t_skip * params % t_it_SC call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and . params % field_model ( 10 : 12 ). eq . 'PSI' . and . & params % SC_E . and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psi_top_FS ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . 'PSI' . OR . & params % field_model ( 12 : 14 ). eq . 'PSI' ). and . & (. not . params % SC_E ). and .(. not . F % Dim2x1t ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psi_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . 'PSI' . OR . & params % field_model ( 12 : 14 ). eq . 'PSI' ). and . & (. not . params % SC_E ). and . F % Dim2x1t . and .(. not . F % ReInterp_2x1t ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psi2x1t_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . 'PSI' . OR . & params % field_model ( 12 : 14 ). eq . 'PSI' ). and . & (. not . params % SC_E ). and . F % Dim2x1t . and . F % ReInterp_2x1t . and .. not . params % field_model . eq . 'M3D_C1' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) 'time' , F % X % PHI ( F % ind_2x1t ) * params % cpp % time end if do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psiwE_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) F % ind_2x1t = F % ind_2x1t + 1_ip if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) 'time' , F % X % PHI ( F % ind_2x1t ) * params % cpp % time end if call initialize_fields_interpolant ( params , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and . F % dBfield . and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_2DBdB_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . '2DB' . or . & params % field_model ( 12 : 13 ). eq . '2D' ). and .. not .( F % dBfield ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_B2D_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & . not .( F % axisymmetric_fields ). and .( F % dBfield ). and . & ( params % field_model ( 10 : 14 ). eq . '3DBdB' ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_3DBdB_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & . not .( F % axisymmetric_fields ). and .( F % dBfield ). and . & . not .( params % field_model ( 10 : 14 ). eq . '3DBdB' ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_3DBdB1_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & . not .( F % axisymmetric_fields ). and .. not .( F % dBfield ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_B_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_m3dc1_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip * params % t_it_SC , rp ) * params % dt params % it = it - 1_ip + params % t_skip * params % t_it_SC call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if call timing_KORC ( params ) ! * * * FINALIZING SIMULATION * * * call finalize_HDF5 () call finalize_interpolants ( params ) ! DEALLOCATION OF VARIABLES call deallocate_variables ( params , F , spp ) call deallocate_collisions_params ( params ) call finalize_communications ( params ) ! * * * FINALIZING SIMULATION * * * if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"KORC ran successfully!\")' ) close ( output_unit_write ) end if end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"korc_constants.f90 – KORC-Full Orbit","text":"Contents Modules korc_constants Source Code korc_constants.f90 Source Code !> @brief Module containing physical and mathematical constants to be used in KORC. !! @details In this module we define the constant parameters to be used in KORC. Notice that the numerical precision of these quantities is '_rp', see korc_types.f90. !! Any new constant needs to be compliant with the numerical precision used in KORC. module korc_constants USE korc_types IMPLICIT NONE REAL ( rp ), PARAMETER :: C_PI = 4.0_rp * ATAN ( 1.0_rp ) !< Definition of @f$\\pi@f$ REAL ( rp ), PARAMETER :: C_E = 1.602176E-19_rp !< Absolute value of electron charge in Coulombs (C). REAL ( rp ), PARAMETER :: C_ME = 9.109382E-31_rp !< Electron mass in kg REAL ( rp ), PARAMETER :: C_MP = 1.672621E-27_rp !< Proton mass in kg REAL ( rp ), PARAMETER :: C_U = 1.660538E-27_rp !< Atomic mass unit in kg REAL ( rp ), PARAMETER :: C_KB = 1.380650E-23_rp !< Boltzmann constant in Joules/Kelvin REAL ( rp ), PARAMETER :: C_C = 29979245 8.0_rp !< Light speed in m/s REAL ( rp ), PARAMETER :: C_MU = 4.0_rp * C_PI * 1E-7_rp !< Vacuum permeability in N/A&#94;2 REAL ( rp ), PARAMETER :: C_E0 = 1.0_rp / ( C_MU * C_C ** 2 ) !< Vacuum permittivity in C&#94;2/(N*m&#94;2) REAL ( rp ), PARAMETER :: C_Ke = 1.0_rp / ( 4.0_rp * C_PI * C_E0 ) !< Coulomb constant in N*m&#94;2/C&#94;2 REAL ( rp ), PARAMETER :: C_RE = C_E ** 2 / ( 4.0_rp * C_PI * C_E0 * C_ME * C_C ** 2 ) !< Classical electron radius REAL ( rp ), PARAMETER :: C_h = 6.6261E-34_rp !< Planck constant in Joules*s REAL ( rp ), PARAMETER :: C_a = 1._rp / 13 7._rp !< Fine-structure constant end module korc_constants","tags":"","loc":"sourcefile/korc_constants.f90.html"},{"title":"main_documentation_page.f90 – KORC-Full Orbit","text":"Contents Source Code main_documentation_page.f90 Source Code !> @mainpage KORC documentation !! @author Leopoldo Carbajal @note KORC and its documentation are in !! constant evolution. This makes it possible that there are issues !! that need to be solved.  If you find an issue please report it !! immediatly through the \"issues\" section of the github repository. !! !! @section s1 Introduction The Kinetic Orbit Runaway electrons Code !! (KORC) is a full-orbit particle tracer that evolves relativistic !! electrons in both analytical and grid-based pre-computed electric !! and magnetic fields. KORC includes the effects of: the acceleration !! of the electrons due to the electric field, synchrotron radiation !! energy losses, and collisions with the background plasma containing !! high-Z impurities. !! !! For details about the equations of motion of the relativistic !! electrons followed by KOqRC we refer the user to <em>Carbajal et !! al. Phys. Plasmas <b>24</b>, 042512 (2017)</em> and <em>Carbajal !! and del-Castillo-Negrete, Nuclear Fusion, submitted !! (2018)</em>. Also, for details about the KORC's synchrotron !! radiation synthetic diagnostic we refer the user to <em>Carbajal !! and del-Castillo-Negrete, Plasma Phys. Controll. Fusion <b>59</b>, !! 124001 (2017)</em>. !! !! KORC is a modular Fortran 95 code that uses a hybrid MPI + open MP !! parallelization paradigm to exploit multi-core nodes systems, such !! as Cori and Edison NERSC systems (<a !! href=\"https://www.nersc.gov\">www.nersc.gov</a>). !! !! !! @section s2 Installation @warning KORC has been installed and !! tested in systems with OS 10.6 and higher, Ubuntu 14.04, and SuSe !! 12. Though we have paid special attention to portability when !! developing KORC, there is no guarantee that KORC can be compiled, !! ran, and is accurate in other systems not listed above. As a rule !! of thumb, we recommend to perform any convenient benchmark tests !! when compiling and running KORC in a new system, this to make sure !! that the external libraries and compilers do not modify the !! simulation results. !! !! @subsection s1s2 Getting started To compile and run KORC you will !! need the following: <ol> <li>The <a !! href=\"https://support.hdfgroup.org/downloads/index.html\">HDF5</a> !! library for I/O.</li> <li>The <a !! href=\"https://w3.pppl.gov/ntcc/PSPLINE/\">PSPLINES</a> library for !! interpolating the pre-computed electric and magnetic fields as well !! aqs the plasma profiles.</li> <li>The GNU compilers suite, or</li> !! <li>The INTEL compilers suite.</li> <li>The corresponding open MP !! library</li> <li>The MPI or open MPI library</li> <li><a !! href=\"https://git-scm.com/\"> Git, for obtaining the latest version !! of KORC. </a> </ol> !! !! The HDF5 and PSPLINES libraries need to be installed BEFORE !! compiling KORC, or if these are already present in the system, they !! need to be loaded to your environment and their installation paths !! need to be added to the Makefile accordingly. We refer the user to !! the documentation of HDF5 and PSPLINES for the specifics about !! their installation. !! !! If you are installing the HDF5 and PSPLINES libraries in your !! system, we recommend to perform a local installation. Then enter !! the absolute path of the folder containing the <em>\"lib\"</em> and !! <em>\"bin\"</em> folders of each library to the PSPLINE_INSTALL and !! HDF5_INSTALL variables of the Makefile. !! !! !! @note PSPLINES is known for having precision issues sometimes when !! compiled using the INTEL compilers suite in Linux systems.  Please, !! double-check that the interpolations are giving the correct !! numbers. !! !! @subsection s2s2 Cloning and compiling KORC To obtain the latest !! version of KORC you will need to clone the Github repository to the !! system where you want to run KORC.  This can be done as follows: !! <ol> <li> Make sure you have all the needed external libraries and !! compilers in place.  <li>Using the terminal of your system, !! <em>cd</em> to the directory where you want to save KORC.</li> !! <li>Type the following in the terminal <em>\"git !! https://github.com/ORNL-Fusion/KORC.git\"</em>. This will copy all !! the KORC files from the Github repository to your local system. !! <li><em>cd</em> to the KORC-FO folder.  <li>In the terminal type: !! <em>\"./compile.sh GNU\"</em> if you are using GNU compilers, or !! <em>\"./compile.sh INTEL\"</em> if you are using INTEL compilers. !! </ol> !! !! @section s3 Running KORC If you are running KORC in a system that !! uses a resource manager such as TORQUE or SLURM, you will need to !! request the number of nodes and cores per node that you will need, !! this along with any other resources such as wall time, memory per !! node, etc. Decide the number of MPI processes (nmpi) and the number !! of open MP threads per MPI process (nomp) that you will use in your !! simulation.  Then, on the terminal or in your batch file type the !! following: !! !! <em> mpirun -np nmpi -x OMP_NUM_THREADS=nomp ./bin/KORC !! \"full_path_to_input_file.korc\" \"full_path_to_the_outputs_folder\" !! </em> !! !! The above example assumes that you are using the open MPI wrapper !! mpirun to execute the binary <em>\"KORC\"</em> generated after !! compiling KORC. This wrapper can be replaced by any other wrapper !! that you might want to use. Notice that when using a different MPI !! wrapper the way to pass the number of MPI processes (nmpi) and the !! number of open MP threads per MPI (nomp) to KORC might vary. !! !! @section s4 Generating the KORC's input file. !! KORC uses...","tags":"","loc":"sourcefile/main_documentation_page.f90.html"},{"title":"korc_coords.f90 – KORC-Full Orbit","text":"Contents Modules korc_coords Source Code korc_coords.f90 Source Code module korc_coords !! @note Module containing subroutines to calculate the position of !! the simulated particles in toroidal and cylindrical coordinates. @endnote use korc_types use korc_constants IMPLICIT NONE PUBLIC :: cart_to_cyl ,& cart_to_cyl_p ,& cart_to_tor_check_if_confined ,& cart_to_tor_p ,& cyl_to_cart ,& cyl_check_if_confined ,& cyl_check_if_confined_p CONTAINS subroutine cart_to_cyl ( X , Xcyl ) !! @note  Subroutine that converts the position of simulated particles !! from Cartesian (x,y,z) to cylindrical (R,\\phi,Z) coordinates. !! @endnote !! Here, the coordinate transformation is: !! !! R = \\sqrt{x&#94;2 + y&#94;2}, !! \\phi = \\arctan{\\left( \\frac{y}{x} \\right)}, !! Z = z. implicit none REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: X !! Particles' position in Cartesian coordinates. X(1,:) = x, X(2,:) !! = y, X(3,:) = z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: Xcyl !! Particles' position in cylindrical coordinates. Xcyl(1,:) = R, !! Xcyl(2,:) = \\phi, Xcyl(3,:) = Z INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. !    write(output_unit_write,'(\"X_X: \",E17.10)') X(1:10,1) !    write(output_unit_write,'(\"X_Y: \",E17.10)') X(1:10,2) !    write(output_unit_write,'(\"X_Z: \",E17.10)') X(1:10,3) if ( X ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( X , 1 ) end if !    write(output_unit_write,*) 'varX',X(:,1) !    write(output_unit_write,*) 'varY',X(:,2) !    write(output_unit_write,*) 'varR',Xcyl(:,1) !    write(output_unit_write,*) 'varPHI',Xcyl(:,2) !    !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp) SHARED(X,Xcyl) do pp = 1_idef , ss !       write(output_unit_write,*) 'pp',pp Xcyl ( pp , 1 ) = SQRT ( X ( pp , 1 ) ** 2 + X ( pp , 2 ) ** 2 ) Xcyl ( pp , 2 ) = ATAN2 ( X ( pp , 2 ), X ( pp , 1 )) Xcyl ( pp , 2 ) = MODULO ( Xcyl ( pp , 2 ), 2.0_rp * C_PI ) Xcyl ( pp , 3 ) = X ( pp , 3 ) end do !    !$OMP END PARALLEL DO !    write(output_unit_write,*) 'varX',X(:,1) !    write(output_unit_write,*) 'varY',X(:,2) !    write(output_unit_write,*) 'varR',Xcyl(:,1) !    write(output_unit_write,*) 'varPHI',Xcyl(:,2) end subroutine cart_to_cyl subroutine cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) implicit none INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: X_X REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: X_Y REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: X_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Y_R REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Y_PHI REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Y_Z INTEGER :: pp !! Iterator. !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,X_X,X_Y,X_Z) do pp = 1_idef , pchunk Y_R ( pp ) = SQRT ( X_X ( pp ) * X_X ( pp ) + X_Y ( pp ) * X_Y ( pp )) Y_PHI ( pp ) = ATAN2 ( X_Y ( pp ), X_X ( pp )) Y_PHI ( pp ) = MODULO ( Y_PHI ( pp ), 2.0_rp * C_PI ) Y_Z ( pp ) = X_Z ( pp ) end do !$OMP END SIMD end subroutine cart_to_cyl_p subroutine cyl_to_cart ( Xcyl , X ) !! @note  Subroutine that converts the position of simulated particles !! from cylindrical (R,\\phi,Z) to Cartesian (x,y,z)\\ coordinates. !! @endnote !! Here, the coordinate transformation is: !! !! x=R\\cos(\\phi), !! y=R\\sin(\\phi),, !! Z = z. implicit none REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: X !! Particles' position in Cartesian coordinates. X(1,:) = x, X(2,:) !! = y, X(3,:) = z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Xcyl !! Particles' position in cylindrical coordinates. Xcyl(1,:) = R, !! Xcyl(2,:) = \\phi, Xcyl(3,:) = Z INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. if ( Xcyl ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Xcyl , 1 ) end if !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp) SHARED(X,Xcyl) do pp = 1_idef , ss X ( pp , 1 ) = Xcyl ( pp , 1 ) * cos ( Xcyl ( pp , 2 )) X ( pp , 2 ) = Xcyl ( pp , 1 ) * sin ( Xcyl ( pp , 2 )) X ( pp , 3 ) = Xcyl ( pp , 3 ) end do !$OMP END PARALLEL DO end subroutine cyl_to_cart subroutine cyl_check_if_confined ( F , Xcyl , flag ) implicit none TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Xcyl !! Particles' position in cylindrical coordinates. Xcyl(1,:) = R, !! Xcyl(2,:) = \\phi, Xcyl(3,:) = Z INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag REAL ( rp ) :: a !! Distance to plasma edge as measured from the magnetic axis. REAL ( rp ) :: Ro !! Radial position of the magnetic axis. INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. if ( Xcyl ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Xcyl , 1 ) end if a = F % AB % a Ro = F % AB % Ro !$OMP PARALLEL DO FIRSTPRIVATE(ss,a,Ro) PRIVATE(pp) SHARED(Xcyl,flag) do pp = 1_idef , ss if ( sqrt (( Xcyl ( pp , 1 ) - Ro ) ** 2 + Xcyl ( pp , 3 ) ** 2 ) . gt . a ) then flag ( pp ) = 0_is endif end do !$OMP END PARALLEL DO end subroutine cyl_check_if_confined subroutine cyl_check_if_confined_p ( pchunk , a , R0 , Xcyl_R , Xcyl_Z , flag ) implicit none INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Xcyl_R REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Xcyl_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag REAL ( rp ), INTENT ( IN ) :: a , R0 !! Distance to plasma edge as measured from the magnetic axis. INTEGER :: cc !$OMP SIMD !    !$OMP& aligned(Xcyl_R,Xcyl_Z,flag) do cc = 1_idef , pchunk if ( sqrt (( Xcyl_R ( cc ) - R0 ) ** 2 + Xcyl_Z ( cc ) ** 2 ) . gt . a ) flag ( cc ) = 0_is end do !$OMP END SIMD end subroutine cyl_check_if_confined_p subroutine cart_to_tor_check_if_confined ( X , F , Xtor , flag ) !! @note Subroutine that converts the position of simulated particles !! from Cartesian (x,y,z) to toroidal (r,\\theta, \\zeta) coordinates. !! In addition to performing the coordinate transformation, this !! subroutine checks whether a given particle is within the plasma or not. !! A particle is not longer considered to be within the plasma if its !! minor radius r > r_{edge}, where r_{edge} is the radial !! distance to the plasma edge as measured from the magnetic axis. For !! more details see the analytical model of the magnetic field in !! [[korc_types]] and [[korc_fields]]. !! !! The coordinate transformation is given by: !! !! r = \\sqrt{ \\left[\\sqrt{x&#94;2 + y&#94;2}-R_0\\right]&#94;2 + z&#94;2 }, !! \\theta = \\arctan{\\left( \\frac{z}{\\sqrt{x&#94;2 + y&#94;2}-Ro} \\right)}. !! \\zeta = \\arctan{\\left( \\frac{x}{y} \\right)}, !! !! where R_0 is the radial position of the magnetic axis. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: X !! Particles' position in Cartesian coordinates. X(1,:) = x, X(2,:) !! = y, X(3,:) = z TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: Xtor !! Particles' position in cylindrical coordinates. Xtor(1,:) = !! r, Xtor(2,:) = \\theta, Xtor(3,:) = \\zeta INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag REAL ( rp ) :: a !! Distance to plasma edge as measured from the magnetic axis. REAL ( rp ) :: Ro !! Radial position of the magnetic axis. INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. if ( X ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( X , 1 ) end if a = F % AB % a Ro = F % AB % Ro !    write(output_unit_write,'(\"X c2tor: \",E17.10)') X(1,:) !$OMP PARALLEL DO FIRSTPRIVATE(ss,a,Ro) PRIVATE(pp) SHARED(X,Xtor,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then Xtor ( pp , 1 ) = SQRT ( ( SQRT ( X ( pp , 1 ) ** 2 + X ( pp , 2 ) ** 2 ) - Ro ) ** 2 + & X ( pp , 3 ) ** 2 ) Xtor ( pp , 2 ) = ATAN2 ( X ( pp , 3 ), SQRT ( X ( pp , 1 ) ** 2 + X ( pp , 2 ) ** 2 ) - Ro ) Xtor ( pp , 2 ) = MODULO ( Xtor ( pp , 2 ), 2.0_rp * C_PI ) Xtor ( pp , 3 ) = ATAN2 ( X ( pp , 1 ), X ( pp , 2 )) Xtor ( pp , 3 ) = MODULO ( Xtor ( pp , 3 ), 2.0_rp * C_PI ) !          write(output_unit_write,'(\"r: \",E17.10)') Xtor(1,1) !          write(output_unit_write,'(\"a: \",E17.10)') a !          write(output_unit_write,'(\"Ro: \",E17.10)') Ro if ( Xtor ( pp , 1 ) . GT . F % AB % a ) then flag ( pp ) = 0_is !             stop 'error in dist init' end if end if end do !$OMP END PARALLEL DO end subroutine cart_to_tor_check_if_confined subroutine cart_to_tor_p ( pchunk , R0 , X_X , X_Y , X_Z , T_R , T_T , T_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: R0 REAL ( rp ), INTENT ( IN ), DIMENSION ( pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: T_R , T_T , T_Z REAL ( rp ), DIMENSION ( pchunk ) :: RR INTEGER :: cc !! Particle chunk iterator. !$OMP SIMD !    !$OMP& aligned(RR,X_X,X_Y,T_R,T_T,T_Z,X_Z) do cc = 1_idef , pchunk RR ( cc ) = SQRT ( X_X ( cc ) * X_X ( cc ) + X_Y ( cc ) * X_Y ( cc )) - R0 T_R ( cc ) = SQRT ( RR ( cc ) * RR ( cc ) + X_Z ( cc ) * X_Z ( cc ) ) T_T ( cc ) = ATAN2 ( X_Z ( cc ), RR ( cc )) T_T ( cc ) = MODULO ( T_T ( cc ), 2.0_rp * C_PI ) T_Z ( cc ) = ATAN2 ( X_X ( cc ), X_Y ( cc )) T_Z ( cc ) = MODULO ( T_Z ( cc ), 2.0_rp * C_PI ) end do !$OMP END SIMD end subroutine cart_to_tor_p subroutine cart_to_tor_check_if_confined_p ( pchunk , ar , R0 , X_X , X_Y , X_Z , & T_R , T_T , T_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: R0 , ar REAL ( rp ), INTENT ( IN ), DIMENSION ( pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: T_R , T_T , T_Z INTEGER ( is ), INTENT ( INOUT ), DIMENSION ( pchunk ) :: flag_cache REAL ( rp ), DIMENSION ( pchunk ) :: RR INTEGER :: cc !! Particle chunk iterator. !$OMP SIMD !    !$OMP& aligned(RR,X_X,X_Y,T_R,T_T,T_Z,X_Z) do cc = 1_idef , pchunk RR ( cc ) = SQRT ( X_X ( cc ) * X_X ( cc ) + X_Y ( cc ) * X_Y ( cc )) - R0 T_R ( cc ) = SQRT ( RR ( cc ) * RR ( cc ) + X_Z ( cc ) * X_Z ( cc ) ) T_T ( cc ) = ATAN2 ( X_Z ( cc ), RR ( cc )) T_T ( cc ) = MODULO ( T_T ( cc ), 2.0_rp * C_PI ) T_Z ( cc ) = ATAN2 ( X_X ( cc ), X_Y ( cc )) T_Z ( cc ) = MODULO ( T_Z ( cc ), 2.0_rp * C_PI ) end do !$OMP END SIMD !$OMP SIMD do cc = 1_idef , pchunk if ( T_R ( cc ) . GT . ar ) then flag_cache ( cc ) = 0_is end if end do !$OMP END SIMD end subroutine cart_to_tor_check_if_confined_p end module korc_coords","tags":"","loc":"sourcefile/korc_coords.f90.html"},{"title":"korc_rnd_numbers.f90 – KORC-Full Orbit","text":"Contents Modules korc_rnd_numbers Source Code korc_rnd_numbers.f90 Source Code module korc_rnd_numbers !! @note Module with subrotuines for generating integer !! and real random numbers.@endnote !! This subroutines were taken from Numerical Recipes in Fortran 90, !! and provide a way for generating random numbers of 'better quality' !! in a faster way than build-in Fortran random generators (at least !! better than those of Fortran 77). For more details we refer the user !! to Numerical Recipes in Fortran 90. #ifdef __INTEL_COMPILER use ifport #endif use korc_types IMPLICIT NONE ! Parameters and variables used in generator of uniform random numbers INTEGER ( 8 ), PARAMETER :: iv = 4101842887655102017 _ 8 INTEGER ( 8 ), PARAMETER :: iw = 1 _ 8 INTEGER ( 8 ), PARAMETER :: a = 4294957665 _ 8 INTEGER ( 8 ), PARAMETER :: b = 4294967295 _ 8 INTEGER ( 8 ), PARAMETER :: d = 2862933555777941757 _ 8 INTEGER ( 8 ), PARAMETER :: e = 7046029254386353087 _ 8 REAL ( rp ), PARAMETER :: rcoeff = 5.42101086242752217E-20_rp TYPE , PRIVATE :: URAND INTEGER ( 8 ) :: u INTEGER ( 8 ) :: v INTEGER ( 8 ) :: w END TYPE URAND TYPE ( URAND ), PRIVATE :: urand_vars ! Parameters and variables used in generator of uniform random numbers INTERFACE u_random module procedure rand_int64 , rand_int32 , rand_real , rand_real_array END INTERFACE u_random PUBLIC :: init_u_random , u_random PRIVATE :: rand_int64 , rand_int32 , rand_real CONTAINS subroutine init_u_random ( seed ) INTEGER ( 8 ), INTENT ( IN ) :: seed INTEGER ( 8 ) :: dummy_int64 urand_vars % u = seed ** urand_vars % v call rand_int64 () urand_vars % v = urand_vars % u call rand_int64 () urand_vars % w = urand_vars % v call rand_int64 () end subroutine init_u_random subroutine rand_int64 ( irand ) INTEGER ( 8 ), OPTIONAL , INTENT ( OUT ) :: irand INTEGER ( 8 ) :: x urand_vars % u = urand_vars % u * d + e !u=u* 2862933555777941757LL + 7046029254386353087LL; urand_vars % v = IEOR ( urand_vars % v , ISHFT ( urand_vars % v , - 17 )) ! v&#94;=v>>17; urand_vars % v = IEOR ( urand_vars % v , ISHFT ( urand_vars % v , 31 )) ! v&#94;=v<<31; urand_vars % v = IEOR ( urand_vars % v , ISHFT ( urand_vars % v , - 8 )) ! v&#94;=v>>8; urand_vars % w = a * IAND ( urand_vars % w , b ) + ISHFT ( urand_vars % w , - 32 ) ! w = 4294957665U*(w & 0xffffffff) + (w >> 32); x = IEOR ( urand_vars % u , ISHFT ( urand_vars % u , 21 )) ! Ullong x=u&#94;(u<< 21); x = IEOR ( x , ISHFT ( x , - 35 )) ! x &#94;= x >> 35; x = IEOR ( x , ISHFT ( x , 4 )) ! x &#94;= x << 4; if ( PRESENT ( irand )) then irand = IEOR ( x + urand_vars % v , urand_vars % w ) end if end subroutine rand_int64 subroutine rand_int32 ( irand32 ) INTEGER ( 4 ), INTENT ( OUT ) :: irand32 INTEGER ( 8 ) :: irand64 call rand_int64 ( irand64 ) irand32 = INT ( irand64 , 4 ) end subroutine rand_int32 subroutine rand_real_array ( rrand ) REAL ( rp ), DIMENSION (:), INTENT ( INOUT ) :: rrand INTEGER ( 8 ) :: irand64 INTEGER :: ii ! Iterator do ii = 1_idef , SIZE ( rrand ) call rand_int64 ( irand64 ) rrand ( ii ) = rcoeff * REAL ( irand64 , rp ) + 0.5_rp end do end subroutine rand_real_array subroutine rand_real ( rrand ) REAL ( rp ), INTENT ( OUT ) :: rrand INTEGER ( 8 ) :: irand64 call rand_int64 ( irand64 ) rrand = rcoeff * REAL ( irand64 , rp ) + 0.5_rp end subroutine rand_real subroutine init_random_seed () #ifdef PARALLEL_RANDOM use korc_random #endif INTEGER , allocatable :: seed (:) INTEGER ( 8 ), DIMENSION ( 8 ) :: dt INTEGER ( 8 ) :: i INTEGER ( 8 ) :: istat INTEGER ( 8 ) :: pid INTEGER ( 4 ) :: n INTEGER ( 8 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( default_unit_open , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then read ( default_unit_open ) seed close ( default_unit_open ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 _ 8 ) * 365 _ 8 * 24 _ 8 * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 2 ) * 31 _ 8 * 24 _ 8 * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 3 ) * 24 _ 8 * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 5 ) * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 6 ) * 60 _ 8 * 1000 _ 8 & + dt ( 7 ) * 1000 _ 8 & + dt ( 8 ) end if pid = getpid () write ( output_unit_write , '(\"PID: \",I15)' ) pid t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if #ifdef PARALLEL_RANDOM call initialize_random ( seed ( 1 )) call initialize_random_U ( seed ( 1 )) call initialize_random_N ( seed ( 1 )) !  call initialize_random_mkl(seed(1)) #else call random_seed ( put = seed ) #endif contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) INTEGER :: lcg INTEGER ( 8 ) :: s if ( s == 0 ) then s = 104729 _ 8 else s = mod ( s , 4294967296 _ 8 ) end if s = mod ( s * 279470273 _ 8 , 4294967291 _ 8 ) lcg = int ( mod ( s , int ( huge ( 0 ), 8 )), kind ( 0 )) end function lcg end subroutine init_random_seed end module korc_rnd_numbers","tags":"","loc":"sourcefile/korc_rnd_numbers.f90.html"},{"title":"korc_m3d_c1_interface.f90 – KORC-Full Orbit","text":"@file korc_m3d_c1_interface.f90\n  @brief Interface for the m3d_c1 interpolation library. Contents Modules korc_m3d_c1 Source Code korc_m3d_c1_interface.f90 Source Code #ifdef M3D_C1 !******************************************************************************* !  @file korc_m3d_c1_interface.f90 !  @brief Interface for the m3d_c1 interpolation library. !******************************************************************************* MODULE korc_m3d_c1 USE , INTRINSIC :: iso_c_binding USE korc_types USE korc_input IMPLICIT NONE INTEGER ( C_INT ), PARAMETER :: FIO_SUCCESS = 0 INTEGER ( C_INT ), PARAMETER :: FIO_OUT_OF_BOUNDS = 10002 INTEGER ( C_INT ), PARAMETER :: FIO_NO_DATA = 10006 INTEGER ( C_INT ), PARAMETER :: FIO_M3DC1_SOURCE = 3 INTEGER ( C_INT ), PARAMETER :: FIO_TIMESLICE = 1 INTEGER ( C_INT ), PARAMETER :: FIO_SPECIES = 3 INTEGER ( C_INT ), PARAMETER :: FIO_ELECTRON = 1 INTEGER ( C_INT ), PARAMETER :: FIO_DENSITY = 102 INTEGER ( C_INT ), PARAMETER :: FIO_TEMPERATURE = 103 INTEGER ( C_INT ), PARAMETER :: FIO_ELECTRIC_FIELD = 1001 INTEGER ( C_INT ), PARAMETER :: FIO_MAGNETIC_FIELD = 1003 INTEGER ( C_INT ), PARAMETER :: FIO_VECTOR_POTENTIAL = 1002 INTERFACE INTEGER ( C_INT ) FUNCTION fio_add_field ( icfield , ifield , op , fac ) & BIND ( C , NAME = 'fio_add_field' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: icfield INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: ifield INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: op REAL ( C_DOUBLE ), VALUE , INTENT ( IN ) :: fac END FUNCTION fio_add_field END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_allocate_search_hint ( isrc , hint ) & BIND ( C , NAME = 'fio_allocate_search_hint' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: isrc TYPE ( C_PTR ), INTENT ( OUT ) :: hint END FUNCTION fio_allocate_search_hint END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_close_field ( ifield ) & BIND ( C , NAME = 'fio_close_field' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: ifield END FUNCTION fio_close_field END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_close_series ( iseries ) & BIND ( C , NAME = 'fio_close_series' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: iseries END FUNCTION fio_close_series END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_close_source ( isrc ) & BIND ( C , NAME = 'fio_close_source' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: isrc END FUNCTION fio_close_source END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_create_compound_field ( ifield ) & BIND ( C , NAME = 'fio_create_compound_field' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), INTENT ( IN ) :: ifield END FUNCTION fio_create_compound_field END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_deallocate_search_hint ( isrc , hint ) & BIND ( C , NAME = 'fio_deallocate_search_hint' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: isrc TYPE ( C_PTR ), INTENT ( INOUT ) :: hint END FUNCTION fio_deallocate_search_hint END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_eval_field ( ifield , x , v , hint ) & BIND ( C , NAME = 'fio_eval_field' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: ifield REAL ( C_DOUBLE ), INTENT ( IN ) :: x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v TYPE ( C_PTR ), VALUE , INTENT ( IN ) :: hint END FUNCTION fio_eval_field END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_eval_field_deriv ( ifield , x , v , hint ) & BIND ( C , NAME = 'fio_eval_field_deriv' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: ifield REAL ( C_DOUBLE ), INTENT ( IN ) :: x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v TYPE ( C_PTR ), VALUE , INTENT ( IN ) :: hint END FUNCTION fio_eval_field_deriv END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_eval_series ( iseries , x , v ) & BIND ( C , NAME = 'fio_eval_series' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: iseries REAL ( C_DOUBLE ), INTENT ( IN ) :: x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v END FUNCTION fio_eval_series END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_get_options ( isrc ) & BIND ( C , NAME = 'fio_get_options' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: isrc END FUNCTION fio_get_options END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_get_available_fields ( isrc , n , f ) & BIND ( C , NAME = 'fio_get_available_fields' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: isrc INTEGER ( C_INT ), INTENT ( OUT ) :: n INTEGER ( C_INT ), DIMENSION (:), INTENT ( OUT ) :: f END FUNCTION fio_get_available_fields END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_open_source ( itype , filename , handle ) & BIND ( C , NAME = 'fio_open_source' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: itype CHARACTER ( kind = C_CHAR , len = 1 ), INTENT ( IN ) :: filename INTEGER ( C_INT ), INTENT ( OUT ) :: handle END FUNCTION fio_open_source END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_get_field ( isrc , type , handle ) & BIND ( C , NAME = 'fio_get_field' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( in ) :: isrc INTEGER ( C_INT ), VALUE , INTENT ( IN ) :: type INTEGER ( C_INT ), INTENT ( INOUT ) :: handle END FUNCTION fio_get_field END INTERFACE INTERFACE INTEGER ( C_INT ) FUNCTION fio_set_int_option ( iopt , v ) & BIND ( C , NAME = 'fio_set_int_option' ) USE , INTRINSIC :: iso_c_binding IMPLICIT NONE INTEGER ( C_INT ), VALUE , INTENT ( in ) :: iopt INTEGER ( C_INT ), VALUE , INTENT ( in ) :: v END FUNCTION fio_set_int_option END INTERFACE CONTAINS SUBROUTINE initialize_m3d_c1 ( params , F , P , spp ) IMPLICIT NONE TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( PROFILES ), INTENT ( INOUT ) :: P TYPE ( SPECIES ), DIMENSION (:), INTENT ( INOUT ) :: spp INTEGER :: ii INTEGER :: pp INTEGER :: status INTEGER :: isrc !LOGICAL                        :: Efield !LOGICAL                        :: Bfield !LOGICAL                        :: Bflux,Bflux3D,dBfield !LOGICAL                        :: axisymmetric_fields !LOGICAL                        :: Dim2x1t,E_2x1t,ReInterp_2x1t !integer :: res_double !integer :: dim_1D,ind0_2x1t !real(rp) :: dt_E_SC,Ip_exp,PSIp_lim,PSIp_0 !real(rp) :: t0_2x1t,Eo,E_dyn,E_pulse,E_width !NAMELIST /externalPlasmaModel/ Efield, Bfield, Bflux,Bflux3D,dBfield, & !     axisymmetric_fields,Eo,E_dyn,E_pulse,E_width,res_double, & !     dim_1D,dt_E_SC,Ip_exp,PSIp_lim,Dim2x1t,t0_2x1t,E_2x1t,ReInterp_2x1t, & !     ind0_2x1t,PSIp_0 !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=externalPlasmaModel) !close(default_unit_open) F % Efield = Efield F % PSIp_lim = PSIp_lim F % PSIp_0 = PSIp_0 status = fio_open_source ( FIO_M3DC1_SOURCE , & TRIM ( params % magnetic_field_filename ) & & // C_NULL_CHAR , isrc ) status = fio_get_options ( isrc ) status = fio_set_int_option ( FIO_TIMESLICE , params % time_slice ) status = fio_get_field ( isrc , FIO_MAGNETIC_FIELD , F % M3D_C1_B ) status = fio_get_field ( isrc , FIO_ELECTRIC_FIELD , F % M3D_C1_E ) status = fio_get_field ( isrc , FIO_VECTOR_POTENTIAL , F % M3D_C1_A ) if (. not . F % Efield ) F % M3D_C1_E =- 1 status = fio_set_int_option ( FIO_SPECIES , FIO_ELECTRON ); status = fio_get_field ( isrc , FIO_DENSITY , P % M3D_C1_ne ); status = fio_get_field ( isrc , FIO_TEMPERATURE , P % M3D_C1_te ); !  Hardcode Bo to one for now until a better method of determining the a !  characteristic magnetic field value. F % Bo = 1.0 F % Eo = 1.0 F % Ro = 1.0 F % Zo = 1.0 do ii = 1 , params % num_species do pp = 1 , spp ( ii )% ppp status = fio_allocate_search_hint ( isrc , spp ( ii )% vars % hint ( pp )) !spp(ii)%vars%hint(pp)=c_null_ptr end do spp ( ii )% vars % cart = . false . end do if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) 'Calculate B' , F % M3D_C1_B write ( output_unit_write , * ) 'Calculate E' , F % M3D_C1_E write ( output_unit_write , * ) 'Calculate A' , F % M3D_C1_A write ( output_unit_write , * ) 'Calculate n' , P % M3D_C1_ne write ( output_unit_write , * ) 'Calculate T' , P % M3D_C1_te end if END SUBROUTINE initialize_m3d_c1 END MODULE korc_m3d_c1 #endif","tags":"","loc":"sourcefile/korc_m3d_c1_interface.f90.html"},{"title":"PARAMS – KORC-Full Orbit ","text":"type, private :: PARAMS Contents Variables E Zeff max_pitch_angle min_pitch_angle po Bo lambda Source Code PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: E real(kind=rp), public :: Zeff real(kind=rp), public :: max_pitch_angle real(kind=rp), public :: min_pitch_angle real(kind=rp), public :: po real(kind=rp), public :: Bo real(kind=rp), public :: lambda Source Code TYPE , PRIVATE :: PARAMS REAL ( rp ) :: E ! Parallel electric field normalized using the critical electric field REAL ( rp ) :: Zeff ! Effective atomic number of impurities REAL ( rp ) :: max_pitch_angle ! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle ! Minimum pitch angle of sampled PDF in degrees REAL ( rp ) :: po ! Momentum of sampled PDF in units of mc REAL ( rp ) :: Bo REAL ( rp ) :: lambda END TYPE PARAMS","tags":"","loc":"type/params~2.html"},{"title":"PARAMS_MS – KORC-Full Orbit ","text":"type, private :: PARAMS_MS Contents Variables num_impurity_species Te ne nH nef neb Zi Zo Zj nz IZj aZj Ee_IZj rD re aNe aAr INe IAr Source Code PARAMS_MS Components Type Visibility Attributes Name Initial integer, public :: num_impurity_species real(kind=rp), public :: Te real(kind=rp), public :: ne real(kind=rp), public :: nH real(kind=rp), public :: nef real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: neb real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zi real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zo real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zj real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: nz real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: IZj real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: aZj real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Ee_IZj real(kind=rp), public :: rD real(kind=rp), public :: re real(kind=rp), public, DIMENSION(11) :: aNe = (/111._rp, 100._rp, 90._rp, 80._rp, 71._rp, 62._rp, 52._rp, 40._rp, 24._rp, 23._rp, 0._rp/) real(kind=rp), public, DIMENSION(19) :: aAr = (/96._rp, 90._rp, 84._rp, 78._rp, 72._rp, 65._rp, 59._rp, 53._rp, 47._rp, 44._rp, 41._rp, 38._rp, 25._rp, 32._rp, 27._rp, 21._rp, 13._rp, 13._rp, 0._rp/) real(kind=rp), public, DIMENSION(11) :: INe = (/137.2_rp, 165.2_rp, 196.9_rp, 235.2_rp, 282.8_rp, 352.6_rp, 475.0_rp, 696.8_rp, 1409.2_rp, 1498.4_rp, huge(1._rp)/) real(kind=rp), public, DIMENSION(19) :: IAr = (/188.5_rp, 219.4_rp, 253.8_rp, 293.4_rp, 339.1_rp, 394.5_rp, 463.4_rp, 568.0_rp, 728.0_rp, 795.9_rp, 879.8_rp, 989.9_rp, 1138.1_rp, 1369.5_rp, 1791.2_rp, 2497.0_rp, 4677.2_rp, 4838.2_rp, huge(1._rp)/) Source Code TYPE , PRIVATE :: PARAMS_MS INTEGER :: num_impurity_species REAL ( rp ) :: Te ! Background electron temperature in eV REAL ( rp ) :: ne ! Background electron density in 1/m&#94;3 REAL ( rp ) :: nH ! Background proton density in 1/m&#94;3 REAL ( rp ) :: nef ! Free electron density in 1/m&#94;3 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: neb ! Bound electron density in 1/m&#94;3 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zi ! Atomic number of (majority) background ions REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zo ! Full nuclear charge of each impurity: Z=1 for D, Z=10 for Ne REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zj ! Atomic number of each impurity: Z=1 for D, Z=10 for Ne REAL ( rp ), DIMENSION (:), ALLOCATABLE :: nz ! Impurity densities REAL ( rp ), DIMENSION (:), ALLOCATABLE :: IZj , aZj ! Ionization energy of impurity in eV REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Ee_IZj ! me*c&#94;2/IZj dimensionless parameter REAL ( rp ) :: rD ! Debye length REAL ( rp ) :: re ! Classical electron radius REAL ( rp ), DIMENSION ( 11 ) :: aNe = ( / 11 1._rp , 10 0._rp , 9 0._rp , 8 0._rp , & 7 1._rp , 6 2._rp , 5 2._rp , 4 0._rp , 2 4._rp , 2 3._rp , 0._rp / ) REAL ( rp ), DIMENSION ( 19 ) :: aAr = ( / 9 6._rp , 9 0._rp , 8 4._rp , 7 8._rp , 7 2._rp , & 6 5._rp , 5 9._rp , 5 3._rp , 4 7._rp , 4 4._rp , 4 1._rp , 3 8._rp , 2 5._rp , 3 2._rp , & 2 7._rp , 2 1._rp , 1 3._rp , 1 3._rp , 0._rp / ) REAL ( rp ), DIMENSION ( 11 ) :: INe = ( / 13 7.2_rp , 16 5.2_rp , 19 6.9_rp , 23 5.2_rp , & 28 2.8_rp , 35 2.6_rp , 47 5.0_rp , 69 6.8_rp , 140 9.2_rp , 149 8.4_rp , huge ( 1._rp ) / ) REAL ( rp ), DIMENSION ( 19 ) :: IAr = ( / 18 8.5_rp , 21 9.4_rp , 25 3.8_rp , 29 3.4_rp , & 33 9.1_rp , 39 4.5_rp , 46 3.4_rp , 56 8.0_rp , 72 8.0_rp , 79 5.9_rp , 87 9.8_rp , & 98 9.9_rp , 113 8.1_rp , 136 9.5_rp , 179 1.2_rp , 249 7.0_rp , 467 7.2_rp , & 483 8.2_rp , huge ( 1._rp ) / ) END TYPE PARAMS_MS","tags":"","loc":"type/params_ms.html"},{"title":"PARAMS_SS – KORC-Full Orbit ","text":"type, private :: PARAMS_SS Contents Variables Te Ti ne Zeff rD re CoulombLogee CoulombLogei CLog1 CLog2 CLog0_1 CLog0_2 VTe VTeo delta deltao Gammac Gammaco Tau Tauc taur Ec ED dTau subcycling_iterations x y z P rnd_num rnd_num_count rnd_dim Source Code PARAMS_SS Components Type Visibility Attributes Name Initial real(kind=rp), public :: Te real(kind=rp), public :: Ti real(kind=rp), public :: ne real(kind=rp), public :: Zeff real(kind=rp), public :: rD real(kind=rp), public :: re real(kind=rp), public :: CoulombLogee real(kind=rp), public :: CoulombLogei real(kind=rp), public :: CLog1 real(kind=rp), public :: CLog2 real(kind=rp), public :: CLog0_1 real(kind=rp), public :: CLog0_2 real(kind=rp), public :: VTe real(kind=rp), public :: VTeo real(kind=rp), public :: delta real(kind=rp), public :: deltao real(kind=rp), public :: Gammac real(kind=rp), public :: Gammaco real(kind=rp), public :: Tau real(kind=rp), public :: Tauc real(kind=rp), public :: taur real(kind=rp), public :: Ec real(kind=rp), public :: ED real(kind=rp), public :: dTau integer(kind=ip), public :: subcycling_iterations real(kind=rp), public, DIMENSION(3) :: x = (/1.0_rp, 0.0_rp, 0.0_rp/) real(kind=rp), public, DIMENSION(3) :: y = (/0.0_rp, 1.0_rp, 0.0_rp/) real(kind=rp), public, DIMENSION(3) :: z = (/0.0_rp, 0.0_rp, 1.0_rp/) type(PROFILES), public :: P real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: rnd_num integer, public :: rnd_num_count integer, public :: rnd_dim = 40000000_idef Source Code TYPE , PRIVATE :: PARAMS_SS REAL ( rp ) :: Te ! Electron temperature REAL ( rp ) :: Ti ! Ion temperature REAL ( rp ) :: ne ! Background electron density REAL ( rp ) :: Zeff ! Effective atomic number of ions REAL ( rp ) :: rD ! Debye radius REAL ( rp ) :: re ! Classical electron radius REAL ( rp ) :: CoulombLogee , CoulombLogei ! Coulomb logarithm REAL ( rp ) :: CLog1 , CLog2 , CLog0_1 , CLog0_2 REAL ( rp ) :: VTe ! Thermal velocity of background electrons REAL ( rp ) :: VTeo REAL ( rp ) :: delta ! delta parameter REAL ( rp ) :: deltao REAL ( rp ) :: Gammac ! Collisional Gamma factor REAL ( rp ) :: Gammaco ! Collisional gamma factor normalized for SDE for dp REAL ( rp ) :: Tau ! Collisional time of relativistic particles REAL ( rp ) :: Tauc ! Collisional time of thermal particles REAL ( rp ) :: taur ! radiation timescale REAL ( rp ) :: Ec ! Critical electric field REAL ( rp ) :: ED ! Dreicer electric field REAL ( rp ) :: dTau ! Subcycling time step in collisional time units (Tau) INTEGER ( ip ) :: subcycling_iterations REAL ( rp ), DIMENSION ( 3 ) :: x = ( / 1.0_rp , 0.0_rp , 0.0_rp / ) REAL ( rp ), DIMENSION ( 3 ) :: y = ( / 0.0_rp , 1.0_rp , 0.0_rp / ) REAL ( rp ), DIMENSION ( 3 ) :: z = ( / 0.0_rp , 0.0_rp , 1.0_rp / ) TYPE ( PROFILES ) :: P REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: rnd_num INTEGER :: rnd_num_count INTEGER :: rnd_dim = 40000000_idef END TYPE PARAMS_SS","tags":"","loc":"type/params_ss.html"},{"title":"sprs2_sp – KORC-Full Orbit ","text":"type, public :: sprs2_sp Contents Variables n len val irow jcol Source Code sprs2_sp Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: n integer(kind=I4B), public :: len real(kind=SP), public, DIMENSION(:), POINTER :: val integer(kind=I4B), public, DIMENSION(:), POINTER :: irow integer(kind=I4B), public, DIMENSION(:), POINTER :: jcol Source Code TYPE sprs2_sp INTEGER ( I4B ) :: n , len REAL ( SP ), DIMENSION (:), POINTER :: val INTEGER ( I4B ), DIMENSION (:), POINTER :: irow INTEGER ( I4B ), DIMENSION (:), POINTER :: jcol END TYPE sprs2_sp","tags":"","loc":"type/sprs2_sp.html"},{"title":"sprs2_dp – KORC-Full Orbit ","text":"type, public :: sprs2_dp Contents Variables n len val irow jcol Source Code sprs2_dp Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: n integer(kind=I4B), public :: len real(kind=DP), public, DIMENSION(:), POINTER :: val integer(kind=I4B), public, DIMENSION(:), POINTER :: irow integer(kind=I4B), public, DIMENSION(:), POINTER :: jcol Source Code TYPE sprs2_dp INTEGER ( I4B ) :: n , len REAL ( DP ), DIMENSION (:), POINTER :: val INTEGER ( I4B ), DIMENSION (:), POINTER :: irow INTEGER ( I4B ), DIMENSION (:), POINTER :: jcol END TYPE sprs2_dp","tags":"","loc":"type/sprs2_dp.html"},{"title":"GAMMA_PARAMS – KORC-Full Orbit ","text":"type, private :: GAMMA_PARAMS @brief KORC derived type that contains information about a given Gamma distribution function @f$f_\\Gamma(x,\\kappa,\\theta)@f$.\n @details We write a given Gamma distribution function in terms of its shape factor @f$\\kappa@f$ and scale factor\n @f$\\theta@f$, so that: @f$f_\\Gamma(x,\\kappa,\\theta) = \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. Contents Variables min_energy max_energy min_p max_p k t Source Code GAMMA_PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: min_energy real(kind=rp), public :: max_energy real(kind=rp), public :: min_p real(kind=rp), public :: max_p real(kind=rp), public :: k real(kind=rp), public :: t Source Code TYPE , PRIVATE :: GAMMA_PARAMS REAL ( rp ) :: min_energy !< Minimum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV. REAL ( rp ) :: max_energy !< Maximum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV. REAL ( rp ) :: min_p !< Minimum momentum of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$. REAL ( rp ) :: max_p !< Maximum momentum of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$. REAL ( rp ) :: k !< Shape factor @f$\\kappa@f$. REAL ( rp ) :: t !< Scale factor @f$\\theta@f$. END TYPE GAMMA_PARAMS","tags":"","loc":"type/gamma_params.html"},{"title":"KORC_3D_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_3D_FIELDS_INTERPOLANT Note Derived type containing 3-D PSPLINE interpolants for \n cylindrical components of vector fields . Real precision of 8 bytes. Contents Variables A R PHI Z NR NPHI NZ BCSR BCSPHI BCSZ Source Code KORC_3D_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline3_r8), public :: A Interpolant of a scalar field . type(EZspline3_r8), public :: R Interpolant of . type(EZspline3_r8), public :: PHI Interpolant of . type(EZspline3_r8), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. Source Code TYPE , PRIVATE :: KORC_3D_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for !! cylindrical components of vector fields !! \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + F_\\phi\\hat{e}_phi + !! F_Z\\hat{e}_Z. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline3_r8 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: PHI !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both !! ends of the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_3D_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_3d_fields_interpolant.html"},{"title":"KORC_2X1T_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_2X1T_FIELDS_INTERPOLANT Note Derived type containing 3-D PSPLINE interpolants for \n cylindrical components of vector fields . Real precision of 8 bytes. Contents Variables A R T Z NR NT NZ BCSR BCST BCSZ Source Code KORC_2X1T_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline3_r8), public :: A Interpolant of a scalar field . type(EZspline3_r8), public :: R Interpolant of . type(EZspline3_r8), public :: T Interpolant of . type(EZspline3_r8), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NT Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCST = (/0, 0/) Periodic boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. Source Code TYPE , PRIVATE :: KORC_2X1T_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for !! cylindrical components of vector fields !! \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + F_\\phi\\hat{e}_phi + !! F_Z\\hat{e}_Z. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline3_r8 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: T !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NT !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCST = ( / 0 , 0 / ) !! Periodic boundary condition for the interpolants at both !! ends of the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2X1T_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_2x1t_fields_interpolant.html"},{"title":"KORC_2D_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_2D_FIELDS_INTERPOLANT Note Derived type containing 2-D PSPLINE interpolants for\n cylindrical components of vector fields .\n Real precision of 8 bytes. Contents Variables A R PHI Z NR NZ BCSR BCSZ Source Code KORC_2D_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline2_r8), public :: A Interpolant of a scalar field . type(EZspline2_r8), public :: R Interpolant of . type(EZspline2_r8), public :: PHI Interpolant of . type(EZspline2_r8), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. Source Code TYPE , PRIVATE :: KORC_2D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline2_r8 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline2_r8 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline2_r8 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2D_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_2d_fields_interpolant.html"},{"title":"KORC_1D_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_1D_FIELDS_INTERPOLANT Note Derived type containing 2-D PSPLINE interpolants for\n cylindrical components of vector fields .\n Real precision of 8 bytes. Contents Variables A R PHI Z Nrm BCSrm NPSIP BCSPSIP Source Code KORC_1D_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline1_r8), public :: A Interpolant of a scalar field . type(EZspline1_r8), public :: R Interpolant of . type(EZspline1_r8), public :: PHI Interpolant of . type(EZspline1_r8), public :: Z Interpolant of . integer, public :: Nrm Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSrm = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. integer, public :: NPSIP Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSPSIP = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. Source Code TYPE , PRIVATE :: KORC_1D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline1_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline1_r8 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline1_r8 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline1_r8 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: Nrm !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSrm = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER :: NPSIP !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSPSIP = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. END TYPE KORC_1D_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_1d_fields_interpolant.html"},{"title":"KORC_3D_PROFILES_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_3D_PROFILES_INTERPOLANT Note Derived type containing 3-D PSPLINE interpolants for cylindrical\n components of the density ,\n temperature , and effective charge number profiles. Real precision of 8 bytes. Contents Variables ne Te Zeff NR NPHI NZ BCSR BCSPHI BCSZ Source Code KORC_3D_PROFILES_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline3_r8), public :: ne Interpolant of background electron density . type(EZspline3_r8), public :: Te Interpolant of background electron temperature . type(EZspline3_r8), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. Source Code TYPE , PRIVATE :: KORC_3D_PROFILES_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,\\phi,Z), !! temperature T_e(R,\\phi,Z), and effective charge number !! Z_{eff}(R,\\phi,Z) profiles. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: ne !! Interpolant of background electron density n_e(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Te !! Interpolant of background electron temperature T_e(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both ends of !! the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the Z direction. END TYPE KORC_3D_PROFILES_INTERPOLANT","tags":"","loc":"type/korc_3d_profiles_interpolant.html"},{"title":"KORC_2D_PROFILES_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_2D_PROFILES_INTERPOLANT Note Derived type containing 2-D PSPLINE interpolants for cylindrical\n components of the density , temperature , and\n effective charge number profiles.\n Real precision of 8 bytes. Contents Variables ne Te Zeff NR NZ BCSR BCSZ Source Code KORC_2D_PROFILES_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline2_r8), public :: ne Interpolant of background electron density . type(EZspline2_r8), public :: Te Interpolant of background electron temperature . type(EZspline2_r8), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. Source Code TYPE , PRIVATE :: KORC_2D_PROFILES_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,Z), temperature T_e(R,Z), and !! effective charge number Z_{eff}(R,Z) profiles. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r8 ) :: ne !! Interpolant of background electron density n_e(R,Z). TYPE ( EZspline2_r8 ) :: Te !! Interpolant of background electron temperature T_e(R,Z). TYPE ( EZspline2_r8 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2D_PROFILES_INTERPOLANT","tags":"","loc":"type/korc_2d_profiles_interpolant.html"},{"title":"KORC_3D_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_3D_FIELDS_INTERPOLANT Note Derived type containing 3-D PSPLINE interpolants for cylindrical\n components of vector fields .\n Real precision of 4 bytes. Contents Variables R PHI Z NR NPHI NZ BCSR BCSPHI BCSZ Source Code KORC_3D_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline3_r4), public :: R Interpolant of . type(EZspline3_r4), public :: PHI Interpolant of . type(EZspline3_r4), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends of\n the direction. Source Code TYPE , PRIVATE :: KORC_3D_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for !! cylindrical components of vector fields !! \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + F_\\phi\\hat{e}_phi + !! F_Z\\hat{e}_Z. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline3_r8 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: PHI !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both !! ends of the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_3D_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_3d_fields_interpolant~2.html"},{"title":"KORC_2X1T_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_2X1T_FIELDS_INTERPOLANT Note Derived type containing 3-D PSPLINE interpolants for cylindrical\n components of vector fields .\n Real precision of 4 bytes. Contents Variables R T Z NR NT NZ BCSR BCST BCSZ Source Code KORC_2X1T_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline3_r4), public :: R Interpolant of . type(EZspline3_r4), public :: T Interpolant of . type(EZspline3_r4), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NT Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCST = (/0, 0/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends of\n the direction. Source Code TYPE , PRIVATE :: KORC_2X1T_FIELDS_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for !! cylindrical components of vector fields !! \\mathbf{F}(R,\\phi,Z) = F_R\\hat{e}_R + F_\\phi\\hat{e}_phi + !! F_Z\\hat{e}_Z. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline3_r8 ) :: R !! Interpolant of F_R(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: T !! Interpolant of F_\\phi(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Z !! Interpolant of F_Z(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NT !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCST = ( / 0 , 0 / ) !! Periodic boundary condition for the interpolants at both !! ends of the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2X1T_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_2x1t_fields_interpolant~2.html"},{"title":"KORC_2D_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_2D_FIELDS_INTERPOLANT Note Derived type containing 2-D PSPLINE interpolants for cylindrical\n components of vector fields .\n Real precision of 4 bytes. Contents Variables A R PHI Z NR NZ BCSR BCSZ Source Code KORC_2D_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline2_r4), public :: A Interpolant of a scalar field . type(EZspline2_r4), public :: R Interpolant of . type(EZspline2_r4), public :: PHI Interpolant of . type(EZspline2_r4), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. Source Code TYPE , PRIVATE :: KORC_2D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline2_r8 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline2_r8 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline2_r8 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2D_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_2d_fields_interpolant~2.html"},{"title":"KORC_1D_FIELDS_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_1D_FIELDS_INTERPOLANT Note Derived type containing 2-D PSPLINE interpolants for\n cylindrical components of vector fields .\n Real precision of 8 bytes. Contents Variables A R PHI Z Nrm BCSrm Source Code KORC_1D_FIELDS_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline1_r4), public :: A Interpolant of a scalar field . type(EZspline1_r4), public :: R Interpolant of . type(EZspline1_r4), public :: PHI Interpolant of . type(EZspline1_r4), public :: Z Interpolant of . integer, public :: Nrm Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSrm = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. Source Code TYPE , PRIVATE :: KORC_1D_FIELDS_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for !! cylindrical components of vector fields \\mathbf{F}(R,Z) = !! F_R\\hat{e}_R + F_\\phi\\hat{e}_phi+ F_Z\\hat{e}_Z. !! Real precision of 8 bytes. @endnote TYPE ( EZspline1_r8 ) :: A !! Interpolant of a scalar field A(R,Z). TYPE ( EZspline1_r8 ) :: R !! Interpolant of F_R(R,Z). TYPE ( EZspline1_r8 ) :: PHI !! Interpolant of F_\\phi(R,Z). TYPE ( EZspline1_r8 ) :: Z !! Interpolant of F_Z(R,Z). INTEGER :: Nrm !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSrm = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER :: NPSIP !! Size of mesh containing the field data along the R-axis. INTEGER , DIMENSION ( 2 ) :: BCSPSIP = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. END TYPE KORC_1D_FIELDS_INTERPOLANT","tags":"","loc":"type/korc_1d_fields_interpolant~2.html"},{"title":"KORC_3D_PROFILES_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_3D_PROFILES_INTERPOLANT Note Derived type containing 3-D PSPLINE interpolants for cylindrical\n components of the density ,\n temperature , and effective charge number profiles.\n Real precision of 4 bytes. Contents Variables ne Te Zeff NR NPHI NZ BCSR BCSPHI BCSZ Source Code KORC_3D_PROFILES_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline3_r4), public :: ne Interpolant of background electron density . type(EZspline3_r4), public :: Te Interpolant of background electron temperature . type(EZspline3_r4), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. Source Code TYPE , PRIVATE :: KORC_3D_PROFILES_INTERPOLANT !! @note Derived type containing 3-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,\\phi,Z), !! temperature T_e(R,\\phi,Z), and effective charge number !! Z_{eff}(R,\\phi,Z) profiles. Real precision of 8 bytes. @endnote TYPE ( EZspline3_r8 ) :: ne !! Interpolant of background electron density n_e(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Te !! Interpolant of background electron temperature T_e(R,\\phi,Z). TYPE ( EZspline3_r8 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,\\phi,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NPHI !! Size of mesh containing the field data along the \\phi-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSPHI = ( / - 1 , - 1 / ) !! Periodic boundary condition for the interpolants at both ends of !! the \\phi direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both ends !! of the Z direction. END TYPE KORC_3D_PROFILES_INTERPOLANT","tags":"","loc":"type/korc_3d_profiles_interpolant~2.html"},{"title":"KORC_2D_PROFILES_INTERPOLANT – KORC-Full Orbit ","text":"type, private :: KORC_2D_PROFILES_INTERPOLANT Note Derived type containing 2-D PSPLINE interpolants for\n cylindrical components of the density ,\n temperature , and effective charge number profiles.\n Real precision of 8 bytes. Contents Variables ne Te Zeff NR NZ BCSR BCSZ Source Code KORC_2D_PROFILES_INTERPOLANT Components Type Visibility Attributes Name Initial type(EZspline2_r4), public :: ne Interpolant of background electron density . type(EZspline2_r4), public :: Te Interpolant of background electron temperature . type(EZspline2_r4), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. Source Code TYPE , PRIVATE :: KORC_2D_PROFILES_INTERPOLANT !! @note Derived type containing 2-D PSPLINE interpolants for cylindrical !! components of the density n_e(R,Z), temperature T_e(R,Z), and !! effective charge number Z_{eff}(R,Z) profiles. !! Real precision of 8 bytes. @endnote TYPE ( EZspline2_r8 ) :: ne !! Interpolant of background electron density n_e(R,Z). TYPE ( EZspline2_r8 ) :: Te !! Interpolant of background electron temperature T_e(R,Z). TYPE ( EZspline2_r8 ) :: Zeff !! Interpolant of effective charge number Z_{eff}(R,Z). INTEGER :: NR !! Size of mesh containing the field data along the R-axis. INTEGER :: NZ !! Size of mesh containing the field data along the Z-axis. INTEGER , DIMENSION ( 2 ) :: BCSR = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the R direction. INTEGER , DIMENSION ( 2 ) :: BCSZ = ( / 0 , 0 / ) !! Not-a-knot boundary condition for the interpolants at both !! ends of the Z direction. END TYPE KORC_2D_PROFILES_INTERPOLANT","tags":"","loc":"type/korc_2d_profiles_interpolant~2.html"},{"title":"KORC_INTERPOLANT_DOMAIN – KORC-Full Orbit ","text":"type, private :: KORC_INTERPOLANT_DOMAIN Note Derived type containing 2-D and 3-D arrays with the information of\n the spatial domain where the fields and profiles are known.\n This info is used for detecting when a particle is lost, and therefore not\n followed anymore. Contents Variables FLAG1D FLAG2D FLAG3D Ro Zo To Drm DPSIP DR DPHI DT DZ Source Code KORC_INTERPOLANT_DOMAIN Components Type Visibility Attributes Name Initial integer(kind=1), public, DIMENSION(:), ALLOCATABLE :: FLAG1D 2-D array with info of the spatial domain where the axisymmetric fields\n and plasma profiles are known. integer(kind=1), public, DIMENSION(:,:), ALLOCATABLE :: FLAG2D 2-D array with info of the spatial domain where the axisymmetric fields\n and plasma profiles are known. integer(kind=1), public, DIMENSION(:,:,:), ALLOCATABLE :: FLAG3D 3-D array with info of the spatial domain where the 3-D fields and plasma\n profiles are known. real(kind=rp), public :: Ro Smaller radial position of the fields and profiles domain. real(kind=rp), public :: Zo Smaller vertical position of the fields and profiles domain real(kind=rp), public :: To real(kind=rp), public :: Drm real(kind=rp), public :: DPSIP real(kind=rp), public :: DR Separation between grid points along the radial direction. real(kind=rp), public :: DPHI real(kind=rp), public :: DT real(kind=rp), public :: DZ Separation between grid points along the vertical direction. Source Code TYPE , PRIVATE :: KORC_INTERPOLANT_DOMAIN !! @note Derived type containing 2-D and 3-D arrays with the information of !! the spatial domain where the fields and profiles are known. !! This info is used for detecting when a particle is lost, and therefore not !! followed anymore. @endnote INTEGER ( KIND = 1 ), DIMENSION (:), ALLOCATABLE :: FLAG1D !! 2-D array with info of the spatial domain where the axisymmetric fields !! and plasma profiles are known. INTEGER ( KIND = 1 ), DIMENSION (:,:), ALLOCATABLE :: FLAG2D !! 2-D array with info of the spatial domain where the axisymmetric fields !! and plasma profiles are known. INTEGER ( KIND = 1 ), DIMENSION (:,:,:), ALLOCATABLE :: FLAG3D !! 3-D array with info of the spatial domain where the 3-D fields and plasma !! profiles are known. REAL ( rp ) :: Ro !! Smaller radial position of the fields and profiles domain. REAL ( rp ) :: Zo !! Smaller vertical position of the fields and profiles domain REAL ( rp ) :: To REAL ( rp ) :: Drm REAL ( rp ) :: DPSIP REAL ( rp ) :: DR !! Separation between grid points along the radial direction. REAL ( rp ) :: DPHI ! ! Separation between grid points along the azimuthal direction. REAL ( rp ) :: DT ! ! Separation between grid points along the azimuthal direction. REAL ( rp ) :: DZ !! Separation between grid points along the vertical direction. END TYPE KORC_INTERPOLANT_DOMAIN","tags":"","loc":"type/korc_interpolant_domain.html"},{"title":"AVALANCHE_PDF_PARAMS – KORC-Full Orbit ","text":"type, private :: AVALANCHE_PDF_PARAMS Contents Variables max_pitch_angle min_pitch_angle min_energy max_energy min_p max_p ne Zeff Ec Epar Ebar Te lD bmin CoulombLog Tau dth dp dR dZ fo alpha cz C1 C2 Source Code AVALANCHE_PDF_PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: max_pitch_angle Maximum pitch angle of sampled PDF in degrees real(kind=rp), public :: min_pitch_angle Minimum pitch angle of sampled PDF in degrees real(kind=rp), public :: min_energy Minimum energy of sampled PDF in MeV real(kind=rp), public :: max_energy Maximum energy of sampled PDF in MeV real(kind=rp), public :: min_p Minimum momentum of sampled PDF real(kind=rp), public :: max_p Maximum momentum of sampled PDF real(kind=rp), public :: ne Background electron density in m&#94;-3 real(kind=rp), public :: Zeff Effective atomic number of ions real(kind=rp), public :: Ec Critical electric field in V/m real(kind=rp), public :: Epar Parallel electric field in V/m real(kind=rp), public :: Ebar Epar/Ec real(kind=rp), public :: Te Background electron temperature in eV real(kind=rp), public :: lD Debye length real(kind=rp), public :: bmin Maximum approach radius real(kind=rp), public :: CoulombLog Coulomb Logarithm real(kind=rp), public :: Tau Collisional time real(kind=rp), public :: dth Variance of sampling normal variate for pitch angle real(kind=rp), public :: dp Variance of sampling normal variate for momentum real(kind=rp), public :: dR Variance of sampling normal variate for R location real(kind=rp), public :: dZ Variance of sampling normal variate for Z location real(kind=rp), public :: fo real(kind=rp), public :: alpha real(kind=rp), public :: cz real(kind=rp), public :: C1 real(kind=rp), public :: C2 Source Code TYPE , PRIVATE :: AVALANCHE_PDF_PARAMS REAL ( rp ) :: max_pitch_angle !! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle !! Minimum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_energy !! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_energy !! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_p !! Minimum momentum of sampled PDF REAL ( rp ) :: max_p !! Maximum momentum of sampled PDF REAL ( rp ) :: ne !! Background electron density in m&#94;-3 REAL ( rp ) :: Zeff !! Effective atomic number of ions REAL ( rp ) :: Ec !! Critical electric field in V/m REAL ( rp ) :: Epar !! Parallel electric field in V/m REAL ( rp ) :: Ebar !! Epar/Ec REAL ( rp ) :: Te !! Background electron temperature in eV REAL ( rp ) :: lD !! Debye length REAL ( rp ) :: bmin !! Maximum approach radius REAL ( rp ) :: CoulombLog !! Coulomb Logarithm REAL ( rp ) :: Tau !! Collisional time REAL ( rp ) :: dth !! Variance of sampling normal variate for pitch angle REAL ( rp ) :: dp !! Variance of sampling normal variate for momentum REAL ( rp ) :: dR !! Variance of sampling normal variate for R location REAL ( rp ) :: dZ !! Variance of sampling normal variate for Z location REAL ( rp ) :: fo REAL ( rp ) :: alpha REAL ( rp ) :: cz REAL ( rp ) :: C1 REAL ( rp ) :: C2 END TYPE AVALANCHE_PDF_PARAMS","tags":"","loc":"type/avalanche_pdf_params.html"},{"title":"KORC_STRING – KORC-Full Orbit ","text":"type, public :: KORC_STRING Note KORC string type of length MAX_STRING_LENGTH. Contents Variables str Source Code KORC_STRING Components Type Visibility Attributes Name Initial character(len=MAX_STRING_LENGTH), public :: str Source Code TYPE , PUBLIC :: KORC_STRING CHARACTER ( MAX_STRING_LENGTH ) :: str END TYPE KORC_STRING","tags":"","loc":"type/korc_string.html"},{"title":"V_FIELD_3D – KORC-Full Orbit ","text":"type, public :: V_FIELD_3D Note KORC 3-D vector field type This KORC type represents a 3-D vector field varible in\n cylindrical coordinates. For example, this could be the 3-D magnetic\n field, which can be written as All the members (components) of the V_FIELD_3D type follow the\n following index convention:\n ( index, index, index) Contents Variables R PHI Z Source Code V_FIELD_3D Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: R component of the vector field variable. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: PHI component of the vector field variable. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: Z component of the vector field variable. Source Code TYPE , PUBLIC :: V_FIELD_3D !! @note KORC 3-D vector field type @endnote !! This KORC type represents a 3-D vector field varible in !! cylindrical coordinates. For example, this could be the 3-D magnetic !! field, which can be written as \\mathbf{B}(R,\\phi,Z) = B_R(R,\\phi,Z) !! \\hat{R} + B_\\phi(R,\\phi,Z) \\hat{\\phi} + B_Z(R,\\phi,Z) \\hat{Z}. !! All the members (components) of the V_FIELD_3D type follow the !! following index convention: !! (R index,\\phi index, Z index) REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: R !! R component of the vector field variable. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: PHI !! \\phi component of the vector field variable. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Z !! Z component of the vector field variable. END TYPE V_FIELD_3D","tags":"","loc":"type/v_field_3d.html"},{"title":"V_FIELD_2D – KORC-Full Orbit ","text":"type, public :: V_FIELD_2D Note KORC 2-D vector field type This KORC type represents a 2-D vector field varible in cylindrical\n coordinates. For example, this could be the magnetic\n field in an axisymmetric plasma, which can be written as All the members (components) of the V_FIELD_2D type follow the\n following index convention:\n ( index, index). Contents Variables R PHI Z Source Code V_FIELD_2D Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: R component of the vector field variable. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: PHI component of the vector field variable. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Z component of the vector field variable. Source Code TYPE , PUBLIC :: V_FIELD_2D !! @note KORC 2-D vector field type @endnote !! This KORC type represents a 2-D vector field varible in cylindrical !! coordinates. For example, this could be the magnetic !! field in an axisymmetric plasma, which can be written as !! \\mathbf{B}(R,Z) = B_R(R,Z) \\hat{R} + B_\\phi(R,Z) \\hat{\\phi} + B_Z(R,Z) !! \\hat{Z}. !! All the members (components) of the V_FIELD_2D type follow the !! following index convention: !! (R index,Z index). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: R !! R  component of the vector field variable. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: PHI !! \\phi  component of the vector field variable. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Z !! Z  component of the vector field variable. END TYPE V_FIELD_2D","tags":"","loc":"type/v_field_2d.html"},{"title":"V_FIELD_1D – KORC-Full Orbit ","text":"type, public :: V_FIELD_1D Note KORC 1-D vector field type This KORC type represents a 1-D vector field varible in cylindrical\n coordinates. For example, this could be the magnetic\n field in an axisymmetric plasma, which can be written as All the members (components) of the V_FIELD_1D type follow the\n following index convention:\n ( index). Contents Variables R PHI Z Source Code V_FIELD_1D Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: R component of the vector field variable. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PHI component of the vector field variable. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Z component of the vector field variable. Source Code TYPE , PUBLIC :: V_FIELD_1D !! @note KORC 1-D vector field type @endnote !! This KORC type represents a 1-D vector field varible in cylindrical !! coordinates. For example, this could be the magnetic !! field in an axisymmetric plasma, which can be written as !! \\mathbf{B}(r) = B_R(r) \\hat{R} + B_\\phi(r) \\hat{\\phi} + B_Z(r) !! \\hat{Z}. !! All the members (components) of the V_FIELD_1D type follow the !! following index convention: !! (r index). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R !! R  component of the vector field variable. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI !! \\phi  component of the vector field variable. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z !! Z  component of the vector field variable. END TYPE V_FIELD_1D","tags":"","loc":"type/v_field_1d.html"},{"title":"KORC_MPI – KORC-Full Orbit ","text":"type, private :: KORC_MPI Note KORC derived type to keep relevant MPI parameters. Contents Variables nmpi rank rank_topo mpi_topo Source Code KORC_MPI Components Type Visibility Attributes Name Initial integer, public :: nmpi Number of MPI processes. integer, public :: rank Rank in WORLD COMMON communicator. integer, public :: rank_topo Rank in mpi_topo communicator integer, public :: mpi_topo MPI communicator for a certain topology. Source Code TYPE , PRIVATE :: KORC_MPI !! @note KORC derived type to keep relevant MPI parameters. @endnote INTEGER :: nmpi !! Number of MPI processes. INTEGER :: rank !! Rank in WORLD COMMON communicator. INTEGER :: rank_topo !! Rank in mpi_topo communicator INTEGER :: mpi_topo !! MPI communicator for a certain topology. END TYPE KORC_MPI","tags":"","loc":"type/korc_mpi.html"},{"title":"CHARCS_PARAMS – KORC-Full Orbit ","text":"type, public :: CHARCS_PARAMS Note KORC derived type containing characteristic scales used in the normalization of KORC variables. These characteristic scales are problem-dependent quantities. They are calculated in korc_units using the input\n parameters of a given KORC simulation. Contents Variables time time_r velocity length mass charge density Eo Bo energy pressure temperature Source Code CHARCS_PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: time Note Characteristic non-relativistic time scale given by , where is the\n largest electron cyclotron frequency in the simulation. real(kind=rp), public :: time_r Note Characteristic relativistic time scale given by , where is the\n largest relativistic electron cyclotron frequency in the simulation. real(kind=rp), public :: velocity Characteristic velocity. This is fixed to the speed of . real(kind=rp), public :: length Characteristic length scale calculated as times the relativistic time scale. real(kind=rp), public :: mass Characteristic particle mass. This is equal to the electron mass . real(kind=rp), public :: charge Characteristic particle charge. This is equal to the electron charge . real(kind=rp), public :: density Characteristic particle density. This is equal to , with the characteristic length. real(kind=rp), public :: Eo Characteristic electric field . Usually at the magnetic axis. real(kind=rp), public :: Bo Characteristic magnetic field . Usually at the magnetic axis. real(kind=rp), public :: energy Characteristic energy. This is equal to . real(kind=rp), public :: pressure Characteristic pressure. Todo This needs to be defined. real(kind=rp), public :: temperature Characteristic plasma temperature (Joules). This is equal to . Source Code TYPE , PUBLIC :: CHARCS_PARAMS !! @note KORC derived type containing characteristic scales used in the normalization of KORC variables. @endnote !! These characteristic scales are problem-dependent quantities. They are calculated in [[korc_units(module)]] using the input !! parameters of a given KORC simulation. REAL ( rp ) :: time !! @note Characteristic non-relativistic time scale given by 1/\\omega_{ce}, where \\omega_{ce}=e B_0/m_e is the !! largest electron cyclotron frequency in the simulation. @endnote REAL ( rp ) :: time_r !! @note Characteristic relativistic time scale given by 1/\\omega_{ce}, where \\omega_{ce}=e B_0/\\gamma m_e is the !! largest relativistic electron cyclotron frequency in the simulation. @endnote REAL ( rp ) :: velocity !! Characteristic velocity. This is fixed to the speed of c. REAL ( rp ) :: length !! Characteristic length scale calculated as c times the relativistic time scale. REAL ( rp ) :: mass !! Characteristic particle mass. This is equal to the electron mass m_e. REAL ( rp ) :: charge !! Characteristic particle charge. This is equal to the electron charge q_e. REAL ( rp ) :: density !! Characteristic particle density. This is equal to 1/l&#94;3, with l the characteristic length. REAL ( rp ) :: Eo !! Characteristic electric field E_0. Usually E_0 at the magnetic axis. REAL ( rp ) :: Bo !! Characteristic magnetic field B_0. Usually B_0 at the magnetic axis. REAL ( rp ) :: energy !! Characteristic energy. This is equal to m_e c&#94;2. REAL ( rp ) :: pressure !! Characteristic pressure. @todo This needs to be defined. REAL ( rp ) :: temperature !! Characteristic plasma temperature (Joules). This is equal to m_e c&#94;2. END TYPE CHARCS_PARAMS","tags":"","loc":"type/charcs_params.html"},{"title":"KORC_PARAMS – KORC-Full Orbit ","text":"type, public :: KORC_PARAMS Note Core KORC parameters. This KORC derived type contains the variables that control KORC's\n core behavior. Contents Variables path_to_inputs path_to_outputs num_omp_threads restart proceed reinit simulation_time snapshot_frequency restart_overwrite_frequency dt time ito it init_time t_steps prev_iter_2x1t t_skip t_it_SC output_cadence restart_output_cadence num_snapshots num_species minimum_particle_energy minimum_particle_g radiation collisions GC_rad_model collisions_model bound_electron_model field_model profile_model magnetic_field_filename outputs_list HDF5_error_handling mpi_params cpp FO_GC_compare orbit_model field_eval GC_coords FokPlan SameRandSeed SC_E SC_E_add time_slice rmax rmin zmax zmin pchunk Source Code KORC_PARAMS Components Type Visibility Attributes Name Initial character(len=MAX_STRING_LENGTH), public :: path_to_inputs Absolute path to KORC's input file. character(len=MAX_STRING_LENGTH), public :: path_to_outputs Absolute path to the outputs' folder. integer, public :: num_omp_threads Number of open MP threads per MPI process used in the simulation. logical, public :: restart Flag to indicate if the simulations proceeds (restart=T) or not\n (restart=F). Restart simulation that exited before simulation_time\n reached. logical, public :: proceed Flag to indicate if the simulations continues (proceed=T) or not\n (proceed=F). Append simulation results after previous simulation_time\n reached. logical, public :: reinit Flag to begin a new simulation, reinitializing from restart file state real(kind=rp), public :: simulation_time Total simulation time in seconds. real(kind=rp), public :: snapshot_frequency Time between snapshots in time of the simulation. real(kind=rp), public :: restart_overwrite_frequency Time between overwrites of restart file in time of the simulation. real(kind=rp), public :: dt Time step in the simulation as a fraction of the relativistic electron\n gyro-period . real(kind=rp), public :: time = 0.0_rp Current physical time in the simulation. integer(kind=ip), public :: ito = 0_ip Initial time iteration in the simulation, this is different from zero\n in case is a restarting simulation. integer(kind=ip), public :: it = 0_ip Current time iteration in the simulation, this is different from zero\n in case is a restarting simulation. real(kind=rp), public :: init_time = 0.0_rp Time at the beginning of a run with proceed=T integer(kind=ip), public :: t_steps integer(kind=ip), public :: prev_iter_2x1t Number of time steps needed for evolving the electrons up to\n \"simulation_time\". integer(kind=ip), public :: t_skip integer(kind=ip), public :: t_it_SC = 1_ip integer(kind=ip), public :: output_cadence Time iteration offset used to decide when the outputs are generated. integer(kind=ip), public :: restart_output_cadence Time iteration offset used to decide when the restart files are\n generated. integer(kind=ip), public :: num_snapshots Number of snapshots in time for generating the output files. integer, public :: num_species Number of different populations of simulated relativistic electrons\n in KORC. real(kind=rp), public :: minimum_particle_energy Minimum allowed energy of simulated electrons. Todo To improve the criterium to decide when an electron will not\n be followed anymore in the simulation. real(kind=rp), public :: minimum_particle_g Minimum allowed relativistic factor of simulated electrons. logical, public :: radiation Flag to indicate if synchrotron radiation losses are included\n (radiation=T) or not (radiation=F). logical, public :: collisions Flag to indicate if collisionsare included (collisions=T) or not\n (collisions=F). character(len=MAX_STRING_LENGTH), public :: GC_rad_model character(len=MAX_STRING_LENGTH), public :: collisions_model String with the name of the collisions model to be used in the\n simulation. character(len=MAX_STRING_LENGTH), public :: bound_electron_model character(len=MAX_STRING_LENGTH), public :: field_model character(len=MAX_STRING_LENGTH), public :: profile_model String with the name of the model for the fields and plasma profiles. character(len=MAX_STRING_LENGTH), public :: magnetic_field_filename String with the name of the model for the fields and plasma profiles. character(len=MAX_STRING_LENGTH), public, DIMENSION(:), ALLOCATABLE :: outputs_list List of electron variables to include in the outputs. integer, public :: HDF5_error_handling Flag to indicate whether we allow HDF5 to show warnings \n during runtime (HDF5_error_handling=1) or not (HDF5_error_handling=0) type( KORC_MPI ), public :: mpi_params An instance of the KORC_MPI derived type. type( CHARCS_PARAMS ), public :: cpp An instance of the CHARCS_PARAMS derived type. logical, public :: FO_GC_compare character(len=MAX_STRING_LENGTH), public :: orbit_model String with the name of the orbit model ('FO' or 'GC'). character(len=MAX_STRING_LENGTH), public :: field_eval String with the name of the field evaluation method for\n analytical fields ('interp' or 'eqn') logical, public :: GC_coords Flag to get_fields to control whether cartesian to cylindrical\n coordinate transformation needs to be performed logical, public :: FokPlan Flag to decouple spatial-dependence of evolution logical, public :: SameRandSeed logical, public :: SC_E logical, public :: SC_E_add integer, public :: time_slice real(kind=rp), public :: rmax real(kind=rp), public :: rmin real(kind=rp), public :: zmax real(kind=rp), public :: zmin integer, public :: pchunk number of particles per vectorized chunk Source Code TYPE , PUBLIC :: KORC_PARAMS !! @note Core KORC parameters. @endnote !!  This KORC derived type contains the variables that control KORC's !! core behavior. CHARACTER ( MAX_STRING_LENGTH ) :: path_to_inputs !! Absolute path to KORC's input file. CHARACTER ( MAX_STRING_LENGTH ) :: path_to_outputs !! Absolute path to the outputs' folder. INTEGER :: num_omp_threads !! Number of open MP threads per MPI process used in the simulation. LOGICAL :: restart !! Flag to indicate if the simulations proceeds (restart=T) or not !! (restart=F). Restart simulation that exited before simulation_time !! reached. LOGICAL :: proceed !! Flag to indicate if the simulations continues (proceed=T) or not !! (proceed=F). Append simulation results after previous simulation_time !! reached. LOGICAL :: reinit !! Flag to begin a new simulation, reinitializing from restart file state REAL ( rp ) :: simulation_time !! Total simulation time in seconds. REAL ( rp ) :: snapshot_frequency !! Time between snapshots in time of the simulation. REAL ( rp ) :: restart_overwrite_frequency !! Time between overwrites of restart file in time of the simulation. REAL ( rp ) :: dt !! Time step in the simulation as a fraction of the relativistic electron !! gyro-period \\tau_e = 2\\pi\\gamma m_e/eB_0. REAL ( rp ) :: time = 0.0_rp !! Current physical time in the simulation. INTEGER ( ip ) :: ito = 0_ip !! Initial time iteration in the simulation, this is different from zero !! in case is a restarting simulation. INTEGER ( ip ) :: it = 0_ip !! Current time iteration in the simulation, this is different from zero !! in case is a restarting simulation. REAL ( rp ) :: init_time = 0.0_rp !! Time at the beginning of a run with proceed=T INTEGER ( ip ) :: t_steps INTEGER ( ip ) :: prev_iter_2x1t !! Number of time steps needed for evolving the electrons up to !! \"simulation_time\". INTEGER ( ip ) :: t_skip INTEGER ( ip ) :: t_it_SC = 1_ip INTEGER ( ip ) :: output_cadence !! Time iteration offset used to decide when the outputs are generated. INTEGER ( ip ) :: restart_output_cadence !! Time iteration offset used to decide when the restart files are !! generated. INTEGER ( ip ) :: num_snapshots !! Number of snapshots in time for generating the output files. INTEGER :: num_species !! Number of different populations of simulated relativistic electrons !! in KORC. REAL ( rp ) :: minimum_particle_energy !! Minimum allowed energy of simulated electrons. !! @todo To improve the criterium to decide when an electron will not !! be followed anymore in the simulation. REAL ( rp ) :: minimum_particle_g !! Minimum allowed relativistic factor \\gamma of simulated electrons. LOGICAL :: radiation !! Flag to indicate if synchrotron radiation losses are included !! (radiation=T) or not (radiation=F). LOGICAL :: collisions !! Flag to indicate if collisionsare included (collisions=T) or not !! (collisions=F). CHARACTER ( MAX_STRING_LENGTH ) :: GC_rad_model CHARACTER ( MAX_STRING_LENGTH ) :: collisions_model !! String with the name of the collisions model to be used in the !! simulation. CHARACTER ( MAX_STRING_LENGTH ) :: bound_electron_model CHARACTER ( MAX_STRING_LENGTH ) :: field_model CHARACTER ( MAX_STRING_LENGTH ) :: profile_model !! String with the name of the model for the fields and plasma profiles. CHARACTER ( MAX_STRING_LENGTH ) :: magnetic_field_filename !! String with the name of the model for the fields and plasma profiles. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: outputs_list !! List of electron variables to include in the outputs. INTEGER :: HDF5_error_handling !! Flag to indicate whether we allow HDF5 to show warnings !! during runtime (HDF5_error_handling=1) or not (HDF5_error_handling=0) TYPE ( KORC_MPI ) :: mpi_params !! An instance of the KORC_MPI derived type. TYPE ( CHARCS_PARAMS ) :: cpp !! An instance of the CHARCS_PARAMS derived type. LOGICAL :: FO_GC_compare CHARACTER ( MAX_STRING_LENGTH ) :: orbit_model !! String with the name of the orbit model ('FO' or 'GC'). CHARACTER ( MAX_STRING_LENGTH ) :: field_eval !! String with the name of the field evaluation method for !! analytical fields ('interp' or 'eqn') LOGICAL :: GC_coords !! Flag to [[get_fields]] to control whether cartesian to cylindrical !! coordinate transformation needs to be performed LOGICAL :: FokPlan !! Flag to decouple spatial-dependence of evolution LOGICAL :: SameRandSeed LOGICAL :: SC_E LOGICAL :: SC_E_add INTEGER :: time_slice !< M3D-C1 time slice to use. REAL ( rp ) :: rmax !< Maximum r for M3D-C1 fields. REAL ( rp ) :: rmin !< Minimum r for M3D-C1 fields. REAL ( rp ) :: zmax !< Maximum z for M3D-C1 fields. REAL ( rp ) :: zmin !< Minimum z for M3D-C1 fields. INTEGER :: pchunk !! number of particles per vectorized chunk END TYPE KORC_PARAMS","tags":"","loc":"type/korc_params.html"},{"title":"PARTICLES – KORC-Full Orbit ","text":"type, public :: PARTICLES Note Derived type containing all the electrons' variables\nin the simulation. Contents Variables X V Rgc Y Y0 V0 E B PSI_P BR BPHI BZ gradB curlb RHS k1 k2 k3 k4 k5 k6 ne Te Zeff g eta mu Prad Pin flagCon flagCol AUX wt hint cart Source Code PARTICLES Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: X Cartesian coordinates of the electrons' position.\n dim(X) = (3,SPECIES::ppp). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: V Cartesian components of the electrons' velocity. dim(V) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Rgc Cartesian coordinates of the electrons' guiding-center position. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Y Coordinates of the electrons' position in cylindrical or toroidal\n coordinates. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Y0 Placeholder coordinates of the electrons' position in cylindrical\n coordinates for GC orbit model. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: V0 Placeholder of the electrons' parallel momentum for the GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: E Cartesian components of the electric field felt by each electron.\n dim(E) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: B Cartesian components of the magnetic field felt by each electron.\n dim(B) = dim(X). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PSI_P real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: BR Cartesian components of the gradient of the R-component of the\n magnetic field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: BPHI Cartesian components of the gradient of the PHI-component of the\n magnetic field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: BZ Cartesian components of the gradient of the Z-component of the\n magnetic field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: gradB Cylindrical components of the gradient of magnitude of magnetic\n field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: curlb Cylindrical components of the curl of the magnetic field unit\n vector felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: RHS RHS of equations of motion for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k1 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k2 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k3 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k4 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k5 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k6 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: ne Electron density seen by each electron. dim(ne) = (1,SPECIES::ppp). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Te Electron temperature seen by each electron. dim(Te) = (1,SPECIES::ppp). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zeff Zeff seen by each electron. dim(Zeff) = (1,SPECIES::ppp). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: g Instantaneous relativistic factor\n of each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: eta Instantaneous pitch angle of each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: mu Magnetic moment of each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Prad Instantaneous radiated power by each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Pin Instantaneous input power of each electron due to the electric\n field acceleration. integer(kind=is), public, DIMENSION(:), ALLOCATABLE :: flagCon integer(kind=is), public, DIMENSION(:), ALLOCATABLE :: flagCol Flag for each particle to decide whether it is being followed\n (flag=T) or not (flag=F). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: AUX An auxiliary scalar variable for each electron. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: wt Weight of each electron. This is used when sampling weighted\n PDFs and in the synthetic camera diagnostic. type(C_PTR), public, DIMENSION(:), ALLOCATABLE :: hint Hint for M3D_C1 interpolation. logical, public :: cart Source Code TYPE , PUBLIC :: PARTICLES !! @note Derived type containing all the electrons' variables !!in the simulation. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: X !! Cartesian coordinates of the electrons' position. !! dim(X) = (3,SPECIES::ppp). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: V !! Cartesian components of the electrons' velocity. dim(V) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Rgc !! Cartesian coordinates of the electrons' guiding-center position. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Y !! Coordinates of the electrons' position in cylindrical or toroidal !! coordinates. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Y0 !! Placeholder coordinates of the electrons' position in cylindrical !! coordinates for GC orbit model. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V0 !! Placeholder of the electrons' parallel momentum for the GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: E !! Cartesian components of the electric field felt by each electron. !! dim(E) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: B !! Cartesian components of the magnetic field felt by each electron. !! dim(B) = dim(X). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PSI_P REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: BR !! Cartesian components of the gradient of the R-component of the !! magnetic field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: BPHI !! Cartesian components of the gradient of the PHI-component of the !! magnetic field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: BZ !! Cartesian components of the gradient of the Z-component of the !! magnetic field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: gradB !! Cylindrical components of the gradient of magnitude of magnetic !! field felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: curlb !! Cylindrical components of the curl of the magnetic field unit !! vector felt by each electron. dim(B) = dim(X). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: RHS !! RHS of equations of motion for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k1 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k2 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k3 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k4 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k5 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: k6 !! Cash-Karp Runge-Kutta coefficient for GC orbit model REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ne !! Electron density seen by each electron. dim(ne) = (1,SPECIES::ppp). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Te !! Electron temperature seen by each electron. dim(Te) = (1,SPECIES::ppp). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Zeff !! Zeff seen by each electron. dim(Zeff) = (1,SPECIES::ppp). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g !! Instantaneous relativistic \\gamma = 1/\\sqrt{1 - v&#94;2/c&#94;2} factor !! of each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta !! Instantaneous pitch angle of each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: mu !! Magnetic moment of each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Prad !! Instantaneous radiated power by each electron in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Pin !! Instantaneous input power of each electron due to the electric !! field acceleration. INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: flagCon INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: flagCol !! Flag for each particle to decide whether it is being followed !! (flag=T) or not (flag=F). REAL ( rp ), DIMENSION (:), ALLOCATABLE :: AUX !! An auxiliary scalar variable for each electron. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: wt !! Weight of each electron. This is used when sampling weighted !! PDFs and in the synthetic camera diagnostic. TYPE ( C_PTR ), DIMENSION (:), ALLOCATABLE :: hint !! Hint for M3D_C1 interpolation. LOGICAL :: cart END TYPE PARTICLES","tags":"","loc":"type/particles.html"},{"title":"SPECIES – KORC-Full Orbit ","text":"type, public :: SPECIES Note Derived type containing the initial parameters of each electron\n ensemble followed in a KORC simulation. Contents Variables vars runaway spatial_distribution energy_distribution pitch_distribution Eo go etao Eo_lims etao_lims wc wc_r q m ppp Ro PHIo Zo r_inner r_outter falloff_rate shear_factor sigmaR sigmaZ theta_gauss psi_max Spong_b Spong_w Spong_dlam dth dgam dR dZ Xtrace Source Code SPECIES Components Type Visibility Attributes Name Initial type( PARTICLES ), public :: vars An instance of the PARTICLES derived type. logical, public :: runaway Flag to decide whether a given electron is a runaway (runaway=T)\n or not (runaway=F). character(len=MAX_STRING_LENGTH), public :: spatial_distribution String describing the type of initial spatial distribution for\n each electron species. character(len=MAX_STRING_LENGTH), public :: energy_distribution String describing the type of initial energy distribution for\n each electron species. character(len=MAX_STRING_LENGTH), public :: pitch_distribution String describing the type of initial pitch-angle distribution for\n each electron species. real(kind=rp), public :: Eo Initial energy of each electron species in case of using an initial\n mono-energetic distribution. real(kind=rp), public :: go Corresponding relativisitc factor of each electron species in case\n of using an initial mono-energetic distribution. real(kind=rp), public :: etao Initial pitch-angle of each electron species in case of using an\n initial mono-pitch-angle distribution. real(kind=rp), public, DIMENSION(2) :: Eo_lims Minimum and maximum energy limits of a given initial\n non-mono-energetic distribution. real(kind=rp), public, DIMENSION(2) :: etao_lims Minimum and maximum pitch-angle limits of a given initial\n non-mono-pitch-angle distribution. real(kind=rp), public :: wc The mean electron cyclotron frequency of each electron species. real(kind=rp), public :: wc_r The mean relativistic electron cyclotron frequency of each electron\n species. real(kind=rp), public :: q Charge of each species. Note This was left explicit to allow \n KORC to follow electrons and ions in the future. real(kind=rp), public :: m Mass of each species. Note This was left explicit to allow KORC \n to follow electrons and ions in the future. integer, public :: ppp Number of computational particles used to simulate each electron\n species. real(kind=rp), public :: Ro Radial position of the center of the electrons' initial spatial\n distribution. real(kind=rp), public :: PHIo Azimuthal position of the electrons' initial spatial \n distribution, in case of using a disk at a certain poloidal section. real(kind=rp), public :: Zo Height of the center of the electrons' initial spatial distribution. real(kind=rp), public :: r_inner Minimum minor radius of the electrons' initial spatial distribution. real(kind=rp), public :: r_outter Maximum minor radius of the electrons' initial spatial distribution. real(kind=rp), public :: falloff_rate Exponential falloff or standard deviation of a non-uniform radial\n distribution of electrons. real(kind=rp), public :: shear_factor Shear factor used to generate an initial spatial distribution with an\n elliptic poloidal cross section. Note See Carbajal and del-Castillo-Negrete, Nuclear Fusion,\n submitted (2018) . real(kind=rp), public :: sigmaR Variance of the first dimension of a 2D Gaussian, spatial\n distribution function real(kind=rp), public :: sigmaZ Variance of the second dimension of a 2D Gaussian, spatial\n distribution function real(kind=rp), public :: theta_gauss Angle of counter-clockwise rotation (in degrees) of 2D Gaussian\n distribution relative to R,Z real(kind=rp), public :: psi_max Maximum value of the argument of the 2D gaussian exponential, used\n for an indicator function that limits the region of MH sampling real(kind=rp), public :: Spong_b real(kind=rp), public :: Spong_w real(kind=rp), public :: Spong_dlam real(kind=rp), public :: dth real(kind=rp), public :: dgam real(kind=rp), public :: dR real(kind=rp), public :: dZ real(kind=rp), public, DIMENSION(3) :: Xtrace Initial position in Cartesian coordinates for tracer particle Source Code TYPE , PUBLIC :: SPECIES !! @note Derived type containing the initial parameters of each electron !! ensemble followed in a KORC simulation. @endnote TYPE ( PARTICLES ) :: vars !! An instance of the PARTICLES derived type. LOGICAL :: runaway !! Flag to decide whether a given electron is a runaway (runaway=T) !! or not (runaway=F). CHARACTER ( MAX_STRING_LENGTH ) :: spatial_distribution !! String describing the type of initial spatial distribution for !! each electron species. CHARACTER ( MAX_STRING_LENGTH ) :: energy_distribution !! String describing the type of initial energy distribution for !! each electron species. CHARACTER ( MAX_STRING_LENGTH ) :: pitch_distribution !! String describing the type of initial pitch-angle distribution for !! each electron species. REAL ( rp ) :: Eo !! Initial energy of each electron species in case of using an initial !! mono-energetic distribution. REAL ( rp ) :: go !! Corresponding relativisitc factor of each electron species in case !! of using an initial mono-energetic distribution. REAL ( rp ) :: etao !! Initial pitch-angle of each electron species in case of using an !! initial mono-pitch-angle distribution. REAL ( rp ), DIMENSION ( 2 ) :: Eo_lims !! Minimum and maximum energy limits of a given initial !! non-mono-energetic distribution. REAL ( rp ), DIMENSION ( 2 ) :: etao_lims !! Minimum and maximum pitch-angle limits of a given initial !! non-mono-pitch-angle distribution. REAL ( rp ) :: wc !! The mean electron cyclotron frequency of each electron species. REAL ( rp ) :: wc_r !! The mean relativistic electron cyclotron frequency of each electron !! species. REAL ( rp ) :: q !! Charge of each species. @note This was left explicit to allow !! KORC to follow electrons and ions in the future. @endnote REAL ( rp ) :: m !! Mass of each species. @note This was left explicit to allow KORC !! to follow electrons and ions in the future. @endnote INTEGER :: ppp !! Number of computational particles used to simulate each electron !! species. REAL ( rp ) :: Ro !! Radial position of the center of the electrons' initial spatial !! distribution. REAL ( rp ) :: PHIo !! Azimuthal position of the electrons' initial spatial !! distribution, in case of using a disk at a certain poloidal section. REAL ( rp ) :: Zo !! Height of the center of the electrons' initial spatial distribution. REAL ( rp ) :: r_inner !! Minimum minor radius of the electrons' initial spatial distribution. REAL ( rp ) :: r_outter !! Maximum minor radius of the electrons' initial spatial distribution. REAL ( rp ) :: falloff_rate !! Exponential falloff or standard deviation of a non-uniform radial !! distribution of electrons. REAL ( rp ) :: shear_factor !! Shear factor used to generate an initial spatial distribution with an !! elliptic poloidal cross section. !! @note See <em>Carbajal and del-Castillo-Negrete, Nuclear Fusion, !! submitted (2018)</em>. @endnote REAL ( rp ) :: sigmaR !! Variance of the first dimension of a 2D Gaussian, spatial !! distribution function REAL ( rp ) :: sigmaZ !! Variance of the second dimension of a 2D Gaussian, spatial !! distribution function REAL ( rp ) :: theta_gauss !! Angle of counter-clockwise rotation (in degrees) of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: psi_max !! Maximum value of the argument of the 2D gaussian exponential, used !! for an indicator function that limits the region of MH sampling REAL ( rp ) :: Spong_b REAL ( rp ) :: Spong_w REAL ( rp ) :: Spong_dlam REAL ( rp ) :: dth REAL ( rp ) :: dgam REAL ( rp ) :: dR REAL ( rp ) :: dZ REAL ( rp ), DIMENSION ( 3 ) :: Xtrace !! Initial position in Cartesian coordinates for tracer particle END TYPE SPECIES","tags":"","loc":"type/species.html"},{"title":"A_FIELD – KORC-Full Orbit ","text":"type, private :: A_FIELD Note Derived type having all the parameters of the analytical\n magnetic field included in KORC. The analytical magnetic field is given by: where is the aspect ratio, the constant denotes the magnitude of the toroidal magnetic field, \n and is the poloidal magnetic\n field with safety factor . The\n constant is the safety factor at \n the magnetic axis and the constant is obtained from\n the values of and at the plasma edge . Contents Variables Bo a Ro qa qo lambda Bpo Bp_sign current_direction Source Code A_FIELD Components Type Visibility Attributes Name Initial real(kind=rp), public :: Bo Magnitude of the toroidal magnetic field . real(kind=rp), public :: a Plasma edge as measured from the magnetic axis. real(kind=rp), public :: Ro Radial position of the magnetic axis real(kind=rp), public :: qa Safety factor at the plasma edge. real(kind=rp), public :: qo Safety factor at the magnetic axis . real(kind=rp), public :: lambda parameter of . real(kind=rp), public :: Bpo @deprecated Parameter not used anymore. Todo Delete parameter. real(kind=rp), public :: Bp_sign Sign of . This depends on current_direction,\n Bp_sign=1 for \n current_direction='PARALLEL', and Bp_sign=-1 for\n current_direction='ANTI-PARALLEL'. character(len=MAX_STRING_LENGTH), public :: current_direction Direction of plasma current: PARALLEL or ANTI-PARALLEL to the\n toroidal magnetic field. Source Code TYPE , PRIVATE :: A_FIELD !! @note Derived type having all the parameters of the analytical !! magnetic field included in KORC. @endnote !! The analytical magnetic field is given by: !! \\mathbf{B}(r,\\vartheta) = \\frac{1}{1 + \\eta \\cos{\\vartheta}} !! \\left[ B_0 \\hat{e}_\\zeta  + B_\\vartheta(r) \\hat{e}_\\vartheta \\right], !! where \\eta = r/R_0 is the aspect ratio, the constant B_0 !! denotes the magnitude of the toroidal magnetic field, !! and B_\\vartheta(r) = \\eta B_0/q(r) is the poloidal magnetic !! field with safety factor !! q(r) = q_0\\left( 1 + \\frac{r&#94;2}{\\lambda&#94;2} \\right). The !! constant q_0 is the safety factor at !! the magnetic axis and the constant \\lambda is obtained from !! the values of q_0 and q(r) !! at the plasma edge r=r_{edge}. REAL ( rp ) :: Bo !! Magnitude of the toroidal magnetic field B_0. REAL ( rp ) :: a !! Plasma edge r_{edge} as measured from the magnetic axis. REAL ( rp ) :: Ro !! Radial position of the magnetic axis R_0 REAL ( rp ) :: qa !! Safety factor at the plasma edge. REAL ( rp ) :: qo !! Safety factor at the magnetic axis q_0. REAL ( rp ) :: lambda !! \\lambda parameter of q(r). REAL ( rp ) :: Bpo !! @deprecated Parameter not used anymore. @todo Delete parameter. REAL ( rp ) :: Bp_sign !! Sign of B_\\vartheta(r). This depends on current_direction, !! Bp_sign=1 for !! current_direction='PARALLEL', and Bp_sign=-1 for !! current_direction='ANTI-PARALLEL'. CHARACTER ( MAX_STRING_LENGTH ) :: current_direction !! Direction of plasma current: PARALLEL or ANTI-PARALLEL to the !! toroidal magnetic field. END TYPE A_FIELD","tags":"","loc":"type/a_field.html"},{"title":"MESH – KORC-Full Orbit ","text":"type, private :: MESH Derived type with the cylindrical coordinates of the grid nodes \n at which the pre-computed plasma profiles and fields are known. Contents Variables R PHI Z Source Code MESH Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: R Radial grid. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PHI Azimuthal grid. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Z Z grid. Source Code TYPE , PRIVATE :: MESH !! Derived type with the cylindrical coordinates of the grid nodes !! at which the pre-computed plasma profiles and fields are known. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R !! Radial grid. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI !! Azimuthal grid. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z !! Z grid. END TYPE MESH","tags":"","loc":"type/mesh.html"},{"title":"FIELDS – KORC-Full Orbit ","text":"type, public :: FIELDS Note Derived type with all the variables and data of analytical \n and pre-computed electric and magnetic fields. Contents Variables AB E_3D B_3D dBdR_3D dBdPHI_3D dBdZ_3D E_2D B_2D dBdR_2D dBdPHI_2D dBdZ_2D gradB_2D gradB_3D curlb_2D curlb_3D E_SC_1D J0_SC_1D J1_SC_1D J2_SC_1D J3_SC_1D A1_SC_1D A2_SC_1D A3_SC_1D r_1D PSIP_1D dMagPsiSqdPsiP ddMagPsiSqdPsiPSq X E_model E_dyn E_pulse E_width PSIP_min PSIp_lim PSIp_0 res_double dims dim_1D subcycle_E_SC dt_E_SC Ip_exp Ip0 PSIp PSIp_FS PSIp3D FLAG2D FLAG3D Eo Bo Ro Zo Bfield dBfield Bflux Bflux3D Efield Bfield_in_file dBfield_in_file Bflux_in_file Efield_in_file axisymmetric_fields Dim2x1t E_2x1t ReInterp_2x1t t0_2x1t ind0_2x1t ind_2x1t M3D_C1_B M3D_C1_E M3D_C1_A Source Code FIELDS Components Type Visibility Attributes Name Initial type( A_FIELD ), public :: AB An instance of the KORC derived data type A_FIELD. type( V_FIELD_3D ), public :: E_3D KORC 3-D vector field of the pre-computed electric field. type( V_FIELD_3D ), public :: B_3D type( V_FIELD_3D ), public :: dBdR_3D type( V_FIELD_3D ), public :: dBdPHI_3D type( V_FIELD_3D ), public :: dBdZ_3D KORC 3-D vector field of the pre-computed magnetic field. type( V_FIELD_2D ), public :: E_2D KORC 2-D vector field of the pre-computed electric field. type( V_FIELD_2D ), public :: B_2D type( V_FIELD_2D ), public :: dBdR_2D type( V_FIELD_2D ), public :: dBdPHI_2D type( V_FIELD_2D ), public :: dBdZ_2D KORC 3-D vector field of the pre-computed magnetic field. type( V_FIELD_2D ), public :: gradB_2D type( V_FIELD_3D ), public :: gradB_3D KORC 3-D vector field of the gradient of the magnitude of the\n pre-computed magnetic field. type( V_FIELD_2D ), public :: curlb_2D type( V_FIELD_3D ), public :: curlb_3D KORC 3-D vector field of the curl of the unit vector in the\n direction of the pre-computed magnetic field. type( V_FIELD_1D ), public :: E_SC_1D type( V_FIELD_1D ), public :: J0_SC_1D type( V_FIELD_1D ), public :: J1_SC_1D type( V_FIELD_1D ), public :: J2_SC_1D type( V_FIELD_1D ), public :: J3_SC_1D type( V_FIELD_1D ), public :: A1_SC_1D type( V_FIELD_1D ), public :: A2_SC_1D type( V_FIELD_1D ), public :: A3_SC_1D real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: r_1D real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PSIP_1D real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: dMagPsiSqdPsiP real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: ddMagPsiSqdPsiPSq type( MESH ), public :: X An instance of the KORC derived type MESH. character(len=MAX_STRING_LENGTH), public :: E_model Name for dynamical, analytic, electric field model to be added to real(kind=rp), public :: E_dyn real(kind=rp), public :: E_pulse real(kind=rp), public :: E_width real(kind=rp), public :: PSIP_min real(kind=rp), public :: PSIp_lim interpolated E field real(kind=rp), public :: PSIp_0 interpolated E field integer, public :: res_double integer, public, DIMENSION(3) :: dims Dimensions of the KORC vector field. dims=(number of grid \n nodes along , number of grid nodes along , \n number of grid nodes along ). integer, public :: dim_1D integer, public :: subcycle_E_SC real(kind=rp), public :: dt_E_SC real(kind=rp), public :: Ip_exp real(kind=rp), public :: Ip0 real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: PSIp real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: PSIp_FS real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: PSIp3D 2-D array for storing the data of the poloidal magnetic flux. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: FLAG2D 2-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: FLAG3D 3-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public :: Eo Characteristic electric field. real(kind=rp), public :: Bo Characteristic magnetic field. real(kind=rp), public :: Ro Radial position of the magnetic axis. real(kind=rp), public :: Zo position of the magnetic axis. logical, public :: Bfield Flag to indicate whether a pre-computed magnetic field will be\n used (Bfield=T) or not (Bfield=F). logical, public :: dBfield Flag to indicate whether a pre-computed magnetic field will be\n used (Bfield=T) or not (Bfield=F). logical, public :: Bflux logical, public :: Bflux3D Flag to indicate whether a pre-computed poloidal magnetic flux will\n be used (Bflux=T) or not (Bflux=F). logical, public :: Efield Flag to indicate whether a pre-computed electric field will be used\n (Efield=T) or not (Efield=F). logical, public :: Bfield_in_file Flag to indicate if a pre-computed magnetic field is in the input file. logical, public :: dBfield_in_file Flag to indicate if a pre-computed magnetic field is in the input file. logical, public :: Bflux_in_file Flag to indicate if a pre-computed poloidal magnetic flux is in the\n input file. logical, public :: Efield_in_file Flag to indicate if a pre-computed electric field is in the input file. logical, public :: axisymmetric_fields Flag to indicate if the pre-computed fields are axisymmetric. logical, public :: Dim2x1t logical, public :: E_2x1t logical, public :: ReInterp_2x1t real(kind=rp), public :: t0_2x1t integer, public :: ind0_2x1t integer, public :: ind_2x1t integer(kind=C_INT), public :: M3D_C1_B An M3D-C1 magnetic field. integer(kind=C_INT), public :: M3D_C1_E An M3D-C1 Electric field. integer(kind=C_INT), public :: M3D_C1_A An M3D-C1 vector potential. Source Code TYPE , PUBLIC :: FIELDS !! @note Derived type with all the variables and data of analytical !! and pre-computed electric and magnetic fields. @endnote TYPE ( A_FIELD ) :: AB !! An instance of the KORC derived data type A_FIELD. TYPE ( V_FIELD_3D ) :: E_3D !! KORC 3-D vector field of the pre-computed electric field. TYPE ( V_FIELD_3D ) :: B_3D TYPE ( V_FIELD_3D ) :: dBdR_3D TYPE ( V_FIELD_3D ) :: dBdPHI_3D TYPE ( V_FIELD_3D ) :: dBdZ_3D !! KORC 3-D vector field of the pre-computed magnetic field. TYPE ( V_FIELD_2D ) :: E_2D !! KORC 2-D vector field of the pre-computed electric field. TYPE ( V_FIELD_2D ) :: B_2D TYPE ( V_FIELD_2D ) :: dBdR_2D TYPE ( V_FIELD_2D ) :: dBdPHI_2D TYPE ( V_FIELD_2D ) :: dBdZ_2D !! KORC 3-D vector field of the pre-computed magnetic field. TYPE ( V_FIELD_2D ) :: gradB_2D TYPE ( V_FIELD_3D ) :: gradB_3D !! KORC 3-D vector field of the gradient of the magnitude of the !! pre-computed magnetic field. TYPE ( V_FIELD_2D ) :: curlb_2D TYPE ( V_FIELD_3D ) :: curlb_3D !! KORC 3-D vector field of the curl of the unit vector in the !! direction of the pre-computed magnetic field. TYPE ( V_FIELD_1D ) :: E_SC_1D TYPE ( V_FIELD_1D ) :: J0_SC_1D TYPE ( V_FIELD_1D ) :: J1_SC_1D TYPE ( V_FIELD_1D ) :: J2_SC_1D TYPE ( V_FIELD_1D ) :: J3_SC_1D TYPE ( V_FIELD_1D ) :: A1_SC_1D TYPE ( V_FIELD_1D ) :: A2_SC_1D TYPE ( V_FIELD_1D ) :: A3_SC_1D REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r_1D REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PSIP_1D REAL ( rp ), DIMENSION (:), ALLOCATABLE :: dMagPsiSqdPsiP REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ddMagPsiSqdPsiPSq TYPE ( MESH ) :: X !! An instance of the KORC derived type MESH. CHARACTER ( MAX_STRING_LENGTH ) :: E_model !! Name for dynamical, analytic, electric field model to be added to REAL ( rp ) :: E_dyn REAL ( rp ) :: E_pulse REAL ( rp ) :: E_width REAL ( rp ) :: PSIP_min REAL ( rp ) :: PSIp_lim , PSIp_0 !! interpolated E field INTEGER :: res_double INTEGER , DIMENSION ( 3 ) :: dims !! Dimensions of the KORC vector field. dims=(number of grid !! nodes along R, number of grid nodes along \\phi, !! number of grid nodes along Z). INTEGER :: dim_1D INTEGER :: subcycle_E_SC REAL ( rp ) :: dt_E_SC , Ip_exp , Ip0 REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: PSIp REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: PSIp_FS REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: PSIp3D !! 2-D array for storing the data of the poloidal magnetic flux. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: FLAG2D !! 2-D array defining the simulation domain where pre-computed data exist. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: FLAG3D !! 3-D array defining the simulation domain where pre-computed data exist. REAL ( rp ) :: Eo !! Characteristic electric field. REAL ( rp ) :: Bo !! Characteristic magnetic field. REAL ( rp ) :: Ro !! Radial position of the magnetic axis. REAL ( rp ) :: Zo !! Z position of the magnetic axis. LOGICAL :: Bfield !! Flag to indicate whether a pre-computed magnetic field will be !! used (Bfield=T) or not (Bfield=F). LOGICAL :: dBfield !! Flag to indicate whether a pre-computed magnetic field will be !! used (Bfield=T) or not (Bfield=F). LOGICAL :: Bflux LOGICAL :: Bflux3D !! Flag to indicate whether a pre-computed poloidal magnetic flux will !! be used (Bflux=T) or not (Bflux=F). LOGICAL :: Efield !! Flag to indicate whether a pre-computed electric field will be used !! (Efield=T) or not (Efield=F). LOGICAL :: Bfield_in_file !! Flag to indicate if a pre-computed magnetic field is in the input file. LOGICAL :: dBfield_in_file !! Flag to indicate if a pre-computed magnetic field is in the input file. LOGICAL :: Bflux_in_file !! Flag to indicate if a pre-computed poloidal magnetic flux is in the !! input file. LOGICAL :: Efield_in_file !! Flag to indicate if a pre-computed electric field is in the input file. LOGICAL :: axisymmetric_fields !! Flag to indicate if the pre-computed fields are axisymmetric. LOGICAL :: Dim2x1t LOGICAL :: E_2x1t , ReInterp_2x1t REAL ( rp ) :: t0_2x1t INTEGER :: ind0_2x1t , ind_2x1t #ifdef M3D_C1 INTEGER ( C_INT ) :: M3D_C1_B !! An M3D-C1 magnetic field. INTEGER ( C_INT ) :: M3D_C1_E !! An M3D-C1 Electric field. INTEGER ( C_INT ) :: M3D_C1_A !! An M3D-C1 vector potential. #endif END TYPE FIELDS","tags":"","loc":"type/fields.html"},{"title":"PROFILES – KORC-Full Orbit ","text":"type, public :: PROFILES Note KORC derived data type having information about the plasma\n profiles. \n See [[korc_profiles.f90(\"file\")]] for more information. KORC can run using either analytical and pre-computed plasma profiles. \n Pre-computed plasma profiles, \n as in the case of pre-computed electric or magnetic fields, are\n interpolated \n to electrons' position in korc_profiles . There are two types of analytical plsama profiles that can be used\n in KORC: \n 3rd degree polynomial radial plasma profiles, and radial plasma profiles with a dependency: where is a given plasma parameter at the magnetic axis,\n and is \n the plasma radius as measured \n from the magnetic axis to the last closed flux surface. Notice that the \n larger is, the more uniform the radial profiles are. Contents Variables X a R0 Z0 R0_RE Z0_RE dims FLAG2D FLAG3D n_ne n_Te n_Zeff n_REr0 n_tauion n_tauin n_tauout n_shelfdelay n_lamfront n_lamback n_lamshelf n_shelf psiN_0 a_ne a_Te a_Zeff Zeff_profile Zeffo Zeff_3D Zeff_2D ne_profile neo ne_3D ne_2D Te_profile Teo Te_3D Te_2D filename axisymmetric M3D_C1_ne M3D_C1_te M3D_C1_zeff Source Code PROFILES Components Type Visibility Attributes Name Initial type( MESH ), public :: X An instance of the KORC derived data type MESH. real(kind=rp), public :: a Plasma radius as measured from the magnetic axis real(kind=rp), public :: R0 real(kind=rp), public :: Z0 real(kind=rp), public :: R0_RE real(kind=rp), public :: Z0_RE integer, public, DIMENSION(3) :: dims Dimensions of the arrays containing the pre-computed profiles data. dims=(number of grid nodes along , \n number of grid nodes along , number of grid nodes along ). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: FLAG2D 2-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: FLAG3D 3-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public :: n_ne used in of the electron density profile. real(kind=rp), public :: n_Te used in of the electron temperature profile. real(kind=rp), public :: n_Zeff used in of the profile. real(kind=rp), public :: n_REr0 = 0._rp real(kind=rp), public :: n_tauion = 0._rp real(kind=rp), public :: n_tauin = 0._rp real(kind=rp), public :: n_tauout = 0._rp real(kind=rp), public :: n_shelfdelay = 0._rp real(kind=rp), public :: n_lamfront = 0._rp real(kind=rp), public :: n_lamback = 0._rp real(kind=rp), public :: n_lamshelf = 0._rp real(kind=rp), public :: n_shelf = 0._rp real(kind=rp), public :: psiN_0 = 1._rp real(kind=rp), public, DIMENSION(4) :: a_ne Coefficients of the polynomial electron density profile. \n See detailed description above, a_ne=( , , , ). real(kind=rp), public, DIMENSION(4) :: a_Te Coefficients of the polynomial electron temperature profile. \n See detailed description above, a_ne=( , , , ). real(kind=rp), public, DIMENSION(4) :: a_Zeff Coefficients of the profile. \n See detailed description above, a_ne=( , , , ). character(len=MAX_STRING_LENGTH), public :: Zeff_profile String containing the type of profile to be used in the simulation. real(kind=rp), public :: Zeffo at the magnetic axis. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: Zeff_3D 3-D array for keeping the pre-computed data of the profile. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Zeff_2D 2-D array for keeping the pre-computed data of the profile. character(len=MAX_STRING_LENGTH), public :: ne_profile String containing the type of electron density profile to be used in the simulation. real(kind=rp), public :: neo Electron density at the magnetic axis real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: ne_3D 3-D array for keeping the pre-computed data of the electron density profile. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: ne_2D 2-D array for keeping the pre-computed data of the electron density profile. character(len=MAX_STRING_LENGTH), public :: Te_profile String containing the type of electron temperature profile to be used in the simulation. real(kind=rp), public :: Teo Electron temperature at the magnetic axis real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: Te_3D 3-D array for keeping the pre-computed data of the electron density profile. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Te_2D 2-D array for keeping the pre-computed data of the electron density profile. character(len=MAX_STRING_LENGTH), public :: filename Full path to the HDF5 file containing the pre-computed plasma profiles. logical, public :: axisymmetric Flag to indicate if the plasma profiles are axisymmetric. integer(kind=C_INT), public :: M3D_C1_ne integer(kind=C_INT), public :: M3D_C1_te integer(kind=C_INT), public :: M3D_C1_zeff Source Code TYPE , PUBLIC :: PROFILES !! @note KORC derived data type having information about the plasma !! profiles. !! See [[korc_profiles.f90(\"file\")]] for more information. @endnote !! KORC can run using either analytical and pre-computed plasma profiles. !! Pre-computed plasma profiles, !! as in the case of pre-computed electric or magnetic fields, are !! interpolated !! to electrons' position in [[korc_profiles]]. !! !! There are two types of analytical plsama profiles that can be used !! in KORC: !! 3rd degree polynomial radial plasma profiles, !! f(r) = a_3r&#94;3 + a_2r&#94;2 +a_1r + a_0, !! and radial plasma profiles with a \\tanh(r) dependency: !! f(r) = f_0\\left[1 - \\tanh&#94;n\\left(\\frac{2r}{a}\\right)\\right], !! where f_0 is a given plasma parameter at the magnetic axis, !! and a is !! the plasma radius as measured !! from the magnetic axis to the last closed flux surface. Notice that the !! larger n is, the more uniform the radial profiles are. TYPE ( MESH ) :: X !! An instance of the KORC derived data type MESH. REAL ( rp ) :: a !! Plasma radius as measured from the magnetic axis REAL ( rp ) :: R0 REAL ( rp ) :: Z0 REAL ( rp ) :: R0_RE REAL ( rp ) :: Z0_RE INTEGER , DIMENSION ( 3 ) :: dims !! Dimensions of the arrays containing the pre-computed profiles data. dims=(number of grid nodes along R, !! number of grid nodes along \\phi, number of grid nodes along Z). REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: FLAG2D !! 2-D array defining the simulation domain where pre-computed data exist. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: FLAG3D !! 3-D array defining the simulation domain where pre-computed data exist. REAL ( rp ) :: n_ne !! n used in \\tanh&#94;n(r) of the electron density profile. REAL ( rp ) :: n_Te !! n used in \\tanh&#94;n(r) of the electron temperature profile. REAL ( rp ) :: n_Zeff !! n used in \\tanh&#94;n(r) of the Z_{eff} profile. REAL ( rp ) :: n_REr0 = 0._rp REAL ( rp ) :: n_tauion = 0._rp REAL ( rp ) :: n_tauin = 0._rp REAL ( rp ) :: n_tauout = 0._rp REAL ( rp ) :: n_shelfdelay = 0._rp REAL ( rp ) :: n_lamfront = 0._rp REAL ( rp ) :: n_lamback = 0._rp REAL ( rp ) :: n_lamshelf = 0._rp REAL ( rp ) :: n_shelf = 0._rp REAL ( rp ) :: psiN_0 = 1._rp REAL ( rp ), DIMENSION ( 4 ) :: a_ne !! Coefficients of the polynomial electron density profile. !! See detailed description above, a_ne=(a_{0},a_{2},a_{3},a_{4}). REAL ( rp ), DIMENSION ( 4 ) :: a_Te !! Coefficients of the polynomial electron temperature profile. !! See detailed description above, a_ne=(a_{0},a_{2},a_{3},a_{4}). REAL ( rp ), DIMENSION ( 4 ) :: a_Zeff !! Coefficients of the Z_{eff} profile. !! See detailed description above, a_ne=(a_{0},a_{2},a_{3},a_{4}). ! Zeff CHARACTER ( MAX_STRING_LENGTH ) :: Zeff_profile !! String containing the type of Z_{eff} profile to be used in the simulation. REAL ( rp ) :: Zeffo !! Z_{eff} at the magnetic axis. REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Zeff_3D !! 3-D array for keeping the pre-computed data of the Z_{eff} profile. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Zeff_2D !! 2-D array for keeping the pre-computed data of the Z_{eff} profile. ! Density CHARACTER ( MAX_STRING_LENGTH ) :: ne_profile !! String containing the type of electron density profile to be used in the simulation. REAL ( rp ) :: neo !! Electron density at the magnetic axis REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: ne_3D !! 3-D array for keeping the pre-computed data of the electron density profile. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: ne_2D !! 2-D array for keeping the pre-computed data of the electron density profile. !Temperature CHARACTER ( MAX_STRING_LENGTH ) :: Te_profile !! String containing the type of electron temperature profile to be used in the simulation. REAL ( rp ) :: Teo !! Electron temperature at the magnetic axis REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Te_3D !! 3-D array for keeping the pre-computed data of the electron density profile. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Te_2D !! 2-D array for keeping the pre-computed data of the electron density profile. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! Full path to the HDF5 file containing the pre-computed plasma profiles. LOGICAL :: axisymmetric !! Flag to indicate if the plasma profiles are axisymmetric. #ifdef M3D_C1 INTEGER ( C_INT ) :: M3D_C1_ne INTEGER ( C_INT ) :: M3D_C1_te INTEGER ( C_INT ) :: M3D_C1_zeff #endif END TYPE PROFILES","tags":"","loc":"type/profiles.html"},{"title":"PARAMS – KORC-Full Orbit ","text":"type, private :: PARAMS Contents Variables E Zeff max_pitch_angle min_pitch_angle min_energy max_energy min_p max_p k t fGo Bo lambda A_fact Source Code PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: E real(kind=rp), public :: Zeff real(kind=rp), public :: max_pitch_angle real(kind=rp), public :: min_pitch_angle real(kind=rp), public :: min_energy real(kind=rp), public :: max_energy real(kind=rp), public :: min_p real(kind=rp), public :: max_p real(kind=rp), public :: k real(kind=rp), public :: t real(kind=rp), public :: fGo real(kind=rp), public :: Bo real(kind=rp), public :: lambda real(kind=rp), public :: A_fact Source Code TYPE , PRIVATE :: PARAMS REAL ( rp ) :: E ! Parallel electric field normalized using the critical electric field REAL ( rp ) :: Zeff ! Effective atomic number of impurities REAL ( rp ) :: max_pitch_angle ! Maximum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_pitch_angle ! Minimum pitch angle of sampled PDF in degrees REAL ( rp ) :: min_energy ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_energy ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_p ! Minimum momentum of sampled PDF REAL ( rp ) :: max_p ! Maximum momentum of sampled PDF REAL ( rp ) :: k ! Shape factor of Gamma distribution REAL ( rp ) :: t ! Scale factor of Gamma distribution REAL ( rp ) :: fGo ! Normalization factor of Gamma distribution REAL ( rp ) :: Bo REAL ( rp ) :: lambda REAL ( rp ) :: A_fact ! Multiplication factor for A in distributon. END TYPE PARAMS","tags":"","loc":"type/params.html"},{"title":"HOLLMANN_PARAMS – KORC-Full Orbit ","text":"type, private :: HOLLMANN_PARAMS Contents Variables filename E Eo sigma_E Zeff sigma_Z max_pitch_angle min_pitch_angle min_sampling_energy max_sampling_energy min_sampling_g max_sampling_g min_energy max_energy min_g max_g min_pitch max_pitch N E_axis g fRE_E fRE_pitch current_direction Bo lambda A_fact Source Code HOLLMANN_PARAMS Components Type Visibility Attributes Name Initial character(len=MAX_STRING_LENGTH), public :: filename real(kind=rp), public :: E real(kind=rp), public :: Eo real(kind=rp), public :: sigma_E real(kind=rp), public :: Zeff real(kind=rp), public :: sigma_Z real(kind=rp), public :: max_pitch_angle real(kind=rp), public :: min_pitch_angle real(kind=rp), public :: min_sampling_energy real(kind=rp), public :: max_sampling_energy real(kind=rp), public :: min_sampling_g real(kind=rp), public :: max_sampling_g real(kind=rp), public :: min_energy real(kind=rp), public :: max_energy real(kind=rp), public :: min_g real(kind=rp), public :: max_g real(kind=rp), public :: min_pitch real(kind=rp), public :: max_pitch integer, public :: N real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: E_axis real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: g real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: fRE_E real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: fRE_pitch character(len=MAX_STRING_LENGTH), public :: current_direction real(kind=rp), public :: Bo real(kind=rp), public :: lambda real(kind=rp), public :: A_fact Source Code TYPE , PRIVATE :: HOLLMANN_PARAMS CHARACTER ( MAX_STRING_LENGTH ) :: filename REAL ( rp ) :: E REAL ( rp ) :: Eo REAL ( rp ) :: sigma_E REAL ( rp ) :: Zeff REAL ( rp ) :: sigma_Z REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: min_sampling_energy ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_sampling_energy ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_sampling_g ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_sampling_g ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_energy ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_energy ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_g ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_g ! Maximum energy of sampled PDF in MeV REAL ( rp ) :: min_pitch ! Minimum energy of sampled PDF in MeV REAL ( rp ) :: max_pitch ! Maximum energy of sampled PDF in MeV INTEGER :: N REAL ( rp ), DIMENSION (:), ALLOCATABLE :: E_axis REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE :: fRE_E REAL ( rp ), DIMENSION (:), ALLOCATABLE :: fRE_pitch CHARACTER ( MAX_STRING_LENGTH ) :: current_direction REAL ( rp ) :: Bo REAL ( rp ) :: lambda REAL ( rp ) :: A_fact ! Multiplication factor for A in distributon. END TYPE HOLLMANN_PARAMS","tags":"","loc":"type/hollmann_params.html"},{"title":"URAND – KORC-Full Orbit ","text":"type, private :: URAND Contents Variables u v w Source Code URAND Components Type Visibility Attributes Name Initial integer(kind=8), public :: u integer(kind=8), public :: v integer(kind=8), public :: w Source Code TYPE , PRIVATE :: URAND INTEGER ( 8 ) :: u INTEGER ( 8 ) :: v INTEGER ( 8 ) :: w END TYPE URAND","tags":"","loc":"type/urand.html"},{"title":"chebev_s – KORC-Full Orbit","text":"function chebev_s(a, b, c, x) Uses nrtype nrutil Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: x Return Value real(kind=SP) Contents Source Code chebev_s Source Code FUNCTION chebev_s ( a , b , c , x ) USE nrtype ; USE nrutil , ONLY : nrerror IMPLICIT NONE REAL ( SP ), INTENT ( IN ) :: a , b , x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c REAL ( SP ) :: chebev_s INTEGER ( I4B ) :: j , m REAL ( SP ) :: d , dd , sv , y , y2 if (( x - a ) * ( x - b ) > 0.0 ) call nrerror ( 'x not in range in chebev_s' ) m = size ( c ) d = 0.0 dd = 0.0 y = ( 2.0_sp * x - a - b ) / ( b - a ) y2 = 2.0_sp * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev_s = y * d - dd + 0.5_sp * c ( 1 ) END FUNCTION chebev_s","tags":"","loc":"proc/chebev_s.html"},{"title":"chebev_v – KORC-Full Orbit","text":"function chebev_v(a, b, c, x) Uses nrtype nrutil Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) Contents Source Code chebev_v Source Code FUNCTION chebev_v ( a , b , c , x ) USE nrtype ; USE nrutil , ONLY : nrerror IMPLICIT NONE REAL ( SP ), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: c , x REAL ( SP ), DIMENSION ( size ( x )) :: chebev_v INTEGER ( I4B ) :: j , m REAL ( SP ), DIMENSION ( size ( x )) :: d , dd , sv , y , y2 if ( any (( x - a ) * ( x - b ) > 0.0 )) call nrerror ( 'x not in range in chebev_v' ) m = size ( c ) d = 0.0 dd = 0.0 y = ( 2.0_sp * x - a - b ) / ( b - a ) y2 = 2.0_sp * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev_v = y * d - dd + 0.5_sp * c ( 1 ) END FUNCTION chebev_v","tags":"","loc":"proc/chebev_v.html"},{"title":"beschb_s – KORC-Full Orbit","text":"subroutine beschb_s(x, gam1, gam2, gampl, gammi) Uses nrtype nr Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(out) :: gam1 real(kind=DP), intent(out) :: gam2 real(kind=DP), intent(out) :: gampl real(kind=DP), intent(out) :: gammi Contents Source Code beschb_s Source Code SUBROUTINE beschb_s ( x , gam1 , gam2 , gampl , gammi ) USE nrtype USE nr , ONLY : chebev IMPLICIT NONE REAL ( DP ), INTENT ( IN ) :: x REAL ( DP ), INTENT ( OUT ) :: gam1 , gam2 , gampl , gammi INTEGER ( I4B ), PARAMETER :: NUSE1 = 5 , NUSE2 = 5 REAL ( SP ) :: xx REAL ( SP ), DIMENSION ( 7 ) :: c1 = ( /- 1.142022680371168_sp ,& 6.5165112670737e-3_sp , 3.087090173086e-4_sp , - 3.4706269649e-6_sp ,& 6.9437664e-9_sp , 3.67795e-11_sp , - 1.356e-13_sp / ) REAL ( SP ), DIMENSION ( 8 ) :: c2 = ( / 1.843740587300905_sp ,& - 7.68528408447867e-2_sp , 1.2719271366546e-3_sp ,& - 4.9717367042e-6_sp , - 3.31261198e-8_sp , 2.423096e-10_sp ,& - 1.702e-13_sp , - 1.49e-15_sp / ) xx = 8.0_dp * x * x - 1.0_dp gam1 = chebev ( - 1.0_sp , 1.0_sp , c1 ( 1 : NUSE1 ), xx ) gam2 = chebev ( - 1.0_sp , 1.0_sp , c2 ( 1 : NUSE2 ), xx ) gampl = gam2 - x * gam1 gammi = gam2 + x * gam1 END SUBROUTINE beschb_s","tags":"","loc":"proc/beschb_s.html"},{"title":"beschb_v – KORC-Full Orbit","text":"subroutine beschb_v(x, gam1, gam2, gampl, gammi) Uses nrtype nr Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(out), DIMENSION(:) :: gam1 real(kind=DP), intent(out), DIMENSION(:) :: gam2 real(kind=DP), intent(out), DIMENSION(:) :: gampl real(kind=DP), intent(out), DIMENSION(:) :: gammi Contents Source Code beschb_v Source Code SUBROUTINE beschb_v ( x , gam1 , gam2 , gampl , gammi ) USE nrtype USE nr , ONLY : chebev IMPLICIT NONE REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: gam1 , gam2 , gampl , gammi INTEGER ( I4B ), PARAMETER :: NUSE1 = 5 , NUSE2 = 5 REAL ( SP ), DIMENSION ( size ( x )) :: xx REAL ( SP ), DIMENSION ( 7 ) :: c1 = ( /- 1.142022680371168_sp ,& 6.5165112670737e-3_sp , 3.087090173086e-4_sp , - 3.4706269649e-6_sp ,& 6.9437664e-9_sp , 3.67795e-11_sp , - 1.356e-13_sp / ) REAL ( SP ), DIMENSION ( 8 ) :: c2 = ( / 1.843740587300905_sp ,& - 7.68528408447867e-2_sp , 1.2719271366546e-3_sp ,& - 4.9717367042e-6_sp , - 3.31261198e-8_sp , 2.423096e-10_sp ,& - 1.702e-13_sp , - 1.49e-15_sp / ) xx = 8.0_dp * x * x - 1.0_dp gam1 = chebev ( - 1.0_sp , 1.0_sp , c1 ( 1 : NUSE1 ), xx ) gam2 = chebev ( - 1.0_sp , 1.0_sp , c2 ( 1 : NUSE2 ), xx ) gampl = gam2 - x * gam1 gammi = gam2 + x * gam1 END SUBROUTINE beschb_v","tags":"","loc":"proc/beschb_v.html"},{"title":"initialize_HDF5 – KORC-Full Orbit","text":"public subroutine initialize_HDF5() Arguments None Contents Source Code initialize_HDF5 Source Code subroutine initialize_HDF5 () INTEGER :: h5error ! Error flag call h5open_f ( h5error ) #ifdef HDF5_DOUBLE_PRESICION call h5tcopy_f ( H5T_NATIVE_DOUBLE , KORC_HDF5_REAL , h5error ) #elif HDF5_SINGLE_PRESICION call h5tcopy_f ( H5T_NATIVE_REAL , KORC_HDF5_REAL , h5error ) #endif call h5tget_size_f ( KORC_HDF5_REAL , rp_hdf5 , h5error ) end subroutine initialize_HDF5","tags":"","loc":"proc/initialize_hdf5.html"},{"title":"finalize_HDF5 – KORC-Full Orbit","text":"public subroutine finalize_HDF5() Arguments None Contents Source Code finalize_HDF5 Source Code subroutine finalize_HDF5 () INTEGER :: h5error ! Error flag call h5close_f ( h5error ) end subroutine finalize_HDF5","tags":"","loc":"proc/finalize_hdf5.html"},{"title":"iload_from_hdf5 – KORC-Full Orbit","text":"private subroutine iload_from_hdf5(h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(out) :: idatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr Contents Source Code iload_from_hdf5 Source Code subroutine iload_from_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER , INTENT ( OUT ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( OUT ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: h5error ! * * * Read datum from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: iload_from_hdf5 & --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_INTEGER , idatum , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: iload_from_hdf5 & --> h5dread_f\")' ) end if call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: iload_from_hdf5 & --> h5dclose_f\")' ) end if if ( PRESENT ( attr )) then ! * * * Read attribute from file * * * ! * * * Read attribute from file * * * end if ! * * * Read datum from file * * * end subroutine iload_from_hdf5","tags":"","loc":"proc/iload_from_hdf5.html"},{"title":"rload_from_hdf5 – KORC-Full Orbit","text":"private subroutine rload_from_hdf5(h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(out) :: rdatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr Contents Source Code rload_from_hdf5 Source Code subroutine rload_from_hdf5 ( h5file_id , dset , rdatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), INTENT ( OUT ) :: rdatum REAL :: raw_datum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( OUT ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: h5error ! * * * Read datum from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 & --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_datum , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 & --> h5dread_f\")' ) end if rdatum = REAL ( raw_datum , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 & --> h5dclose_f\")' ) end if if ( PRESENT ( attr )) then ! * * * Read attribute from file * * * ! * * * Read attribute from file * * * end if ! * * * Read datum from file * * * end subroutine rload_from_hdf5","tags":"","loc":"proc/rload_from_hdf5.html"},{"title":"rload_1d_array_from_hdf5 – KORC-Full Orbit","text":"private subroutine rload_1d_array_from_hdf5(h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(out), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code rload_1d_array_from_hdf5 Source Code subroutine rload_1d_array_from_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: rdata REAL , DIMENSION (:), ALLOCATABLE :: raw_data CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: attr CHARACTER ( MAX_STRING_LENGTH ) :: aname INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims INTEGER :: h5error dims = ( / shape ( rdata ) / ) ALLOCATE ( raw_data ( dims ( 1 )) ) ! * * * Read data from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_data , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dread_f\")' ) end if rdata = REAL ( raw_data , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dclose_f\")' ) end if DEALLOCATE ( raw_data ) if ( PRESENT ( attr )) then ! * * * Read data attribute(s) from file * * * end if ! * * * Read data from file * * * end subroutine rload_1d_array_from_hdf5","tags":"","loc":"proc/rload_1d_array_from_hdf5.html"},{"title":"rload_2d_array_from_hdf5 – KORC-Full Orbit","text":"private subroutine rload_2d_array_from_hdf5(h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code rload_2d_array_from_hdf5 Source Code subroutine rload_2d_array_from_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: rdata REAL , DIMENSION (:,:), ALLOCATABLE :: raw_data CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( MAX_STRING_LENGTH ) :: aname INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 2 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 2 ) :: adims INTEGER :: h5error dims = shape ( rdata ) ALLOCATE ( raw_data ( dims ( 1 ), dims ( 2 )) ) ! * * * Read data from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_data , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dread_f\")' ) end if rdata = REAL ( raw_data , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dclose_f\")' ) end if DEALLOCATE ( raw_data ) if ( PRESENT ( attr )) then ! * * * Read data attribute(s) from file * * * end if ! * * * Read data from file * * * end subroutine rload_2d_array_from_hdf5","tags":"","loc":"proc/rload_2d_array_from_hdf5.html"},{"title":"rload_3d_array_from_hdf5 – KORC-Full Orbit","text":"private subroutine rload_3d_array_from_hdf5(h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code rload_3d_array_from_hdf5 Source Code subroutine rload_3d_array_from_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE , INTENT ( INOUT ) :: rdata REAL , DIMENSION (:,:,:), ALLOCATABLE :: raw_data CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( MAX_STRING_LENGTH ) :: aname INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 3 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 3 ) :: adims INTEGER :: h5error dims = shape ( rdata ) ALLOCATE ( raw_data ( dims ( 1 ), dims ( 2 ), dims ( 3 )) ) ! * * * Read data from file * * * call h5dopen_f ( h5file_id , TRIM ( dset ), dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dopen_f\")' ) end if call h5dread_f ( dset_id , H5T_NATIVE_REAL , raw_data , dims , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dread_f\")' ) end if rdata = REAL ( raw_data , rp ) call h5dclose_f ( dset_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: rload_from_hdf5 --> h5dclose_f\")' ) end if DEALLOCATE ( raw_data ) if ( PRESENT ( attr )) then ! * * * Read data attribute(s) from file * * * end if ! * * * Read data from file * * * end subroutine rload_3d_array_from_hdf5","tags":"","loc":"proc/rload_3d_array_from_hdf5.html"},{"title":"i1save_to_hdf5 – KORC-Full Orbit","text":"private subroutine i1save_to_hdf5(h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=1), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr Contents Source Code i1save_to_hdf5 Source Code subroutine i1save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 1 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , INT ( idatum , idef ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i1save_to_hdf5","tags":"","loc":"proc/i1save_to_hdf5.html"},{"title":"i2save_to_hdf5 – KORC-Full Orbit","text":"private subroutine i2save_to_hdf5(h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=2), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr Contents Source Code i2save_to_hdf5 Source Code subroutine i2save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 2 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , INT ( idatum , idef ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i2save_to_hdf5","tags":"","loc":"proc/i2save_to_hdf5.html"},{"title":"i4save_to_hdf5 – KORC-Full Orbit","text":"private subroutine i4save_to_hdf5(h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=4), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr Contents Source Code i4save_to_hdf5 Source Code subroutine i4save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 4 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , INT ( idatum , idef ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i4save_to_hdf5","tags":"","loc":"proc/i4save_to_hdf5.html"},{"title":"i8save_to_hdf5 – KORC-Full Orbit","text":"private subroutine i8save_to_hdf5(h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=8), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr Contents Source Code i8save_to_hdf5 Source Code subroutine i8save_to_hdf5 ( h5file_id , dset , idatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER ( KIND = 8 ), INTENT ( IN ) :: idatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_DOUBLE , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_DOUBLE , REAL ( idatum , 8 ), dims , h5error ) if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine i8save_to_hdf5","tags":"","loc":"proc/i8save_to_hdf5.html"},{"title":"isave_1d_array_to_hdf5 – KORC-Full Orbit","text":"private subroutine isave_1d_array_to_hdf5(h5file_id, dset, idata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(in), DIMENSION(:) :: idata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code isave_1d_array_to_hdf5 Source Code subroutine isave_1d_array_to_hdf5 ( h5file_id , dset , idata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset INTEGER , DIMENSION (:), INTENT ( IN ) :: idata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: attrlen INTEGER ( SIZE_T ) :: tmplen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( idata )) ALLOCATE ( dims ( rank )) dims = shape ( idata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), H5T_NATIVE_INTEGER , dspace_id , dset_id , h5error ) call h5dwrite_f ( dset_id , H5T_NATIVE_INTEGER , idata , dims , h5error ) if ( PRESENT ( attr )) then arank = size ( shape ( attr )) ALLOCATE ( adims ( arank )) adims = shape ( attr ) ! * * * Write attribute of data to file * * * tmplen = 0 attrlen = 0 do rr = 1_idef , arank do dd = 1_idef , adims ( rr ) tmplen = LEN_TRIM ( attr ( dd )) if ( tmplen . GT . attrlen ) then attrlen = tmplen end if end do end do call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * DEALLOCATE ( adims ) end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine isave_1d_array_to_hdf5","tags":"","loc":"proc/isave_1d_array_to_hdf5.html"},{"title":"rsave_to_hdf5 – KORC-Full Orbit","text":"private subroutine rsave_to_hdf5(h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in) :: rdatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr Contents Source Code rsave_to_hdf5 Source Code subroutine rsave_to_hdf5 ( h5file_id , dset , rdatum , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), INTENT ( IN ) :: rdatum CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims = ( / 1 / ) INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 1 / ) INTEGER :: rank = 1 INTEGER :: arank = 1 INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdatum , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdatum , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * attrlen = LEN_TRIM ( attr ) call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * end subroutine rsave_to_hdf5","tags":"","loc":"proc/rsave_to_hdf5.html"},{"title":"rsave_1d_array_to_hdf5 – KORC-Full Orbit","text":"private subroutine rsave_1d_array_to_hdf5(h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code rsave_1d_array_to_hdf5 Source Code subroutine rsave_1d_array_to_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:), INTENT ( IN ) :: rdata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: tmplen INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( rdata )) ALLOCATE ( dims ( rank )) dims = shape ( rdata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdata , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdata , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then arank = size ( shape ( attr )) ALLOCATE ( adims ( arank )) adims = shape ( attr ) ! * * * Write attribute of data to file * * * tmplen = 0 attrlen = 0 do rr = 1_idef , arank do dd = 1_idef , adims ( rr ) tmplen = LEN_TRIM ( attr ( dd )) if ( tmplen . GT . attrlen ) then attrlen = tmplen end if end do end do call h5screate_simple_f ( arank , adims , aspace_id , h5error ) call h5tcopy_f ( H5T_NATIVE_CHARACTER , atype_id , h5error ) call h5tset_size_f ( atype_id , attrlen , h5error ) call h5acreate_f ( dset_id , aname , atype_id , aspace_id , attr_id , h5error ) call h5awrite_f ( attr_id , atype_id , attr , adims , h5error ) call h5aclose_f ( attr_id , h5error ) call h5sclose_f ( aspace_id , h5error ) ! * * * Write attribute of data to file * * * DEALLOCATE ( adims ) end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine rsave_1d_array_to_hdf5","tags":"","loc":"proc/rsave_1d_array_to_hdf5.html"},{"title":"rsave_2d_array_to_hdf5 – KORC-Full Orbit","text":"private subroutine rsave_2d_array_to_hdf5(h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code rsave_2d_array_to_hdf5 Source Code subroutine rsave_2d_array_to_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:), INTENT ( IN ) :: rdata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( rdata )) ALLOCATE ( dims ( rank )) dims = shape ( rdata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdata , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdata , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine rsave_2d_array_to_hdf5","tags":"","loc":"proc/rsave_2d_array_to_hdf5.html"},{"title":"rsave_3d_array_to_hdf5 – KORC-Full Orbit","text":"public subroutine rsave_3d_array_to_hdf5(h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Contents Source Code rsave_3d_array_to_hdf5 Source Code subroutine rsave_3d_array_to_hdf5 ( h5file_id , dset , rdata , attr ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset REAL ( rp ), DIMENSION (:,:,:), INTENT ( IN ) :: rdata CHARACTER ( MAX_STRING_LENGTH ), OPTIONAL , DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: attr CHARACTER ( 4 ) :: aname = \"Info\" INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HID_T ) :: aspace_id INTEGER ( HID_T ) :: attr_id INTEGER ( HID_T ) :: atype_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: adims INTEGER :: rank INTEGER :: arank INTEGER ( SIZE_T ) :: attrlen INTEGER :: h5error INTEGER :: rr , dd rank = size ( shape ( rdata )) ALLOCATE ( dims ( rank )) dims = shape ( rdata ) ! * * * Write data to file * * * call h5screate_simple_f ( rank , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), KORC_HDF5_REAL , dspace_id , dset_id , h5error ) if ( rp . EQ . INT ( rp_hdf5 )) then call h5dwrite_f ( dset_id , KORC_HDF5_REAL , rdata , dims , h5error ) else call h5dwrite_f ( dset_id , KORC_HDF5_REAL , REAL ( rdata , 4 ), dims , h5error ) end if if ( PRESENT ( attr )) then ! * * * Write attribute of data to file * * * end if call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) ! * * * Write data to file * * * DEALLOCATE ( dims ) end subroutine rsave_3d_array_to_hdf5","tags":"","loc":"proc/rsave_3d_array_to_hdf5.html"},{"title":"save_string_parameter – KORC-Full Orbit","text":"public subroutine save_string_parameter(h5file_id, dset, string_array) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset character(len=MAX_STRING_LENGTH), intent(in), DIMENSION(:) :: string_array Contents Source Code save_string_parameter Source Code subroutine save_string_parameter ( h5file_id , dset , string_array ) INTEGER ( HID_T ), INTENT ( IN ) :: h5file_id CHARACTER ( MAX_STRING_LENGTH ), INTENT ( IN ) :: dset CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), INTENT ( IN ) :: string_array INTEGER ( HID_T ) :: dset_id INTEGER ( HID_T ) :: dspace_id INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: dims INTEGER ( HSIZE_T ), DIMENSION ( 2 ) :: data_dims INTEGER ( SIZE_T ), DIMENSION (:), ALLOCATABLE :: str_len INTEGER ( HID_T ) :: string_type INTEGER :: h5error ALLOCATE ( str_len ( SIZE ( string_array ))) dims = ( / SIZE ( string_array ) / ) data_dims = ( / MAX_STRING_LENGTH , SIZE ( string_array ) / ) str_len = ( / LEN_TRIM ( string_array ) / ) call h5tcopy_f ( H5T_STRING , string_type , h5error ) call h5tset_strpad_f ( string_type , H5T_STR_SPACEPAD_F , h5error ) call h5screate_simple_f ( 1 , dims , dspace_id , h5error ) call h5dcreate_f ( h5file_id , TRIM ( dset ), string_type , dspace_id , dset_id , h5error ) call h5dwrite_vl_f ( dset_id , string_type , string_array , data_dims , str_len , h5error , dspace_id ) call h5sclose_f ( dspace_id , h5error ) call h5dclose_f ( dset_id , h5error ) DEALLOCATE ( str_len ) end subroutine save_string_parameter","tags":"","loc":"proc/save_string_parameter.html"},{"title":"save_simulation_parameters – KORC-Full Orbit","text":"public subroutine save_simulation_parameters(params, spp, F, P) Note Subroutine to save to a HDF5 file all the relevant simulation\n parameters. This subroutine saves to the HDF5 file \" simulation_parameters.h5 \"\n all the relevant simulation parameters of KORC, most of them being part\n of the input file, but also including some derived quantities from the\n input parameters. This file is intended to facilitate the\n post-processing of KORC data using any software that supports\n the HDF5 software. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(in), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all\n the information of different electron species. See korc_types . type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation. See korc_types and korc_fields . type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . Contents Source Code save_simulation_parameters Source Code subroutine save_simulation_parameters ( params , spp , F , P ) !! @note Subroutine to save to a HDF5 file all the relevant simulation !! parameters. @endnote !! This subroutine saves to the HDF5 file \"<a>simulation_parameters.h5</a>\" !! all the relevant simulation parameters of KORC, most of them being part !! of the input file, but also including some derived quantities from the !! input parameters. This file is intended to facilitate the !! post-processing of KORC data using any software that supports !! the HDF5 software. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !!Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. See [[korc_types]] !! and [[korc_fields]]. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !!  HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims !! Dimensions of data saved to HDF5 file. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rdata !! 1-D array of real data to be saved to HDF5 file. INTEGER , DIMENSION (:), ALLOCATABLE :: idata !! 1-D array of integer data to be saved to HDF5 file. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array !! An 1-D array with attributes of 1-D real or integer arrays that are !! passed to KORC interfaces of HDF5 I/O subroutines. CHARACTER ( MAX_STRING_LENGTH ) :: attr !!  A single attributes of real or integer data that is passed to KORC !! interfaces of HDF5 I/O subroutines. INTEGER :: h5error !! HDF5 error status. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. REAL ( rp ) :: units !! Temporary variable used to add physical units to KORC parameters. ! * * * Error handling * * * ! call h5eset_auto_f ( params % HDF5_error_handling , h5error ) ! Turn off: 0_idef. Turn on: 1_idef if (. NOT .( params % restart )) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Saving simulations parameters\")' ) end if if ( SIZE ( params % outputs_list ). GT . 1_idef ) then write ( tmp_str , '(I18)' ) params % mpi_params % rank filename = TRIM ( params % path_to_outputs ) // \"file_\" & // TRIM ( ADJUSTL ( tmp_str )) // \".h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simulation_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) ! Simulation parameters group gname = \"simulation\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( 1 )) ALLOCATE ( idata ( 1 )) dset = TRIM ( gname ) // \"/field_model\" call save_string_parameter ( h5file_id , dset ,( / params % field_model / )) dset = TRIM ( gname ) // \"/profile_model\" call save_string_parameter ( h5file_id , dset ,( / params % profile_model / )) dset = TRIM ( gname ) // \"/simulation_time\" attr = \"Total aimed simulation time in seconds\" call save_to_hdf5 ( h5file_id , dset , params % simulation_time * & params % cpp % time , attr ) dset = TRIM ( gname ) // \"/snapshot_frequency\" attr = \"Time between snapshots in seconds\" call save_to_hdf5 ( h5file_id , dset , params % snapshot_frequency * & params % cpp % time , attr ) dset = TRIM ( gname ) // \"/dt\" attr = \"Time step in secs\" call save_to_hdf5 ( h5file_id , dset , params % dt * params % cpp % time , attr ) dset = TRIM ( gname ) // \"/t_steps\" attr_array ( 1 ) = \"Number of time steps\" idata = params % t_steps call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/num_omp_threads\" attr = \"Number of omp threads\" call save_to_hdf5 ( h5file_id , dset , params % num_omp_threads , attr ) dset = TRIM ( gname ) // \"/output_cadence\" attr_array ( 1 ) = \"Cadence of output files\" idata = params % output_cadence call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/HDF5_error_handling\" attr_array ( 1 ) = \"Error handling option: 0=OFF, 1=ON\" idata = params % HDF5_error_handling call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/restart_output_cadence\" attr_array ( 1 ) = \"Cadence of output files\" idata = params % restart_output_cadence call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/num_snapshots\" attr_array ( 1 ) = \"Number of outputs for each variable\" idata = params % num_snapshots call save_1d_array_to_hdf5 ( h5file_id , dset , idata , attr_array ) dset = TRIM ( gname ) // \"/num_species\" attr = \"Number of particle species\" call save_to_hdf5 ( h5file_id , dset , params % num_species , attr ) dset = TRIM ( gname ) // \"/nmpi\" attr = \"Number of mpi processes\" call save_to_hdf5 ( h5file_id , dset , params % mpi_params % nmpi , attr ) dset = TRIM ( gname ) // \"/minimum_particle_energy\" attr = \"Minimum energy of simulated particles in eV\" call save_to_hdf5 ( h5file_id , dset , params % minimum_particle_energy * & params % cpp % energy / C_E , attr ) dset = TRIM ( gname ) // \"/minimum_particle_g\" attr = \"Minimum relativistic factor gamma of simulated particles\" call save_to_hdf5 ( h5file_id , dset , params % minimum_particle_g , attr ) dset = TRIM ( gname ) // \"/radiation\" attr = \"Radiation losses included in simulation\" if ( params % radiation ) then call save_to_hdf5 ( h5file_id , dset , 1_idef , attr ) else call save_to_hdf5 ( h5file_id , dset , 0_idef , attr ) end if dset = TRIM ( gname ) // \"/collisions\" attr = \"Collisions included in simulation\" if ( params % collisions ) then call save_to_hdf5 ( h5file_id , dset , 1_idef , attr ) else call save_to_hdf5 ( h5file_id , dset , 0_idef , attr ) end if dset = TRIM ( gname ) // \"/outputs_list\" call save_string_parameter ( h5file_id , dset , params % outputs_list ) dset = TRIM ( gname ) // \"/orbit_model\" call save_string_parameter ( h5file_id , dset ,( / params % orbit_model / )) dset = TRIM ( gname ) // \"/field_eval\" call save_string_parameter ( h5file_id , dset ,( / params % field_eval / )) DEALLOCATE ( idata ) DEALLOCATE ( attr_array ) call h5gclose_f ( group_id , h5error ) ! Plasma species group gname = \"species\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( params % num_species )) dset = TRIM ( gname ) // \"/spatial_distribution\" call save_string_parameter ( h5file_id , dset , spp % spatial_distribution ) dset = TRIM ( gname ) // \"/energy_distribution\" call save_string_parameter ( h5file_id , dset , spp % energy_distribution ) dset = TRIM ( gname ) // \"/pitch_distribution\" call save_string_parameter ( h5file_id , dset , spp % pitch_distribution ) dset = TRIM ( gname ) // \"/ppp\" attr_array ( 1 ) = \"Particles per (mpi) process\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % ppp , attr_array ) dset = TRIM ( gname ) // \"/q\" attr_array ( 1 ) = \"Electric charge\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % q * & params % cpp % charge , attr_array ) dset = TRIM ( gname ) // \"/m\" attr_array ( 1 ) = \"Species mass in kg\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % m * & params % cpp % mass , attr_array ) dset = TRIM ( gname ) // \"/Eo\" attr_array ( 1 ) = \"Initial (average) energy in eV\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % Eo * & params % cpp % energy / C_E , attr_array ) dset = TRIM ( gname ) // \"/go\" attr_array ( 1 ) = \"Initial relativistic g factor.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % go , attr_array ) dset = TRIM ( gname ) // \"/etao\" attr_array ( 1 ) = \"Initial pitch angle in degrees\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % etao , attr_array ) dset = TRIM ( gname ) // \"/wc\" attr_array ( 1 ) = \"Average relativistic cyclotron frequency in Hz\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % wc_r / & params % cpp % time , attr_array ) dset = TRIM ( gname ) // \"/Ro\" attr_array ( 1 ) = \"Initial radial position of population\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % Ro * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/PHIo\" attr_array ( 1 ) = \"Azimuthal angle in degrees.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % PHIo * & 18 0.0_rp / C_PI , attr_array ) dset = TRIM ( gname ) // \"/Zo\" attr_array ( 1 ) = \"Initial Z position of population\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % Zo * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ri\" attr_array ( 1 ) = \"Inner radius of initial spatial distribution\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % r_inner * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ro\" attr_array ( 1 ) = \"Outter radius of initial spatial distribution\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % r_outter * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/falloff_rate\" attr_array ( 1 ) = \"Falloff of gaussian or exponential radial & profile in m\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % falloff_rate / & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/shear_factor\" attr_array ( 1 ) = \"Shear factor (in case ELLIPTIC-TORUS  & spatial distribution is used.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % shear_factor , & attr_array ) dset = TRIM ( gname ) // \"/sigmaR\" attr_array ( 1 ) = \"Variance of first dimension of 2D spatial & distribution.\" call save_1d_array_to_hdf5 ( h5file_id , dset , & spp % sigmaR * params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/sigmaZ\" attr_array ( 1 ) = \"Variance of second dimension of 2D spatial & distribution.\" call save_1d_array_to_hdf5 ( h5file_id , dset , & spp % sigmaZ * params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/theta_gauss\" attr_array ( 1 ) = \"Angle of rotation of 2D spatial distribution.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % theta_gauss , attr_array ) dset = TRIM ( gname ) // \"/psi_max\" attr_array ( 1 ) = \"Indicator function level of the argument of & the 2D gaussian exponential.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % psi_max , attr_array ) dset = TRIM ( gname ) // \"/dth\" attr_array ( 1 ) = \"Variance of sampling normal variate for pitch angle.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dth , attr_array ) dset = TRIM ( gname ) // \"/dgam\" attr_array ( 1 ) = \"Variance of sampling normal variate for gamma.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dgam , attr_array ) dset = TRIM ( gname ) // \"/dR\" attr_array ( 1 ) = \"Variance of sampling normal variate for R.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dR * params % cpp % length , & attr_array ) dset = TRIM ( gname ) // \"/dZ\" attr_array ( 1 ) = \"Variance of sampling normal variate for Z.\" call save_1d_array_to_hdf5 ( h5file_id , dset , spp % dZ * params % cpp % length , & attr_array ) call h5gclose_f ( group_id , h5error ) DEALLOCATE ( attr_array ) ! Plasma profiles group !          if (params%collisions) then gname = \"profiles\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/density_profile\" call save_string_parameter ( h5file_id , dset ,( / P % ne_profile / )) dset = TRIM ( gname ) // \"/temperature_profile\" call save_string_parameter ( h5file_id , dset ,( / P % Te_profile / )) dset = TRIM ( gname ) // \"/Zeff_profile\" call save_string_parameter ( h5file_id , dset ,( / P % Zeff_profile / )) dset = TRIM ( gname ) // \"/neo\" attr = \"Density at the magnetic axis (m&#94;-3)\" call save_to_hdf5 ( h5file_id , dset , P % neo * params % cpp % density , attr ) dset = TRIM ( gname ) // \"/Teo\" attr = \"Temperature at the magnetic axis (eV)\" call save_to_hdf5 ( h5file_id , dset , P % Teo * & params % cpp % temperature / C_E , attr ) dset = TRIM ( gname ) // \"/Zeffo\" attr = \"Zeff at the magnetic axis\" call save_to_hdf5 ( h5file_id , dset , P % Zeffo , attr ) if ( TRIM ( params % profile_model ) . EQ . 'ANALYTICAL' ) then dset = TRIM ( gname ) // \"/n_ne\" attr = \"Exponent of tanh(x)&#94;n for density profile\" call save_to_hdf5 ( h5file_id , dset , P % n_ne , attr ) dset = TRIM ( gname ) // \"/a_ne\" attr = \"Coefficients f=ao+a1*r+a2*r&#94;2+a3*r&#94;3.  & a_ne=[a0,a1,a2,a3]\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % a_ne ) dset = TRIM ( gname ) // \"/n_Te\" attr = \"Exponent of tanh(x)&#94;n for density profile\" call save_to_hdf5 ( h5file_id , dset , P % n_Te , attr ) dset = TRIM ( gname ) // \"/a_Te\" attr = \"Coefficients f=ao+a1*r+a2*r&#94;2+a3*r&#94;3.  & a_Te=[a0,a1,a2,a3]\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % a_Te ) dset = TRIM ( gname ) // \"/n_Zeff\" attr = \"Exponent of tanh(x)&#94;n for Zeff profile\" call save_to_hdf5 ( h5file_id , dset , P % n_Zeff , attr ) dset = TRIM ( gname ) // \"/a_Zeff\" attr = \"Coefficients f=ao+a1*r+a2*r&#94;2+a3*r&#94;3.  & a_Zeff=[a0,a1,a2,a3]\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % a_Zeff ) if ( params % field_eval . EQ . 'interp' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the profile (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Radial position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % R * params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % PHI , attr_array ) end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Z position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % Z * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ne\" units = params % cpp % density call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % ne_2D ) dset = TRIM ( gname ) // \"/Te\" units = params % cpp % temperature call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % Te_2D ) dset = TRIM ( gname ) // \"/Zeff\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & P % Zeff_2D ) DEALLOCATE ( attr_array ) end if else if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the profiles (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Grid nodes of profiles along the & radial position\" call save_1d_array_to_hdf5 ( h5file_id , dset , P % X % R * & params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Grid nodes of profiles along the & azimuthal position\" call save_1d_array_to_hdf5 ( h5file_id , dset , & P % X % PHI , attr_array ) end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Grid nodes of profiles along the Z position\" call save_1d_array_to_hdf5 ( h5file_id , dset , & P % X % Z * params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/ne\" units = params % cpp % density call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % ne_2D ) dset = TRIM ( gname ) // \"/Te\" units = params % cpp % temperature call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * P % Te_2D ) dset = TRIM ( gname ) // \"/Zeff\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & P % Zeff_2D ) DEALLOCATE ( attr_array ) else if ( params % profile_model . EQ . 'UNIFORM' ) then ! Something end if call h5gclose_f ( group_id , h5error ) !end if ! Electromagnetic fields group gname = \"fields\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) if ( TRIM ( params % field_model ( 1 : 10 )) . EQ . 'ANALYTICAL' ) then dset = TRIM ( gname ) // \"/Bo\" attr = \"Toroidal field at the magnetic axis in T\" call save_to_hdf5 ( h5file_id , dset , F % Bo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/current_direction\" call save_string_parameter ( h5file_id , dset , & ( / F % AB % current_direction / )) dset = TRIM ( gname ) // \"/a\" attr = \"Minor radius in m\" call save_to_hdf5 ( h5file_id , dset , F % AB % a * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Ro\" attr = \"Magnetic axis radial position\" call save_to_hdf5 ( h5file_id , dset , F % Ro * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Zo\" attr = \"Magnetic axis vertical position\" call save_to_hdf5 ( h5file_id , dset , F % Zo * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/qa\" attr = \"Safety factor at minor radius\" call save_to_hdf5 ( h5file_id , dset , F % AB % qa , attr ) dset = TRIM ( gname ) // \"/qo\" attr = \"Safety factor at the magnetic axis\" call save_to_hdf5 ( h5file_id , dset , F % AB % qo , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Parameter lamda in m\" call save_to_hdf5 ( h5file_id , dset , F % AB % lambda * & params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Bpo\" attr = \"Poloidal magnetic field in T\" call save_to_hdf5 ( h5file_id , dset , F % AB % Bpo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/Eo\" attr = \"Electric field at the magnetic axis in V/m\" call save_to_hdf5 ( h5file_id , dset , F % Eo * params % cpp % Eo , attr ) if ( params % SC_E ) then dset = TRIM ( gname ) // \"/dt_E_SC\" attr = \"Time step for self-consistent E calculation\" call save_to_hdf5 ( h5file_id , dset , F % dt_E_SC , attr ) dset = TRIM ( gname ) // \"/Ip_exp\" attr = \"Scaling for self-consistent current density\" call save_to_hdf5 ( h5file_id , dset , F % Ip_exp , attr ) dset = TRIM ( gname ) // \"/Ip0\" attr = \"Total RE current normalization\" call save_to_hdf5 ( h5file_id , dset , F % Ip0 , attr ) ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/r_1D\" attr_array ( 1 ) = \"1D minor radial mesh for & self-consistent fields\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % r_1D , attr_array ) DEALLOCATE ( attr_array ) end if if ( params % field_eval . EQ . 'interp' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the magnetic  & field (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Radial position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % R * params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % PHI , attr_array ) end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Z position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % Z * & params % cpp % length , attr_array ) if ( ALLOCATED ( F % PSIp )) then dset = TRIM ( gname ) // \"/psi_p\" units = params % cpp % Bo * params % cpp % length ** 2 call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % PSIp ) end if if ( params % field_model ( 12 : 13 ). eq . '2D' ) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % Z ) if ( ALLOCATED ( F % FLAG2D )) then dset = TRIM ( gname ) // \"/Flag\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & F % FLAG2D ) end if if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % Z ) end if else if ( params % field_model ( 12 : 13 ). eq . '3D' ) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % Z ) if ( ALLOCATED ( F % FLAG3D )) then dset = TRIM ( gname ) // \"/Flag\" call rsave_3d_array_to_hdf5 ( h5file_id , dset , & F % FLAG3D ) end if if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % Z ) end if end if DEALLOCATE ( attr_array ) end if else if ( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then ALLOCATE ( attr_array ( 1 )) dset = TRIM ( gname ) // \"/dims\" attr_array ( 1 ) = \"Mesh dimension of the magnetic  & field (NR,NPHI,NZ)\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % dims , attr_array ) dset = TRIM ( gname ) // \"/R\" attr_array ( 1 ) = \"Radial position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % R * params % cpp % length , attr_array ) if ( ALLOCATED ( F % X % PHI )) then if ( F % Dim2x1t ) then dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , & F % X % PHI * params % cpp % time , attr_array ) else dset = TRIM ( gname ) // \"/PHI\" attr_array ( 1 ) = \"Azimuthal angle of the magnetic & field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % PHI , attr_array ) end if end if dset = TRIM ( gname ) // \"/Z\" attr_array ( 1 ) = \"Z position of the magnetic field grid nodes\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % X % Z * & params % cpp % length , attr_array ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Toroidal field at the magnetic axis in T\" call save_to_hdf5 ( h5file_id , dset , F % Bo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/Eo\" attr = \"Electric field at the magnetic axis in V/m\" call save_to_hdf5 ( h5file_id , dset , F % Eo * params % cpp % Eo , attr ) dset = TRIM ( gname ) // \"/E_dyn\" attr = \"Magnitude of dynamic E\" call save_to_hdf5 ( h5file_id , dset , F % E_dyn * params % cpp % Eo , attr ) dset = TRIM ( gname ) // \"/E_pulse\" attr = \"Magnitude of dynamic E\" call save_to_hdf5 ( h5file_id , dset , F % E_pulse * params % cpp % time , attr ) dset = TRIM ( gname ) // \"/E_width\" attr = \"Magnitude of dynamic E\" call save_to_hdf5 ( h5file_id , dset , F % E_width * params % cpp % time , attr ) dset = TRIM ( gname ) // \"/Ro\" attr = \"Radial position of magnetic axis\" call save_to_hdf5 ( h5file_id , dset , F % Ro * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Zo\" attr = \"Radial position of magnetic axis\" call save_to_hdf5 ( h5file_id , dset , F % Zo * params % cpp % length , attr ) dset = TRIM ( gname ) // \"/Axisymmetric\" attr = \"Radial position of magnetic axis\" if ( F % axisymmetric_fields ) then call save_to_hdf5 ( h5file_id , dset , 1_idef , attr ) else call save_to_hdf5 ( h5file_id , dset , 0_idef , attr ) end if if ( ALLOCATED ( F % PSIp )) then dset = TRIM ( gname ) // \"/psi_p\" units = params % cpp % Bo * params % cpp % length ** 2 call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % PSIp ) end if if ( ALLOCATED ( F % E_3D % R )) then dset = TRIM ( gname ) // \"/ER3D\" units = params % cpp % Eo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % E_3D % R ) end if if ( ALLOCATED ( F % E_3D % PHI )) then dset = TRIM ( gname ) // \"/EPHI3D\" units = params % cpp % Eo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % E_3D % PHI ) end if if ( ALLOCATED ( F % PSIp3D )) then dset = TRIM ( gname ) // \"/psi_p3D\" units = params % cpp % Bo * params % cpp % length ** 2 call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % PSIp3D ) end if if ( ALLOCATED ( F % FLAG2D )) then dset = TRIM ( gname ) // \"/Flag2D\" call rsave_2d_array_to_hdf5 ( h5file_id , dset , & F % FLAG2D ) end if if ( ALLOCATED ( F % FLAG3D )) then dset = TRIM ( gname ) // \"/Flag3D\" call rsave_3d_array_to_hdf5 ( h5file_id , dset , & F % FLAG3D ) end if if ( params % SC_E ) then dset = TRIM ( gname ) // \"/dt_E_SC\" attr = \"Time step for self-consistent E calculation\" call save_to_hdf5 ( h5file_id , dset , F % dt_E_SC , attr ) dset = TRIM ( gname ) // \"/Ip_exp\" attr = \"Scaling for self-consistent current density\" call save_to_hdf5 ( h5file_id , dset , F % Ip_exp , attr ) dset = TRIM ( gname ) // \"/Ip0\" attr = \"Total RE current normalization\" call save_to_hdf5 ( h5file_id , dset , F % Ip0 , attr ) dset = TRIM ( gname ) // \"/PSIP_1D\" attr_array ( 1 ) = \"1D minor radial mesh for & self-consistent fields\" call save_1d_array_to_hdf5 ( h5file_id , dset , F % PSIP_1D , attr_array ) end if if ( F % axisymmetric_fields . and . & . not .( params % field_model ( 10 : 12 ). eq . 'PSI' )) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % B_2D % Z ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_2D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_2D % Z ) end if else if ((. not . F % axisymmetric_fields ). and . & . not .( params % field_model ( 10 : 12 ). eq . 'PSI' )) then dset = TRIM ( gname ) // \"/BR\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % R ) dset = TRIM ( gname ) // \"/BPHI\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % PHI ) dset = TRIM ( gname ) // \"/BZ\" units = params % cpp % Bo call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % B_3D % Z ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then dset = TRIM ( gname ) // \"/gradBR\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % R ) dset = TRIM ( gname ) // \"/gradBPHI\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % PHI ) dset = TRIM ( gname ) // \"/gradBZ\" units = params % cpp % Bo / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % gradB_3D % Z ) dset = TRIM ( gname ) // \"/curlbR\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % R ) dset = TRIM ( gname ) // \"/curlbPHI\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % PHI ) dset = TRIM ( gname ) // \"/curlbZ\" units = 1. / params % cpp % length call rsave_3d_array_to_hdf5 ( h5file_id , dset , & units * F % curlb_3D % Z ) end if end if DEALLOCATE ( attr_array ) else if ( params % field_model . EQ . 'UNIFORM' ) then dset = TRIM ( gname ) // \"/Bo\" attr = \"Magnetic field in T\" call save_to_hdf5 ( h5file_id , dset , F % Bo * params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/Eo\" attr = \"Electric field in V/m\" call save_to_hdf5 ( h5file_id , dset , F % Eo * params % cpp % Eo , attr ) end if call h5gclose_f ( group_id , h5error ) ! Characteristic scales gname = \"scales\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/t\" attr = \"Characteristic time in secs\" call save_to_hdf5 ( h5file_id , dset , params % cpp % time , attr ) dset = TRIM ( gname ) // \"/m\" attr = \"Characteristic mass in kg\" call save_to_hdf5 ( h5file_id , dset , params % cpp % mass , attr ) dset = TRIM ( gname ) // \"/q\" attr = \"Characteristic charge in Coulombs\" call save_to_hdf5 ( h5file_id , dset , params % cpp % charge , attr ) dset = TRIM ( gname ) // \"/l\" attr = \"Characteristic length in m\" call save_to_hdf5 ( h5file_id , dset , params % cpp % length , attr ) dset = TRIM ( gname ) // \"/v\" attr = \"Characteristic velocity in m\" call save_to_hdf5 ( h5file_id , dset , params % cpp % velocity , attr ) dset = TRIM ( gname ) // \"/K\" attr = \"Characteristic kinetic energy in J\" call save_to_hdf5 ( h5file_id , dset , params % cpp % energy , attr ) dset = TRIM ( gname ) // \"/n\" attr = \"Characteristic plasma density in m&#94;-3\" call save_to_hdf5 ( h5file_id , dset , params % cpp % density , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Characteristic electric field in V/m\" call save_to_hdf5 ( h5file_id , dset , params % cpp % Eo , attr ) dset = TRIM ( gname ) // \"/B\" attr = \"Characteristic magnetic field in T\" call save_to_hdf5 ( h5file_id , dset , params % cpp % Bo , attr ) dset = TRIM ( gname ) // \"/P\" attr = \"Characteristic pressure in Pa\" call save_to_hdf5 ( h5file_id , dset , params % cpp % pressure , attr ) dset = TRIM ( gname ) // \"/T\" attr = \"Characteristic plasma temperature in J\" call save_to_hdf5 ( h5file_id , dset , params % cpp % temperature , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if end if end subroutine save_simulation_parameters","tags":"","loc":"proc/save_simulation_parameters.html"},{"title":"save_simulation_outputs – KORC-Full Orbit","text":"public subroutine save_simulation_outputs(params, spp, F) Note Subroutine that saves the electrons' variables specified in\n params::outputs_list to HDF5 files. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(in), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all\n the information\n of different electron species. See korc_types . type(FIELDS), intent(in) :: F Contents Source Code save_simulation_outputs Source Code subroutine save_simulation_outputs ( params , spp , F ) !! @note Subroutine that saves the electrons' variables specified in !! params::outputs_list to HDF5 files. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information !! of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: subgname !! String containing the subgroup name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HID_T ) :: subgroup_id !! HDF5 subgroup identifier. INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims !! Dimensions of data saved to HDF5 file. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rdata !! 1-D array of real data to be saved to HDF5 file. INTEGER , DIMENSION (:), ALLOCATABLE :: idata !!1-D array of integer data to be saved to HDF5 file. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array !! An 1-D array with attributes of 1-D real or integer arrays that are !! passed to KORC interfaces of HDF5 I/O subroutines. CHARACTER ( MAX_STRING_LENGTH ) :: attr !! A single attributes of real or integer data that is passed to KORC !! interfaces of HDF5 I/O subroutines. INTEGER :: h5error !!HDF5 error status. CHARACTER ( 19 ) :: tmp_str !!Temporary string used to manipulate various strings. REAL ( rp ) :: units !! Temporary variable used to add physical units to electrons' variables. INTEGER :: ss !! Electron species iterator. INTEGER :: jj !! Iterator for reading all the entried of params::outputs_list. LOGICAL :: object_exists !! Flag determining if a certain dataset is already present in !! the HDF5 output files. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: YY !! Temporary variable get proper units on vars%Y(1,:) and vars%Y(3,:), which !! are lengths, while keeping vars%Y(2,:), which is an angle if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Saving snapshot: \",I15)' ) & params % it / ( params % t_skip ) !write(output_unit_write,*) 'it',params%it,'t_skip',params%t_skip,'t_SC',params%t_it_SC end if if ( SIZE ( params % outputs_list ). GT . 1_idef ) then write ( tmp_str , '(I18)' ) params % mpi_params % rank filename = TRIM ( params % path_to_outputs ) // \"file_\" & // TRIM ( ADJUSTL ( tmp_str )) // \".h5\" call h5fopen_f ( TRIM ( filename ), H5F_ACC_RDWR_F , h5file_id , h5error ) ! Create group 'it' write ( tmp_str , '(I18)' ) params % it gname = TRIM ( ADJUSTL ( tmp_str )) call h5lexists_f ( h5file_id , TRIM ( gname ), object_exists , h5error ) if (. NOT . object_exists ) then ! Check if group does exist. call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/time\" attr = \"Simulation time in secs\" call save_to_hdf5 ( h5file_id , dset , params % init_time * params % cpp % time & + REAL ( params % it , rp ) * params % dt * params % cpp % time , attr ) do ss = 1_idef , params % num_species write ( tmp_str , '(I18)' ) ss subgname = \"spp_\" // TRIM ( ADJUSTL ( tmp_str )) call h5gcreate_f ( group_id , TRIM ( subgname ), subgroup_id , h5error ) do jj = 1_idef , SIZE ( params % outputs_list ) SELECT CASE ( TRIM ( params % outputs_list ( jj ))) CASE ( 'X' ) dset = \"X\" units = params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % X ) CASE ( 'Y' ) dset = \"Y\" units = params % cpp % length YY = spp ( ss )% vars % Y YY (:, 1 ) = units * YY (:, 1 ) YY (:, 3 ) = units * YY (:, 3 ) call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & YY ) DEALLOCATE ( YY ) CASE ( 'V' ) dset = \"V\" if ( params % orbit_model ( 1 : 2 ). eq . 'FO' ) then units = params % cpp % velocity call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % V ) else if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then YY = spp ( ss )% vars % V YY (:, 1 ) = YY (:, 1 ) * params % cpp % mass * params % cpp % velocity YY (:, 2 ) = YY (:, 2 ) * params % cpp % mass * & ( params % cpp % velocity ) ** 2 / params % cpp % Bo call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & YY ) DEALLOCATE ( YY ) end if CASE ( 'RHS' ) dset = \"RHS\" YY = spp ( ss )% vars % RHS units = params % cpp % length / params % cpp % time YY (:, 1 ) = YY (:, 1 ) * units YY (:, 2 ) = YY (:, 2 ) * units YY (:, 3 ) = YY (:, 3 ) * units units = params % cpp % mass * params % cpp % velocity / params % cpp % time YY (:, 4 ) = YY (:, 4 ) * units YY (:, 5 ) = YY (:, 5 ) * params % cpp % mass * & ( params % cpp % velocity ) ** 2 / params % cpp % Bo / params % cpp % time call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & YY ) DEALLOCATE ( YY ) CASE ( 'Rgc' ) dset = \"Rgc\" units = params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Rgc ) CASE ( 'g' ) dset = \"g\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % g ) CASE ( 'eta' ) dset = \"eta\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % eta ) CASE ( 'mu' ) dset = \"mu\" units = params % cpp % mass * params % cpp % velocity ** 2 / params % cpp % Bo call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % mu ) CASE ( 'Prad' ) dset = \"Prad\" units = params % cpp % mass * ( params % cpp % velocity ** 3 ) / & params % cpp % length call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Prad ) CASE ( 'Pin' ) dset = \"Pin\" units = params % cpp % mass * ( params % cpp % velocity ** 3 ) / & params % cpp % length call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Pin ) CASE ( 'flagCon' ) dset = \"flagCon\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & INT ( spp ( ss )% vars % flagCon , idef )) CASE ( 'flagCol' ) dset = \"flagCol\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & INT ( spp ( ss )% vars % flagCol , idef )) CASE ( 'B' ) dset = \"B\" units = params % cpp % Bo call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % B ) CASE ( 'gradB' ) if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then dset = \"gradB\" units = params % cpp % Bo / params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % gradB ) end if CASE ( 'curlb' ) if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then dset = \"curlb\" units = 1. / params % cpp % length call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % curlb ) end if CASE ( 'E' ) dset = \"E\" units = params % cpp % Eo call rsave_2d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % E ) CASE ( 'PSIp' ) dset = \"PSIp\" if (. not . params % field_model . eq . 'M3D_C1' ) then units = params % cpp % Bo * params % cpp % length ** 2 else units = 1._rp end if call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % PSI_P ) CASE ( 'AUX' ) dset = \"AUX\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % AUX ) CASE ( 'ne' ) dset = \"ne\" units = params % cpp % density call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % ne ) CASE ( 'Te' ) dset = \"Te\" units = params % cpp % temperature call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * spp ( ss )% vars % Te / C_E ) CASE ( 'Zeff' ) dset = \"Zeff\" call save_1d_array_to_hdf5 ( subgroup_id , dset , & spp ( ss )% vars % Zeff ) CASE ( 'J_SC' ) dset = \"J_SC\" if ( params % SC_E ) then call save_1d_array_to_hdf5 ( subgroup_id , dset , & F % J1_SC_1D % PHI ) end if CASE ( 'A_SC' ) dset = \"A_SC\" if ( params % SC_E ) then call save_1d_array_to_hdf5 ( subgroup_id , dset , & F % A1_SC_1D % PHI ) end if CASE ( 'E_SC' ) dset = \"E_SC\" units = params % cpp % Eo if ( params % SC_E ) then call save_1d_array_to_hdf5 ( subgroup_id , dset , & units * F % E_SC_1D % PHI ) end if CASE DEFAULT END SELECT end do call h5gclose_f ( subgroup_id , h5error ) end do call h5gclose_f ( group_id , h5error ) end if ! Check if group does exist. call h5fclose_f ( h5file_id , h5error ) end if end subroutine save_simulation_outputs","tags":"","loc":"proc/save_simulation_outputs.html"},{"title":"save_restart_variables – KORC-Full Orbit","text":"public subroutine save_restart_variables(params, spp, F) Note Subroutine that saves all the variables that KORC needs for\n restarting a simulation. These variables are saved to \"restart_file.h5\". Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params params Core KORC simulation parameters. type(SPECIES), intent(in), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing\n all the information of different electron species. See korc_types . type(FIELDS), intent(in) :: F Contents Source Code save_restart_variables Source Code subroutine save_restart_variables ( params , spp , F ) !! @note Subroutine that saves all the variables that KORC needs for !! restarting a simulation. These variables are saved to \"restart_file.h5\". TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! params Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: spp !! An instance of KORC's derived type SPECIES containing !! all the information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION (:), ALLOCATABLE :: send_buffer_rp , receive_buffer_rp !! Temporary buffer to be used by MPI to gather different electrons' !! variables. !! Temporary buffer to be used by MPI to gather different electrons' !! variables. INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: send_buffer_is , receive_buffer_is !! Temporary buffer to be used by MPI to gather different electrons' !! variables. !! Temporary buffer to be used by MPI to gather different electrons' !! variables. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: X REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: V REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J0_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J1_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J2_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: J3_SC REAL ( rp ), DIMENSION (:), ALLOCATABLE :: E_SC INTEGER ( is ), DIMENSION (:), ALLOCATABLE :: flagCon , flagCol CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a set of KORC parameters. CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HID_T ) :: subgroup_id !! HDF5 subgroup identifier. INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims !!  Dimensions of data saved to HDF5 file. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rdata !! 1-D array of real data to be saved to HDF5 file. INTEGER , DIMENSION (:), ALLOCATABLE :: idata !! 1-D array of integer data to be saved to HDF5 file. CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array !! An 1-D array with attributes of 1-D real or integer arrays that !! are passed to KORC interfaces of HDF5 I/O subroutines. CHARACTER ( MAX_STRING_LENGTH ) :: attr !! A single attributes of real or integer data that is passed to KORC !! interfaces of HDF5 I/O subroutines. INTEGER :: h5error !! HDF5 error status. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. REAL ( rp ) :: units !! Temporary variable used to add physical units to restart variables. INTEGER :: ss , jj !! Electron species iterator. !! Iterator for reading all the entried of params::outputs_list. INTEGER :: mpierr !! MPI error status. INTEGER :: numel_send , numel_receive !! Variable used by MPI to count the amount of data sent by each MPI !! procces. !! Variable used by MPI to count the amount of data received by the main !! MPI procces. !    if ( MODULO(params%it,params%restart_output_cadence) .EQ. 0_ip ) then if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , '(\"Saving restart: \",I15)' ) & params % it / ( params % t_skip * params % t_it_SC ) filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) dset = \"it\" attr = \"Iteration\" call save_to_hdf5 ( h5file_id , dset , params % it , attr ) dset = \"time\" attr = \"Current simulation time in secs\" call save_to_hdf5 ( h5file_id , dset , params % init_time * params % cpp % time & + REAL ( params % it , rp ) * params % dt * params % cpp % time , attr ) dset = \"simulation_time\" attr = \"Total simulation time in secs\" call save_to_hdf5 ( h5file_id , dset , params % simulation_time * & params % cpp % time , attr ) dset = \"snapshot_frequency\" attr = \"Snapshot frequency in secs\" call save_to_hdf5 ( h5file_id , dset , params % snapshot_frequency * & params % cpp % time , attr ) dset = \"dt\" attr = \"Time step in secs\" call save_to_hdf5 ( h5file_id , dset , params % dt * params % cpp % time , attr ) dset = \"t_steps\" attr = \"Time steps in simulation\" call save_to_hdf5 ( h5file_id , dset , params % t_steps , attr ) dset = \"output_cadence\" attr = \"Output cadence\" call save_to_hdf5 ( h5file_id , dset , params % output_cadence , attr ) dset = \"restart_output_cadence\" attr = \"Restart output cadence\" call save_to_hdf5 ( h5file_id , dset , params % restart_output_cadence , attr ) dset = \"num_snapshots\" attr = \"Number of snapshots in time for saving simulation variables\" call save_to_hdf5 ( h5file_id , dset , params % num_snapshots , attr ) if ( F % ReInterp_2x1t ) then dset = \"ind_2x1t\" attr = \"ReInterp_2x1t iteration\" call save_to_hdf5 ( h5file_id , dset , F % ind_2x1t , attr ) end if end if do ss = 1_idef , params % num_species numel_send = 3_idef * spp ( ss )% ppp numel_receive = 3_idef * spp ( ss )% ppp * params % mpi_params % nmpi if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( X ( spp ( ss )% ppp * params % mpi_params % nmpi , 3 )) ALLOCATE ( V ( spp ( ss )% ppp * params % mpi_params % nmpi , 3 )) ALLOCATE ( g ( spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( flagCon ( spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( flagCol ( spp ( ss )% ppp * params % mpi_params % nmpi )) end if ALLOCATE ( send_buffer_rp ( numel_send )) ALLOCATE ( receive_buffer_rp ( numel_receive )) if ( params % orbit_model ( 1 : 2 ). EQ . 'FO' ) then send_buffer_rp = RESHAPE ( spp ( ss )% vars % X ,( / numel_send / )) else if ( params % orbit_model ( 1 : 2 ). EQ . 'GC' ) then send_buffer_rp = RESHAPE ( spp ( ss )% vars % Y ,( / numel_send / )) end if receive_buffer_rp = 0.0_rp CALL MPI_GATHER ( send_buffer_rp , numel_send , MPI_REAL8 , & receive_buffer_rp , numel_send , MPI_REAL8 , 0 , MPI_COMM_WORLD , & mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then X = RESHAPE ( receive_buffer_rp ,( / spp ( ss )% ppp * & params % mpi_params % nmpi , 3 / )) end if send_buffer_rp = RESHAPE ( spp ( ss )% vars % V ,( / numel_send / )) receive_buffer_rp = 0.0_rp CALL MPI_GATHER ( send_buffer_rp , numel_send , MPI_REAL8 , & receive_buffer_rp , numel_send , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then V = RESHAPE ( receive_buffer_rp ,( / spp ( ss )% ppp * & params % mpi_params % nmpi , 3 / )) end if DEALLOCATE ( send_buffer_rp ) DEALLOCATE ( receive_buffer_rp ) numel_send = spp ( ss )% ppp numel_receive = spp ( ss )% ppp * params % mpi_params % nmpi ALLOCATE ( send_buffer_is ( numel_send )) ALLOCATE ( receive_buffer_is ( numel_receive )) send_buffer_is = spp ( ss )% vars % flagCon receive_buffer_is = 0_is CALL MPI_GATHER ( send_buffer_is , numel_send , MPI_INTEGER1 , & receive_buffer_is , numel_send ,& MPI_INTEGER1 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then flagCon = receive_buffer_is end if send_buffer_is = spp ( ss )% vars % flagCol receive_buffer_is = 0_is CALL MPI_GATHER ( send_buffer_is , numel_send , MPI_INTEGER1 , & receive_buffer_is , numel_send ,& MPI_INTEGER1 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then flagCol = receive_buffer_is end if DEALLOCATE ( send_buffer_is ) DEALLOCATE ( receive_buffer_is ) ALLOCATE ( send_buffer_rp ( numel_send )) ALLOCATE ( receive_buffer_rp ( numel_receive )) send_buffer_rp = spp ( ss )% vars % g receive_buffer_rp = 0_rp CALL MPI_GATHER ( send_buffer_rp , numel_send , MPI_REAL8 , & receive_buffer_rp , numel_send ,& MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then g = receive_buffer_rp end if DEALLOCATE ( send_buffer_rp ) DEALLOCATE ( receive_buffer_rp ) if ( params % mpi_params % rank . EQ . 0_idef ) then write ( tmp_str , '(I18)' ) ss subgname = \"spp_\" // TRIM ( ADJUSTL ( tmp_str )) call h5gcreate_f ( h5file_id , TRIM ( subgname ), group_id , h5error ) dset = \"X\" call rsave_2d_array_to_hdf5 ( group_id , dset , X ) dset = \"V\" call rsave_2d_array_to_hdf5 ( group_id , dset , V ) dset = \"flagCon\" call save_1d_array_to_hdf5 ( group_id , dset , INT ( flagCon , idef )) dset = \"flagCol\" call save_1d_array_to_hdf5 ( group_id , dset , INT ( flagCol , idef )) dset = \"g\" call save_1d_array_to_hdf5 ( group_id , dset , g ) if ( params % SC_E ) then ALLOCATE ( J0_SC ( F % dim_1D )) ALLOCATE ( J1_SC ( F % dim_1D )) ALLOCATE ( J2_SC ( F % dim_1D )) ALLOCATE ( J3_SC ( F % dim_1D )) ALLOCATE ( E_SC ( F % dim_1D )) J0_SC = F % J1_SC_1D % PHI / F % Ip0 J1_SC = F % J1_SC_1D % PHI J2_SC = F % J2_SC_1D % PHI J3_SC = F % J3_SC_1D % PHI E_SC = F % E_SC_1D % PHI dset = \"J0_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J0_SC ) dset = \"J1_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J1_SC ) dset = \"J2_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J2_SC ) dset = \"J3_SC\" call save_1d_array_to_hdf5 ( group_id , dset , J3_SC ) dset = \"E_SC\" call save_1d_array_to_hdf5 ( group_id , dset , E_SC ) DEALLOCATE ( J0_SC ) DEALLOCATE ( J1_SC ) DEALLOCATE ( J2_SC ) DEALLOCATE ( J3_SC ) DEALLOCATE ( E_SC ) end if call h5gclose_f ( group_id , h5error ) end if if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( X ) DEALLOCATE ( V ) DEALLOCATE ( g ) DEALLOCATE ( flagCon ) DEALLOCATE ( flagCol ) end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then call h5fclose_f ( h5file_id , h5error ) end if !    end if end subroutine save_restart_variables","tags":"","loc":"proc/save_restart_variables.html"},{"title":"load_time_stepping_params – KORC-Full Orbit","text":"public subroutine load_time_stepping_params(params) Note Subroutine that loads KORC parameters that control the time\n stepping in main . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code load_time_stepping_params Source Code subroutine load_time_stepping_params ( params ) !! @note Subroutine that loads KORC parameters that control the time !! stepping in [[main]]. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. REAL ( KIND = 8 ) :: real_number !! A temporary real number. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !!  MPI error status. INTEGER :: ss !! Electron species iterator. if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) end if dset = \"/it\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % ito = INT ( real_number , ip ) + 1_ip dset = \"/dt\" call load_from_hdf5 ( h5file_id , dset , params % dt ) dset = \"/t_steps\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % t_steps = INT ( real_number , ip ) dset = \"/simulation_time\" call load_from_hdf5 ( h5file_id , dset , params % simulation_time ) dset = \"/snapshot_frequency\" call load_from_hdf5 ( h5file_id , dset , params % snapshot_frequency ) dset = \"/output_cadence\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % output_cadence = INT ( real_number , ip ) dset = \"/restart_output_cadence\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % restart_output_cadence = INT ( real_number , ip ) dset = \"/num_snapshots\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % num_snapshots = INT ( real_number , ip ) call h5fclose_f ( h5file_id , h5error ) end if CALL MPI_BCAST ( params % ito , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % dt , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % t_steps , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % simulation_time , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % snapshot_frequency , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , & mpierr ) CALL MPI_BCAST ( params % output_cadence , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % restart_output_cadence , 1 , MPI_INTEGER8 , 0 , & MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( params % num_snapshots , 1 , MPI_INTEGER8 , 0 , MPI_COMM_WORLD , mpierr ) end subroutine load_time_stepping_params","tags":"","loc":"proc/load_time_stepping_params.html"},{"title":"load_prev_time – KORC-Full Orbit","text":"public subroutine load_prev_time(params) Note Subroutine that loads KORC parameters that control the time\n stepping in main . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code load_prev_time Source Code subroutine load_prev_time ( params ) !! @note Subroutine that loads KORC parameters that control the time !! stepping in [[main]]. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. REAL ( KIND = 8 ) :: real_number !! A temporary real number. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !!  MPI error status. INTEGER :: ss !! Electron species iterator. if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) end if dset = \"/time\" call load_from_hdf5 ( h5file_id , dset , params % init_time ) call h5fclose_f ( h5file_id , h5error ) end if CALL MPI_BCAST ( params % init_time , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) end subroutine load_prev_time","tags":"","loc":"proc/load_prev_time.html"},{"title":"load_prev_iter – KORC-Full Orbit","text":"public subroutine load_prev_iter(params) Note Subroutine that loads KORC parameters that control the time\n stepping in main . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code load_prev_iter Source Code subroutine load_prev_iter ( params ) !! @note Subroutine that loads KORC parameters that control the time !! stepping in [[main]]. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. REAL ( KIND = 8 ) :: real_number !! A temporary real number. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !!  MPI error status. INTEGER :: ss !! Electron species iterator. if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) end if dset = \"/ind_2x1t\" call load_from_hdf5 ( h5file_id , dset , real_number ) params % prev_iter_2x1t = INT ( real_number , ip ) call h5fclose_f ( h5file_id , h5error ) end if CALL MPI_BCAST ( params % prev_iter_2x1t , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) end subroutine load_prev_iter","tags":"","loc":"proc/load_prev_iter.html"},{"title":"load_particles_ic – KORC-Full Orbit","text":"public subroutine load_particles_ic(params, spp, F) Note Subroutine that loads all the electrons' data from\n \"restart_file.h5\" to restart a simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the\n information of different electron species. See korc_types.f90. type(FIELDS), intent(inout) :: F Contents Source Code load_particles_ic Source Code subroutine load_particles_ic ( params , spp , F ) !! @note Subroutine that loads all the electrons' data from !! \"restart_file.h5\" to restart a simulation. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the !! information of different electron species. See korc_types.f90. TYPE ( FIELDS ), INTENT ( INOUT ) :: F REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X_send_buffer !! Temporary buffer used by MPI for scattering the electrons' position !! to different MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X_receive_buffer !! Temporary buffer used by MPI for scattering the electrons' position !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V_send_buffer !! Temporary buffer used by MPI for scattering the electrons' velocity !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V_receive_buffer !! Temporary buffer used by MPI for scattering the electrons' velocity !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: AUX_send_buffer !!  Temporary buffer used by MPI to scatter various electrons' variables !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: AUX_receive_buffer !! Temporary buffer used by MPI to scatter various electrons' variables !! among MPI processes. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC0_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC1_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC2_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: JSC3_buffer REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ESC_buffer CHARACTER ( MAX_STRING_LENGTH ) :: filename !! String containing the name of the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !! Name of data set to be saved to file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. CHARACTER ( 19 ) :: tmp_str !! Temporary string used to manipulate various strings. INTEGER :: h5error !! HDF5 error status. INTEGER :: mpierr !! Electron species iterator. INTEGER :: ss !! MPI error status. do ss = 1_idef , params % num_species ALLOCATE ( X_send_buffer ( 3 * spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( X_receive_buffer ( 3 * spp ( ss )% ppp )) ALLOCATE ( V_send_buffer ( 3 * spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( V_receive_buffer ( 3 * spp ( ss )% ppp )) ALLOCATE ( AUX_send_buffer ( spp ( ss )% ppp * params % mpi_params % nmpi )) ALLOCATE ( AUX_receive_buffer ( spp ( ss )% ppp )) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/X\" call load_array_from_hdf5 ( h5file_id , dset , X_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if X_receive_buffer = 0.0_rp CALL MPI_SCATTER ( X_send_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , & X_receive_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) if ( params % orbit_model ( 1 : 2 ). EQ . 'FO' ) then spp ( ss )% vars % X = RESHAPE ( X_receive_buffer ,( / spp ( ss )% ppp , 3 / )) else if ( params % orbit_model ( 1 : 2 ). EQ . 'GC' ) then spp ( ss )% vars % Y = RESHAPE ( X_receive_buffer ,( / spp ( ss )% ppp , 3 / )) spp ( ss )% vars % Y (:, 2 ) = modulo ( spp ( ss )% vars % Y (:, 2 ), 2 * C_PI ) end if if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/V\" call load_array_from_hdf5 ( h5file_id , dset , V_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if V_receive_buffer = 0.0_rp CALL MPI_SCATTER ( V_send_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , & V_receive_buffer , 3 * spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % V = RESHAPE ( V_receive_buffer ,( / spp ( ss )% ppp , 3 / )) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/flagCon\" call load_array_from_hdf5 ( h5file_id , dset , AUX_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if AUX_receive_buffer = 0.0_rp CALL MPI_SCATTER ( AUX_send_buffer , spp ( ss )% ppp , MPI_REAL8 , & AUX_receive_buffer , spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % flagCon = INT ( AUX_receive_buffer , is ) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/flagCol\" call load_array_from_hdf5 ( h5file_id , dset , AUX_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if AUX_receive_buffer = 0.0_rp CALL MPI_SCATTER ( AUX_send_buffer , spp ( ss )% ppp , MPI_REAL8 , & AUX_receive_buffer , spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % flagCol = INT ( AUX_receive_buffer , is ) if ( params % mpi_params % rank . EQ . 0_idef ) then filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/g\" call load_array_from_hdf5 ( h5file_id , dset , AUX_send_buffer ) call h5fclose_f ( h5file_id , h5error ) end if AUX_receive_buffer = 0.0_rp CALL MPI_SCATTER ( AUX_send_buffer , spp ( ss )% ppp , MPI_REAL8 , & AUX_receive_buffer , spp ( ss )% ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) spp ( ss )% vars % g = AUX_receive_buffer if ( params % SC_E ) then ALLOCATE ( JSC0_buffer ( F % dim_1D )) ALLOCATE ( JSC1_buffer ( F % dim_1D )) ALLOCATE ( JSC2_buffer ( F % dim_1D )) ALLOCATE ( JSC3_buffer ( F % dim_1D )) ALLOCATE ( ESC_buffer ( F % dim_1D )) filename = TRIM ( params % path_to_outputs ) // \"restart_file.h5\" call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: & &load_particles_ic --> h5fopen_f\")' ) call KORC_ABORT () end if write ( tmp_str , '(I18)' ) ss dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J0_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC0_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J1_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC1_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J2_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC2_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/J3_SC\" call load_array_from_hdf5 ( h5file_id , dset , JSC3_buffer ) dset = \"/spp_\" // TRIM ( ADJUSTL ( tmp_str )) // \"/E_SC\" call load_array_from_hdf5 ( h5file_id , dset , ESC_buffer ) call h5fclose_f ( h5file_id , h5error ) F % J0_SC_1D % PHI = JSC0_buffer F % J1_SC_1D % PHI = JSC1_buffer F % J2_SC_1D % PHI = JSC2_buffer F % J3_SC_1D % PHI = JSC3_buffer F % E_SC_1D % PHI = ESC_buffer / params % cpp % Eo DEALLOCATE ( JSC0_buffer ) DEALLOCATE ( JSC1_buffer ) DEALLOCATE ( JSC2_buffer ) DEALLOCATE ( JSC3_buffer ) DEALLOCATE ( ESC_buffer ) end if DEALLOCATE ( X_send_buffer ) DEALLOCATE ( X_receive_buffer ) DEALLOCATE ( V_send_buffer ) DEALLOCATE ( V_receive_buffer ) DEALLOCATE ( AUX_send_buffer ) DEALLOCATE ( AUX_receive_buffer ) end do if ( params % orbit_model ( 1 : 2 ). EQ . 'GC' ) then params % GC_coords = . TRUE . end if end subroutine load_particles_ic","tags":"","loc":"proc/load_particles_ic.html"},{"title":"load_from_hdf5 – KORC-Full Orbit","text":"public interface load_from_hdf5 Note Fortran interface to subroutines loading a real or integer\n value from HDF5 files. Contents Module Procedures iload_from_hdf5 rload_from_hdf5 Module Procedures private subroutine iload_from_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(out) :: idatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr private subroutine rload_from_hdf5 (h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(out) :: rdatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr","tags":"","loc":"interface/load_from_hdf5.html"},{"title":"load_array_from_hdf5 – KORC-Full Orbit","text":"public interface load_array_from_hdf5 Note Fortran interface to subroutines loading 2-D and 3-D arrays\n of real values from HDF5 files. Contents Module Procedures rload_1d_array_from_hdf5 rload_3d_array_from_hdf5 rload_2d_array_from_hdf5 Module Procedures private subroutine rload_1d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(out), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rload_3d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rload_2d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr","tags":"","loc":"interface/load_array_from_hdf5.html"},{"title":"save_to_hdf5 – KORC-Full Orbit","text":"public interface save_to_hdf5 Note Fortran interface to subroutines saving real or integer\n values to HDF5 files. Contents Module Procedures i1save_to_hdf5 i2save_to_hdf5 i4save_to_hdf5 i8save_to_hdf5 rsave_to_hdf5 Module Procedures private subroutine i1save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=1), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i2save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=2), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i4save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=4), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i8save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=8), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine rsave_to_hdf5 (h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in) :: rdatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr","tags":"","loc":"interface/save_to_hdf5.html"},{"title":"save_1d_array_to_hdf5 – KORC-Full Orbit","text":"public interface save_1d_array_to_hdf5 Contents Module Procedures isave_1d_array_to_hdf5 rsave_1d_array_to_hdf5 Module Procedures private subroutine isave_1d_array_to_hdf5 (h5file_id, dset, idata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(in), DIMENSION(:) :: idata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_1d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr","tags":"","loc":"interface/save_1d_array_to_hdf5.html"},{"title":"save_2d_array_to_hdf5 – KORC-Full Orbit","text":"public interface save_2d_array_to_hdf5 Contents Module Procedures rsave_2d_array_to_hdf5 Module Procedures private subroutine rsave_2d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr","tags":"","loc":"interface/save_2d_array_to_hdf5.html"},{"title":"save_3d_array_to_hdf5 – KORC-Full Orbit","text":"public interface save_3d_array_to_hdf5 Contents Module Procedures rsave_3d_array_to_hdf5 Module Procedures public subroutine rsave_3d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr","tags":"","loc":"interface/save_3d_array_to_hdf5.html"},{"title":"save_array_to_hdf5 – KORC-Full Orbit","text":"public interface save_array_to_hdf5 Contents Module Procedures isave_1d_array_to_hdf5 rsave_1d_array_to_hdf5 rsave_2d_array_to_hdf5 rsave_3d_array_to_hdf5 Module Procedures private subroutine isave_1d_array_to_hdf5 (h5file_id, dset, idata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(in), DIMENSION(:) :: idata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_1d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_2d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public subroutine rsave_3d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr","tags":"","loc":"interface/save_array_to_hdf5.html"},{"title":"deg2rad – KORC-Full Orbit","text":"private function deg2rad(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code deg2rad Source Code FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad","tags":"","loc":"proc/deg2rad~2.html"},{"title":"rad2deg – KORC-Full Orbit","text":"private function rad2deg(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code rad2deg Source Code FUNCTION rad2deg ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: rad2deg rad2deg = 18 0.0_rp * x / C_PI END FUNCTION rad2deg","tags":"","loc":"proc/rad2deg.html"},{"title":"fRE – KORC-Full Orbit","text":"private function fRE(eta, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p Return Value real(kind=rp) Contents Source Code fRE Source Code FUNCTION fRE ( eta , p ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRE REAL ( rp ) :: A A = ( 2.0_rp * pdf_params % E / ( pdf_params % Zeff + 1.0_rp )) * ( p ** 2 / SQRT ( p ** 2.0_rp + 1.0_rp )) fRE = 0.5_rp * A * EXP ( A * COS ( deg2rad ( eta ))) / SINH ( A ) !\tfRE = fRE*PR(eta,p,pdf_params%Bo,pdf_params%lambda) END FUNCTION fRE","tags":"","loc":"proc/fre~2.html"},{"title":"random_norm – KORC-Full Orbit","text":"private function random_norm(mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Contents Source Code random_norm Source Code FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = SQRT ( - 2.0_rp * LOG ( 1.0_rp - rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm","tags":"","loc":"proc/random_norm~3.html"},{"title":"IntK – KORC-Full Orbit","text":"private function IntK(v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code IntK Source Code FUNCTION IntK ( v , x ) IMPLICIT NONE REAL ( rp ) :: IntK REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: x IntK = ( C_PI / SQRT ( 2.0_rp )) * ( 1.0_rp - 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp )) * ERFC ( SQRT ( x ))& + 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp ) * SQRT ( 0.5_rp * C_PI / x ) * EXP ( - x ) END FUNCTION IntK","tags":"","loc":"proc/intk.html"},{"title":"besselk – KORC-Full Orbit","text":"public function besselk(v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code besselk Source Code FUNCTION besselk ( v , x ) IMPLICIT NONE REAL ( rp ) :: besselk REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ), INTENT ( IN ) :: v REAL ( 4 ) :: ri , rk , rip , rkp call bessik ( REAL ( x , 4 ), REAL ( v , 4 ), ri , rk , rip , rkp ) besselk = REAL ( rk , rp ) END FUNCTION besselk","tags":"","loc":"proc/besselk.html"},{"title":"IntBesselK – KORC-Full Orbit","text":"private function IntBesselK(a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b Return Value real(kind=rp) Contents Source Code IntBesselK Source Code FUNCTION IntBesselK ( a , b ) REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ) :: IntBesselK REAL ( rp ) :: Iold REAL ( rp ) :: Inew REAL ( rp ) :: rerr REAL ( rp ) :: sum_f REAL ( rp ) :: v , h , z INTEGER :: ii , jj , npoints LOGICAL :: flag v = 5.0_rp / 3.0_rp h = b - a sum_f = 0.5 * ( besselk ( v , a ) + besselk ( v , b )) Iold = 0.0_rp Inew = sum_f * h ii = 1_idef flag = . TRUE . do while ( flag ) Iold = Inew ii = ii + 1_idef npoints = 2_idef ** ( ii - 2_idef ) h = 0.5_rp * ( b - a ) / REAL ( npoints , rp ) sum_f = 0.0_rp do jj = 1_idef , npoints z = a + h + 2.0_rp * ( REAL ( jj , rp ) - 1.0_rp ) * h sum_f = sum_f + besselk ( v , z ) end do Inew = 0.5_rp * Iold + sum_f * h rerr = ABS (( Inew - Iold ) / Iold ) flag = . NOT .( rerr . LT . Tol ) end do IntBesselK = Inew END FUNCTION IntBesselK","tags":"","loc":"proc/intbesselk.html"},{"title":"PR – KORC-Full Orbit","text":"private function PR(eta, p, Bo, l) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p real(kind=rp), intent(in) :: Bo real(kind=rp), intent(in) :: l Return Value real(kind=rp) Contents Source Code PR Source Code FUNCTION PR ( eta , p , Bo , l ) REAL ( rp ), INTENT ( IN ) :: eta ! in radians REAL ( rp ), INTENT ( IN ) :: p ! dimensionless (in units of mc) REAL ( rp ), INTENT ( IN ) :: Bo REAL ( rp ), INTENT ( IN ) :: l REAL ( rp ) :: PR REAL ( rp ) :: g REAL ( rp ) :: v REAL ( rp ) :: k REAL ( rp ) :: lc REAL ( rp ) :: z REAL ( rp ) :: Pi g = SQRT ( p ** 2 + 1.0_rp ) v = C_C * SQRT ( 1.0_rp - 1.0_rp / g ** 2 ) k = C_E * Bo * SIN ( deg2rad ( eta )) / ( g * C_ME * v ) lc = ( 4.0_rp * C_PI / 3.0_rp ) / ( k * g ** 3 ) ! Critical wavelength z = lc / l call P_integral ( z , Pi ) PR = ( C_C * C_E ** 2 ) * Pi / ( SQRT ( 3.0_rp ) * C_E0 * g ** 2 * l ** 3 ) END FUNCTION PR","tags":"","loc":"proc/pr.html"},{"title":"get_equilibrium_distribution – KORC-Full Orbit","text":"public subroutine get_equilibrium_distribution(params, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(in) :: go real(kind=rp), intent(out) :: etao Contents Source Code get_equilibrium_distribution Source Code SUBROUTINE get_equilibrium_distribution ( params , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( IN ) :: go REAL ( rp ), INTENT ( OUT ) :: etao call initialize_params ( params , go ) call save_params ( params ) call sample_distribution ( params , eta , etao ) END SUBROUTINE get_equilibrium_distribution","tags":"","loc":"proc/get_equilibrium_distribution.html"},{"title":"initialize_params – KORC-Full Orbit","text":"private subroutine initialize_params(params, go) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: go Contents Source Code initialize_params Source Code SUBROUTINE initialize_params ( params , go ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: go !REAL(rp) :: max_pitch_angle !REAL(rp) :: min_pitch_angle !REAL(rp) :: Zeff !REAL(rp) :: E !REAL(rp) :: Bo !REAL(rp) :: lambda !NAMELIST /SimpleEquilibriumPDF/ max_pitch_angle,min_pitch_angle,Zeff,E,Bo,lambda !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=SimpleEquilibriumPDF) !close(default_unit_open) pdf_params % max_pitch_angle = max_pitch_angle_simple pdf_params % min_pitch_angle = min_pitch_angle_simple pdf_params % Zeff = Zeff_simple pdf_params % E = E_simple pdf_params % Bo = Bo_simple pdf_params % lambda = lambda_simple pdf_params % po = sqrt ( go ** 2 - 1.0_rp ) END SUBROUTINE initialize_params","tags":"","loc":"proc/initialize_params.html"},{"title":"P_integral – KORC-Full Orbit","text":"private subroutine P_integral(z, P) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: z real(kind=rp), intent(out) :: P Contents Source Code P_integral Source Code SUBROUTINE P_integral ( z , P ) REAL ( rp ), INTENT ( OUT ) :: P REAL ( rp ), INTENT ( IN ) :: z REAL ( rp ) :: a P = 0.0_rp IF ( z . LT . 0.5_rp ) THEN a = ( 2.16_rp / 2.0_rp ** ( 2.0_rp / 3.0_rp )) * z ** ( 1.0_rp / 3.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE IF (( z . GE . 0.5_rp ). AND .( z . LT . 2.5_rp )) THEN a = 0.72_rp * ( z + 1.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE P = IntK ( 5.0_rp / 3.0_rp , z ) END IF END SUBROUTINE P_integral","tags":"","loc":"proc/p_integral.html"},{"title":"sample_distribution – KORC-Full Orbit","text":"private subroutine sample_distribution(params, eta, etao) Transient * ! Transient * ! Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: etao Contents Source Code sample_distribution Source Code SUBROUTINE sample_distribution ( params , eta , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: etao REAL ( rp ) :: go_root REAL ( rp ) :: etao_root REAL ( rp ) :: eta_buffer , eta_test REAL ( rp ) :: ratio , rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax , min_pitch_angle , max_pitch_angle REAL ( rp ) :: deta LOGICAL :: leta INTEGER :: num_accepted INTEGER :: ii , jj , ppp , nsamples INTEGER :: mpierr ppp = SIZE ( eta ) nsamples = ppp * params % mpi_params % nmpi deta = ( pdf_params % max_pitch_angle - pdf_params % min_pitch_angle ) / 10 0.0_rp if ( pdf_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = pdf_params % min_pitch_angle end if do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax end if end do !\twrite(output_unit_write,*) min_pitch_angle,max_pitch_angle if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes !* * * Transient * * *! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_buffer = pdf_params % min_pitch_angle + ( pdf_params % max_pitch_angle - pdf_params % min_pitch_angle ) * rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . pdf_params % max_pitch_angle ). OR .( ABS ( eta_test ) . LT . pdf_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) end do ratio = fRE ( eta_test , pdf_params % po ) / fRE ( eta_buffer , pdf_params % po ) if ( ratio . GE . 1.0_rp ) then eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then eta_buffer = eta_test ii = ii + 1_idef end if end if end do !* * * Transient * * *! eta_tmp ( 1 ) = eta_buffer call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR .( ABS ( eta_test ) . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) end do ratio = fRE ( eta_test , pdf_params % po ) / fRE ( eta_tmp ( ii - 1 ), pdf_params % po ) if ( ratio . GE . 1.0_rp ) then eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) leta = ( eta_tmp ( ii ). LE . pdf_params % max_pitch_angle ). AND .( eta_tmp ( ii ). GE . pdf_params % min_pitch_angle ) if ( leta ) then num_accepted = num_accepted + 1_idef eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do end do etao = SUM ( eta_samples ) / nsamples end if CALL MPI_SCATTER ( eta_samples , ppp , MPI_REAL8 , eta , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( etao , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( eta_samples ) DEALLOCATE ( eta_tmp ) end if END SUBROUTINE sample_distribution","tags":"","loc":"proc/sample_distribution.html"},{"title":"save_params – KORC-Full Orbit","text":"private subroutine save_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_params Source Code SUBROUTINE save_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simple_equilibrium_pdf.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Zeff , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % E , attr ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Characteristic magnetic field in T (in case of using PR)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Bo , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Characteristic wavelength in m (in case of using PR)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % lambda , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_params","tags":"","loc":"proc/save_params.html"},{"title":"VTe_wu – KORC-Full Orbit","text":"private function VTe_wu(Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Te In Joules Return Value real(kind=rp) Contents Source Code VTe_wu Source Code function VTe_wu ( Te ) REAL ( rp ), INTENT ( IN ) :: Te !! In Joules REAL ( rp ) :: VTe_wu VTe_wu = SQRT ( 2.0_rp * Te / C_ME ) end function VTe_wu","tags":"","loc":"proc/vte_wu.html"},{"title":"VTe – KORC-Full Orbit","text":"private function VTe(Te) Dimensionless temperature Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code VTe Source Code function VTe ( Te ) !! Dimensionless temperature REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: VTe VTe = SQRT ( 2.0_rp * Te ) * cparams_ss % VTeo end function VTe","tags":"","loc":"proc/vte.html"},{"title":"Gammac_wu – KORC-Full Orbit","text":"private function Gammac_wu(params, ne, Te) With units Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code Gammac_wu Source Code function Gammac_wu ( params , ne , Te ) !! With units TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: Gammac_wu Gammac_wu = ne * CLogee_wu ( params , ne , Te ) * cparams_ss % Gammaco end function Gammac_wu","tags":"","loc":"proc/gammac_wu.html"},{"title":"Gammacee – KORC-Full Orbit","text":"private function Gammacee(v, ne, Te) Dimensionless ne and Te Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code Gammacee Source Code function Gammacee ( v , ne , Te ) !! Dimensionless ne and Te REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: Gammacee Gammacee = ne * CLogee ( v , ne , Te ) * cparams_ss % Gammaco end function Gammacee","tags":"","loc":"proc/gammacee.html"},{"title":"CLog_wu – KORC-Full Orbit","text":"private function CLog_wu(ne, Te) With units Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLog_wu Source Code function CLog_wu ( ne , Te ) !! With units REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLog_wu CLog_wu = 2 5.3_rp - 1.15_rp * LOG10 ( 1E-6_rp * ne ) + 2.3_rp * LOG10 ( Te / C_E ) end function CLog_wu","tags":"","loc":"proc/clog_wu.html"},{"title":"CLog0_wu – KORC-Full Orbit","text":"public function CLog0_wu(ne, Te) With units Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLog0_wu Source Code function CLog0_wu ( ne , Te ) !! With units REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLog0_wu CLog0_wu = 1 4.9_rp - LOG ( 1E-20_rp * ne ) / 2._rp + LOG ( 1E-3_rp * Te / C_E ) end function CLog0_wu","tags":"","loc":"proc/clog0_wu.html"},{"title":"CLogee_wu – KORC-Full Orbit","text":"public function CLogee_wu(params, ne, Te) With units Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLogee_wu Source Code function CLogee_wu ( params , ne , Te ) !! With units TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogee_wu REAL ( rp ) :: k = 5._rp CLogee_wu = CLog0_wu ( ne , Te ) + & log ( 1 + ( 2 * ( params % minimum_particle_g - 1 ) / & ( VTe_wu ( Te ) / C_C ) ** 2 ) ** ( k / 2._rp )) / k end function CLogee_wu","tags":"","loc":"proc/clogee_wu.html"},{"title":"CLogei_wu – KORC-Full Orbit","text":"public function CLogei_wu(params, ne, Te) With units Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLogei_wu Source Code function CLogei_wu ( params , ne , Te ) !! With units TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogei_wu REAL ( rp ) :: k = 5._rp REAL ( rp ) :: p p = sqrt ( params % minimum_particle_g ** 2 - 1 ) CLogei_wu = CLog0_wu ( ne , Te ) + & log ( 1 + ( 2 * p / ( VTe_wu ( Te ) / C_C )) ** k ) / k end function CLogei_wu","tags":"","loc":"proc/clogei_wu.html"},{"title":"CLog – KORC-Full Orbit","text":"private function CLog(ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLog Source Code function CLog ( ne , Te ) ! Dimensionless ne and Te REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CLog CLog = 2 5.3_rp - 1.15_rp * LOG10 ( ne ) + 2.3_rp * LOG10 ( Te ) + & cparams_ss % CLog1 + cparams_ss % CLog2 end function CLog","tags":"","loc":"proc/clog.html"},{"title":"CLog0 – KORC-Full Orbit","text":"public function CLog0(ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLog0 Source Code function CLog0 ( ne , Te ) ! Dimensionless ne and Te REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CLog0 CLog0 = 1 4.9_rp - LOG ( ne ) / 2._rp + LOG ( Te ) + & cparams_ss % CLog0_1 + cparams_ss % CLog0_2 end function CLog0","tags":"","loc":"proc/clog0.html"},{"title":"CLogee – KORC-Full Orbit","text":"public function CLogee(v, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLogee Source Code function CLogee ( v , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogee REAL ( rp ) :: k = 5._rp REAL ( rp ) :: gam gam = 1 / sqrt ( 1 - v ** 2 ) CLogee = CLog0 ( ne , Te ) + & log ( 1 + ( 2 * ( gam - 1 ) / VTe ( Te ) ** 2 ) ** ( k / 2._rp )) / k !    write(output_unit_write,*) gam,CLogee end function CLogee","tags":"","loc":"proc/clogee.html"},{"title":"CLogei – KORC-Full Orbit","text":"public function CLogei(v, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CLogei Source Code function CLogei ( v , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne !! ne is in m&#94;-3 and below is converted to cm&#94;-3 REAL ( rp ), INTENT ( IN ) :: Te ! In Joules REAL ( rp ) :: CLogei REAL ( rp ) :: k = 5._rp REAL ( rp ) :: gam , p gam = 1 / sqrt ( 1 - v ** 2 ) p = gam * v CLogei = CLog0 ( ne , Te ) + log ( 1 + ( 2 * p / VTe ( Te )) ** k ) / k end function CLogei","tags":"","loc":"proc/clogei.html"},{"title":"delta – KORC-Full Orbit","text":"private function delta(Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code delta Source Code function delta ( Te ) REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: delta delta = VTe ( Te ) * cparams_ss % deltao end function delta","tags":"","loc":"proc/delta.html"},{"title":"psi – KORC-Full Orbit","text":"public function psi(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code psi Source Code function psi ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: psi psi = 0.5_rp * ( ERF ( x ) - 2.0_rp * x * EXP ( - x ** 2 ) / SQRT ( C_PI )) / x ** 2 end function psi","tags":"","loc":"proc/psi.html"},{"title":"CA – KORC-Full Orbit","text":"private function CA(v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code CA Source Code function CA ( v ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CA REAL ( rp ) :: x x = v / cparams_ss % VTe CA = cparams_ss % Gammac * psi ( x ) / v end function CA","tags":"","loc":"proc/ca.html"},{"title":"CA_SD – KORC-Full Orbit","text":"private function CA_SD(v, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CA_SD Source Code function CA_SD ( v , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CA_SD REAL ( rp ) :: x !   write(6,*) ne,Te x = v / VTe ( Te ) CA_SD = Gammacee ( v , ne , Te ) * psi ( x ) / v !    write(output_unit_write,'(\"ne, \"E17.10)') ne !    write(output_unit_write,'(\"Te, \"E17.10)') Te !    write(output_unit_write,'(\"x, \"E17.10)') x !    write(output_unit_write,'(\"psi, \"E17.10)') psi(x) !    write(output_unit_write,'(\"Gammac, \"E17.10)') Gammac(ne,Te) end function CA_SD","tags":"","loc":"proc/ca_sd.html"},{"title":"dCA_SD – KORC-Full Orbit","text":"public function dCA_SD(v, me, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: me real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code dCA_SD Source Code function dCA_SD ( v , me , ne , Te ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: me REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: dCA_SD REAL ( rp ) :: x real ( rp ) :: gam gam = 1 / sqrt ( 1 - v ** 2 ) x = v / VTe ( Te ) dCA_SD = Gammacee ( v , ne , Te ) * (( 2 * ( gam * v ) ** 2 - 1 ) * psi ( x ) + & 2.0_rp * x * EXP ( - x ** 2 ) / SQRT ( C_PI )) / ( gam ** 3 * me * v ** 2 ) end function dCA_SD","tags":"","loc":"proc/dca_sd.html"},{"title":"CF – KORC-Full Orbit","text":"private function CF(params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code CF Source Code function CF ( params , v ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CF REAL ( rp ) :: CF_temp REAL ( rp ) :: x INTEGER :: i REAL ( rp ) :: k = 5._rp x = v / cparams_ss % VTe CF = cparams_ss % Gammac * psi ( x ) / cparams_ss % Te if ( params % bound_electron_model . eq . 'HESSLOW' ) then CF_temp = CF do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / & CLogee ( v , cparams_ss % ne , cparams_ss % Te ) * & ( log ( 1 + h_j ( i , v ) ** k ) / k - v ** 2 ) end do CF = CF_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CF_temp = CF do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CF = CF_temp end if end function CF","tags":"","loc":"proc/cf.html"},{"title":"CF_SD – KORC-Full Orbit","text":"private function CF_SD(params, v, ne, Te) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) Contents Source Code CF_SD Source Code function CF_SD ( params , v , ne , Te ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ) :: CF_SD REAL ( rp ) :: CF_temp REAL ( rp ) :: x INTEGER :: i REAL ( rp ) :: k = 5._rp x = v / VTe ( Te ) CF_SD = Gammacee ( v , ne , Te ) * psi ( x ) / Te if ( params % bound_electron_model . eq . 'HESSLOW' ) then CF_temp = CF_SD do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF_SD * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / & CLogee ( v , ne , Te ) * ( log ( 1 + h_j ( i , v ) ** k ) / k - v ** 2 ) end do CF_SD = CF_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CF_temp = CF_SD do i = 1 , cparams_ms % num_impurity_species CF_temp = CF_temp + CF_SD * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CF_SD = CF_temp end if end function CF_SD","tags":"","loc":"proc/cf_sd.html"},{"title":"CB_ee – KORC-Full Orbit","text":"private function CB_ee(v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code CB_ee Source Code function CB_ee ( v ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CB_ee REAL ( rp ) :: x x = v / cparams_ss % VTe CB_ee = ( 0.5_rp * cparams_ss % Gammac / v ) * ( ERF ( x ) - & psi ( x ) + 0.5_rp * cparams_ss % delta ** 4 * x ** 2 ) end function CB_ee","tags":"","loc":"proc/cb_ee.html"},{"title":"CB_ei – KORC-Full Orbit","text":"private function CB_ei(params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code CB_ei Source Code function CB_ei ( params , v ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: CB_ei REAL ( rp ) :: CB_ei_temp REAL ( rp ) :: x INTEGER :: i x = v / cparams_ss % VTe CB_ei = ( 0.5_rp * cparams_ss % Gammac / v ) * ( cparams_ss % Zeff * & CLogei ( v , cparams_ss % ne , cparams_ss % Te ) / & CLogee ( v , cparams_ss % ne , cparams_ss % Te )) if ( params % bound_electron_model . eq . 'HESSLOW' ) then CB_ei_temp = CB_ei do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei * cparams_ms % nz ( i ) / ( cparams_ms % ne * & cparams_ss % Zeff * CLogei ( v , cparams_ss % ne , cparams_ss % Te )) * & g_j ( i , v ) end do CB_ei = CB_ei_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CB_ei_temp = CB_ei do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CB_ei = CB_ei_temp end if end function CB_ei","tags":"","loc":"proc/cb_ei.html"},{"title":"CB_ee_SD – KORC-Full Orbit","text":"private function CB_ee_SD(v, ne, Te, Zeff) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te real(kind=rp), intent(in) :: Zeff Return Value real(kind=rp) Contents Source Code CB_ee_SD Source Code function CB_ee_SD ( v , ne , Te , Zeff ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ), INTENT ( IN ) :: Zeff REAL ( rp ) :: CB_ee_SD REAL ( rp ) :: x x = v / VTe ( Te ) CB_ee_SD = ( 0.5_rp * Gammacee ( v , ne , Te ) / v ) * & ( ERF ( x ) - psi ( x ) + & 0.5_rp * delta ( Te ) ** 4 * x ** 2 ) end function CB_ee_SD","tags":"","loc":"proc/cb_ee_sd.html"},{"title":"CB_ei_SD – KORC-Full Orbit","text":"private function CB_ei_SD(params, v, ne, Te, Zeff) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te real(kind=rp), intent(in) :: Zeff Return Value real(kind=rp) Contents Source Code CB_ei_SD Source Code function CB_ei_SD ( params , v , ne , Te , Zeff ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: ne REAL ( rp ), INTENT ( IN ) :: Te REAL ( rp ), INTENT ( IN ) :: Zeff REAL ( rp ) :: CB_ei_SD REAL ( rp ) :: CB_ei_temp REAL ( rp ) :: x INTEGER :: i x = v / VTe ( Te ) CB_ei_SD = ( 0.5_rp * Gammacee ( v , ne , Te ) / v ) * & ( Zeff * CLogei ( v , ne , Te ) / CLogee ( v , ne , Te )) if ( params % bound_electron_model . eq . 'HESSLOW' ) then CB_ei_temp = CB_ei_SD do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei_SD * cparams_ms % nz ( i ) / ( cparams_ms % ne * & Zeff * CLogei ( v , ne , Te )) * g_j ( i , v ) end do CB_ei_SD = CB_ei_temp else if ( params % bound_electron_model . eq . 'ROSENBLUTH' ) then CB_ei_temp = CB_ei_SD do i = 1 , cparams_ms % num_impurity_species CB_ei_temp = CB_ei_temp + CB_ei_SD * cparams_ms % nz ( i ) / cparams_ms % ne * & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) / 2._rp end do CB_ei_SD = CB_ei_temp end if end function CB_ei_SD","tags":"","loc":"proc/cb_ei_sd.html"},{"title":"nu_S – KORC-Full Orbit","text":"private function nu_S(params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code nu_S Source Code function nu_S ( params , v ) ! Slowing down collision frequency TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), INTENT ( IN ) :: v ! Normalised particle speed REAL ( rp ) :: nu_S REAL ( rp ) :: nu_S_temp REAL ( rp ) :: p p = v / SQRT ( 1.0_rp - v ** 2 ) nu_S = CF ( params , v ) / p end function nu_S","tags":"","loc":"proc/nu_s.html"},{"title":"h_j – KORC-Full Orbit","text":"public function h_j(i, v) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code h_j Source Code function h_j ( i , v ) INTEGER , INTENT ( IN ) :: i REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: gam REAL ( rp ) :: p REAL ( rp ) :: h_j gam = 1 / sqrt ( 1 - v ** 2 ) p = v * gam h_j = p * sqrt ( gam - 1 ) / cparams_ms % IZj ( i ) end function h_j","tags":"","loc":"proc/h_j.html"},{"title":"g_j – KORC-Full Orbit","text":"public function g_j(i, v) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code g_j Source Code function g_j ( i , v ) INTEGER , INTENT ( IN ) :: i REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: gam REAL ( rp ) :: p REAL ( rp ) :: g_j gam = 1 / sqrt ( 1 - v ** 2 ) p = v * gam g_j = 2._rp / 3._rp * (( cparams_ms % Zo ( i ) ** 2 - cparams_ms % Zj ( i ) ** 2 ) * & log (( p * cparams_ms % aZj ( i )) ** ( 3._rp / 2._rp ) + 1 ) - & ( cparams_ms % Zo ( i ) - cparams_ms % Zj ( i )) ** 2 * & ( p * cparams_ms % aZj ( i )) ** ( 3._rp / 2._rp ) / & (( p * cparams_ms % aZj ( i )) ** ( 3._rp / 2._rp ) + 1 )) !    write(output_unit_write,'(\"g_j: \",E17.10)') g_j end function g_j","tags":"","loc":"proc/g_j.html"},{"title":"nu_D – KORC-Full Orbit","text":"private function nu_D(params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code nu_D Source Code function nu_D ( params , v ) ! perpendicular diffusion (pitch angle scattering) collision frequency REAL ( rp ), INTENT ( IN ) :: v TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params ! Normalised particle speed REAL ( rp ) :: nu_D REAL ( rp ) :: p p = v / SQRT ( 1.0_rp - v ** 2 ) nu_D = 2.0_rp * ( CB_ee ( v ) + CB_ei ( params , v )) / p ** 2 end function nu_D","tags":"","loc":"proc/nu_d.html"},{"title":"nu_par – KORC-Full Orbit","text":"private function nu_par(v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code nu_par Source Code function nu_par ( v ) ! parallel (speed diffusion) collision frequency REAL ( rp ), INTENT ( IN ) :: v ! Normalised particle speed REAL ( rp ) :: nu_par REAL ( rp ) :: p p = v / SQRT ( 1.0_rp - v ** 2 ) nu_par = 2.0_rp * CA ( v ) / p ** 2 end function nu_par","tags":"","loc":"proc/nu_par.html"},{"title":"fun – KORC-Full Orbit","text":"private function fun(v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) Contents Source Code fun Source Code function fun ( v ) REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ) :: fun REAL ( rp ) :: x x = v / cparams_ss % VTe fun = 2.0_rp * ( 1.0_rp / x + x ) * EXP ( - x ** 2 ) / SQRT ( C_PI ) - ERF ( x ) / x ** 2 - psi ( v ) end function fun","tags":"","loc":"proc/fun.html"},{"title":"cross – KORC-Full Orbit","text":"private function cross(a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: a real(kind=rp), intent(in), DIMENSION(3) :: b Return Value real(kind=rp),\n  DIMENSION(3) Contents Source Code cross Source Code function cross ( a , b ) REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: a REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: b REAL ( rp ), DIMENSION ( 3 ) :: cross cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross","tags":"","loc":"proc/cross~3.html"},{"title":"load_params_ms – KORC-Full Orbit","text":"private subroutine load_params_ms(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code load_params_ms Source Code subroutine load_params_ms ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) \t\t\t\t:: Te ! Background electron temperature in eV !REAL(rp) \t\t\t\t:: ne ! Background electron density in 1/m&#94;3 !INTEGER \t\t\t\t:: num_impurity_species !REAL(rp), DIMENSION(10) \t\t:: Zo ! Full nuclear charge of each impurity: Z=1 for D, Z=10 for Ne !REAL(rp), DIMENSION(10) \t\t:: Zj ! Atomic number of each impurity: Z=1 for D, Z=10 for Ne !REAL(rp), DIMENSION(10) \t\t:: nz ! Impurity densities !REAL(rp), DIMENSION(10) \t\t:: IZj ! Ionization energy of impurity in eV !REAL(rp), DIMENSION(10) \t\t:: aZj INTEGER :: i !NAMELIST /CollisionParamsMultipleSpecies/ num_impurity_species,Te,ne, & !     Zo,Zj,nz,IZj !open(unit=output_unit_write,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(output_unit_write,nml=CollisionParamsMultipleSpecies) !close(output_unit_write) cparams_ms % num_impurity_species = num_impurity_species ALLOCATE ( cparams_ms % Zj ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % Zo ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % nz ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % neb ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % IZj ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % aZj ( cparams_ms % num_impurity_species )) ALLOCATE ( cparams_ms % Ee_IZj ( cparams_ms % num_impurity_species )) cparams_ms % Te = Te_mult * C_E cparams_ms % ne = ne_mult cparams_ms % nH = ne_mult cparams_ms % Zj = Zj_mult ( 1 : cparams_ms % num_impurity_species ) cparams_ms % Zo = Zo_mult ( 1 : cparams_ms % num_impurity_species ) cparams_ms % nz = nz_mult ( 1 : cparams_ms % num_impurity_species ) do i = 1 , cparams_ms % num_impurity_species if ( int ( cparams_ms % Zo ( i )). eq . 10 ) then cparams_ms % IZj ( i ) = C_E * cparams_ms % INe ( int ( cparams_ms % Zj ( i ) + 1 )) cparams_ms % aZj ( i ) = cparams_ms % aNe ( int ( cparams_ms % Zj ( i ) + 1 )) else if ( int ( cparams_ms % Zo ( i )). eq . 18 ) then cparams_ms % IZj ( i ) = C_E * cparams_ms % IAr ( int ( cparams_ms % Zj ( i ) + 1 )) cparams_ms % aZj ( i ) = cparams_ms % aAr ( int ( cparams_ms % Zj ( i ) + 1 )) else if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Atomic number not defined!\")' ) end if exit end if end do cparams_ms % nef = ne_mult + sum ( cparams_ms % Zj * cparams_ms % nz ) cparams_ms % neb = ( cparams_ms % Zo - cparams_ms % Zj ) * cparams_ms % nz cparams_ms % rD = SQRT ( C_E0 * cparams_ms % Te / ( cparams_ms % ne * C_E ** 2 ) ) cparams_ms % re = C_RE cparams_ms % Ee_IZj = C_ME * C_C ** 2 / cparams_ms % IZj if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Number of impurity species: \",I16)' )& cparams_ms % num_impurity_species do i = 1 , cparams_ms % num_impurity_species if ( cparams_ms % Zo ( i ). eq . 10 ) then write ( output_unit_write , '(\"Ne with charge state: \",I16)' ) int ( cparams_ms % Zj ( i )) write ( output_unit_write , '(\"Mean excitation energy I (eV)\",E17.10)' ) & cparams_ms % IZj ( i ) / C_E write ( output_unit_write , '(\"Effective ion length scale a (a_0)\",E17.10)' ) & cparams_ms % aZj ( i ) else if ( cparams_ms % Zo ( i ). eq . 18 ) then write ( output_unit_write , '(\"Ar with charge state: \",I16)' ) int ( cparams_ms % Zj ( i )) write ( output_unit_write , '(\"Mean excitation energy I (eV)\",E17.10)' ) & cparams_ms % IZj ( i ) / C_E write ( output_unit_write , '(\"Effective ion length scale a (a_0)\",E17.10)' ) & cparams_ms % aZj ( i ) end if end do end if end subroutine load_params_ms","tags":"","loc":"proc/load_params_ms.html"},{"title":"load_params_ss – KORC-Full Orbit","text":"private subroutine load_params_ss(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code load_params_ss Source Code subroutine load_params_ss ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) \t\t\t\t:: Te ! Electron temperature !REAL(rp) \t\t\t\t:: Ti ! Ion temperature !REAL(rp) \t\t\t\t:: ne ! Background electron density !REAL(rp) \t\t\t\t:: Zeff ! Effective atomic number of ions !REAL(rp) \t\t\t\t:: dTau ! Subcycling time step in collisional time units (Tau) !CHARACTER(MAX_STRING_LENGTH) \t:: ne_profile !CHARACTER(MAX_STRING_LENGTH) \t:: Te_profile !CHARACTER(MAX_STRING_LENGTH) \t:: Zeff_profile !CHARACTER(MAX_STRING_LENGTH) \t:: filename !REAL(rp) \t\t\t\t:: radius_profile !REAL(rp) \t\t\t\t:: neo !REAL(rp) \t\t\t\t:: Teo !REAL(rp) \t\t\t\t:: Zeffo !REAL(rp) \t\t\t\t:: n_ne !REAL(rp) \t\t\t\t:: n_Te !REAL(rp) \t\t\t\t:: n_Zeff !REAL(rp), DIMENSION(4) \t\t:: a_ne !REAL(rp), DIMENSION(4) \t\t:: a_Te !REAL(rp), DIMENSION(4) \t\t:: a_Zeff !LOGICAL \t\t\t\t:: axisymmetric !REAL(rp)  ::  n_REr0 !REAL(rp)  ::  n_tauion !REAL(rp)  ::  n_lamfront,psiN_0 !REAL(rp)  ::  n_lamback,n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf !NAMELIST /CollisionParamsSingleSpecies/ Te, Ti, ne, Zeff, dTau !NAMELIST /plasmaProfiles/ radius_profile,ne_profile,neo,n_ne,a_ne,& !     Te_profile,Teo,n_Te,a_Te,n_REr0,n_tauion,n_lamfront,n_lamback, & !     Zeff_profile,Zeffo,n_Zeff,a_Zeff,filename,axisymmetric, & !     n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf,psiN_0 !open(unit=output_unit_write,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(output_unit_write,nml=CollisionParamsSingleSpecies) !close(output_unit_write) cparams_ss % Te = Te_sing * C_E cparams_ss % Ti = Ti_sing * C_E cparams_ss % ne = ne_sing cparams_ss % Zeff = Zeff_sing cparams_ss % dTau = dTau_sing cparams_ss % rD = SQRT ( C_E0 * cparams_ss % Te / ( cparams_ss % ne * C_E ** 2 * ( 1.0_rp + & cparams_ss % Te / cparams_ss % Ti ))) cparams_ss % re = C_E ** 2 / ( 4.0_rp * C_PI * C_E0 * C_ME * C_C ** 2 ) cparams_ss % CoulombLogee = CLogee_wu ( params , cparams_ss % ne , cparams_ss % Te ) cparams_ss % CoulombLogei = CLogei_wu ( params , cparams_ss % ne , cparams_ss % Te ) cparams_ss % VTe = VTe_wu ( cparams_ss % Te ) cparams_ss % delta = cparams_ss % VTe / C_C cparams_ss % Gammaco = C_E ** 4 / ( 4.0_rp * C_PI * C_E0 ** 2 ) cparams_ss % Gammac = Gammac_wu ( params , cparams_ss % ne , cparams_ss % Te ) cparams_ss % Tauc = C_ME ** 2 * cparams_ss % VTe ** 3 / cparams_ss % Gammac cparams_ss % Tau = C_ME ** 2 * C_C ** 3 / cparams_ss % Gammac cparams_ss % Ec = C_ME * C_C / ( C_E * cparams_ss % Tau ) cparams_ss % ED = cparams_ss % ne * C_E ** 3 * cparams_ss % CoulombLogee / & ( 4.0_rp * C_PI * C_E0 ** 2 * cparams_ss % Te ) cparams_ss % taur = 6 * C_PI * C_E0 * ( C_ME * C_C ) ** 3 / ( C_E ** 4 * params % cpp % Bo ** 2 * & params % cpp % time ) !\tALLOCATE(cparams_ss%rnd_num(3,cparams_ss%rnd_dim)) !\tcall RANDOM_NUMBER(cparams_ss%rnd_num) cparams_ss % rnd_num_count = 1_idef !open(unit=output_unit_write,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(output_unit_write,nml=plasmaProfiles) !close(output_unit_write) cparams_ss % P % a = radius_profile cparams_ss % P % ne_profile = TRIM ( ne_profile ) cparams_ss % P % neo = neo cparams_ss % P % n_ne = n_ne cparams_ss % P % a_ne = a_ne cparams_ss % P % Te_profile = TRIM ( Te_profile ) cparams_ss % P % Teo = Teo * C_E cparams_ss % P % n_Te = n_Te cparams_ss % P % a_Te = a_Te cparams_ss % P % Zeff_profile = TRIM ( Zeff_profile ) cparams_ss % P % Zeffo = Zeffo cparams_ss % P % n_Zeff = n_Zeff cparams_ss % P % a_Zeff = a_Zeff end subroutine load_params_ss","tags":"","loc":"proc/load_params_ss.html"},{"title":"initialize_collision_params – KORC-Full Orbit","text":"public subroutine initialize_collision_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code initialize_collision_params Source Code subroutine initialize_collision_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if ( params % collisions ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * * * INITIALIZING COLLISIONS * * * * * * *\")' ) end if SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) call load_params_ss ( params ) SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call load_params_ms ( params ) CASE ( 'HESSLOW' ) call load_params_ms ( params ) CASE ( 'ROSENBLUTH' ) call load_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call load_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end if end subroutine initialize_collision_params","tags":"","loc":"proc/initialize_collision_params.html"},{"title":"normalize_params_ms – KORC-Full Orbit","text":"private subroutine normalize_params_ms(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code normalize_params_ms Source Code subroutine normalize_params_ms ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params cparams_ms % Te = cparams_ms % Te / params % cpp % temperature cparams_ms % ne = cparams_ms % ne / params % cpp % density cparams_ms % nH = cparams_ms % nH / params % cpp % density cparams_ms % nef = cparams_ms % nef / params % cpp % density cparams_ms % neb = cparams_ms % neb / params % cpp % density if ( ALLOCATED ( cparams_ms % nz )) cparams_ms % nz = cparams_ms % nz / & params % cpp % density if ( ALLOCATED ( cparams_ms % IZj )) cparams_ms % IZj = cparams_ms % IZj / & params % cpp % energy cparams_ms % rD = cparams_ms % rD / params % cpp % length cparams_ms % re = cparams_ms % re / params % cpp % length end subroutine normalize_params_ms","tags":"","loc":"proc/normalize_params_ms.html"},{"title":"normalize_params_ss – KORC-Full Orbit","text":"private subroutine normalize_params_ss(params) Calculate constant quantities used in various functions within\n this module Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code normalize_params_ss Source Code subroutine normalize_params_ss ( params ) !! Calculate constant quantities used in various functions within !! this module TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params cparams_ss % Clog1 = - 1.15_rp * LOG10 ( 1.0E-6_rp * params % cpp % density ) cparams_ss % Clog2 = 2.3_rp * LOG10 ( params % cpp % temperature / C_E ) cparams_ss % Clog0_1 = - LOG ( 1.0E-20_rp * params % cpp % density ) / 2._rp cparams_ss % Clog0_2 = LOG ( 1.0E-3 * params % cpp % temperature / C_E ) cparams_ss % Gammaco = cparams_ss % Gammaco * params % cpp % density * & params % cpp % time / ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) cparams_ss % VTeo = SQRT ( params % cpp % temperature / C_ME ) / params % cpp % velocity cparams_ss % deltao = params % cpp % velocity / C_C cparams_ss % Te = cparams_ss % Te / params % cpp % temperature cparams_ss % Ti = cparams_ss % Ti / params % cpp % temperature cparams_ss % ne = cparams_ss % ne / params % cpp % density cparams_ss % rD = cparams_ss % rD / params % cpp % length cparams_ss % re = cparams_ss % re / params % cpp % length cparams_ss % VTe = cparams_ss % VTe / params % cpp % velocity cparams_ss % Gammac = cparams_ss % Gammac * params % cpp % time / & ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) cparams_ss % Tau = cparams_ss % Tau / params % cpp % time cparams_ss % Tauc = cparams_ss % Tauc / params % cpp % time cparams_ss % Ec = cparams_ss % Ec / params % cpp % Eo cparams_ss % ED = cparams_ss % ED / params % cpp % Eo cparams_ss % taur = cparams_ss % taur / params % cpp % time cparams_ss % P % a = cparams_ss % P % a / params % cpp % length cparams_ss % P % neo = cparams_ss % P % neo / params % cpp % density cparams_ss % P % Teo = cparams_ss % P % Teo / params % cpp % temperature end subroutine normalize_params_ss","tags":"","loc":"proc/normalize_params_ss.html"},{"title":"normalize_collisions_params – KORC-Full Orbit","text":"public subroutine normalize_collisions_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code normalize_collisions_params Source Code subroutine normalize_collisions_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if ( params % collisions ) then SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) call normalize_params_ss ( params ) SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call normalize_params_ms ( params ) CASE ( 'HESSLOW' ) call normalize_params_ms ( params ) CASE ( 'ROSENBLUTH' ) call normalize_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call normalize_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT end if end subroutine normalize_collisions_params","tags":"","loc":"proc/normalize_collisions_params.html"},{"title":"collision_force – KORC-Full Orbit","text":"public subroutine collision_force(spp, U, Fcoll) For multiple-species collisions\n J. R. Martin-Solis et al. PoP 22, 092512 (2015)\n if (params%collisions .AND. (TRIM(params%collisions_model) .EQ.\n 'MULTIPLE_SPECIES')) then call collision_force(spp(ii),U_os,Fcoll)\n    U_RC = U_RC + a*Fcoll/spp(ii)%q end if Arguments Type Intent Optional Attributes Name type(SPECIES), intent(in) :: spp real(kind=rp), intent(in), DIMENSION(3) :: U real(kind=rp), intent(out), DIMENSION(3) :: Fcoll Contents Source Code collision_force Source Code subroutine collision_force ( spp , U , Fcoll ) !! For multiple-species collisions !! J. R. Martin-Solis et al. PoP 22, 092512 (2015) !! if (params%collisions .AND. (TRIM(params%collisions_model) .EQ. !! 'MULTIPLE_SPECIES')) then call collision_force(spp(ii),U_os,Fcoll) !!\tU_RC = U_RC + a*Fcoll/spp(ii)%q end if TYPE ( SPECIES ), INTENT ( IN ) :: spp REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: U REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: Fcoll REAL ( rp ), DIMENSION ( 3 ) :: V REAL ( rp ), DIMENSION ( 3 ) :: Fcolle REAL ( rp ), DIMENSION ( 3 ) :: Fcolli REAL ( rp ) :: gamma REAL ( rp ) :: tmp REAL ( rp ) :: ae REAL ( rp ) :: ai REAL ( rp ) :: Clog_ef REAL ( rp ) :: Clog_eb REAL ( rp ) :: Clog_eH REAL ( rp ) :: Clog_eZj REAL ( rp ) :: Clog_eZo INTEGER :: ppi gamma = SQRT ( 1.0_rp + DOT_PRODUCT ( U , U )) V = U / gamma tmp = ( gamma - 1.0_rp ) * SQRT ( gamma + 1.0_rp ) Clog_ef = log ( 0.5_rp * tmp * ( cparams_ms % rD / cparams_ms % re ) / gamma ) ae = cparams_ms % nef * Clog_ef do ppi = 1_idef , cparams_ms % num_impurity_species Clog_eb = log ( tmp * cparams_ms % Ee_IZj ( ppi )) ae = ae + cparams_ms % neb ( ppi ) * Clog_eb end do tmp = ( gamma ** 2 - 1.0_rp ) / gamma Clog_eH = log ( tmp * ( cparams_ms % rD / cparams_ms % re ) ) ai = cparams_ms % nH * Clog_eH do ppi = 1_idef , cparams_ms % num_impurity_species Clog_eZj = log ( cparams_ms % rD / ( cparams_ms % Zj ( ppi ) * & cparams_ms % re * cparams_ms % Ee_IZj ( ppi )) ) Clog_eZo = log ( tmp * cparams_ms % Ee_IZj ( ppi )) ai = ai + & cparams_ms % nz ( ppi ) * ( Clog_eZj * cparams_ms % Zj ( ppi ) ** 2 + & Clog_eZo * cparams_ms % Zo ( ppi ) ** 2 ) end do tmp = gamma * ( gamma + 1.0_rp ) / ( SQRT ( DOT_PRODUCT ( U , U )) ** 3 ) Fcolle = - 4.0_rp * C_PI * ae * spp % m * ( cparams_ms % re ** 2 ) * tmp * U tmp = gamma / ( SQRT ( DOT_PRODUCT ( U , U )) ** 3 ) Fcolli = - 4.0_rp * C_PI * ai * spp % m * ( cparams_ms % re ** 2 ) * tmp * U Fcoll = Fcolle + Fcolli end subroutine collision_force","tags":"","loc":"proc/collision_force.html"},{"title":"define_collisions_time_step – KORC-Full Orbit","text":"public subroutine define_collisions_time_step(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code define_collisions_time_step Source Code subroutine define_collisions_time_step ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( ip ) :: iterations REAL ( rp ) :: E REAL ( rp ) :: v REAL ( rp ) :: Tau REAL ( rp ), DIMENSION ( 3 ) :: nu REAL ( rp ) :: num_collisions_in_simulation if ( params % collisions ) then E = C_ME * C_C ** 2 + params % minimum_particle_energy * params % cpp % energy v = SQRT ( 1.0_rp - ( C_ME * C_C ** 2 / E ) ** 2 ) nu = ( / nu_S ( params , v ), nu_D ( params , v ), nu_par ( v ) / ) Tau = MINVAL ( 1.0_rp / nu ) !       write(output_unit_write,'(\"collision freqencies \",F25.12)') nu cparams_ss % subcycling_iterations = FLOOR ( cparams_ss % dTau * Tau / & params % dt , ip ) + 1_ip num_collisions_in_simulation = params % simulation_time / Tau if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * SUBCYCLING FOR  & COLLISIONS * * * * * * * * * * *\")' ) write ( output_unit_write , '(\"Slowing down freqency (CF): \",E17.10)' ) & nu ( 1 ) / params % cpp % time write ( output_unit_write , '(\"Pitch angle scattering freqency (CB): \",E17.10)' ) & nu ( 2 ) / params % cpp % time write ( output_unit_write , '(\"Speed diffusion freqency (CA): \",E17.10)' ) & nu ( 3 ) / params % cpp % time write ( output_unit_write , '(\"The shorter collisional time in the simulations  & is: \",E17.10,\" s\")' ) Tau * params % cpp % time write ( output_unit_write , '(\"Number of KORC iterations per collision: \",I16)' ) & cparams_ss % subcycling_iterations write ( output_unit_write , '(\"Number of collisions in simulated time: \",E17.10)' ) & num_collisions_in_simulation write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * & * * * * * * * * * * * * * * *\",/)' ) end if end if end subroutine define_collisions_time_step","tags":"","loc":"proc/define_collisions_time_step.html"},{"title":"unitVectorsC – KORC-Full Orbit","text":"private subroutine unitVectorsC(B, b1, b2, b3) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: B real(kind=rp), intent(out), DIMENSION(3) :: b1 real(kind=rp), intent(out), DIMENSION(3) :: b2 real(kind=rp), intent(out), DIMENSION(3) :: b3 Contents Source Code unitVectorsC Source Code subroutine unitVectorsC ( B , b1 , b2 , b3 ) REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: B REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: b1 REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: b2 REAL ( rp ), DIMENSION ( 3 ), INTENT ( OUT ) :: b3 b1 = B / SQRT ( DOT_PRODUCT ( B , B )) b2 = cross ( b1 ,( / 0.0_rp , 0.0_rp , 1.0_rp / )) b2 = b2 / SQRT ( DOT_PRODUCT ( b2 , b2 )) b3 = cross ( b1 , b2 ) b3 = b3 / SQRT ( DOT_PRODUCT ( b3 , b3 )) end subroutine unitVectorsC","tags":"","loc":"proc/unitvectorsc.html"},{"title":"unitVectors_p – KORC-Full Orbit","text":"private subroutine unitVectors_p(pchunk, b_unit_X, b_unit_Y, b_unit_Z, b1_X, b1_Y, b1_Z, b2_X, b2_Y, b2_Z, b3_X, b3_Y, b3_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: b_unit_X real(kind=rp), intent(in), DIMENSION(pchunk) :: b_unit_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: b_unit_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: b1_X real(kind=rp), intent(out), DIMENSION(pchunk) :: b1_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: b1_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: b2_X real(kind=rp), intent(out), DIMENSION(pchunk) :: b2_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: b2_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: b3_X real(kind=rp), intent(out), DIMENSION(pchunk) :: b3_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: b3_Z Contents Source Code unitVectors_p Source Code subroutine unitVectors_p ( pchunk , b_unit_X , b_unit_Y , b_unit_Z , b1_X , b1_Y , b1_Z , & b2_X , b2_Y , b2_Z , b3_X , b3_Y , b3_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: b1_X , b1_Y , b1_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: b2_X , b2_Y , b2_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: b3_X , b3_Y , b3_Z REAL ( rp ), DIMENSION ( pchunk ) :: b2mag , b3mag integer ( ip ) :: cc !$OMP SIMD !    !$OMP& aligned(b1_X,b1_Y,b1_Z,b_unit_X,b_unit_Y,b_unit_Z, & !    !$OMP& b2_X,b2_Y,b2_Z,b2mag,b3_X,b3_Y,b3_Z,b3mag) do cc = 1_idef , pchunk b1_X ( cc ) = b_unit_X ( cc ) b1_Y ( cc ) = b_unit_Y ( cc ) b1_Z ( cc ) = b_unit_Z ( cc ) b2_X ( cc ) = b1_Y ( cc ) b2_Y ( cc ) = - b1_X ( cc ) b2_Z ( cc ) = 0._rp b2mag ( cc ) = sqrt ( b2_X ( cc ) * b2_X ( cc ) + b2_Y ( cc ) * b2_Y ( cc ) + b2_Z ( cc ) * b2_Z ( cc )) b2_X ( cc ) = b2_X ( cc ) / b2mag ( cc ) b2_Y ( cc ) = b2_Y ( cc ) / b2mag ( cc ) b2_Z ( cc ) = b2_Z ( cc ) / b2mag ( cc ) b3_X ( cc ) = b1_Y ( cc ) * b2_Z ( cc ) - b1_Z ( cc ) * b2_Y ( cc ) b3_Y ( cc ) = b1_Z ( cc ) * b2_X ( cc ) - b1_X ( cc ) * b2_Z ( cc ) b3_Z ( cc ) = b1_X ( cc ) * b2_Y ( cc ) - b1_Y ( cc ) * b2_X ( cc ) b3mag ( cc ) = sqrt ( b3_X ( cc ) * b3_X ( cc ) + b3_Y ( cc ) * b3_Y ( cc ) + b3_Z ( cc ) * b3_Z ( cc )) b3_X ( cc ) = b3_X ( cc ) / b3mag ( cc ) b3_Y ( cc ) = b3_Y ( cc ) / b3mag ( cc ) b3_Z ( cc ) = b3_Z ( cc ) / b3mag ( cc ) end do !$OMP END SIMD end subroutine unitVectors_p","tags":"","loc":"proc/unitvectors_p.html"},{"title":"check_collisions_params – KORC-Full Orbit","text":"public subroutine check_collisions_params(spp) Uses omp_lib Arguments Type Intent Optional Attributes Name type(SPECIES), intent(in) :: spp Contents Source Code check_collisions_params Source Code subroutine check_collisions_params ( spp ) #ifdef PARALLEL_RANDOM USE omp_lib #endif TYPE ( SPECIES ), INTENT ( IN ) :: spp INTEGER aux aux = cparams_ss % rnd_num_count + 2_idef * INT ( spp % ppp , idef ) if ( aux . GE . cparams_ss % rnd_dim ) then #ifdef PARALLEL_RANDOM cparams_ss % rnd_num = get_random () #else call RANDOM_NUMBER ( cparams_ss % rnd_num ) #endif cparams_ss % rnd_num_count = 1_idef end if end subroutine check_collisions_params","tags":"","loc":"proc/check_collisions_params.html"},{"title":"include_CoulombCollisions_FO_p – KORC-Full Orbit","text":"public subroutine include_CoulombCollisions_FO_p(tt, params, X_X, X_Y, X_Z, U_X, U_Y, U_Z, B_X, B_Y, B_Z, me, P, F, flagCon, flagCol, PSIp) This subroutine performs a Stochastic collision process consistent\n with the Fokker-Planck model for relativitic electron colliding with\n a thermal (Maxwellian) plasma. The collision operator is in spherical\n coordinates of the form found in Papp et al., NF (2011). CA\n corresponds to the parallel (speed diffusion) process, CF corresponds\n to a slowing down (momentum loss) process, and CB corresponds to a\n perpendicular diffusion process. Ordering of the processes are and only the dominant terms are kept. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: U_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: U_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: U_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in) :: me type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code include_CoulombCollisions_FO_p Source Code subroutine include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , me , P , F , flagCon , flagCol , PSIp ) !! This subroutine performs a Stochastic collision process consistent !! with the Fokker-Planck model for relativitic electron colliding with !! a thermal (Maxwellian) plasma. The collision operator is in spherical !! coordinates of the form found in Papp et al., NF (2011). CA !! corresponds to the parallel (speed diffusion) process, CF corresponds !! to a slowing down (momentum loss) process, and CB corresponds to a !! perpendicular diffusion process. Ordering of the processes are !!  \\sqrt{CB}\\gg CB \\gg CF \\sim \\sqrt{CA} \\gg CA, !! and only the dominant terms are kept. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: X_X , X_Y , X_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCol INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon REAL ( rp ), INTENT ( IN ) :: me INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b1_X , b1_Y , b1_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b2_X , b2_Y , b2_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: b3_X , b3_Y , b3_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk , 3 ) :: dW !! 3D Weiner process REAL ( rp ), DIMENSION ( params % pchunk , 3 ) :: rnd1 REAL ( rp ) :: dt , time REAL ( rp ), DIMENSION ( params % pchunk ) :: um REAL ( rp ), DIMENSION ( params % pchunk ) :: dpm REAL ( rp ), DIMENSION ( params % pchunk ) :: vm REAL ( rp ), DIMENSION ( params % pchunk ) :: pm REAL ( rp ), DIMENSION ( params % pchunk ) :: Ub_X , Ub_Y , Ub_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: xi REAL ( rp ), DIMENSION ( params % pchunk ) :: dxi REAL ( rp ), DIMENSION ( params % pchunk ) :: phi REAL ( rp ), DIMENSION ( params % pchunk ) :: dphi !! speed of particle REAL ( rp ), DIMENSION ( params % pchunk ) :: CAL REAL ( rp ), DIMENSION ( params % pchunk ) :: dCAL REAL ( rp ), DIMENSION ( params % pchunk ) :: CFL REAL ( rp ), DIMENSION ( params % pchunk ) :: CBL integer :: cc , pchunk pchunk = params % pchunk if ( MODULO ( params % it + tt , cparams_ss % subcycling_iterations ) . EQ . 0_ip ) then dt = REAL ( cparams_ss % subcycling_iterations , rp ) * params % dt time = params % init_time + ( params % it - 1 + tt ) * params % dt ! subcylcling iterations a fraction of fastest collision frequency, ! where fraction set by dTau in namelist &CollisionParamsSingleSpecies call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) if ( params % profile_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then call analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) else  if ( params % profile_model ( 1 : 8 ). eq . 'EXTERNAL' ) then call interp_FOcollision_p ( pchunk , Y_R , Y_PHI , Y_Z , ne , Te , Zeff , flagCon ) end if !$OMP SIMD !       !$OMP& aligned(um,pm,vm,U_X,U_Y,U_Z,Bmag,B_X,B_Y,B_Z, & !       !$OMP& b_unit_X,b_unit_Y,b_unit_Z,xi) do cc = 1_idef , pchunk um ( cc ) = SQRT ( U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) pm ( cc ) = me * um ( cc ) vm ( cc ) = um ( cc ) / SQRT ( 1.0_rp + um ( cc ) * um ( cc )) ! um is gamma times v, this solves for v Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) xi ( cc ) = ( U_X ( cc ) * b_unit_X ( cc ) + U_Y ( cc ) * b_unit_Y ( cc ) + & U_Z ( cc ) * b_unit_Z ( cc )) / um ( cc ) ! pitch angle in b_unit reference frame end do !$OMP END SIMD !       write(output_unit_write,'(\"vm: \",E17.10)') vm !       write(output_unit_write,'(\"xi: \",E17.10)') xi call unitVectors_p ( pchunk , b_unit_X , b_unit_Y , b_unit_Z , b1_X , b1_Y , b1_Z , & b2_X , b2_Y , b2_Z , b3_X , b3_Y , b3_Z ) ! b1=b_unit, (b1,b2,b3) is right-handed !$OMP SIMD !       !$OMP& aligned(phi,U_X,U_Y,U_Z,b3_X,b3_Y,b3_Z,b2_X,b2_Y,b2_Z) do cc = 1_idef , pchunk phi ( cc ) = atan2 (( U_X ( cc ) * b3_X ( cc ) + U_Y ( cc ) * b3_Y ( cc ) + & U_Z ( cc ) * b3_Z ( cc )), & ( U_X ( cc ) * b2_X ( cc ) + U_Y ( cc ) * b2_Y ( cc ) + U_Z ( cc ) * b2_Z ( cc ))) ! azimuthal angle in b_unit refernce frame end do !$OMP END SIMD !       write(output_unit_write,'(\"phi: \",E17.10)') phi !$OMP SIMD !       !$OMP& aligned(rnd1,dW,CAL,dCAL,CFL,CBL,vm,ne,Te,Zeff,dpm, & !       !$OMP& flagCon,flagCol,dxi,xi,pm,dphi,um,Ub_X,Ub_Y,Ub_Z,U_X,U_Y,U_Z, & !       !$OMP& b1_X,b1_Y,b1_Z,b2_X,b2_Y,b2_Z,b3_X,b3_Y,b3_Z) do cc = 1_idef , pchunk #ifdef PARALLEL_RANDOM ! uses C library to generate normal_distribution random variables, ! preserving parallelization where Fortran random number generator ! does not rnd1 ( cc , 1 ) = get_random () rnd1 ( cc , 2 ) = get_random () rnd1 ( cc , 3 ) = get_random () #else call RANDOM_NUMBER ( rnd1 ) #endif dW ( cc , 1 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 1 )) dW ( cc , 2 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 2 )) dW ( cc , 3 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 3 )) ! 3D Weiner process CAL ( cc ) = CA_SD ( vm ( cc ), ne ( cc ), Te ( cc )) dCAL ( cc ) = dCA_SD ( vm ( cc ), me , ne ( cc ), Te ( cc )) CFL ( cc ) = CF_SD ( params , vm ( cc ), ne ( cc ), Te ( cc )) CBL ( cc ) = ( CB_ee_SD ( vm ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc )) + & CB_ei_SD ( params , vm ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc ))) dpm ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - CFL ( cc ) + dCAL ( cc )) * dt + & sqrt ( 2.0_rp * CAL ( cc )) * dW ( cc , 1 )) dxi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & ( - 2 * xi ( cc ) * CBL ( cc ) / ( pm ( cc ) * pm ( cc )) * dt - & sqrt ( 2.0_rp * CBL ( cc ) * ( 1 - xi ( cc ) * xi ( cc ))) / pm ( cc ) * dW ( cc , 2 )) dphi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & ( sqrt ( 2 * CBL ( cc )) / ( pm ( cc ) * & sqrt ( 1 - xi ( cc ) * xi ( cc ))) * dW ( cc , 3 )) pm ( cc ) = pm ( cc ) + dpm ( cc ) xi ( cc ) = xi ( cc ) + dxi ( cc ) phi ( cc ) = phi ( cc ) + dphi ( cc ) !          if (pm(cc)<0) pm(cc)=-pm(cc) ! Keep xi between [-1,1] if ( xi ( cc ) > 1 ) then xi ( cc ) = 1 - mod ( xi ( cc ), 1._rp ) else if ( xi ( cc ) <- 1 ) then xi ( cc ) =- 1 - mod ( xi ( cc ), - 1._rp ) endif ! Keep phi between [0,pi] !          if (phi(cc)>C_PI) then !             phi(cc)=C_PI-mod(phi(cc),C_PI) !          else if (phi(cc)<0) then !             phi(cc)=mod(-phi(cc),C_PI) !          endif um ( cc ) = pm ( cc ) / me Ub_X ( cc ) = um ( cc ) * xi ( cc ) Ub_Y ( cc ) = um ( cc ) * sqrt ( 1 - xi ( cc ) * xi ( cc )) * cos ( phi ( cc )) Ub_Z ( cc ) = um ( cc ) * sqrt ( 1 - xi ( cc ) * xi ( cc )) * sin ( phi ( cc )) U_X ( cc ) = Ub_X ( cc ) * b1_X ( cc ) + Ub_Y ( cc ) * b2_X ( cc ) + Ub_Z ( cc ) * b3_X ( cc ) U_Y ( cc ) = Ub_X ( cc ) * b1_Y ( cc ) + Ub_Y ( cc ) * b2_Y ( cc ) + Ub_Z ( cc ) * b3_Y ( cc ) U_Z ( cc ) = Ub_X ( cc ) * b1_Z ( cc ) + Ub_Y ( cc ) * b2_Z ( cc ) + Ub_Z ( cc ) * b3_Z ( cc ) end do !$OMP END SIMD !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"CA: \",E17.10)') CAL(1) !          write(output_unit_write,'(\"dCA: \",E17.10)') dCAL(1) !          write(output_unit_write,'(\"CF \",E17.10)') CFL(1) !          write(output_unit_write,'(\"CB: \",E17.10)') CBL(1) !       end if do cc = 1_idef , pchunk if ( pm ( cc ). lt . 0 ) then write ( output_unit_write , '(\"Momentum less than zero\")' ) stop end if end do end if end subroutine include_CoulombCollisions_FO_p","tags":"","loc":"proc/include_coulombcollisions_fo_p.html"},{"title":"include_CoulombCollisions_GC_p – KORC-Full Orbit","text":"public subroutine include_CoulombCollisions_GC_p(tt, params, Y_R, Y_PHI, Y_Z, Ppll, Pmu, me, flagCon, flagCol, F, P, E_PHI, ne, PSIp) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(KORC_PARAMS), intent(inout) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Ppll real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Pmu real(kind=rp), intent(in) :: me integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp Contents Source Code include_CoulombCollisions_GC_p Source Code subroutine include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & Ppll , Pmu , me , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Ppll REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Pmu REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI , ne , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCol INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon REAL ( rp ), INTENT ( IN ) :: me REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: dW REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: rnd1 REAL ( rp ) :: dt , time REAL ( rp ), DIMENSION ( params % pchunk ) :: pm REAL ( rp ), DIMENSION ( params % pchunk ) :: dp REAL ( rp ), DIMENSION ( params % pchunk ) :: xi REAL ( rp ), DIMENSION ( params % pchunk ) :: dxi REAL ( rp ), DIMENSION ( params % pchunk ) :: v , gam !! speed of particle REAL ( rp ), DIMENSION ( params % pchunk ) :: CAL REAL ( rp ) , DIMENSION ( params % pchunk ) :: dCAL REAL ( rp ), DIMENSION ( params % pchunk ) :: CFL REAL ( rp ), DIMENSION ( params % pchunk ) :: CBL REAL ( rp ), DIMENSION ( params % pchunk ) :: SC_p , SC_mu , BREM_p REAL ( rp ) :: kappa integer :: cc , pchunk integer ( ip ), INTENT ( IN ) :: tt pchunk = params % pchunk if ( MODULO ( params % it + tt , cparams_ss % subcycling_iterations ) . EQ . 0_ip ) then dt = REAL ( cparams_ss % subcycling_iterations , rp ) * params % dt time = params % init_time + ( params % it - 1 + tt ) * params % dt if ( params % field_eval . eq . 'eqn' ) then call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) else if ( params % field_eval . eq . 'interp' ) then if ( F % axisymmetric_fields ) then if ( F % Bflux ) then if (. not . params % SC_E ) then call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) end if else if ( F % ReInterp_2x1t ) then call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else if ( F % Bflux3D ) then call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp , time ) else if ( F % dBfield ) then call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon ) end if else if ( F % dBfield ) then call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) else call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon ) end if endif call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) end if if ( params % profile_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then call analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) else if ( params % profile_model ( 1 : 8 ). eq . 'EXTERNAL' ) then call interp_FOcollision_p ( pchunk , Y_R , Y_PHI , Y_Z , ne , Te , Zeff , flagCon ) end if if (. not . params % FokPlan ) E_PHI = 0._rp !$OMP SIMD !       !$OMP& aligned (pm,xi,v,Ppll,Bmag,Pmu) do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Transform p_pll,mu to P,eta pm ( cc ) = SQRT ( Ppll ( cc ) * Ppll ( cc ) + 2 * me * Bmag ( cc ) * Pmu ( cc )) xi ( cc ) = Ppll ( cc ) / pm ( cc ) gam ( cc ) = sqrt ( 1 + pm ( cc ) * pm ( cc )) v ( cc ) = pm ( cc ) / gam ( cc ) ! normalized speed (v_K=v_P/c) end do !$OMP END SIMD !       write(output_unit_write,'(\"ne: \"E17.10)') ne !       write(output_unit_write,'(\"Te: \"E17.10)') Te !       write(output_unit_write,'(\"Bmag: \"E17.10)') Bmag !       write(output_unit_write,'(\"v: \",E17.10)') v !       write(output_unit_write,'(\"xi: \",E17.10)') xi !       write(output_unit_write,'(\"size(E_PHI_GC): \",I16)') size(E_PHI) !$OMP SIMD !       !$OMP& aligned(rnd1,dW,CAL,dCAL,CFL,CBL,v,ne,Te,Zeff,dp, & !       !$OMP& flagCon,flagCol,dxi,xi,pm,Ppll,Pmu,Bmag) do cc = 1_idef , pchunk #ifdef PARALLEL_RANDOM rnd1 ( cc , 1 ) = get_random () rnd1 ( cc , 2 ) = get_random () !       rnd1(:,1) = get_random_mkl() !       rnd1(:,2) = get_random_mkl() #else call RANDOM_NUMBER ( rnd1 ) #endif dW ( cc , 1 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 1 )) dW ( cc , 2 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 2 )) !          write(output_unit_write,'(\"dW1: \",E17.10)') dW(cc,1) !          write(output_unit_write,'(\"dW2: \",E17.10)') dW(cc,2) CAL ( cc ) = CA_SD ( v ( cc ), ne ( cc ), Te ( cc )) dCAL ( cc ) = dCA_SD ( v ( cc ), me , ne ( cc ), Te ( cc )) CFL ( cc ) = CF_SD ( params , v ( cc ), ne ( cc ), Te ( cc )) CBL ( cc ) = ( CB_ee_SD ( v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc )) + & CB_ei_SD ( params , v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc ))) dp ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - CFL ( cc ) + dCAL ( cc ) + E_PHI ( cc ) * xi ( cc )) * dt + & sqrt ( 2.0_rp * CAL ( cc )) * dW ( cc , 1 )) dxi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - 2 * xi ( cc ) * CBL ( cc ) / ( pm ( cc ) * pm ( cc )) + & E_PHI ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / pm ( cc )) * dt - & sqrt ( 2.0_rp * CBL ( cc ) * ( 1 - xi ( cc ) * xi ( cc ))) / pm ( cc ) * dW ( cc , 2 )) !          write(output_unit_write,'(\"dp: \",E17.10)') dp(cc) !          write(output_unit_write,'(\"dxi: \",E17.10)') dxi(cc) end do !$OMP END SIMD if ( params % FokPlan . and . params % radiation ) then if ( params % GC_rad_model . eq . 'SDE' ) then !$OMP SIMD do cc = 1_idef , pchunk SC_p ( cc ) =- gam ( cc ) * pm ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & ( cparams_ss % taur / Bmag ( cc ) ** 2 ) SC_mu ( cc ) = xi ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & (( cparams_ss % taur / Bmag ( cc ) ** 2 ) * gam ( cc )) kappa = 2._rp * C_PI * C_RE ** 2._rp * C_ME * C_C ** 2._rp BREM_p ( cc ) =- 2._rp * ne ( cc ) * kappa * Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * & C_a / C_PI * ( gam ( cc ) - 1._rp ) * ( log ( 2._rp * gam ( cc )) - 1._rp / 3._rp ) dp ( cc ) = dp ( cc ) + ( SC_p ( cc ) + BREM_p ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) dxi ( cc ) = dxi ( cc ) + ( SC_mu ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) end do !$OMP END SIMD end if end if !$OMP SIMD do cc = 1_idef , pchunk pm ( cc ) = pm ( cc ) + dp ( cc ) xi ( cc ) = xi ( cc ) + dxi ( cc ) !          if (pm(cc)<0) pm(cc)=-pm(cc) ! Keep xi between [-1,1] if ( xi ( cc ) > 1 ) then !             write(output_unit_write,'(\"High xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) xi ( cc ) = 1 - mod ( xi ( cc ), 1._rp ) else if ( xi ( cc ) <- 1 ) then xi ( cc ) =- 1 - mod ( xi ( cc ), - 1._rp ) !             write(output_unit_write,'(\"Low xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) endif ! Transform P,xi to p_pll,mu Ppll ( cc ) = pm ( cc ) * xi ( cc ) Pmu ( cc ) = ( pm ( cc ) * pm ( cc ) - Ppll ( cc ) * Ppll ( cc )) / ( 2 * me * Bmag ( cc )) end do !$OMP END SIMD !       write(output_unit_write,'(\"rnd1: \",E17.10)') rnd1 !       write(output_unit_write,'(\"flag: \",I16)') flag !       write(output_unit_write,'(\"CA: \",E17.10)') CAL !       write(output_unit_write,'(\"dCA: \",E17.10)') dCAL !       write(output_unit_write,'(\"CF \",E17.10)') CFL !       write(output_unit_write,'(\"CB: \",E17.10)') CBL !       write(output_unit_write,'(\"dp: \",E17.10)') dp !       write(output_unit_write,'(\"dxi: \",E17.10)') dxi !       write(output_unit_write,'(\"Ppll: \",E17.10)') Ppll !      write(output_unit_write,'(\"Pmu: \",E17.10)') Pmu !       write(output_unit_write,'(\"E_PHI_COL: \",E17.10)') E_PHI do cc = 1_idef , pchunk if (( pm ( cc ). lt . 1._rp ). and . flagCol ( cc ). eq . 1_ip ) then !             write(output_unit_write,'(\"Momentum less than zero\")') !             stop !             write(output_unit_write,'(\"Particle not tracked at: \",E17.10,\" & !                  & with xi: \",E17.10)') time*params%cpp%time, xi(cc) flagCol ( cc ) = 0_ip end if end do !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"dp_rad: \",E17.10)') & !               -gam(1)*pm(1)*(1-xi(1)*xi(1))/ & !               (cparams_ss%taur/Bmag(1)**2)*dt !          write(output_unit_write,'(\"dxi_rad: \",E17.10)') & !               xi(1)*(1-xi(1)*xi(1))/ & !               ((cparams_ss%taur/Bmag(1)**2)*gam(1))*dt !       end if !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"CA: \",E17.10)') CAL(1) !          write(output_unit_write,'(\"dCA: \",E17.10)') dCAL(1) !          write(output_unit_write,'(\"CF \",E17.10)') CFL(1) !          write(output_unit_write,'(\"CB: \",E17.10)') CBL(1) !       end if end if end subroutine include_CoulombCollisions_GC_p","tags":"","loc":"proc/include_coulombcollisions_gc_p.html"},{"title":"include_CoulombCollisions_GCm3dc1_p – KORC-Full Orbit","text":"public subroutine include_CoulombCollisions_GCm3dc1_p(tt, params, Y_R, Y_PHI, Y_Z, Ppll, Pmu, me, flagCon, flagCol, F, P, E_PHI, ne, Te, PSIp, hint) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(KORC_PARAMS), intent(inout) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Ppll real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Pmu real(kind=rp), intent(in) :: me integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Te real(kind=rp), DIMENSION(params%pchunk) :: PSIp type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code include_CoulombCollisions_GCm3dc1_p Source Code subroutine include_CoulombCollisions_GCm3dc1_p ( tt , params , Y_R , Y_PHI , Y_Z , & Ppll , Pmu , me , flagCon , flagCol , F , P , E_PHI , ne , Te , PSIp , hint ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Ppll REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Pmu REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_PHI , PSIp , E_PHI0 REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: ne , Te REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCol INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint REAL ( rp ), INTENT ( IN ) :: me REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: dW REAL ( rp ), DIMENSION ( params % pchunk , 2 ) :: rnd1 REAL ( rp ) :: dt , time REAL ( rp ), DIMENSION ( params % pchunk ) :: pm REAL ( rp ), DIMENSION ( params % pchunk ) :: dp REAL ( rp ), DIMENSION ( params % pchunk ) :: xi REAL ( rp ), DIMENSION ( params % pchunk ) :: dxi REAL ( rp ), DIMENSION ( params % pchunk ) :: v , gam !! speed of particle REAL ( rp ), DIMENSION ( params % pchunk ) :: CAL REAL ( rp ) , DIMENSION ( params % pchunk ) :: dCAL REAL ( rp ), DIMENSION ( params % pchunk ) :: CFL REAL ( rp ), DIMENSION ( params % pchunk ) :: CBL REAL ( rp ), DIMENSION ( params % pchunk ) :: SC_p , SC_mu , BREM_p REAL ( rp ) :: kappa integer :: cc , pchunk integer ( ip ), INTENT ( IN ) :: tt pchunk = params % pchunk if ( MODULO ( params % it + tt , cparams_ss % subcycling_iterations ) . EQ . 0_ip ) then dt = REAL ( cparams_ss % subcycling_iterations , rp ) * params % dt time = params % init_time + ( params % it - 1 + tt ) * params % dt call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call get_m3d_c1_profile_p ( params , P , Y_R , Y_PHI , Y_Z , & ne , Te , flagCon , hint ) !$OMP SIMD !       !$OMP& aligned (pm,xi,v,Ppll,Bmag,Pmu) do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Transform p_pll,mu to P,eta pm ( cc ) = SQRT ( Ppll ( cc ) * Ppll ( cc ) + 2 * me * Bmag ( cc ) * Pmu ( cc )) xi ( cc ) = Ppll ( cc ) / pm ( cc ) gam ( cc ) = sqrt ( 1 + pm ( cc ) * pm ( cc )) v ( cc ) = pm ( cc ) / gam ( cc ) ! normalized speed (v_K=v_P/c) Zeff ( cc ) = 1._rp E_PHI0 ( cc ) = E_PHI ( cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) E_PHI = 0._rp !       write(output_unit_write,'(\"ne: \"E17.10)') ne !       write(output_unit_write,'(\"Te: \"E17.10)') Te !       write(output_unit_write,'(\"Bmag: \"E17.10)') Bmag !       write(output_unit_write,'(\"v: \",E17.10)') v !       write(output_unit_write,'(\"xi: \",E17.10)') xi !       write(output_unit_write,'(\"size(E_PHI_GC): \",I16)') size(E_PHI) !$OMP SIMD !       !$OMP& aligned(rnd1,dW,CAL,dCAL,CFL,CBL,v,ne,Te,Zeff,dp, & !       !$OMP& flagCon,flagCol,dxi,xi,pm,Ppll,Pmu,Bmag) do cc = 1_idef , pchunk #ifdef PARALLEL_RANDOM rnd1 ( cc , 1 ) = get_random () rnd1 ( cc , 2 ) = get_random () !       rnd1(:,1) = get_random_mkl() !       rnd1(:,2) = get_random_mkl() #else call RANDOM_NUMBER ( rnd1 ) #endif dW ( cc , 1 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 1 )) dW ( cc , 2 ) = SQRT ( 3 * dt ) * ( - 1 + 2 * rnd1 ( cc , 2 )) !          write(output_unit_write,'(\"dW1: \",E17.10)') dW(cc,1) !          write(output_unit_write,'(\"dW2: \",E17.10)') dW(cc,2) CAL ( cc ) = CA_SD ( v ( cc ), ne ( cc ), Te ( cc )) dCAL ( cc ) = dCA_SD ( v ( cc ), me , ne ( cc ), Te ( cc )) CFL ( cc ) = CF_SD ( params , v ( cc ), ne ( cc ), Te ( cc )) CBL ( cc ) = ( CB_ee_SD ( v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc )) + & CB_ei_SD ( params , v ( cc ), ne ( cc ), Te ( cc ), Zeff ( cc ))) dp ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - CFL ( cc ) + dCAL ( cc ) + E_PHI ( cc ) * xi ( cc )) * dt + & sqrt ( 2.0_rp * CAL ( cc )) * dW ( cc , 1 )) dxi ( cc ) = REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) * & (( - 2 * xi ( cc ) * CBL ( cc ) / ( pm ( cc ) * pm ( cc )) + & E_PHI ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / pm ( cc )) * dt - & sqrt ( 2.0_rp * CBL ( cc ) * ( 1 - xi ( cc ) * xi ( cc ))) / pm ( cc ) * dW ( cc , 2 )) !          write(output_unit_write,'(\"dp: \",E17.10)') dp(cc) !          write(output_unit_write,'(\"dxi: \",E17.10)') dxi(cc) end do !$OMP END SIMD if ( params % FokPlan . and . params % radiation ) then if ( params % GC_rad_model . eq . 'SDE' ) then !$OMP SIMD do cc = 1_idef , pchunk SC_p ( cc ) =- gam ( cc ) * pm ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & ( cparams_ss % taur / Bmag ( cc ) ** 2 ) SC_mu ( cc ) = xi ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) / & (( cparams_ss % taur / Bmag ( cc ) ** 2 ) * gam ( cc )) kappa = 2._rp * C_PI * C_RE ** 2._rp * C_ME * C_C ** 2._rp BREM_p ( cc ) =- 2._rp * ne ( cc ) * kappa * Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * & C_a / C_PI * ( gam ( cc ) - 1._rp ) * ( log ( 2._rp * gam ( cc )) - 1._rp / 3._rp ) dp ( cc ) = dp ( cc ) + ( SC_p ( cc ) + BREM_p ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) dxi ( cc ) = dxi ( cc ) + ( SC_mu ( cc )) * dt * & REAL ( flagCol ( cc )) * REAL ( flagCon ( cc )) end do !$OMP END SIMD end if end if !$OMP SIMD do cc = 1_idef , pchunk pm ( cc ) = pm ( cc ) + dp ( cc ) xi ( cc ) = xi ( cc ) + dxi ( cc ) !          if (pm(cc)<0) pm(cc)=-pm(cc) ! Keep xi between [-1,1] if ( xi ( cc ) > 1 ) then !             write(output_unit_write,'(\"High xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) xi ( cc ) = 1 - mod ( xi ( cc ), 1._rp ) else if ( xi ( cc ) <- 1 ) then xi ( cc ) =- 1 - mod ( xi ( cc ), - 1._rp ) !             write(output_unit_write,'(\"Low xi at: \",E17.10,\" with dxi: \",E17.10)') & !                  time*params%cpp%time, dxi(cc) endif ! Transform P,xi to p_pll,mu Ppll ( cc ) = pm ( cc ) * xi ( cc ) Pmu ( cc ) = ( pm ( cc ) * pm ( cc ) - Ppll ( cc ) * Ppll ( cc )) / ( 2 * me * Bmag ( cc )) end do !$OMP END SIMD !       write(output_unit_write,'(\"rnd1: \",E17.10)') rnd1 !       write(output_unit_write,'(\"flag: \",I16)') flag !       write(output_unit_write,'(\"CA: \",E17.10)') CAL !       write(output_unit_write,'(\"dCA: \",E17.10)') dCAL !       write(output_unit_write,'(\"CF \",E17.10)') CFL !       write(output_unit_write,'(\"CB: \",E17.10)') CBL !       write(output_unit_write,'(\"dp: \",E17.10)') dp !       write(output_unit_write,'(\"dxi: \",E17.10)') dxi !       write(output_unit_write,'(\"Ppll: \",E17.10)') Ppll !      write(output_unit_write,'(\"Pmu: \",E17.10)') Pmu !       write(output_unit_write,'(\"E_PHI_COL: \",E17.10)') E_PHI do cc = 1_idef , pchunk if (( pm ( cc ). lt . 1._rp ). and . flagCol ( cc ). eq . 1_ip ) then !             write(output_unit_write,'(\"Momentum less than zero\")') !             stop !             write(output_unit_write,'(\"Particle not tracked at: \",E17.10,\" & !                  & with xi: \",E17.10)') time*params%cpp%time, xi(cc) flagCol ( cc ) = 0_ip end if end do !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"dp_rad: \",E17.10)') & !               -gam(1)*pm(1)*(1-xi(1)*xi(1))/ & !               (cparams_ss%taur/Bmag(1)**2)*dt !          write(output_unit_write,'(\"dxi_rad: \",E17.10)') & !               xi(1)*(1-xi(1)*xi(1))/ & !               ((cparams_ss%taur/Bmag(1)**2)*gam(1))*dt !       end if !       if (tt .EQ. 1_ip) then !          write(output_unit_write,'(\"CA: \",E17.10)') CAL(1) !          write(output_unit_write,'(\"dCA: \",E17.10)') dCAL(1) !          write(output_unit_write,'(\"CF \",E17.10)') CFL(1) !          write(output_unit_write,'(\"CB: \",E17.10)') CBL(1) !       end if if (. not . params % FokPlan ) E_PHI = E_PHI0 end if end subroutine include_CoulombCollisions_GCm3dc1_p","tags":"","loc":"proc/include_coulombcollisions_gcm3dc1_p.html"},{"title":"save_params_ms – KORC-Full Orbit","text":"private subroutine save_params_ms(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_params_ms Source Code subroutine save_params_ms ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simulation_parameters.h5\" call h5fopen_f ( TRIM ( filename ), H5F_ACC_RDWR_F , h5file_id , h5error ) gname = \"collisions_ms\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( cparams_ms % num_impurity_species )) dset = TRIM ( gname ) // \"/model\" call save_string_parameter ( h5file_id , dset ,( / params % collisions_model / )) dset = TRIM ( gname ) // \"/num_impurity_species\" attr = \"Number of impurity species\" call save_to_hdf5 ( h5file_id , dset , cparams_ms % num_impurity_species , attr ) dset = TRIM ( gname ) // \"/Te\" attr = \"Background electron temperature in eV\" units = params % cpp % temperature / C_E call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % Te , attr ) dset = TRIM ( gname ) // \"/ne\" attr = \"Background electron density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % ne , attr ) dset = TRIM ( gname ) // \"/nH\" attr = \"Background proton density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % nH , attr ) dset = TRIM ( gname ) // \"/nef\" attr = \"Free electron density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % nef , attr ) dset = TRIM ( gname ) // \"/neb\" attr_array ( 1 ) = \"Bound electron density per impurity in m&#94;-3\" units = params % cpp % density call save_1d_array_to_hdf5 ( h5file_id , dset , units * cparams_ms % neb , & attr_array ) dset = TRIM ( gname ) // \"/Zo\" attr_array ( 1 ) = \"Full nuclear charge of impurities\" call save_1d_array_to_hdf5 ( h5file_id , dset , cparams_ms % Zo , attr_array ) dset = TRIM ( gname ) // \"/Zj\" attr_array ( 1 ) = \"Average charge state of impurities\" call save_1d_array_to_hdf5 ( h5file_id , dset , cparams_ms % Zj , attr_array ) dset = TRIM ( gname ) // \"/nz\" attr_array ( 1 ) = \"Density of impurities in m&#94;-3\" units = params % cpp % density call save_1d_array_to_hdf5 ( h5file_id , dset , units * cparams_ms % nz , attr_array ) dset = TRIM ( gname ) // \"/IZj\" attr_array ( 1 ) = \" Ionization energy of impurities in eV\" units = params % cpp % energy / C_E call save_1d_array_to_hdf5 ( h5file_id , dset , units * cparams_ms % IZj , & attr_array ) dset = TRIM ( gname ) // \"/rD\" attr = \"Debye length in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % rD , attr ) dset = TRIM ( gname ) // \"/re\" attr = \"Classical electron radius in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ms % re , attr ) DEALLOCATE ( attr_array ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if end subroutine save_params_ms","tags":"","loc":"proc/save_params_ms.html"},{"title":"save_params_ss – KORC-Full Orbit","text":"private subroutine save_params_ss(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_params_ss Source Code subroutine save_params_ss ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"simulation_parameters.h5\" call h5fopen_f ( TRIM ( filename ), H5F_ACC_RDWR_F , h5file_id , h5error ) gname = \"collisions_ss\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) ALLOCATE ( attr_array ( cparams_ms % num_impurity_species )) dset = TRIM ( gname ) // \"/collisions_model\" call save_string_parameter ( h5file_id , dset ,( / params % collisions_model / )) dset = TRIM ( gname ) // \"/Te\" attr = \"Background electron temperature in eV\" units = params % cpp % temperature / C_E call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Te , attr ) dset = TRIM ( gname ) // \"/Ti\" attr = \"Background ion temperature in eV\" units = params % cpp % temperature / C_E call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Ti , attr ) dset = TRIM ( gname ) // \"/ne\" attr = \"Background electron density in m&#94;-3\" units = params % cpp % density call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % ne , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective nuclear charge of impurities\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % Zeff , attr ) dset = TRIM ( gname ) // \"/rD\" attr = \"Debye length in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % rD , attr ) dset = TRIM ( gname ) // \"/re\" attr = \"Classical electron radius in m\" units = params % cpp % length call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % re , attr ) dset = TRIM ( gname ) // \"/Clogee\" attr = \"Coulomb logarithm\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % CoulombLogee , attr ) dset = TRIM ( gname ) // \"/Clogei\" attr = \"Coulomb logarithm\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % CoulombLogei , attr ) dset = TRIM ( gname ) // \"/VTe\" attr = \"Background electron temperature\" units = params % cpp % velocity call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % VTe , attr ) dset = TRIM ( gname ) // \"/delta\" attr = \"Delta parameter VTe/C\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % delta , attr ) dset = TRIM ( gname ) // \"/Gamma\" attr = \"Gamma coefficient\" units = ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) / params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Gammac , attr ) dset = TRIM ( gname ) // \"/Tau\" attr = \"Relativistic collisional time in s\" units = params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Tau , attr ) dset = TRIM ( gname ) // \"/Tauc\" attr = \"Thermal collisional time in s\" units = params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Tauc , attr ) dset = TRIM ( gname ) // \"/dTau\" attr = \"Subcycling time step in s\" units = params % cpp % time call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % dTau * & cparams_ss % Tau , attr ) dset = TRIM ( gname ) // \"/subcycling_iterations\" attr = \"KORC iterations per collision\" call save_to_hdf5 ( h5file_id , dset , cparams_ss % subcycling_iterations , attr ) dset = TRIM ( gname ) // \"/Ec\" attr = \"Critical electric field\" units = params % cpp % Eo call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % Ec , attr ) dset = TRIM ( gname ) // \"/ED\" attr = \"Dreicer electric field\" units = params % cpp % Eo call save_to_hdf5 ( h5file_id , dset , units * cparams_ss % ED , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if end subroutine save_params_ss","tags":"","loc":"proc/save_params_ss.html"},{"title":"save_collision_params – KORC-Full Orbit","text":"public subroutine save_collision_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_collision_params Source Code subroutine save_collision_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if (. NOT .( params % restart . OR . params % proceed )) then if ( params % collisions ) then SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) call save_params_ss ( params ) SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call save_params_ms ( params ) CASE ( 'HESSLOW' ) call save_params_ms ( params ) CASE ( 'ROSENBLUTH' ) call save_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call save_params_ms ( params ) CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT end if end if end subroutine save_collision_params","tags":"","loc":"proc/save_collision_params.html"},{"title":"deallocate_params_ms – KORC-Full Orbit","text":"private subroutine deallocate_params_ms() Arguments None Contents Source Code deallocate_params_ms Source Code subroutine deallocate_params_ms () if ( ALLOCATED ( cparams_ms % Zj )) DEALLOCATE ( cparams_ms % Zj ) if ( ALLOCATED ( cparams_ms % Zo )) DEALLOCATE ( cparams_ms % Zo ) if ( ALLOCATED ( cparams_ms % nz )) DEALLOCATE ( cparams_ms % nz ) if ( ALLOCATED ( cparams_ms % neb )) DEALLOCATE ( cparams_ms % neb ) if ( ALLOCATED ( cparams_ms % IZj )) DEALLOCATE ( cparams_ms % IZj ) if ( ALLOCATED ( cparams_ms % Zj )) DEALLOCATE ( cparams_ms % Ee_IZj ) end subroutine deallocate_params_ms","tags":"","loc":"proc/deallocate_params_ms.html"},{"title":"deallocate_collisions_params – KORC-Full Orbit","text":"public subroutine deallocate_collisions_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code deallocate_collisions_params Source Code subroutine deallocate_collisions_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if ( params % collisions ) then SELECT CASE ( TRIM ( params % collisions_model )) CASE ( MODEL1 ) !\t\t\t\twrite(output_unit_write,'(\"Something to be done\")') SELECT CASE ( TRIM ( params % bound_electron_model )) CASE ( 'NO_BOUND' ) call deallocate_params_ms () CASE ( 'HESSLOW' ) call deallocate_params_ms () CASE ( 'ROSENBLUTH' ) call deallocate_params_ms () CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT CASE ( MODEL2 ) call deallocate_params_ms () CASE DEFAULT write ( output_unit_write , '(\"Default case\")' ) END SELECT end if end subroutine deallocate_collisions_params","tags":"","loc":"proc/deallocate_collisions_params.html"},{"title":"reallocate_rv – KORC-Full Orbit","text":"public function reallocate_rv(p, n) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(:),POINTER Contents Source Code reallocate_rv Source Code FUNCTION reallocate_rv ( p , n ) REAL ( SP ), DIMENSION (:), POINTER :: p , reallocate_rv INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ) :: nold , ierr allocate ( reallocate_rv ( n ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_rv: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p ) reallocate_rv ( 1 : min ( nold , n )) = p ( 1 : min ( nold , n )) deallocate ( p ) END FUNCTION reallocate_rv","tags":"","loc":"proc/reallocate_rv.html"},{"title":"reallocate_iv – KORC-Full Orbit","text":"public function reallocate_iv(p, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(:),POINTER Contents Source Code reallocate_iv Source Code FUNCTION reallocate_iv ( p , n ) INTEGER ( I4B ), DIMENSION (:), POINTER :: p , reallocate_iv INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ) :: nold , ierr allocate ( reallocate_iv ( n ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_iv: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p ) reallocate_iv ( 1 : min ( nold , n )) = p ( 1 : min ( nold , n )) deallocate ( p ) END FUNCTION reallocate_iv","tags":"","loc":"proc/reallocate_iv.html"},{"title":"reallocate_hv – KORC-Full Orbit","text":"public function reallocate_hv(p, n) Arguments Type Intent Optional Attributes Name character(len=1), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value character(len=1),\n  DIMENSION(:),POINTER Contents Source Code reallocate_hv Source Code FUNCTION reallocate_hv ( p , n ) CHARACTER ( 1 ), DIMENSION (:), POINTER :: p , reallocate_hv INTEGER ( I4B ), INTENT ( IN ) :: n INTEGER ( I4B ) :: nold , ierr allocate ( reallocate_hv ( n ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_hv: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p ) reallocate_hv ( 1 : min ( nold , n )) = p ( 1 : min ( nold , n )) deallocate ( p ) END FUNCTION reallocate_hv","tags":"","loc":"proc/reallocate_hv.html"},{"title":"reallocate_rm – KORC-Full Orbit","text":"public function reallocate_rm(p, n, m) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value real(kind=SP),\n  DIMENSION(:,:),POINTER Contents Source Code reallocate_rm Source Code FUNCTION reallocate_rm ( p , n , m ) REAL ( SP ), DIMENSION (:,:), POINTER :: p , reallocate_rm INTEGER ( I4B ), INTENT ( IN ) :: n , m INTEGER ( I4B ) :: nold , mold , ierr allocate ( reallocate_rm ( n , m ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_rm: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p , 1 ) mold = size ( p , 2 ) reallocate_rm ( 1 : min ( nold , n ), 1 : min ( mold , m )) = & p ( 1 : min ( nold , n ), 1 : min ( mold , m )) deallocate ( p ) END FUNCTION reallocate_rm","tags":"","loc":"proc/reallocate_rm.html"},{"title":"reallocate_im – KORC-Full Orbit","text":"public function reallocate_im(p, n, m) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value integer(kind=I4B),\n  DIMENSION(:,:),POINTER Contents Source Code reallocate_im Source Code FUNCTION reallocate_im ( p , n , m ) INTEGER ( I4B ), DIMENSION (:,:), POINTER :: p , reallocate_im INTEGER ( I4B ), INTENT ( IN ) :: n , m INTEGER ( I4B ) :: nold , mold , ierr allocate ( reallocate_im ( n , m ), stat = ierr ) if ( ierr /= 0 ) call & nrerror ( 'reallocate_im: problem in attempt to allocate memory' ) if (. not . associated ( p )) RETURN nold = size ( p , 1 ) mold = size ( p , 2 ) reallocate_im ( 1 : min ( nold , n ), 1 : min ( mold , m )) = & p ( 1 : min ( nold , n ), 1 : min ( mold , m )) deallocate ( p ) END FUNCTION reallocate_im","tags":"","loc":"proc/reallocate_im.html"},{"title":"ifirstloc – KORC-Full Orbit","text":"public function ifirstloc(mask) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value integer(kind=I4B) Contents Source Code ifirstloc Source Code FUNCTION ifirstloc ( mask ) LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask INTEGER ( I4B ) :: ifirstloc INTEGER ( I4B ), DIMENSION ( 1 ) :: loc loc = maxloc ( merge ( 1 , 0 , mask )) ifirstloc = loc ( 1 ) if (. not . mask ( ifirstloc )) ifirstloc = size ( mask ) + 1 END FUNCTION ifirstloc","tags":"","loc":"proc/ifirstloc.html"},{"title":"imaxloc_r – KORC-Full Orbit","text":"public function imaxloc_r(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) Contents Source Code imaxloc_r Source Code FUNCTION imaxloc_r ( arr ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ) :: imaxloc_r INTEGER ( I4B ), DIMENSION ( 1 ) :: imax imax = maxloc ( arr (:)) imaxloc_r = imax ( 1 ) END FUNCTION imaxloc_r","tags":"","loc":"proc/imaxloc_r.html"},{"title":"imaxloc_i – KORC-Full Orbit","text":"public function imaxloc_i(iarr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B) Contents Source Code imaxloc_i Source Code FUNCTION imaxloc_i ( iarr ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: iarr INTEGER ( I4B ), DIMENSION ( 1 ) :: imax INTEGER ( I4B ) :: imaxloc_i imax = maxloc ( iarr (:)) imaxloc_i = imax ( 1 ) END FUNCTION imaxloc_i","tags":"","loc":"proc/imaxloc_i.html"},{"title":"iminloc – KORC-Full Orbit","text":"public function iminloc(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) Contents Source Code iminloc Source Code FUNCTION iminloc ( arr ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION ( 1 ) :: imin INTEGER ( I4B ) :: iminloc imin = minloc ( arr (:)) iminloc = imin ( 1 ) END FUNCTION iminloc","tags":"","loc":"proc/iminloc.html"},{"title":"assert_eq2 – KORC-Full Orbit","text":"public function assert_eq2(n1, n2, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer Contents Source Code assert_eq2 Source Code FUNCTION assert_eq2 ( n1 , n2 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 INTEGER :: assert_eq2 if ( n1 == n2 ) then assert_eq2 = n1 else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eq2' end if END FUNCTION assert_eq2","tags":"","loc":"proc/assert_eq2.html"},{"title":"assert_eq3 – KORC-Full Orbit","text":"public function assert_eq3(n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer Contents Source Code assert_eq3 Source Code FUNCTION assert_eq3 ( n1 , n2 , n3 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 , n3 INTEGER :: assert_eq3 if ( n1 == n2 . and . n2 == n3 ) then assert_eq3 = n1 else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eq3' end if END FUNCTION assert_eq3","tags":"","loc":"proc/assert_eq3.html"},{"title":"assert_eq4 – KORC-Full Orbit","text":"public function assert_eq4(n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer Contents Source Code assert_eq4 Source Code FUNCTION assert_eq4 ( n1 , n2 , n3 , n4 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , INTENT ( IN ) :: n1 , n2 , n3 , n4 INTEGER :: assert_eq4 if ( n1 == n2 . and . n2 == n3 . and . n3 == n4 ) then assert_eq4 = n1 else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eq4' end if END FUNCTION assert_eq4","tags":"","loc":"proc/assert_eq4.html"},{"title":"assert_eqn – KORC-Full Orbit","text":"public function assert_eqn(nn, string) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string Return Value integer Contents Source Code assert_eqn Source Code FUNCTION assert_eqn ( nn , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER , DIMENSION (:), INTENT ( IN ) :: nn INTEGER :: assert_eqn if ( all ( nn ( 2 :) == nn ( 1 ))) then assert_eqn = nn ( 1 ) else write ( * , * ) 'nrerror: an assert_eq failed with this tag:' , & string STOP 'program terminated by assert_eqn' end if END FUNCTION assert_eqn","tags":"","loc":"proc/assert_eqn.html"},{"title":"arth_r – KORC-Full Orbit","text":"public function arth_r(first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) Contents Source Code arth_r Source Code FUNCTION arth_r ( first , increment , n ) REAL ( SP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: arth_r INTEGER ( I4B ) :: k , k2 REAL ( SP ) :: temp if ( n > 0 ) arth_r ( 1 ) = first if ( n <= NPAR_ARTH ) then do k = 2 , n arth_r ( k ) = arth_r ( k - 1 ) + increment end do else do k = 2 , NPAR2_ARTH arth_r ( k ) = arth_r ( k - 1 ) + increment end do temp = increment * NPAR2_ARTH k = NPAR2_ARTH do if ( k >= n ) exit k2 = k + k arth_r ( k + 1 : min ( k2 , n )) = temp + arth_r ( 1 : min ( k , n - k )) temp = temp + temp k = k2 end do end if END FUNCTION arth_r","tags":"","loc":"proc/arth_r.html"},{"title":"arth_d – KORC-Full Orbit","text":"public function arth_d(first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) Contents Source Code arth_d Source Code FUNCTION arth_d ( first , increment , n ) REAL ( DP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( n ) :: arth_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp if ( n > 0 ) arth_d ( 1 ) = first if ( n <= NPAR_ARTH ) then do k = 2 , n arth_d ( k ) = arth_d ( k - 1 ) + increment end do else do k = 2 , NPAR2_ARTH arth_d ( k ) = arth_d ( k - 1 ) + increment end do temp = increment * NPAR2_ARTH k = NPAR2_ARTH do if ( k >= n ) exit k2 = k + k arth_d ( k + 1 : min ( k2 , n )) = temp + arth_d ( 1 : min ( k , n - k )) temp = temp + temp k = k2 end do end if END FUNCTION arth_d","tags":"","loc":"proc/arth_d.html"},{"title":"arth_i – KORC-Full Orbit","text":"public function arth_i(first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) Contents Source Code arth_i Source Code FUNCTION arth_i ( first , increment , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , increment , n INTEGER ( I4B ), DIMENSION ( n ) :: arth_i INTEGER ( I4B ) :: k , k2 , temp if ( n > 0 ) arth_i ( 1 ) = first if ( n <= NPAR_ARTH ) then do k = 2 , n arth_i ( k ) = arth_i ( k - 1 ) + increment end do else do k = 2 , NPAR2_ARTH arth_i ( k ) = arth_i ( k - 1 ) + increment end do temp = increment * NPAR2_ARTH k = NPAR2_ARTH do if ( k >= n ) exit k2 = k + k arth_i ( k + 1 : min ( k2 , n )) = temp + arth_i ( 1 : min ( k , n - k )) temp = temp + temp k = k2 end do end if END FUNCTION arth_i","tags":"","loc":"proc/arth_i.html"},{"title":"geop_r – KORC-Full Orbit","text":"public function geop_r(first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) Contents Source Code geop_r Source Code FUNCTION geop_r ( first , factor , n ) REAL ( SP ), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: geop_r INTEGER ( I4B ) :: k , k2 REAL ( SP ) :: temp if ( n > 0 ) geop_r ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_r ( k ) = geop_r ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_r ( k ) = geop_r ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_r ( k + 1 : min ( k2 , n )) = temp * geop_r ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_r","tags":"","loc":"proc/geop_r.html"},{"title":"geop_d – KORC-Full Orbit","text":"public function geop_d(first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) Contents Source Code geop_d Source Code FUNCTION geop_d ( first , factor , n ) REAL ( DP ), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( n ) :: geop_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp if ( n > 0 ) geop_d ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_d ( k ) = geop_d ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_d ( k ) = geop_d ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_d ( k + 1 : min ( k2 , n )) = temp * geop_d ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_d","tags":"","loc":"proc/geop_d.html"},{"title":"geop_i – KORC-Full Orbit","text":"public function geop_i(first, factor, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) Contents Source Code geop_i Source Code FUNCTION geop_i ( first , factor , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , factor , n INTEGER ( I4B ), DIMENSION ( n ) :: geop_i INTEGER ( I4B ) :: k , k2 , temp if ( n > 0 ) geop_i ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_i ( k ) = geop_i ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_i ( k ) = geop_i ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_i ( k + 1 : min ( k2 , n )) = temp * geop_i ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_i","tags":"","loc":"proc/geop_i.html"},{"title":"geop_c – KORC-Full Orbit","text":"public function geop_c(first, factor, n) Arguments Type Intent Optional Attributes Name complex(kind=SP), intent(in) :: first complex(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value complex(kind=SP),\n  DIMENSION(n) Contents Source Code geop_c Source Code FUNCTION geop_c ( first , factor , n ) COMPLEX ( SP ), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n COMPLEX ( SP ), DIMENSION ( n ) :: geop_c INTEGER ( I4B ) :: k , k2 COMPLEX ( SP ) :: temp if ( n > 0 ) geop_c ( 1 ) = first if ( n <= NPAR_GEOP ) then do k = 2 , n geop_c ( k ) = geop_c ( k - 1 ) * factor end do else do k = 2 , NPAR2_GEOP geop_c ( k ) = geop_c ( k - 1 ) * factor end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_c ( k + 1 : min ( k2 , n )) = temp * geop_c ( 1 : min ( k , n - k )) temp = temp * temp k = k2 end do end if END FUNCTION geop_c","tags":"","loc":"proc/geop_c.html"},{"title":"geop_dv – KORC-Full Orbit","text":"public function geop_dv(first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: first real(kind=DP), intent(in), DIMENSION(:) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(size(first),n) Contents Source Code geop_dv Source Code FUNCTION geop_dv ( first , factor , n ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: first , factor INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( size ( first ), n ) :: geop_dv INTEGER ( I4B ) :: k , k2 REAL ( DP ), DIMENSION ( size ( first )) :: temp if ( n > 0 ) geop_dv (:, 1 ) = first (:) if ( n <= NPAR_GEOP ) then do k = 2 , n geop_dv (:, k ) = geop_dv (:, k - 1 ) * factor (:) end do else do k = 2 , NPAR2_GEOP geop_dv (:, k ) = geop_dv (:, k - 1 ) * factor (:) end do temp = factor ** NPAR2_GEOP k = NPAR2_GEOP do if ( k >= n ) exit k2 = k + k geop_dv (:, k + 1 : min ( k2 , n )) = geop_dv (:, 1 : min ( k , n - k )) * & spread ( temp , 2 , size ( geop_dv (:, 1 : min ( k , n - k )), 2 )) temp = temp * temp k = k2 end do end if END FUNCTION geop_dv","tags":"","loc":"proc/geop_dv.html"},{"title":"cumsum_r – KORC-Full Orbit","text":"public recursive function cumsum_r(arr, seed) result(ans) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(in), optional :: seed Return Value real(kind=SP),\n  DIMENSION(size(arr)) Contents Source Code cumsum_r Source Code RECURSIVE FUNCTION cumsum_r ( arr , seed ) RESULT ( ans ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr REAL ( SP ), OPTIONAL , INTENT ( IN ) :: seed REAL ( SP ), DIMENSION ( size ( arr )) :: ans INTEGER ( I4B ) :: n , j REAL ( SP ) :: sd n = size ( arr ) if ( n == 0_i4b ) RETURN sd = 0.0_sp if ( present ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) + sd if ( n < NPAR_CUMSUM ) then do j = 2 , n ans ( j ) = ans ( j - 1 ) + arr ( j ) end do else ans ( 2 : n : 2 ) = cumsum_r ( arr ( 2 : n : 2 ) + arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) + arr ( 3 : n : 2 ) end if END FUNCTION cumsum_r","tags":"","loc":"proc/cumsum_r.html"},{"title":"cumsum_i – KORC-Full Orbit","text":"public recursive function cumsum_i(arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(size(arr)) Contents Source Code cumsum_i Source Code RECURSIVE FUNCTION cumsum_i ( arr , seed ) RESULT ( ans ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: seed INTEGER ( I4B ), DIMENSION ( size ( arr )) :: ans INTEGER ( I4B ) :: n , j , sd n = size ( arr ) if ( n == 0_i4b ) RETURN sd = 0_i4b if ( present ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) + sd if ( n < NPAR_CUMSUM ) then do j = 2 , n ans ( j ) = ans ( j - 1 ) + arr ( j ) end do else ans ( 2 : n : 2 ) = cumsum_i ( arr ( 2 : n : 2 ) + arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) + arr ( 3 : n : 2 ) end if END FUNCTION cumsum_i","tags":"","loc":"proc/cumsum_i.html"},{"title":"cumprod – KORC-Full Orbit","text":"public recursive function cumprod(arr, seed) result(ans) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(in), optional :: seed Return Value real(kind=SP),\n  DIMENSION(size(arr)) Contents Source Code cumprod Source Code RECURSIVE FUNCTION cumprod ( arr , seed ) RESULT ( ans ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: arr REAL ( SP ), OPTIONAL , INTENT ( IN ) :: seed REAL ( SP ), DIMENSION ( size ( arr )) :: ans INTEGER ( I4B ) :: n , j REAL ( SP ) :: sd n = size ( arr ) if ( n == 0_i4b ) RETURN sd = 1.0_sp if ( present ( seed )) sd = seed ans ( 1 ) = arr ( 1 ) * sd if ( n < NPAR_CUMPROD ) then do j = 2 , n ans ( j ) = ans ( j - 1 ) * arr ( j ) end do else ans ( 2 : n : 2 ) = cumprod ( arr ( 2 : n : 2 ) * arr ( 1 : n - 1 : 2 ), sd ) ans ( 3 : n : 2 ) = ans ( 2 : n - 1 : 2 ) * arr ( 3 : n : 2 ) end if END FUNCTION cumprod","tags":"","loc":"proc/cumprod.html"},{"title":"poly_rr – KORC-Full Orbit","text":"public function poly_rr(x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP) Contents Source Code poly_rr Source Code FUNCTION poly_rr ( x , coeffs ) REAL ( SP ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs REAL ( SP ) :: poly_rr REAL ( SP ) :: pow REAL ( SP ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_rr = 0.0_sp else if ( n < NPAR_POLY ) then poly_rr = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_rr = x * poly_rr + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_sp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_rr = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_rr","tags":"","loc":"proc/poly_rr.html"},{"title":"poly_dd – KORC-Full Orbit","text":"public function poly_dd(x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP) Contents Source Code poly_dd Source Code FUNCTION poly_dd ( x , coeffs ) REAL ( DP ), INTENT ( IN ) :: x REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: coeffs REAL ( DP ) :: poly_dd REAL ( DP ) :: pow REAL ( DP ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_dd = 0.0_dp else if ( n < NPAR_POLY ) then poly_dd = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_dd = x * poly_dd + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_dp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_dd = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_dd","tags":"","loc":"proc/poly_dd.html"},{"title":"poly_rc – KORC-Full Orbit","text":"public function poly_rc(x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) Contents Source Code poly_rc Source Code FUNCTION poly_rc ( x , coeffs ) COMPLEX ( SPC ), INTENT ( IN ) :: x REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs COMPLEX ( SPC ) :: poly_rc COMPLEX ( SPC ) :: pow COMPLEX ( SPC ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_rc = 0.0_sp else if ( n < NPAR_POLY ) then poly_rc = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_rc = x * poly_rc + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_sp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_rc = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_rc","tags":"","loc":"proc/poly_rc.html"},{"title":"poly_cc – KORC-Full Orbit","text":"public function poly_cc(x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x complex(kind=SPC), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) Contents Source Code poly_cc Source Code FUNCTION poly_cc ( x , coeffs ) COMPLEX ( SPC ), INTENT ( IN ) :: x COMPLEX ( SPC ), DIMENSION (:), INTENT ( IN ) :: coeffs COMPLEX ( SPC ) :: poly_cc COMPLEX ( SPC ) :: pow COMPLEX ( SPC ), DIMENSION (:), ALLOCATABLE :: vec INTEGER ( I4B ) :: i , n , nn n = size ( coeffs ) if ( n <= 0 ) then poly_cc = 0.0_sp else if ( n < NPAR_POLY ) then poly_cc = coeffs ( n ) do i = n - 1 , 1 , - 1 poly_cc = x * poly_cc + coeffs ( i ) end do else allocate ( vec ( n + 1 )) pow = x vec ( 1 : n ) = coeffs do vec ( n + 1 ) = 0.0_sp nn = ishft ( n + 1 , - 1 ) vec ( 1 : nn ) = vec ( 1 : n : 2 ) + pow * vec ( 2 : n + 1 : 2 ) if ( nn == 1 ) exit pow = pow * pow n = nn end do poly_cc = vec ( 1 ) deallocate ( vec ) end if END FUNCTION poly_cc","tags":"","loc":"proc/poly_cc.html"},{"title":"poly_rrv – KORC-Full Orbit","text":"public function poly_rrv(x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP),\n  DIMENSION(size(x)) Contents Source Code poly_rrv Source Code FUNCTION poly_rrv ( x , coeffs ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x REAL ( SP ), DIMENSION ( size ( x )) :: poly_rrv INTEGER ( I4B ) :: i , n , m m = size ( coeffs ) n = size ( x ) if ( m <= 0 ) then poly_rrv = 0.0_sp else if ( m < n . or . m < NPAR_POLY ) then poly_rrv = coeffs ( m ) do i = m - 1 , 1 , - 1 poly_rrv = x * poly_rrv + coeffs ( i ) end do else do i = 1 , n poly_rrv ( i ) = poly_rr ( x ( i ), coeffs ) end do end if END FUNCTION poly_rrv","tags":"","loc":"proc/poly_rrv.html"},{"title":"poly_ddv – KORC-Full Orbit","text":"public function poly_ddv(x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP),\n  DIMENSION(size(x)) Contents Source Code poly_ddv Source Code FUNCTION poly_ddv ( x , coeffs ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x REAL ( DP ), DIMENSION ( size ( x )) :: poly_ddv INTEGER ( I4B ) :: i , n , m m = size ( coeffs ) n = size ( x ) if ( m <= 0 ) then poly_ddv = 0.0_dp else if ( m < n . or . m < NPAR_POLY ) then poly_ddv = coeffs ( m ) do i = m - 1 , 1 , - 1 poly_ddv = x * poly_ddv + coeffs ( i ) end do else do i = 1 , n poly_ddv ( i ) = poly_dd ( x ( i ), coeffs ) end do end if END FUNCTION poly_ddv","tags":"","loc":"proc/poly_ddv.html"},{"title":"poly_msk_rrv – KORC-Full Orbit","text":"public function poly_msk_rrv(x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=SP),\n  DIMENSION(size(x)) Contents Source Code poly_msk_rrv Source Code FUNCTION poly_msk_rrv ( x , coeffs , mask ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( SP ), DIMENSION ( size ( x )) :: poly_msk_rrv poly_msk_rrv = unpack ( poly_rrv ( pack ( x , mask ), coeffs ), mask , 0.0_sp ) END FUNCTION poly_msk_rrv","tags":"","loc":"proc/poly_msk_rrv.html"},{"title":"poly_msk_ddv – KORC-Full Orbit","text":"public function poly_msk_ddv(x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=DP),\n  DIMENSION(size(x)) Contents Source Code poly_msk_ddv Source Code FUNCTION poly_msk_ddv ( x , coeffs , mask ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: coeffs , x LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( DP ), DIMENSION ( size ( x )) :: poly_msk_ddv poly_msk_ddv = unpack ( poly_ddv ( pack ( x , mask ), coeffs ), mask , 0.0_dp ) END FUNCTION poly_msk_ddv","tags":"","loc":"proc/poly_msk_ddv.html"},{"title":"poly_term_rr – KORC-Full Orbit","text":"public recursive function poly_term_rr(a, b) result(u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP),\n  DIMENSION(size(a)) Contents Source Code poly_term_rr Source Code RECURSIVE FUNCTION poly_term_rr ( a , b ) RESULT ( u ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a REAL ( SP ), INTENT ( IN ) :: b REAL ( SP ), DIMENSION ( size ( a )) :: u INTEGER ( I4B ) :: n , j n = size ( a ) if ( n <= 0 ) RETURN u ( 1 ) = a ( 1 ) if ( n < NPAR_POLYTERM ) then do j = 2 , n u ( j ) = a ( j ) + b * u ( j - 1 ) end do else u ( 2 : n : 2 ) = poly_term_rr ( a ( 2 : n : 2 ) + a ( 1 : n - 1 : 2 ) * b , b * b ) u ( 3 : n : 2 ) = a ( 3 : n : 2 ) + b * u ( 2 : n - 1 : 2 ) end if END FUNCTION poly_term_rr","tags":"","loc":"proc/poly_term_rr.html"},{"title":"poly_term_cc – KORC-Full Orbit","text":"public recursive function poly_term_cc(a, b) result(u) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(in) :: b Return Value complex(kind=SPC),\n  DIMENSION(size(a)) Contents Source Code poly_term_cc Source Code RECURSIVE FUNCTION poly_term_cc ( a , b ) RESULT ( u ) COMPLEX ( SPC ), DIMENSION (:), INTENT ( IN ) :: a COMPLEX ( SPC ), INTENT ( IN ) :: b COMPLEX ( SPC ), DIMENSION ( size ( a )) :: u INTEGER ( I4B ) :: n , j n = size ( a ) if ( n <= 0 ) RETURN u ( 1 ) = a ( 1 ) if ( n < NPAR_POLYTERM ) then do j = 2 , n u ( j ) = a ( j ) + b * u ( j - 1 ) end do else u ( 2 : n : 2 ) = poly_term_cc ( a ( 2 : n : 2 ) + a ( 1 : n - 1 : 2 ) * b , b * b ) u ( 3 : n : 2 ) = a ( 3 : n : 2 ) + b * u ( 2 : n - 1 : 2 ) end if END FUNCTION poly_term_cc","tags":"","loc":"proc/poly_term_cc.html"},{"title":"zroots_unity – KORC-Full Orbit","text":"public function zroots_unity(n, nn) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: nn Return Value complex(kind=SPC),\n  DIMENSION(nn) Contents Source Code zroots_unity Source Code FUNCTION zroots_unity ( n , nn ) INTEGER ( I4B ), INTENT ( IN ) :: n , nn COMPLEX ( SPC ), DIMENSION ( nn ) :: zroots_unity INTEGER ( I4B ) :: k REAL ( SP ) :: theta zroots_unity ( 1 ) = 1.0 theta = TWOPI / n k = 1 do if ( k >= nn ) exit zroots_unity ( k + 1 ) = cmplx ( cos ( k * theta ), sin ( k * theta ), SPC ) zroots_unity ( k + 2 : min ( 2 * k , nn )) = zroots_unity ( k + 1 ) * & zroots_unity ( 2 : min ( k , nn - k )) k = 2 * k end do END FUNCTION zroots_unity","tags":"","loc":"proc/zroots_unity.html"},{"title":"outerprod_r – KORC-Full Orbit","text":"public function outerprod_r(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerprod_r Source Code FUNCTION outerprod_r ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerprod_r outerprod_r = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerprod_r","tags":"","loc":"proc/outerprod_r.html"},{"title":"outerprod_d – KORC-Full Orbit","text":"public function outerprod_d(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerprod_d Source Code FUNCTION outerprod_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( size ( a ), size ( b )) :: outerprod_d outerprod_d = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerprod_d","tags":"","loc":"proc/outerprod_d.html"},{"title":"outerdiv – KORC-Full Orbit","text":"public function outerdiv(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdiv Source Code FUNCTION outerdiv ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerdiv outerdiv = spread ( a , dim = 2 , ncopies = size ( b )) / & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiv","tags":"","loc":"proc/outerdiv.html"},{"title":"outersum – KORC-Full Orbit","text":"public function outersum(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) Contents Source Code outersum Source Code FUNCTION outersum ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outersum outersum = spread ( a , dim = 2 , ncopies = size ( b )) + & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outersum","tags":"","loc":"proc/outersum.html"},{"title":"outerdiff_r – KORC-Full Orbit","text":"public function outerdiff_r(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdiff_r Source Code FUNCTION outerdiff_r ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerdiff_r outerdiff_r = spread ( a , dim = 2 , ncopies = size ( b )) - & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiff_r","tags":"","loc":"proc/outerdiff_r.html"},{"title":"outerdiff_d – KORC-Full Orbit","text":"public function outerdiff_d(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdiff_d Source Code FUNCTION outerdiff_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( size ( a ), size ( b )) :: outerdiff_d outerdiff_d = spread ( a , dim = 2 , ncopies = size ( b )) - & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiff_d","tags":"","loc":"proc/outerdiff_d.html"},{"title":"outerdiff_i – KORC-Full Orbit","text":"public function outerdiff_i(a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdiff_i Source Code FUNCTION outerdiff_i ( a , b ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: a , b INTEGER ( I4B ), DIMENSION ( size ( a ), size ( b )) :: outerdiff_i outerdiff_i = spread ( a , dim = 2 , ncopies = size ( b )) - & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdiff_i","tags":"","loc":"proc/outerdiff_i.html"},{"title":"outerand – KORC-Full Orbit","text":"public function outerand(a, b) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: b Return Value logical(kind=LGT),\n  DIMENSION(size(a),size(b)) Contents Source Code outerand Source Code FUNCTION outerand ( a , b ) LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: a , b LOGICAL ( LGT ), DIMENSION ( size ( a ), size ( b )) :: outerand outerand = spread ( a , dim = 2 , ncopies = size ( b )) . and . & spread ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerand","tags":"","loc":"proc/outerand.html"},{"title":"get_diag_rv – KORC-Full Orbit","text":"public function get_diag_rv(mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=SP),\n  DIMENSION(size(mat,1)) Contents Source Code get_diag_rv Source Code FUNCTION get_diag_rv ( mat ) REAL ( SP ), DIMENSION (:,:), INTENT ( IN ) :: mat REAL ( SP ), DIMENSION ( size ( mat , 1 )) :: get_diag_rv INTEGER ( I4B ) :: j j = assert_eq2 ( size ( mat , 1 ), size ( mat , 2 ), 'get_diag_rv' ) do j = 1 , size ( mat , 1 ) get_diag_rv ( j ) = mat ( j , j ) end do END FUNCTION get_diag_rv","tags":"","loc":"proc/get_diag_rv.html"},{"title":"get_diag_dv – KORC-Full Orbit","text":"public function get_diag_dv(mat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=DP),\n  DIMENSION(size(mat,1)) Contents Source Code get_diag_dv Source Code FUNCTION get_diag_dv ( mat ) REAL ( DP ), DIMENSION (:,:), INTENT ( IN ) :: mat REAL ( DP ), DIMENSION ( size ( mat , 1 )) :: get_diag_dv INTEGER ( I4B ) :: j j = assert_eq2 ( size ( mat , 1 ), size ( mat , 2 ), 'get_diag_dv' ) do j = 1 , size ( mat , 1 ) get_diag_dv ( j ) = mat ( j , j ) end do END FUNCTION get_diag_dv","tags":"","loc":"proc/get_diag_dv.html"},{"title":"upper_triangle – KORC-Full Orbit","text":"public function upper_triangle(j, k, extra) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: j integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in), optional :: extra Return Value logical(kind=LGT),\n  DIMENSION(j,k) Contents Source Code upper_triangle Source Code FUNCTION upper_triangle ( j , k , extra ) INTEGER ( I4B ), INTENT ( IN ) :: j , k INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: extra LOGICAL ( LGT ), DIMENSION ( j , k ) :: upper_triangle INTEGER ( I4B ) :: n n = 0 if ( present ( extra )) n = extra upper_triangle = ( outerdiff ( arth_i ( 1 , 1 , j ), arth_i ( 1 , 1 , k )) < n ) END FUNCTION upper_triangle","tags":"","loc":"proc/upper_triangle.html"},{"title":"lower_triangle – KORC-Full Orbit","text":"public function lower_triangle(j, k, extra) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: j integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in), optional :: extra Return Value logical(kind=LGT),\n  DIMENSION(j,k) Contents Source Code lower_triangle Source Code FUNCTION lower_triangle ( j , k , extra ) INTEGER ( I4B ), INTENT ( IN ) :: j , k INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: extra LOGICAL ( LGT ), DIMENSION ( j , k ) :: lower_triangle INTEGER ( I4B ) :: n n = 0 if ( present ( extra )) n = extra lower_triangle = ( outerdiff ( arth_i ( 1 , 1 , j ), arth_i ( 1 , 1 , k )) > - n ) END FUNCTION lower_triangle","tags":"","loc":"proc/lower_triangle.html"},{"title":"vabs – KORC-Full Orbit","text":"public function vabs(v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: v Return Value real(kind=SP) Contents Source Code vabs Source Code FUNCTION vabs ( v ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: v REAL ( SP ) :: vabs vabs = SQRT ( dot_product ( v , v )) END FUNCTION vabs","tags":"","loc":"proc/vabs.html"},{"title":"array_copy_r – KORC-Full Orbit","text":"public subroutine array_copy_r(src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: src real(kind=SP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied Contents Source Code array_copy_r Source Code SUBROUTINE array_copy_r ( src , dest , n_copied , n_not_copied ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: src REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dest INTEGER ( I4B ), INTENT ( OUT ) :: n_copied , n_not_copied n_copied = min ( size ( src ), size ( dest )) n_not_copied = size ( src ) - n_copied dest ( 1 : n_copied ) = src ( 1 : n_copied ) END SUBROUTINE array_copy_r","tags":"","loc":"proc/array_copy_r.html"},{"title":"array_copy_d – KORC-Full Orbit","text":"public subroutine array_copy_d(src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: src real(kind=DP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied Contents Source Code array_copy_d Source Code SUBROUTINE array_copy_d ( src , dest , n_copied , n_not_copied ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: src REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: dest INTEGER ( I4B ), INTENT ( OUT ) :: n_copied , n_not_copied n_copied = min ( size ( src ), size ( dest )) n_not_copied = size ( src ) - n_copied dest ( 1 : n_copied ) = src ( 1 : n_copied ) END SUBROUTINE array_copy_d","tags":"","loc":"proc/array_copy_d.html"},{"title":"array_copy_i – KORC-Full Orbit","text":"public subroutine array_copy_i(src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: src integer(kind=I4B), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied Contents Source Code array_copy_i Source Code SUBROUTINE array_copy_i ( src , dest , n_copied , n_not_copied ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: src INTEGER ( I4B ), DIMENSION (:), INTENT ( OUT ) :: dest INTEGER ( I4B ), INTENT ( OUT ) :: n_copied , n_not_copied n_copied = min ( size ( src ), size ( dest )) n_not_copied = size ( src ) - n_copied dest ( 1 : n_copied ) = src ( 1 : n_copied ) END SUBROUTINE array_copy_i","tags":"","loc":"proc/array_copy_i.html"},{"title":"swap_i – KORC-Full Orbit","text":"public subroutine swap_i(a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b Contents Source Code swap_i Source Code SUBROUTINE swap_i ( a , b ) INTEGER ( I4B ), INTENT ( INOUT ) :: a , b INTEGER ( I4B ) :: dum dum = a a = b b = dum END SUBROUTINE swap_i","tags":"","loc":"proc/swap_i.html"},{"title":"swap_r – KORC-Full Orbit","text":"public subroutine swap_r(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b Contents Source Code swap_r Source Code SUBROUTINE swap_r ( a , b ) REAL ( SP ), INTENT ( INOUT ) :: a , b REAL ( SP ) :: dum dum = a a = b b = dum END SUBROUTINE swap_r","tags":"","loc":"proc/swap_r.html"},{"title":"swap_rv – KORC-Full Orbit","text":"public subroutine swap_rv(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b Contents Source Code swap_rv Source Code SUBROUTINE swap_rv ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a , b REAL ( SP ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_rv","tags":"","loc":"proc/swap_rv.html"},{"title":"swap_c – KORC-Full Orbit","text":"public subroutine swap_c(a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout) :: a complex(kind=SPC), intent(inout) :: b Contents Source Code swap_c Source Code SUBROUTINE swap_c ( a , b ) COMPLEX ( SPC ), INTENT ( INOUT ) :: a , b COMPLEX ( SPC ) :: dum dum = a a = b b = dum END SUBROUTINE swap_c","tags":"","loc":"proc/swap_c.html"},{"title":"swap_cv – KORC-Full Orbit","text":"public subroutine swap_cv(a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: a complex(kind=SPC), intent(inout), DIMENSION(:) :: b Contents Source Code swap_cv Source Code SUBROUTINE swap_cv ( a , b ) COMPLEX ( SPC ), DIMENSION (:), INTENT ( INOUT ) :: a , b COMPLEX ( SPC ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cv","tags":"","loc":"proc/swap_cv.html"},{"title":"swap_cm – KORC-Full Orbit","text":"public subroutine swap_cm(a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: a complex(kind=SPC), intent(inout), DIMENSION(:,:) :: b Contents Source Code swap_cm Source Code SUBROUTINE swap_cm ( a , b ) COMPLEX ( SPC ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b COMPLEX ( SPC ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cm","tags":"","loc":"proc/swap_cm.html"},{"title":"swap_z – KORC-Full Orbit","text":"public subroutine swap_z(a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout) :: a complex(kind=DPC), intent(inout) :: b Contents Source Code swap_z Source Code SUBROUTINE swap_z ( a , b ) COMPLEX ( DPC ), INTENT ( INOUT ) :: a , b COMPLEX ( DPC ) :: dum dum = a a = b b = dum END SUBROUTINE swap_z","tags":"","loc":"proc/swap_z.html"},{"title":"swap_zv – KORC-Full Orbit","text":"public subroutine swap_zv(a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:) :: a complex(kind=DPC), intent(inout), DIMENSION(:) :: b Contents Source Code swap_zv Source Code SUBROUTINE swap_zv ( a , b ) COMPLEX ( DPC ), DIMENSION (:), INTENT ( INOUT ) :: a , b COMPLEX ( DPC ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_zv","tags":"","loc":"proc/swap_zv.html"},{"title":"swap_zm – KORC-Full Orbit","text":"public subroutine swap_zm(a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DPC), intent(inout), DIMENSION(:,:) :: b Contents Source Code swap_zm Source Code SUBROUTINE swap_zm ( a , b ) COMPLEX ( DPC ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b COMPLEX ( DPC ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: dum dum = a a = b b = dum END SUBROUTINE swap_zm","tags":"","loc":"proc/swap_zm.html"},{"title":"masked_swap_rs – KORC-Full Orbit","text":"public subroutine masked_swap_rs(a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask Contents Source Code masked_swap_rs Source Code SUBROUTINE masked_swap_rs ( a , b , mask ) REAL ( SP ), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), INTENT ( IN ) :: mask REAL ( SP ) :: swp if ( mask ) then swp = a a = b b = swp end if END SUBROUTINE masked_swap_rs","tags":"","loc":"proc/masked_swap_rs.html"},{"title":"masked_swap_rv – KORC-Full Orbit","text":"public subroutine masked_swap_rv(a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask Contents Source Code masked_swap_rv Source Code SUBROUTINE masked_swap_rv ( a , b , mask ) REAL ( SP ), DIMENSION (:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( SP ), DIMENSION ( size ( a )) :: swp where ( mask ) swp = a a = b b = swp end where END SUBROUTINE masked_swap_rv","tags":"","loc":"proc/masked_swap_rv.html"},{"title":"masked_swap_rm – KORC-Full Orbit","text":"public subroutine masked_swap_rm(a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask Contents Source Code masked_swap_rm Source Code SUBROUTINE masked_swap_rm ( a , b , mask ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:,:), INTENT ( IN ) :: mask REAL ( SP ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: swp where ( mask ) swp = a a = b b = swp end where END SUBROUTINE masked_swap_rm","tags":"","loc":"proc/masked_swap_rm.html"},{"title":"assert1 – KORC-Full Orbit","text":"public subroutine assert1(n1, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string Contents Source Code assert1 Source Code SUBROUTINE assert1 ( n1 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 if (. not . n1 ) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert1' end if END SUBROUTINE assert1","tags":"","loc":"proc/assert1.html"},{"title":"assert2 – KORC-Full Orbit","text":"public subroutine assert2(n1, n2, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string Contents Source Code assert2 Source Code SUBROUTINE assert2 ( n1 , n2 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 if (. not . ( n1 . and . n2 )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert2' end if END SUBROUTINE assert2","tags":"","loc":"proc/assert2.html"},{"title":"assert3 – KORC-Full Orbit","text":"public subroutine assert3(n1, n2, n3, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string Contents Source Code assert3 Source Code SUBROUTINE assert3 ( n1 , n2 , n3 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 , n3 if (. not . ( n1 . and . n2 . and . n3 )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert3' end if END SUBROUTINE assert3","tags":"","loc":"proc/assert3.html"},{"title":"assert4 – KORC-Full Orbit","text":"public subroutine assert4(n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string Contents Source Code assert4 Source Code SUBROUTINE assert4 ( n1 , n2 , n3 , n4 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , INTENT ( IN ) :: n1 , n2 , n3 , n4 if (. not . ( n1 . and . n2 . and . n3 . and . n4 )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert4' end if END SUBROUTINE assert4","tags":"","loc":"proc/assert4.html"},{"title":"assert_v – KORC-Full Orbit","text":"public subroutine assert_v(n, string) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string Contents Source Code assert_v Source Code SUBROUTINE assert_v ( n , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string LOGICAL , DIMENSION (:), INTENT ( IN ) :: n if (. not . all ( n )) then write ( * , * ) 'nrerror: an assertion failed with this tag:' , & string STOP 'program terminated by assert_v' end if END SUBROUTINE assert_v","tags":"","loc":"proc/assert_v.html"},{"title":"nrerror – KORC-Full Orbit","text":"public subroutine nrerror(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Contents Source Code nrerror Source Code SUBROUTINE nrerror ( string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string write ( * , * ) 'nrerror: ' , string STOP 'program terminated by nrerror' END SUBROUTINE nrerror","tags":"","loc":"proc/nrerror.html"},{"title":"scatter_add_r – KORC-Full Orbit","text":"public subroutine scatter_add_r(dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index Contents Source Code scatter_add_r Source Code SUBROUTINE scatter_add_r ( dest , source , dest_index ) REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_add_r' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = dest ( i ) + source ( j ) end do END SUBROUTINE scatter_add_r","tags":"","loc":"proc/scatter_add_r.html"},{"title":"scatter_add_d – KORC-Full Orbit","text":"public subroutine scatter_add_d(dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index Contents Source Code scatter_add_d Source Code SUBROUTINE scatter_add_d ( dest , source , dest_index ) REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_add_d' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = dest ( i ) + source ( j ) end do END SUBROUTINE scatter_add_d","tags":"","loc":"proc/scatter_add_d.html"},{"title":"scatter_max_r – KORC-Full Orbit","text":"public subroutine scatter_max_r(dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index Contents Source Code scatter_max_r Source Code SUBROUTINE scatter_max_r ( dest , source , dest_index ) REAL ( SP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_max_r' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = max ( dest ( i ), source ( j )) end do END SUBROUTINE scatter_max_r","tags":"","loc":"proc/scatter_max_r.html"},{"title":"scatter_max_d – KORC-Full Orbit","text":"public subroutine scatter_max_d(dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index Contents Source Code scatter_max_d Source Code SUBROUTINE scatter_max_d ( dest , source , dest_index ) REAL ( DP ), DIMENSION (:), INTENT ( OUT ) :: dest REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: source INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: dest_index INTEGER ( I4B ) :: m , n , j , i n = assert_eq2 ( size ( source ), size ( dest_index ), 'scatter_max_d' ) m = size ( dest ) do j = 1 , n i = dest_index ( j ) if ( i > 0 . and . i <= m ) dest ( i ) = max ( dest ( i ), source ( j )) end do END SUBROUTINE scatter_max_d","tags":"","loc":"proc/scatter_max_d.html"},{"title":"diagadd_rv – KORC-Full Orbit","text":"public subroutine diagadd_rv(mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag Contents Source Code diagadd_rv Source Code SUBROUTINE diagadd_rv ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = assert_eq2 ( size ( diag ), min ( size ( mat , 1 ), size ( mat , 2 )), 'diagadd_rv' ) do j = 1 , n mat ( j , j ) = mat ( j , j ) + diag ( j ) end do END SUBROUTINE diagadd_rv","tags":"","loc":"proc/diagadd_rv.html"},{"title":"diagadd_r – KORC-Full Orbit","text":"public subroutine diagadd_r(mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag Contents Source Code diagadd_r Source Code SUBROUTINE diagadd_r ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = min ( size ( mat , 1 ), size ( mat , 2 )) do j = 1 , n mat ( j , j ) = mat ( j , j ) + diag end do END SUBROUTINE diagadd_r","tags":"","loc":"proc/diagadd_r.html"},{"title":"diagmult_rv – KORC-Full Orbit","text":"public subroutine diagmult_rv(mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag Contents Source Code diagmult_rv Source Code SUBROUTINE diagmult_rv ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = assert_eq2 ( size ( diag ), min ( size ( mat , 1 ), size ( mat , 2 )), 'diagmult_rv' ) do j = 1 , n mat ( j , j ) = mat ( j , j ) * diag ( j ) end do END SUBROUTINE diagmult_rv","tags":"","loc":"proc/diagmult_rv.html"},{"title":"diagmult_r – KORC-Full Orbit","text":"public subroutine diagmult_r(mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag Contents Source Code diagmult_r Source Code SUBROUTINE diagmult_r ( mat , diag ) REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat REAL ( SP ), INTENT ( IN ) :: diag INTEGER ( I4B ) :: j , n n = min ( size ( mat , 1 ), size ( mat , 2 )) do j = 1 , n mat ( j , j ) = mat ( j , j ) * diag end do END SUBROUTINE diagmult_r","tags":"","loc":"proc/diagmult_r.html"},{"title":"put_diag_rv – KORC-Full Orbit","text":"public subroutine put_diag_rv(diagv, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: diagv real(kind=SP), intent(inout), DIMENSION(:,:) :: mat Contents Source Code put_diag_rv Source Code SUBROUTINE put_diag_rv ( diagv , mat ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: diagv REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat INTEGER ( I4B ) :: j , n n = assert_eq2 ( size ( diagv ), min ( size ( mat , 1 ), size ( mat , 2 )), 'put_diag_rv' ) do j = 1 , n mat ( j , j ) = diagv ( j ) end do END SUBROUTINE put_diag_rv","tags":"","loc":"proc/put_diag_rv.html"},{"title":"put_diag_r – KORC-Full Orbit","text":"public subroutine put_diag_r(scal, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: scal real(kind=SP), intent(inout), DIMENSION(:,:) :: mat Contents Source Code put_diag_r Source Code SUBROUTINE put_diag_r ( scal , mat ) REAL ( SP ), INTENT ( IN ) :: scal REAL ( SP ), DIMENSION (:,:), INTENT ( INOUT ) :: mat INTEGER ( I4B ) :: j , n n = min ( size ( mat , 1 ), size ( mat , 2 )) do j = 1 , n mat ( j , j ) = scal end do END SUBROUTINE put_diag_r","tags":"","loc":"proc/put_diag_r.html"},{"title":"unit_matrix – KORC-Full Orbit","text":"public subroutine unit_matrix(mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:,:) :: mat Contents Source Code unit_matrix Source Code SUBROUTINE unit_matrix ( mat ) REAL ( SP ), DIMENSION (:,:), INTENT ( OUT ) :: mat INTEGER ( I4B ) :: i , n n = min ( size ( mat , 1 ), size ( mat , 2 )) mat (:,:) = 0.0_sp do i = 1 , n mat ( i , i ) = 1.0_sp end do END SUBROUTINE unit_matrix","tags":"","loc":"proc/unit_matrix.html"},{"title":"array_copy – KORC-Full Orbit","text":"public interface array_copy Contents Module Procedures array_copy_r array_copy_d array_copy_i Module Procedures public subroutine array_copy_r (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: src real(kind=SP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine array_copy_d (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: src real(kind=DP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine array_copy_i (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: src integer(kind=I4B), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied","tags":"","loc":"interface/array_copy.html"},{"title":"swap – KORC-Full Orbit","text":"public interface swap Contents Module Procedures swap_i swap_r swap_rv swap_c swap_cv swap_cm swap_z swap_zv swap_zm masked_swap_rs masked_swap_rv masked_swap_rm Module Procedures public subroutine swap_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b public subroutine swap_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b public subroutine swap_rv (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b public subroutine swap_c (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout) :: a complex(kind=SPC), intent(inout) :: b public subroutine swap_cv (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: a complex(kind=SPC), intent(inout), DIMENSION(:) :: b public subroutine swap_cm (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: a complex(kind=SPC), intent(inout), DIMENSION(:,:) :: b public subroutine swap_z (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout) :: a complex(kind=DPC), intent(inout) :: b public subroutine swap_zv (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:) :: a complex(kind=DPC), intent(inout), DIMENSION(:) :: b public subroutine swap_zm (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DPC), intent(inout), DIMENSION(:,:) :: b public subroutine masked_swap_rs (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask public subroutine masked_swap_rv (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask public subroutine masked_swap_rm (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask","tags":"","loc":"interface/swap.html"},{"title":"reallocate – KORC-Full Orbit","text":"public interface reallocate Contents Module Procedures reallocate_rv reallocate_rm reallocate_iv reallocate_im reallocate_hv Module Procedures public function reallocate_rv (p, n) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(:), POINTER public function reallocate_rm (p, n, m) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value real(kind=SP),\n  DIMENSION(:,:), POINTER public function reallocate_iv (p, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(:), POINTER public function reallocate_im (p, n, m) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value integer(kind=I4B),\n  DIMENSION(:,:), POINTER public function reallocate_hv (p, n) Arguments Type Intent Optional Attributes Name character(len=1), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value character(len=1),\n  DIMENSION(:), POINTER","tags":"","loc":"interface/reallocate.html"},{"title":"imaxloc – KORC-Full Orbit","text":"public interface imaxloc Contents Module Procedures imaxloc_r imaxloc_i Module Procedures public function imaxloc_r (arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) public function imaxloc_i (iarr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B)","tags":"","loc":"interface/imaxloc.html"},{"title":"assert – KORC-Full Orbit","text":"public interface assert Contents Module Procedures assert1 assert2 assert3 assert4 assert_v Module Procedures public subroutine assert1 (n1, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string public subroutine assert2 (n1, n2, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string public subroutine assert3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string public subroutine assert4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string public subroutine assert_v (n, string) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string","tags":"","loc":"interface/assert.html"},{"title":"assert_eq – KORC-Full Orbit","text":"public interface assert_eq Contents Module Procedures assert_eq2 assert_eq3 assert_eq4 assert_eqn Module Procedures public function assert_eq2 (n1, n2, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer public function assert_eq3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer public function assert_eq4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer public function assert_eqn (nn, string) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string Return Value integer","tags":"","loc":"interface/assert_eq.html"},{"title":"arth – KORC-Full Orbit","text":"public interface arth Contents Module Procedures arth_r arth_d arth_i Module Procedures public function arth_r (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) public function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n)","tags":"","loc":"interface/arth.html"},{"title":"geop – KORC-Full Orbit","text":"public interface geop Contents Module Procedures geop_r geop_d geop_i geop_c geop_dv Module Procedures public function geop_r (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) public function geop_d (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function geop_i (first, factor, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public function geop_c (first, factor, n) Arguments Type Intent Optional Attributes Name complex(kind=SP), intent(in) :: first complex(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value complex(kind=SP),\n  DIMENSION(n) public function geop_dv (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: first real(kind=DP), intent(in), DIMENSION(:) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(size(first),n)","tags":"","loc":"interface/geop.html"},{"title":"cumsum – KORC-Full Orbit","text":"public interface cumsum Contents Module Procedures cumsum_r cumsum_i Module Procedures public recursive function cumsum_r (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(in), optional :: seed Return Value real(kind=SP),\n  DIMENSION(size(arr)) public recursive function cumsum_i (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(size(arr))","tags":"","loc":"interface/cumsum.html"},{"title":"poly – KORC-Full Orbit","text":"public interface poly Contents Module Procedures poly_rr poly_rrv poly_dd poly_ddv poly_rc poly_cc poly_msk_rrv poly_msk_ddv Module Procedures public function poly_rr (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP) public function poly_rrv (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP),\n  DIMENSION(size(x)) public function poly_dd (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP) public function poly_ddv (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP),\n  DIMENSION(size(x)) public function poly_rc (x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) public function poly_cc (x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x complex(kind=SPC), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) public function poly_msk_rrv (x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=SP),\n  DIMENSION(size(x)) public function poly_msk_ddv (x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=DP),\n  DIMENSION(size(x))","tags":"","loc":"interface/poly.html"},{"title":"poly_term – KORC-Full Orbit","text":"public interface poly_term Contents Module Procedures poly_term_rr poly_term_cc Module Procedures public recursive function poly_term_rr (a, b) result(u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP),\n  DIMENSION(size(a)) public recursive function poly_term_cc (a, b) result(u) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(in) :: b Return Value complex(kind=SPC),\n  DIMENSION(size(a))","tags":"","loc":"interface/poly_term.html"},{"title":"outerprod – KORC-Full Orbit","text":"public interface outerprod Contents Module Procedures outerprod_r outerprod_d Module Procedures public function outerprod_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerprod_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b))","tags":"","loc":"interface/outerprod.html"},{"title":"outerdiff – KORC-Full Orbit","text":"public interface outerdiff Contents Module Procedures outerdiff_r outerdiff_d outerdiff_i Module Procedures public function outerdiff_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerdiff_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) public function outerdiff_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b))","tags":"","loc":"interface/outerdiff.html"},{"title":"scatter_add – KORC-Full Orbit","text":"public interface scatter_add Contents Module Procedures scatter_add_r scatter_add_d Module Procedures public subroutine scatter_add_r (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_add_d (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index","tags":"","loc":"interface/scatter_add.html"},{"title":"scatter_max – KORC-Full Orbit","text":"public interface scatter_max Contents Module Procedures scatter_max_r scatter_max_d Module Procedures public subroutine scatter_max_r (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_max_d (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index","tags":"","loc":"interface/scatter_max.html"},{"title":"diagadd – KORC-Full Orbit","text":"public interface diagadd Contents Module Procedures diagadd_rv diagadd_r Module Procedures public subroutine diagadd_rv (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag public subroutine diagadd_r (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag","tags":"","loc":"interface/diagadd.html"},{"title":"diagmult – KORC-Full Orbit","text":"public interface diagmult Contents Module Procedures diagmult_rv diagmult_r Module Procedures public subroutine diagmult_rv (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag public subroutine diagmult_r (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag","tags":"","loc":"interface/diagmult.html"},{"title":"get_diag – KORC-Full Orbit","text":"public interface get_diag Contents Module Procedures get_diag_rv get_diag_dv Module Procedures public function get_diag_rv (mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=SP),\n  DIMENSION(size(mat,1)) public function get_diag_dv (mat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=DP),\n  DIMENSION(size(mat,1))","tags":"","loc":"interface/get_diag.html"},{"title":"put_diag – KORC-Full Orbit","text":"public interface put_diag Contents Module Procedures put_diag_rv put_diag_r Module Procedures public subroutine put_diag_rv (diagv, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: diagv real(kind=SP), intent(inout), DIMENSION(:,:) :: mat public subroutine put_diag_r (scal, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: scal real(kind=SP), intent(inout), DIMENSION(:,:) :: mat","tags":"","loc":"interface/put_diag.html"},{"title":"airy – KORC-Full Orbit","text":"interface public subroutine airy(x, ai, bi, aip, bip) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: ai real(kind=SP), intent(out) :: bi real(kind=SP), intent(out) :: aip real(kind=SP), intent(out) :: bip","tags":"","loc":"interface/airy.html"},{"title":"amebsa – KORC-Full Orbit","text":"interface public subroutine amebsa(p, y, pb, yb, ftol, func, iter, temptr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: p real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(inout), DIMENSION(:) :: pb real(kind=SP), intent(inout) :: yb real(kind=SP), intent(in) :: ftol function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) integer(kind=I4B), intent(inout) :: iter real(kind=SP), intent(in) :: temptr","tags":"","loc":"interface/amebsa.html"},{"title":"amoeba – KORC-Full Orbit","text":"interface public subroutine amoeba(p, y, ftol, func, iter) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: p real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in) :: ftol function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) integer(kind=I4B), intent(out) :: iter","tags":"","loc":"interface/amoeba.html"},{"title":"anneal – KORC-Full Orbit","text":"interface public subroutine anneal(x, y, iorder) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y integer(kind=I4B), intent(inout), DIMENSION(:) :: iorder","tags":"","loc":"interface/anneal.html"},{"title":"asolve – KORC-Full Orbit","text":"interface public subroutine asolve(b, x, itrnsp) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: b real(kind=DP), intent(out), DIMENSION(:) :: x integer(kind=I4B), intent(in) :: itrnsp","tags":"","loc":"interface/asolve.html"},{"title":"atimes – KORC-Full Orbit","text":"interface public subroutine atimes(x, r, itrnsp) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(out), DIMENSION(:) :: r integer(kind=I4B), intent(in) :: itrnsp","tags":"","loc":"interface/atimes.html"},{"title":"avevar – KORC-Full Orbit","text":"interface public subroutine avevar(data, ave, var) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(out) :: ave real(kind=SP), intent(out) :: var","tags":"","loc":"interface/avevar.html"},{"title":"balanc – KORC-Full Orbit","text":"interface public subroutine balanc(a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a","tags":"","loc":"interface/balanc.html"},{"title":"banbks – KORC-Full Orbit","text":"interface public subroutine banbks(a, m1, m2, al, indx, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 real(kind=SP), intent(in), DIMENSION(:,:) :: al integer(kind=I4B), intent(in), DIMENSION(:) :: indx real(kind=SP), intent(inout), DIMENSION(:) :: b","tags":"","loc":"interface/banbks.html"},{"title":"bandec – KORC-Full Orbit","text":"interface public subroutine bandec(a, m1, m2, al, indx, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 real(kind=SP), intent(out), DIMENSION(:,:) :: al integer(kind=I4B), intent(out), DIMENSION(:) :: indx real(kind=SP), intent(out) :: d","tags":"","loc":"interface/bandec.html"},{"title":"banmul – KORC-Full Orbit","text":"interface public subroutine banmul(a, m1, m2, x, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: b","tags":"","loc":"interface/banmul.html"},{"title":"bcucof – KORC-Full Orbit","text":"interface public subroutine bcucof(y, y1, y2, y12, d1, d2, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(4) :: y real(kind=SP), intent(in), DIMENSION(4) :: y1 real(kind=SP), intent(in), DIMENSION(4) :: y2 real(kind=SP), intent(in), DIMENSION(4) :: y12 real(kind=SP), intent(in) :: d1 real(kind=SP), intent(in) :: d2 real(kind=SP), intent(out), DIMENSION(4,4) :: c","tags":"","loc":"interface/bcucof.html"},{"title":"bcuint – KORC-Full Orbit","text":"interface public subroutine bcuint(y, y1, y2, y12, x1l, x1u, x2l, x2u, x1, x2, ansy, ansy1, ansy2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(4) :: y real(kind=SP), intent(in), DIMENSION(4) :: y1 real(kind=SP), intent(in), DIMENSION(4) :: y2 real(kind=SP), intent(in), DIMENSION(4) :: y12 real(kind=SP), intent(in) :: x1l real(kind=SP), intent(in) :: x1u real(kind=SP), intent(in) :: x2l real(kind=SP), intent(in) :: x2u real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(out) :: ansy real(kind=SP), intent(out) :: ansy1 real(kind=SP), intent(out) :: ansy2","tags":"","loc":"interface/bcuint.html"},{"title":"beschb – KORC-Full Orbit","text":"public interface beschb Contents Subroutines beschb_s beschb_v Subroutines public subroutine beschb_s(x, gam1, gam2, gampl, gammi) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(out) :: gam1 real(kind=DP), intent(out) :: gam2 real(kind=DP), intent(out) :: gampl real(kind=DP), intent(out) :: gammi public subroutine beschb_v(x, gam1, gam2, gampl, gammi) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(out), DIMENSION(:) :: gam1 real(kind=DP), intent(out), DIMENSION(:) :: gam2 real(kind=DP), intent(out), DIMENSION(:) :: gampl real(kind=DP), intent(out), DIMENSION(:) :: gammi","tags":"","loc":"interface/beschb.html"},{"title":"bessi – KORC-Full Orbit","text":"public interface bessi Contents Functions bessi_s bessi_v Functions public function bessi_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessi_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessi.html"},{"title":"bessi0 – KORC-Full Orbit","text":"public interface bessi0 Contents Functions bessi0_s bessi0_v Functions public function bessi0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessi0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessi0.html"},{"title":"bessi1 – KORC-Full Orbit","text":"public interface bessi1 Contents Functions bessi1_s bessi1_v Functions public function bessi1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessi1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessi1.html"},{"title":"bessik – KORC-Full Orbit","text":"interface public subroutine bessik(x, xnu, ri, rk, rip, rkp) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out) :: ri real(kind=SP), intent(out) :: rk real(kind=SP), intent(out) :: rip real(kind=SP), intent(out) :: rkp","tags":"","loc":"interface/bessik.html"},{"title":"bessj – KORC-Full Orbit","text":"public interface bessj Contents Functions bessj_s bessj_v Functions public function bessj_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessj_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessj.html"},{"title":"bessj0 – KORC-Full Orbit","text":"public interface bessj0 Contents Functions bessj0_s bessj0_v Functions public function bessj0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessj0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessj0.html"},{"title":"bessj1 – KORC-Full Orbit","text":"public interface bessj1 Contents Functions bessj1_s bessj1_v Functions public function bessj1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessj1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessj1.html"},{"title":"bessjy – KORC-Full Orbit","text":"public interface bessjy Contents Subroutines bessjy_s bessjy_v Subroutines public subroutine bessjy_s(x, xnu, rj, ry, rjp, ryp) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out) :: rj real(kind=SP), intent(out) :: ry real(kind=SP), intent(out) :: rjp real(kind=SP), intent(out) :: ryp public subroutine bessjy_v(x, xnu, rj, ry, rjp, ryp) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out), DIMENSION(:) :: rj real(kind=SP), intent(out), DIMENSION(:) :: ry real(kind=SP), intent(out), DIMENSION(:) :: rjp real(kind=SP), intent(out), DIMENSION(:) :: ryp","tags":"","loc":"interface/bessjy.html"},{"title":"bessk – KORC-Full Orbit","text":"public interface bessk Contents Functions bessk_s bessk_v Functions public function bessk_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessk_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessk.html"},{"title":"bessk0 – KORC-Full Orbit","text":"public interface bessk0 Contents Functions bessk0_s bessk0_v Functions public function bessk0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessk0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessk0.html"},{"title":"bessk1 – KORC-Full Orbit","text":"public interface bessk1 Contents Functions bessk1_s bessk1_v Functions public function bessk1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessk1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessk1.html"},{"title":"bessy – KORC-Full Orbit","text":"public interface bessy Contents Functions bessy_s bessy_v Functions public function bessy_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessy_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessy.html"},{"title":"bessy0 – KORC-Full Orbit","text":"public interface bessy0 Contents Functions bessy0_s bessy0_v Functions public function bessy0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessy0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessy0.html"},{"title":"bessy1 – KORC-Full Orbit","text":"public interface bessy1 Contents Functions bessy1_s bessy1_v Functions public function bessy1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessy1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/bessy1.html"},{"title":"beta – KORC-Full Orbit","text":"public interface beta Contents Functions beta_s beta_v Functions public function beta_s(z, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: z real(kind=SP), intent(in) :: w Return Value real(kind=SP) public function beta_v(z, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: z real(kind=SP), intent(in), DIMENSION(:) :: w Return Value real(kind=SP),\n  DIMENSION(size(z))","tags":"","loc":"interface/beta.html"},{"title":"betacf – KORC-Full Orbit","text":"public interface betacf Contents Functions betacf_s betacf_v Functions public function betacf_s(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function betacf_v(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/betacf.html"},{"title":"betai – KORC-Full Orbit","text":"public interface betai Contents Functions betai_s betai_v Functions public function betai_s(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function betai_v(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/betai.html"},{"title":"bico – KORC-Full Orbit","text":"public interface bico Contents Functions bico_s bico_v Functions public function bico_s(n, k) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: k Return Value real(kind=SP) public function bico_v(n, k) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: n integer(kind=I4B), intent(in), DIMENSION(:) :: k Return Value real(kind=SP),\n  DIMENSION(size(n))","tags":"","loc":"interface/bico.html"},{"title":"bnldev – KORC-Full Orbit","text":"interface public function bnldev(pp, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: pp integer(kind=I4B), intent(in) :: n Return Value real(kind=SP)","tags":"","loc":"interface/bnldev.html"},{"title":"brent – KORC-Full Orbit","text":"interface public function brent(ax, bx, cx, func, tol, xmin) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: ax real(kind=SP), intent(in) :: bx real(kind=SP), intent(in) :: cx function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: tol real(kind=SP), intent(out) :: xmin Return Value real(kind=SP)","tags":"","loc":"interface/brent.html"},{"title":"broydn – KORC-Full Orbit","text":"interface public subroutine broydn(x, check) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: x logical(kind=LGT), intent(out) :: check","tags":"","loc":"interface/broydn.html"},{"title":"bsstep – KORC-Full Orbit","text":"interface public subroutine bsstep(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/bsstep.html"},{"title":"caldat – KORC-Full Orbit","text":"interface public subroutine caldat(julian, mm, id, iyyy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: julian integer(kind=I4B), intent(out) :: mm integer(kind=I4B), intent(out) :: id integer(kind=I4B), intent(out) :: iyyy","tags":"","loc":"interface/caldat.html"},{"title":"chder – KORC-Full Orbit","text":"interface public function chder(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(c))","tags":"","loc":"interface/chder.html"},{"title":"chebev – KORC-Full Orbit","text":"public interface chebev Contents Functions chebev_s chebev_v Functions public function chebev_s(a, b, c, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function chebev_v(a, b, c, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/chebev.html"},{"title":"chebft – KORC-Full Orbit","text":"interface public function chebft(a, b, n, func) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b integer(kind=I4B), intent(in) :: n function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) Return Value real(kind=SP),\n  DIMENSION(n)","tags":"","loc":"interface/chebft.html"},{"title":"chebpc – KORC-Full Orbit","text":"interface public function chebpc(c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(c))","tags":"","loc":"interface/chebpc.html"},{"title":"chint – KORC-Full Orbit","text":"interface public function chint(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(c))","tags":"","loc":"interface/chint.html"},{"title":"choldc – KORC-Full Orbit","text":"interface public subroutine choldc(a, p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: p","tags":"","loc":"interface/choldc.html"},{"title":"cholsl – KORC-Full Orbit","text":"interface public subroutine cholsl(a, p, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:) :: p real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(inout), DIMENSION(:) :: x","tags":"","loc":"interface/cholsl.html"},{"title":"chsone – KORC-Full Orbit","text":"interface public subroutine chsone(bins, ebins, knstrn, df, chsq, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: bins real(kind=SP), intent(in), DIMENSION(:) :: ebins integer(kind=I4B), intent(in) :: knstrn real(kind=SP), intent(out) :: df real(kind=SP), intent(out) :: chsq real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/chsone.html"},{"title":"chstwo – KORC-Full Orbit","text":"interface public subroutine chstwo(bins1, bins2, knstrn, df, chsq, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: bins1 real(kind=SP), intent(in), DIMENSION(:) :: bins2 integer(kind=I4B), intent(in) :: knstrn real(kind=SP), intent(out) :: df real(kind=SP), intent(out) :: chsq real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/chstwo.html"},{"title":"cisi – KORC-Full Orbit","text":"interface public subroutine cisi(x, ci, si) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: ci real(kind=SP), intent(out) :: si","tags":"","loc":"interface/cisi.html"},{"title":"cntab1 – KORC-Full Orbit","text":"interface public subroutine cntab1(nn, chisq, df, prob, cramrv, ccc) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:,:) :: nn real(kind=SP), intent(out) :: chisq real(kind=SP), intent(out) :: df real(kind=SP), intent(out) :: prob real(kind=SP), intent(out) :: cramrv real(kind=SP), intent(out) :: ccc","tags":"","loc":"interface/cntab1.html"},{"title":"cntab2 – KORC-Full Orbit","text":"interface public subroutine cntab2(nn, h, hx, hy, hygx, hxgy, uygx, uxgy, uxy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:,:) :: nn real(kind=SP), intent(out) :: h real(kind=SP), intent(out) :: hx real(kind=SP), intent(out) :: hy real(kind=SP), intent(out) :: hygx real(kind=SP), intent(out) :: hxgy real(kind=SP), intent(out) :: uygx real(kind=SP), intent(out) :: uxgy real(kind=SP), intent(out) :: uxy","tags":"","loc":"interface/cntab2.html"},{"title":"convlv – KORC-Full Orbit","text":"interface public function convlv(data, respns, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(in), DIMENSION(:) :: respns integer(kind=I4B), intent(in) :: isign Return Value real(kind=SP),\n  DIMENSION(size(data))","tags":"","loc":"interface/convlv.html"},{"title":"correl – KORC-Full Orbit","text":"interface public function correl(data1, data2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 Return Value real(kind=SP),\n  DIMENSION(size(data1))","tags":"","loc":"interface/correl.html"},{"title":"cosft1 – KORC-Full Orbit","text":"interface public subroutine cosft1(y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y","tags":"","loc":"interface/cosft1.html"},{"title":"cosft2 – KORC-Full Orbit","text":"interface public subroutine cosft2(y, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/cosft2.html"},{"title":"covsrt – KORC-Full Orbit","text":"interface public subroutine covsrt(covar, maska) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: covar logical(kind=LGT), intent(in), DIMENSION(:) :: maska","tags":"","loc":"interface/covsrt.html"},{"title":"cyclic – KORC-Full Orbit","text":"interface public subroutine cyclic(a, b, c, alpha, beta, r, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: alpha real(kind=SP), intent(in) :: beta real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(out), DIMENSION(:) :: x","tags":"","loc":"interface/cyclic.html"},{"title":"daub4 – KORC-Full Orbit","text":"interface public subroutine daub4(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/daub4.html"},{"title":"dawson – KORC-Full Orbit","text":"public interface dawson Contents Functions dawson_s dawson_v Functions public function dawson_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function dawson_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/dawson.html"},{"title":"dbrent – KORC-Full Orbit","text":"interface public function dbrent(ax, bx, cx, func, dbrent_dfunc, tol, xmin) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: ax real(kind=SP), intent(in) :: bx real(kind=SP), intent(in) :: cx function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) function dbrent_dfunc(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: tol real(kind=SP), intent(out) :: xmin Return Value real(kind=SP)","tags":"","loc":"interface/dbrent.html"},{"title":"ddpoly – KORC-Full Orbit","text":"interface public subroutine ddpoly(c, x, pd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: x real(kind=SP), intent(out), DIMENSION(:) :: pd","tags":"","loc":"interface/ddpoly.html"},{"title":"decchk – KORC-Full Orbit","text":"interface public function decchk(string, ch) Arguments Type Intent Optional Attributes Name character(len=1), intent(in), DIMENSION(:) :: string character(len=1), intent(out) :: ch Return Value logical(kind=LGT)","tags":"","loc":"interface/decchk.html"},{"title":"dfpmin – KORC-Full Orbit","text":"interface public subroutine dfpmin(p, gtol, iter, fret, func, dfunc) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(in) :: gtol integer(kind=I4B), intent(out) :: iter real(kind=SP), intent(out) :: fret function func(p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: p Return Value real(kind=SP) function dfunc(p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: p Return Value real(kind=SP),\n  DIMENSION(size(p))","tags":"","loc":"interface/dfpmin.html"},{"title":"dfridr – KORC-Full Orbit","text":"interface public function dfridr(func, x, h, err) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: h real(kind=SP), intent(out) :: err Return Value real(kind=SP)","tags":"","loc":"interface/dfridr.html"},{"title":"dftcor – KORC-Full Orbit","text":"interface public subroutine dftcor(w, delta, a, b, endpts, corre, corim, corfac) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: w real(kind=SP), intent(in) :: delta real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: endpts real(kind=SP), intent(out) :: corre real(kind=SP), intent(out) :: corim real(kind=SP), intent(out) :: corfac","tags":"","loc":"interface/dftcor.html"},{"title":"dftint – KORC-Full Orbit","text":"interface public subroutine dftint(func, a, b, w, cosint, sinint) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in) :: w real(kind=SP), intent(out) :: cosint real(kind=SP), intent(out) :: sinint","tags":"","loc":"interface/dftint.html"},{"title":"difeq – KORC-Full Orbit","text":"interface public subroutine difeq(k, k1, k2, jsf, is1, isf, indexv, s, y) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in) :: k1 integer(kind=I4B), intent(in) :: k2 integer(kind=I4B), intent(in) :: jsf integer(kind=I4B), intent(in) :: is1 integer(kind=I4B), intent(in) :: isf integer(kind=I4B), intent(in), DIMENSION(:) :: indexv real(kind=SP), intent(out), DIMENSION(:,:) :: s real(kind=SP), intent(in), DIMENSION(:,:) :: y","tags":"","loc":"interface/difeq.html"},{"title":"eclass – KORC-Full Orbit","text":"interface public function eclass(lista, listb, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: lista integer(kind=I4B), intent(in), DIMENSION(:) :: listb integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n)","tags":"","loc":"interface/eclass.html"},{"title":"eclazz – KORC-Full Orbit","text":"interface public function eclazz(equiv, n) Arguments Type Intent Optional Attributes Name function equiv(i, j) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: i integer(kind=I4B), intent(in) :: j Return Value logical(kind=LGT) integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n)","tags":"","loc":"interface/eclazz.html"},{"title":"ei – KORC-Full Orbit","text":"interface public function ei(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP)","tags":"","loc":"interface/ei.html"},{"title":"eigsrt – KORC-Full Orbit","text":"interface public subroutine eigsrt(d, v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:,:) :: v","tags":"","loc":"interface/eigsrt.html"},{"title":"elle – KORC-Full Orbit","text":"public interface elle Contents Functions elle_s elle_v Functions public function elle_s(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: phi real(kind=SP), intent(in) :: ak Return Value real(kind=SP) public function elle_v(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: phi real(kind=SP), intent(in), DIMENSION(:) :: ak Return Value real(kind=SP),\n  DIMENSION(size(phi))","tags":"","loc":"interface/elle.html"},{"title":"ellf – KORC-Full Orbit","text":"public interface ellf Contents Functions ellf_s ellf_v Functions public function ellf_s(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: phi real(kind=SP), intent(in) :: ak Return Value real(kind=SP) public function ellf_v(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: phi real(kind=SP), intent(in), DIMENSION(:) :: ak Return Value real(kind=SP),\n  DIMENSION(size(phi))","tags":"","loc":"interface/ellf.html"},{"title":"ellpi – KORC-Full Orbit","text":"public interface ellpi Contents Functions ellpi_s ellpi_v Functions public function ellpi_s(phi, en, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: phi real(kind=SP), intent(in) :: en real(kind=SP), intent(in) :: ak Return Value real(kind=SP) public function ellpi_v(phi, en, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: phi real(kind=SP), intent(in), DIMENSION(:) :: en real(kind=SP), intent(in), DIMENSION(:) :: ak Return Value real(kind=SP),\n  DIMENSION(size(phi))","tags":"","loc":"interface/ellpi.html"},{"title":"elmhes – KORC-Full Orbit","text":"interface public subroutine elmhes(a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a","tags":"","loc":"interface/elmhes.html"},{"title":"erf – KORC-Full Orbit","text":"public interface erf Contents Functions erf_s erf_v Functions public function erf_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function erf_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/erf.html"},{"title":"erfc – KORC-Full Orbit","text":"public interface erfc Contents Functions erfc_s erfc_v Functions public function erfc_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function erfc_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/erfc.html"},{"title":"erfcc – KORC-Full Orbit","text":"public interface erfcc Contents Functions erfcc_s erfcc_v Functions public function erfcc_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function erfcc_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/erfcc.html"},{"title":"eulsum – KORC-Full Orbit","text":"interface public subroutine eulsum(sum, term, jterm) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: sum real(kind=SP), intent(in) :: term integer(kind=I4B), intent(in) :: jterm","tags":"","loc":"interface/eulsum.html"},{"title":"evlmem – KORC-Full Orbit","text":"interface public function evlmem(fdt, d, xms) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: fdt real(kind=SP), intent(in), DIMENSION(:) :: d real(kind=SP), intent(in) :: xms Return Value real(kind=SP)","tags":"","loc":"interface/evlmem.html"},{"title":"expdev – KORC-Full Orbit","text":"public interface expdev Contents Subroutines expdev_s expdev_v Subroutines public subroutine expdev_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine expdev_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest","tags":"","loc":"interface/expdev.html"},{"title":"expint – KORC-Full Orbit","text":"interface public function expint(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP)","tags":"","loc":"interface/expint.html"},{"title":"factln – KORC-Full Orbit","text":"public interface factln Contents Functions factln_s factln_v Functions public function factln_s(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Return Value real(kind=SP) public function factln_v(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: n Return Value real(kind=SP),\n  DIMENSION(size(n))","tags":"","loc":"interface/factln.html"},{"title":"factrl – KORC-Full Orbit","text":"public interface factrl Contents Functions factrl_s factrl_v Functions public function factrl_s(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Return Value real(kind=SP) public function factrl_v(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: n Return Value real(kind=SP),\n  DIMENSION(size(n))","tags":"","loc":"interface/factrl.html"},{"title":"fasper – KORC-Full Orbit","text":"interface public subroutine fasper(x, y, ofac, hifac, px, py, jmax, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in) :: ofac real(kind=SP), intent(in) :: hifac real(kind=SP), DIMENSION(:), POINTER :: px real(kind=SP), DIMENSION(:), POINTER :: py integer(kind=I4B), intent(out) :: jmax real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/fasper.html"},{"title":"fdjac – KORC-Full Orbit","text":"interface public subroutine fdjac(x, fvec, df) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: fvec real(kind=SP), intent(out), DIMENSION(:,:) :: df","tags":"","loc":"interface/fdjac.html"},{"title":"fgauss – KORC-Full Orbit","text":"interface public subroutine fgauss(x, a, y, dyda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:,:) :: dyda","tags":"","loc":"interface/fgauss.html"},{"title":"fit – KORC-Full Orbit","text":"interface public subroutine fit(x, y, a, b, siga, sigb, chi2, q, sig) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out) :: a real(kind=SP), intent(out) :: b real(kind=SP), intent(out) :: siga real(kind=SP), intent(out) :: sigb real(kind=SP), intent(out) :: chi2 real(kind=SP), intent(out) :: q real(kind=SP), intent(in), optional DIMENSION(:) :: sig","tags":"","loc":"interface/fit.html"},{"title":"fitexy – KORC-Full Orbit","text":"interface public subroutine fitexy(x, y, sigx, sigy, a, b, siga, sigb, chi2, q) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sigx real(kind=SP), intent(in), DIMENSION(:) :: sigy real(kind=SP), intent(out) :: a real(kind=SP), intent(out) :: b real(kind=SP), intent(out) :: siga real(kind=SP), intent(out) :: sigb real(kind=SP), intent(out) :: chi2 real(kind=SP), intent(out) :: q","tags":"","loc":"interface/fitexy.html"},{"title":"fixrts – KORC-Full Orbit","text":"interface public subroutine fixrts(d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: d","tags":"","loc":"interface/fixrts.html"},{"title":"fleg – KORC-Full Orbit","text":"interface public function fleg(x, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n)","tags":"","loc":"interface/fleg.html"},{"title":"flmoon – KORC-Full Orbit","text":"interface public subroutine flmoon(n, nph, jd, frac) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: nph integer(kind=I4B), intent(out) :: jd real(kind=SP), intent(out) :: frac","tags":"","loc":"interface/flmoon.html"},{"title":"four1 – KORC-Full Orbit","text":"public interface four1 Contents Subroutines four1_dp four1_sp Subroutines public subroutine four1_dp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign public subroutine four1_sp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four1.html"},{"title":"four1_alt – KORC-Full Orbit","text":"interface public subroutine four1_alt(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four1_alt.html"},{"title":"four1_gather – KORC-Full Orbit","text":"interface public subroutine four1_gather(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four1_gather.html"},{"title":"four2 – KORC-Full Orbit","text":"interface public subroutine four2(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four2.html"},{"title":"four2_alt – KORC-Full Orbit","text":"interface public subroutine four2_alt(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four2_alt.html"},{"title":"four3 – KORC-Full Orbit","text":"interface public subroutine four3(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four3.html"},{"title":"four3_alt – KORC-Full Orbit","text":"interface public subroutine four3_alt(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/four3_alt.html"},{"title":"fourcol – KORC-Full Orbit","text":"interface public subroutine fourcol(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/fourcol.html"},{"title":"fourcol_3d – KORC-Full Orbit","text":"interface public subroutine fourcol_3d(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/fourcol_3d.html"},{"title":"fourn_gather – KORC-Full Orbit","text":"interface public subroutine fourn_gather(data, nn, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in), DIMENSION(:) :: nn integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/fourn_gather.html"},{"title":"fourrow – KORC-Full Orbit","text":"public interface fourrow Contents Subroutines fourrow_dp fourrow_sp Subroutines public subroutine fourrow_dp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign public subroutine fourrow_sp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/fourrow.html"},{"title":"fourrow_3d – KORC-Full Orbit","text":"interface public subroutine fourrow_3d(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/fourrow_3d.html"},{"title":"fpoly – KORC-Full Orbit","text":"interface public function fpoly(x, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n)","tags":"","loc":"interface/fpoly.html"},{"title":"fred2 – KORC-Full Orbit","text":"interface public subroutine fred2(a, b, t, f, w, g, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(out), DIMENSION(:) :: t real(kind=SP), intent(out), DIMENSION(:) :: f real(kind=SP), intent(out), DIMENSION(:) :: w function g(t) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t Return Value real(kind=SP),\n  DIMENSION(size(t)) function ak(t, s) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t real(kind=SP), intent(in), DIMENSION(:) :: s Return Value real(kind=SP),\n  DIMENSION(size(t),size(s))","tags":"","loc":"interface/fred2.html"},{"title":"fredin – KORC-Full Orbit","text":"interface public function fredin(x, a, b, t, f, w, g, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: t real(kind=SP), intent(in), DIMENSION(:) :: f real(kind=SP), intent(in), DIMENSION(:) :: w function g(t) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t Return Value real(kind=SP),\n  DIMENSION(size(t)) function ak(t, s) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t real(kind=SP), intent(in), DIMENSION(:) :: s Return Value real(kind=SP),\n  DIMENSION(size(t),size(s)) Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/fredin.html"},{"title":"frenel – KORC-Full Orbit","text":"interface public subroutine frenel(x, s, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: s real(kind=SP), intent(out) :: c","tags":"","loc":"interface/frenel.html"},{"title":"frprmn – KORC-Full Orbit","text":"interface public subroutine frprmn(p, ftol, iter, fret) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(in) :: ftol integer(kind=I4B), intent(out) :: iter real(kind=SP), intent(out) :: fret","tags":"","loc":"interface/frprmn.html"},{"title":"ftest – KORC-Full Orbit","text":"interface public subroutine ftest(data1, data2, f, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: f real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/ftest.html"},{"title":"gamdev – KORC-Full Orbit","text":"interface public function gamdev(ia) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ia Return Value real(kind=SP)","tags":"","loc":"interface/gamdev.html"},{"title":"gammln – KORC-Full Orbit","text":"public interface gammln Contents Functions gammln_s gammln_v Functions public function gammln_s(xx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: xx Return Value real(kind=SP) public function gammln_v(xx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xx Return Value real(kind=SP),\n  DIMENSION(size(xx))","tags":"","loc":"interface/gammln.html"},{"title":"gammp – KORC-Full Orbit","text":"public interface gammp Contents Functions gammp_s gammp_v Functions public function gammp_s(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function gammp_v(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/gammp.html"},{"title":"gammq – KORC-Full Orbit","text":"public interface gammq Contents Functions gammq_s gammq_v Functions public function gammq_s(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function gammq_v(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/gammq.html"},{"title":"gasdev – KORC-Full Orbit","text":"public interface gasdev Contents Subroutines gasdev_s gasdev_v Subroutines public subroutine gasdev_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine gasdev_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest","tags":"","loc":"interface/gasdev.html"},{"title":"gaucof – KORC-Full Orbit","text":"interface public subroutine gaucof(a, b, amu0, x, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b real(kind=SP), intent(in) :: amu0 real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w","tags":"","loc":"interface/gaucof.html"},{"title":"gauher – KORC-Full Orbit","text":"interface public subroutine gauher(x, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w","tags":"","loc":"interface/gauher.html"},{"title":"gaujac – KORC-Full Orbit","text":"interface public subroutine gaujac(x, w, alf, bet) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(in) :: alf real(kind=SP), intent(in) :: bet","tags":"","loc":"interface/gaujac.html"},{"title":"gaulag – KORC-Full Orbit","text":"interface public subroutine gaulag(x, w, alf) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(in) :: alf","tags":"","loc":"interface/gaulag.html"},{"title":"gauleg – KORC-Full Orbit","text":"interface public subroutine gauleg(x1, x2, x, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w","tags":"","loc":"interface/gauleg.html"},{"title":"gaussj – KORC-Full Orbit","text":"interface public subroutine gaussj(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(inout), DIMENSION(:,:) :: b","tags":"","loc":"interface/gaussj.html"},{"title":"gcf – KORC-Full Orbit","text":"public interface gcf Contents Functions gcf_s gcf_v Functions public function gcf_s(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x real(kind=SP), intent(out), optional :: gln Return Value real(kind=SP) public function gcf_v(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), optional DIMENSION(:) :: gln Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/gcf.html"},{"title":"golden – KORC-Full Orbit","text":"interface public function golden(ax, bx, cx, func, tol, xmin) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: ax real(kind=SP), intent(in) :: bx real(kind=SP), intent(in) :: cx function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: tol real(kind=SP), intent(out) :: xmin Return Value real(kind=SP)","tags":"","loc":"interface/golden.html"},{"title":"gser – KORC-Full Orbit","text":"public interface gser Contents Functions gser_s gser_v Functions public function gser_s(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x real(kind=SP), intent(out), optional :: gln Return Value real(kind=SP) public function gser_v(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), optional DIMENSION(:) :: gln Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/gser.html"},{"title":"hqr – KORC-Full Orbit","text":"interface public subroutine hqr(a, wr, wi) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: wr real(kind=SP), intent(out), DIMENSION(:) :: wi","tags":"","loc":"interface/hqr.html"},{"title":"hunt – KORC-Full Orbit","text":"interface public subroutine hunt(xx, x, jlo) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xx real(kind=SP), intent(in) :: x integer(kind=I4B), intent(inout) :: jlo","tags":"","loc":"interface/hunt.html"},{"title":"hypdrv – KORC-Full Orbit","text":"interface public subroutine hypdrv(s, ry, rdyds) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: s real(kind=SP), intent(in), DIMENSION(:) :: ry real(kind=SP), intent(out), DIMENSION(:) :: rdyds","tags":"","loc":"interface/hypdrv.html"},{"title":"hypgeo – KORC-Full Orbit","text":"interface public function hypgeo(a, b, c, z) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: a complex(kind=SPC), intent(in) :: b complex(kind=SPC), intent(in) :: c complex(kind=SPC), intent(in) :: z Return Value complex(kind=SPC)","tags":"","loc":"interface/hypgeo.html"},{"title":"hypser – KORC-Full Orbit","text":"interface public subroutine hypser(a, b, c, z, series, deriv) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: a complex(kind=SPC), intent(in) :: b complex(kind=SPC), intent(in) :: c complex(kind=SPC), intent(in) :: z complex(kind=SPC), intent(out) :: series complex(kind=SPC), intent(out) :: deriv","tags":"","loc":"interface/hypser.html"},{"title":"icrc – KORC-Full Orbit","text":"interface public function icrc(crc, buf, jinit, jrev) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: crc character(len=1), intent(in), DIMENSION(:) :: buf integer(kind=I2B), intent(in) :: jinit integer(kind=I4B), intent(in) :: jrev Return Value integer(kind=I2B)","tags":"","loc":"interface/icrc.html"},{"title":"igray – KORC-Full Orbit","text":"interface public function igray(n, is) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: is Return Value integer(kind=I4B)","tags":"","loc":"interface/igray.html"},{"title":"index_bypack – KORC-Full Orbit","text":"interface public subroutine index_bypack(arr, index, partial) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(inout), DIMENSION(:) :: index integer, intent(in), optional :: partial","tags":"","loc":"interface/index_bypack.html"},{"title":"indexx – KORC-Full Orbit","text":"public interface indexx Contents Subroutines indexx_sp indexx_i4b Subroutines public subroutine indexx_sp(arr, index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(out), DIMENSION(:) :: index public subroutine indexx_i4b(iarr, index) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr integer(kind=I4B), intent(out), DIMENSION(:) :: index","tags":"","loc":"interface/indexx.html"},{"title":"interp – KORC-Full Orbit","text":"interface public function interp(uc) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: uc Return Value real(kind=DP),\n  DIMENSION(2*size(uc,1)-1,2*size(uc,1)-1)","tags":"","loc":"interface/interp.html"},{"title":"rank – KORC-Full Orbit","text":"interface public function rank(indx) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: indx Return Value integer(kind=I4B),\n  DIMENSION(size(indx))","tags":"","loc":"interface/rank.html"},{"title":"irbit1 – KORC-Full Orbit","text":"interface public function irbit1(iseed) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: iseed Return Value integer(kind=I4B)","tags":"","loc":"interface/irbit1.html"},{"title":"irbit2 – KORC-Full Orbit","text":"interface public function irbit2(iseed) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: iseed Return Value integer(kind=I4B)","tags":"","loc":"interface/irbit2.html"},{"title":"jacobi – KORC-Full Orbit","text":"interface public subroutine jacobi(a, d, v, nrot) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: d real(kind=SP), intent(out), DIMENSION(:,:) :: v integer(kind=I4B), intent(out) :: nrot","tags":"","loc":"interface/jacobi.html"},{"title":"jacobn – KORC-Full Orbit","text":"interface public subroutine jacobn(x, y, dfdx, dfdy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dfdx real(kind=SP), intent(out), DIMENSION(:,:) :: dfdy","tags":"","loc":"interface/jacobn.html"},{"title":"julday – KORC-Full Orbit","text":"interface public function julday(mm, id, iyyy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: id integer(kind=I4B), intent(in) :: iyyy Return Value integer(kind=I4B)","tags":"","loc":"interface/julday.html"},{"title":"kendl1 – KORC-Full Orbit","text":"interface public subroutine kendl1(data1, data2, tau, z, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: tau real(kind=SP), intent(out) :: z real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/kendl1.html"},{"title":"kendl2 – KORC-Full Orbit","text":"interface public subroutine kendl2(tab, tau, z, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: tab real(kind=SP), intent(out) :: tau real(kind=SP), intent(out) :: z real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/kendl2.html"},{"title":"kermom – KORC-Full Orbit","text":"interface public function kermom(y, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: y integer(kind=I4B), intent(in) :: m Return Value real(kind=DP),\n  DIMENSION(m)","tags":"","loc":"interface/kermom.html"},{"title":"ks2d1s – KORC-Full Orbit","text":"interface public subroutine ks2d1s(x1, y1, quadvl, d1, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1 real(kind=SP), intent(in), DIMENSION(:) :: y1 subroutine quadvl(x, y, fa, fb, fc, fd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc real(kind=SP), intent(out) :: fd real(kind=SP), intent(out) :: d1 real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/ks2d1s.html"},{"title":"ks2d2s – KORC-Full Orbit","text":"interface public subroutine ks2d2s(x1, y1, x2, y2, d, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1 real(kind=SP), intent(in), DIMENSION(:) :: y1 real(kind=SP), intent(in), DIMENSION(:) :: x2 real(kind=SP), intent(in), DIMENSION(:) :: y2 real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/ks2d2s.html"},{"title":"ksone – KORC-Full Orbit","text":"interface public subroutine ksone(data, func, d, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: data function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/ksone.html"},{"title":"kstwo – KORC-Full Orbit","text":"interface public subroutine kstwo(data1, data2, d, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/kstwo.html"},{"title":"laguer – KORC-Full Orbit","text":"interface public subroutine laguer(a, x, its) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(inout) :: x integer(kind=I4B), intent(out) :: its","tags":"","loc":"interface/laguer.html"},{"title":"lfit – KORC-Full Orbit","text":"interface public subroutine lfit(x, y, sig, a, maska, covar, chisq, funcs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(inout), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: maska real(kind=SP), intent(inout), DIMENSION(:,:) :: covar real(kind=SP), intent(out) :: chisq subroutine funcs(x, arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out), DIMENSION(:) :: arr","tags":"","loc":"interface/lfit.html"},{"title":"linbcg – KORC-Full Orbit","text":"interface public subroutine linbcg(b, x, itol, tol, itmax, iter, err) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: b real(kind=DP), intent(inout), DIMENSION(:) :: x integer(kind=I4B), intent(in) :: itol real(kind=DP), intent(in) :: tol integer(kind=I4B), intent(in) :: itmax integer(kind=I4B), intent(out) :: iter real(kind=DP), intent(out) :: err","tags":"","loc":"interface/linbcg.html"},{"title":"linmin – KORC-Full Orbit","text":"interface public subroutine linmin(p, xi, fret) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:), TARGET :: p real(kind=SP), intent(inout), DIMENSION(:), TARGET :: xi real(kind=SP), intent(out) :: fret","tags":"","loc":"interface/linmin.html"},{"title":"lnsrch – KORC-Full Orbit","text":"interface public subroutine lnsrch(xold, fold, g, p, x, f, stpmax, check, func) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xold real(kind=SP), intent(in) :: fold real(kind=SP), intent(in), DIMENSION(:) :: g real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out) :: f real(kind=SP), intent(in) :: stpmax logical(kind=LGT), intent(out) :: check function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP)","tags":"","loc":"interface/lnsrch.html"},{"title":"locate – KORC-Full Orbit","text":"interface public function locate(xx, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xx real(kind=SP), intent(in) :: x Return Value integer(kind=I4B)","tags":"","loc":"interface/locate.html"},{"title":"lop – KORC-Full Orbit","text":"interface public function lop(u) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: u Return Value real(kind=DP),\n  DIMENSION(size(u,1),size(u,1))","tags":"","loc":"interface/lop.html"},{"title":"lubksb – KORC-Full Orbit","text":"interface public subroutine lubksb(a, indx, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: indx real(kind=SP), intent(inout), DIMENSION(:) :: b","tags":"","loc":"interface/lubksb.html"},{"title":"ludcmp – KORC-Full Orbit","text":"interface public subroutine ludcmp(a, indx, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a integer(kind=I4B), intent(out), DIMENSION(:) :: indx real(kind=SP), intent(out) :: d","tags":"","loc":"interface/ludcmp.html"},{"title":"machar – KORC-Full Orbit","text":"interface public subroutine machar(ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp, eps, epsneg, xmin, xmax) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(out) :: ibeta integer(kind=I4B), intent(out) :: it integer(kind=I4B), intent(out) :: irnd integer(kind=I4B), intent(out) :: ngrd integer(kind=I4B), intent(out) :: machep integer(kind=I4B), intent(out) :: negep integer(kind=I4B), intent(out) :: iexp integer(kind=I4B), intent(out) :: minexp integer(kind=I4B), intent(out) :: maxexp real(kind=SP), intent(out) :: eps real(kind=SP), intent(out) :: epsneg real(kind=SP), intent(out) :: xmin real(kind=SP), intent(out) :: xmax","tags":"","loc":"interface/machar.html"},{"title":"medfit – KORC-Full Orbit","text":"interface public subroutine medfit(x, y, a, b, abdev) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out) :: a real(kind=SP), intent(out) :: b real(kind=SP), intent(out) :: abdev","tags":"","loc":"interface/medfit.html"},{"title":"memcof – KORC-Full Orbit","text":"interface public subroutine memcof(data, xms, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(out) :: xms real(kind=SP), intent(out), DIMENSION(:) :: d","tags":"","loc":"interface/memcof.html"},{"title":"mgfas – KORC-Full Orbit","text":"interface public subroutine mgfas(u, maxcyc) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u integer(kind=I4B), intent(in) :: maxcyc","tags":"","loc":"interface/mgfas.html"},{"title":"mglin – KORC-Full Orbit","text":"interface public subroutine mglin(u, ncycle) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u integer(kind=I4B), intent(in) :: ncycle","tags":"","loc":"interface/mglin.html"},{"title":"midexp – KORC-Full Orbit","text":"interface public subroutine midexp(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/midexp.html"},{"title":"midinf – KORC-Full Orbit","text":"interface public subroutine midinf(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/midinf.html"},{"title":"midpnt – KORC-Full Orbit","text":"interface public subroutine midpnt(func, a, b, s, n) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/midpnt.html"},{"title":"midsql – KORC-Full Orbit","text":"interface public subroutine midsql(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/midsql.html"},{"title":"midsqu – KORC-Full Orbit","text":"interface public subroutine midsqu(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/midsqu.html"},{"title":"miser – KORC-Full Orbit","text":"interface public subroutine miser(func, regn, ndim, npts, dith, ave, var) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) real(kind=SP), intent(in), DIMENSION(:) :: regn integer(kind=I4B), intent(in) :: ndim integer(kind=I4B), intent(in) :: npts real(kind=SP), intent(in) :: dith real(kind=SP), intent(out) :: ave real(kind=SP), intent(out) :: var","tags":"","loc":"interface/miser.html"},{"title":"mmid – KORC-Full Orbit","text":"interface public subroutine mmid(y, dydx, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in) :: xs real(kind=SP), intent(in) :: htot integer(kind=I4B), intent(in) :: nstep real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/mmid.html"},{"title":"mnbrak – KORC-Full Orbit","text":"interface public subroutine mnbrak(ax, bx, cx, fa, fb, fc, func) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: ax real(kind=SP), intent(inout) :: bx real(kind=SP), intent(out) :: cx real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP)","tags":"","loc":"interface/mnbrak.html"},{"title":"mnewt – KORC-Full Orbit","text":"interface public subroutine mnewt(ntrial, x, tolx, tolf, usrfun) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntrial real(kind=SP), intent(inout), DIMENSION(:) :: x real(kind=SP), intent(in) :: tolx real(kind=SP), intent(in) :: tolf subroutine usrfun(x, fvec, fjac) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: fvec real(kind=SP), intent(out), DIMENSION(:,:) :: fjac","tags":"","loc":"interface/mnewt.html"},{"title":"moment – KORC-Full Orbit","text":"interface public subroutine moment(data, ave, adev, sdev, var, skew, curt) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(out) :: ave real(kind=SP), intent(out) :: adev real(kind=SP), intent(out) :: sdev real(kind=SP), intent(out) :: var real(kind=SP), intent(out) :: skew real(kind=SP), intent(out) :: curt","tags":"","loc":"interface/moment.html"},{"title":"mp2dfr – KORC-Full Orbit","text":"interface public subroutine mp2dfr(a, s, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), DIMENSION(:) :: a character(len=1), intent(out), DIMENSION(:) :: s integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(out) :: m","tags":"","loc":"interface/mp2dfr.html"},{"title":"mpdiv – KORC-Full Orbit","text":"interface public subroutine mpdiv(q, r, u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: q character(len=1), intent(out), DIMENSION(:) :: r character(len=1), intent(in), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m","tags":"","loc":"interface/mpdiv.html"},{"title":"mpinv – KORC-Full Orbit","text":"interface public subroutine mpinv(u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m","tags":"","loc":"interface/mpinv.html"},{"title":"mpmul – KORC-Full Orbit","text":"interface public subroutine mpmul(w, u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: w character(len=1), intent(in), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m","tags":"","loc":"interface/mpmul.html"},{"title":"mppi – KORC-Full Orbit","text":"interface public subroutine mppi(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/mppi.html"},{"title":"mprove – KORC-Full Orbit","text":"interface public subroutine mprove(a, alud, indx, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:,:) :: alud integer(kind=I4B), intent(in), DIMENSION(:) :: indx real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(inout), DIMENSION(:) :: x","tags":"","loc":"interface/mprove.html"},{"title":"mpSQRT – KORC-Full Orbit","text":"interface public subroutine mpSQRT(w, u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: w character(len=1), intent(out), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m","tags":"","loc":"interface/mpsqrt.html"},{"title":"mrqcof – KORC-Full Orbit","text":"interface public subroutine mrqcof(x, y, sig, a, maska, alpha, beta, chisq, funcs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(in), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: maska real(kind=SP), intent(out), DIMENSION(:,:) :: alpha real(kind=SP), intent(out), DIMENSION(:) :: beta real(kind=SP), intent(out) :: chisq subroutine funcs(x, a, yfit, dyda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: yfit real(kind=SP), intent(out), DIMENSION(:,:) :: dyda","tags":"","loc":"interface/mrqcof.html"},{"title":"mrqmin – KORC-Full Orbit","text":"interface public subroutine mrqmin(x, y, sig, a, maska, covar, alpha, chisq, funcs, alamda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(inout), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: maska real(kind=SP), intent(out), DIMENSION(:,:) :: covar real(kind=SP), intent(out), DIMENSION(:,:) :: alpha real(kind=SP), intent(out) :: chisq subroutine funcs(x, a, yfit, dyda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: yfit real(kind=SP), intent(out), DIMENSION(:,:) :: dyda real(kind=SP), intent(inout) :: alamda","tags":"","loc":"interface/mrqmin.html"},{"title":"newt – KORC-Full Orbit","text":"interface public subroutine newt(x, check) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: x logical(kind=LGT), intent(out) :: check","tags":"","loc":"interface/newt.html"},{"title":"odeint – KORC-Full Orbit","text":"interface public subroutine odeint(ystart, x1, x2, eps, h1, hmin, derivs, rkqs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: ystart real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: eps real(kind=SP), intent(in) :: h1 real(kind=SP), intent(in) :: hmin subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx subroutine rkqs(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/odeint.html"},{"title":"orthog – KORC-Full Orbit","text":"interface public subroutine orthog(anu, alpha, beta, a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: anu real(kind=SP), intent(in), DIMENSION(:) :: alpha real(kind=SP), intent(in), DIMENSION(:) :: beta real(kind=SP), intent(out), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: b","tags":"","loc":"interface/orthog.html"},{"title":"pade – KORC-Full Orbit","text":"interface public subroutine pade(cof, resid) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: cof real(kind=SP), intent(out) :: resid","tags":"","loc":"interface/pade.html"},{"title":"pccheb – KORC-Full Orbit","text":"interface public function pccheb(d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: d Return Value real(kind=SP),\n  DIMENSION(size(d))","tags":"","loc":"interface/pccheb.html"},{"title":"pcshft – KORC-Full Orbit","text":"interface public subroutine pcshft(a, b, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(inout), DIMENSION(:) :: d","tags":"","loc":"interface/pcshft.html"},{"title":"pearsn – KORC-Full Orbit","text":"interface public subroutine pearsn(x, y, r, prob, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out) :: r real(kind=SP), intent(out) :: prob real(kind=SP), intent(out) :: z","tags":"","loc":"interface/pearsn.html"},{"title":"period – KORC-Full Orbit","text":"interface public subroutine period(x, y, ofac, hifac, px, py, jmax, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in) :: ofac real(kind=SP), intent(in) :: hifac real(kind=SP), DIMENSION(:), POINTER :: px real(kind=SP), DIMENSION(:), POINTER :: py integer(kind=I4B), intent(out) :: jmax real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/period.html"},{"title":"plgndr – KORC-Full Orbit","text":"public interface plgndr Contents Functions plgndr_s plgndr_v Functions public function plgndr_s(l, m, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: l integer(kind=I4B), intent(in) :: m real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function plgndr_v(l, m, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: l integer(kind=I4B), intent(in) :: m real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/plgndr.html"},{"title":"poidev – KORC-Full Orbit","text":"interface public function poidev(xm) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: xm Return Value real(kind=SP)","tags":"","loc":"interface/poidev.html"},{"title":"polcoe – KORC-Full Orbit","text":"interface public function polcoe(x, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/polcoe.html"},{"title":"polcof – KORC-Full Orbit","text":"interface public function polcof(xa, ya) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya Return Value real(kind=SP),\n  DIMENSION(size(xa))","tags":"","loc":"interface/polcof.html"},{"title":"poldiv – KORC-Full Orbit","text":"interface public subroutine poldiv(u, v, q, r) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: u real(kind=SP), intent(in), DIMENSION(:) :: v real(kind=SP), intent(out), DIMENSION(:) :: q real(kind=SP), intent(out), DIMENSION(:) :: r","tags":"","loc":"interface/poldiv.html"},{"title":"polin2 – KORC-Full Orbit","text":"interface public subroutine polin2(x1a, x2a, ya, x1, x2, y, dy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1a real(kind=SP), intent(in), DIMENSION(:) :: x2a real(kind=SP), intent(in), DIMENSION(:,:) :: ya real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(out) :: y real(kind=SP), intent(out) :: dy","tags":"","loc":"interface/polin2.html"},{"title":"polint – KORC-Full Orbit","text":"interface public subroutine polint(xa, ya, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: y real(kind=SP), intent(out) :: dy","tags":"","loc":"interface/polint.html"},{"title":"powell – KORC-Full Orbit","text":"interface public subroutine powell(p, xi, ftol, iter, fret) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(inout), DIMENSION(:,:) :: xi real(kind=SP), intent(in) :: ftol integer(kind=I4B), intent(out) :: iter real(kind=SP), intent(out) :: fret","tags":"","loc":"interface/powell.html"},{"title":"predic – KORC-Full Orbit","text":"interface public function predic(data, d, nfut) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(in), DIMENSION(:) :: d integer(kind=I4B), intent(in) :: nfut Return Value real(kind=SP),\n  DIMENSION(nfut)","tags":"","loc":"interface/predic.html"},{"title":"probks – KORC-Full Orbit","text":"interface public function probks(alam) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: alam Return Value real(kind=SP)","tags":"","loc":"interface/probks.html"},{"title":"psdes – KORC-Full Orbit","text":"public interface psdes Contents Subroutines psdes_s psdes_v Subroutines public subroutine psdes_s(lword, rword) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: lword integer(kind=I4B), intent(inout) :: rword public subroutine psdes_v(lword, rword) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), DIMENSION(:) :: lword integer(kind=I4B), intent(inout), DIMENSION(:) :: rword","tags":"","loc":"interface/psdes.html"},{"title":"pwt – KORC-Full Orbit","text":"interface public subroutine pwt(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/pwt.html"},{"title":"pwtset – KORC-Full Orbit","text":"interface public subroutine pwtset(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/pwtset.html"},{"title":"pythag – KORC-Full Orbit","text":"public interface pythag Contents Functions pythag_dp pythag_sp Functions public function pythag_dp(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: b Return Value real(kind=DP) public function pythag_sp(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP)","tags":"","loc":"interface/pythag.html"},{"title":"pzextr – KORC-Full Orbit","text":"interface public subroutine pzextr(iest, xest, yest, yz, dy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iest real(kind=SP), intent(in) :: xest real(kind=SP), intent(in), DIMENSION(:) :: yest real(kind=SP), intent(out), DIMENSION(:) :: yz real(kind=SP), intent(out), DIMENSION(:) :: dy","tags":"","loc":"interface/pzextr.html"},{"title":"qrdcmp – KORC-Full Orbit","text":"interface public subroutine qrdcmp(a, c, d, sing) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: c real(kind=SP), intent(out), DIMENSION(:) :: d logical(kind=LGT), intent(out) :: sing","tags":"","loc":"interface/qrdcmp.html"},{"title":"qromb – KORC-Full Orbit","text":"interface public function qromb(func, a, b) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP)","tags":"","loc":"interface/qromb.html"},{"title":"qromo – KORC-Full Orbit","text":"interface public function qromo(func, a, b, choose) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b subroutine choose(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n Return Value real(kind=SP)","tags":"","loc":"interface/qromo.html"},{"title":"qroot – KORC-Full Orbit","text":"interface public subroutine qroot(p, b, c, eps) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: p real(kind=SP), intent(inout) :: b real(kind=SP), intent(inout) :: c real(kind=SP), intent(in) :: eps","tags":"","loc":"interface/qroot.html"},{"title":"qrsolv – KORC-Full Orbit","text":"interface public subroutine qrsolv(a, c, d, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:) :: b","tags":"","loc":"interface/qrsolv.html"},{"title":"qrupdt – KORC-Full Orbit","text":"interface public subroutine qrupdt(r, qt, u, v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: r real(kind=SP), intent(inout), DIMENSION(:,:) :: qt real(kind=SP), intent(inout), DIMENSION(:) :: u real(kind=SP), intent(in), DIMENSION(:) :: v","tags":"","loc":"interface/qrupdt.html"},{"title":"qsimp – KORC-Full Orbit","text":"interface public function qsimp(func, a, b) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP)","tags":"","loc":"interface/qsimp.html"},{"title":"qtrap – KORC-Full Orbit","text":"interface public function qtrap(func, a, b) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP)","tags":"","loc":"interface/qtrap.html"},{"title":"quadct – KORC-Full Orbit","text":"interface public subroutine quadct(x, y, xx, yy, fa, fb, fc, fd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in), DIMENSION(:) :: xx real(kind=SP), intent(in), DIMENSION(:) :: yy real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc real(kind=SP), intent(out) :: fd","tags":"","loc":"interface/quadct.html"},{"title":"quadmx – KORC-Full Orbit","text":"interface public subroutine quadmx(a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:,:) :: a","tags":"","loc":"interface/quadmx.html"},{"title":"quadvl – KORC-Full Orbit","text":"interface public subroutine quadvl(x, y, fa, fb, fc, fd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc real(kind=SP), intent(out) :: fd","tags":"","loc":"interface/quadvl.html"},{"title":"ran – KORC-Full Orbit","text":"interface public function ran(idum) Arguments Type Intent Optional Attributes Name integer(kind=selected_int_kind(9)), intent(inout) :: idum Return Value real","tags":"","loc":"interface/ran.html"},{"title":"ran0 – KORC-Full Orbit","text":"public interface ran0 Contents Subroutines ran0_s ran0_v Subroutines public subroutine ran0_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran0_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest","tags":"","loc":"interface/ran0.html"},{"title":"ran1 – KORC-Full Orbit","text":"public interface ran1 Contents Subroutines ran1_s ran1_v Subroutines public subroutine ran1_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran1_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest","tags":"","loc":"interface/ran1.html"},{"title":"ran2 – KORC-Full Orbit","text":"public interface ran2 Contents Subroutines ran2_s ran2_v Subroutines public subroutine ran2_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran2_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest","tags":"","loc":"interface/ran2.html"},{"title":"ran3 – KORC-Full Orbit","text":"public interface ran3 Contents Subroutines ran3_s ran3_v Subroutines public subroutine ran3_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran3_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest","tags":"","loc":"interface/ran3.html"},{"title":"ratint – KORC-Full Orbit","text":"interface public subroutine ratint(xa, ya, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: y real(kind=SP), intent(out) :: dy","tags":"","loc":"interface/ratint.html"},{"title":"ratlsq – KORC-Full Orbit","text":"interface public subroutine ratlsq(func, a, b, mm, kk, cof, dev) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x Return Value real(kind=DP),\n  DIMENSION(size(x)) real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: b integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: kk real(kind=DP), intent(out), DIMENSION(:) :: cof real(kind=DP), intent(out) :: dev","tags":"","loc":"interface/ratlsq.html"},{"title":"ratval – KORC-Full Orbit","text":"public interface ratval Contents Functions ratval_s ratval_v Functions public function ratval_s(x, cof, mm, kk) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(in), DIMENSION(mm+kk+1) :: cof integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: kk Return Value real(kind=DP) public function ratval_v(x, cof, mm, kk) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(mm+kk+1) :: cof integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: kk Return Value real(kind=DP),\n  DIMENSION(size(x))","tags":"","loc":"interface/ratval.html"},{"title":"rc – KORC-Full Orbit","text":"public interface rc Contents Functions rc_s rc_v Functions public function rc_s(x, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y Return Value real(kind=SP) public function rc_v(x, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/rc.html"},{"title":"rd – KORC-Full Orbit","text":"public interface rd Contents Functions rd_s rd_v Functions public function rd_s(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in) :: z Return Value real(kind=SP) public function rd_v(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: z Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/rd.html"},{"title":"realft – KORC-Full Orbit","text":"public interface realft Contents Subroutines realft_dp realft_sp Subroutines public subroutine realft_dp(data, isign, zdata) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign complex(kind=DPC), optional DIMENSION(:), TARGET :: zdata public subroutine realft_sp(data, isign, zdata) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign complex(kind=SPC), optional DIMENSION(:), TARGET :: zdata","tags":"","loc":"interface/realft.html"},{"title":"recur1 – KORC-Full Orbit","text":"interface public recursive function recur1(a, b) result(u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/recur1.html"},{"title":"recur2 – KORC-Full Orbit","text":"interface public function recur2(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(a))","tags":"","loc":"interface/recur2.html"},{"title":"relax – KORC-Full Orbit","text":"interface public subroutine relax(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:,:) :: rhs","tags":"","loc":"interface/relax.html"},{"title":"relax2 – KORC-Full Orbit","text":"interface public subroutine relax2(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:,:) :: rhs","tags":"","loc":"interface/relax2.html"},{"title":"resid – KORC-Full Orbit","text":"interface public function resid(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:,:) :: rhs Return Value real(kind=DP),\n  DIMENSION(size(u,1),size(u,1))","tags":"","loc":"interface/resid.html"},{"title":"rf – KORC-Full Orbit","text":"public interface rf Contents Functions rf_s rf_v Functions public function rf_s(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in) :: z Return Value real(kind=SP) public function rf_v(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: z Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/rf.html"},{"title":"rj – KORC-Full Orbit","text":"public interface rj Contents Functions rj_s rj_v Functions public function rj_s(x, y, z, p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in) :: z real(kind=SP), intent(in) :: p Return Value real(kind=SP) public function rj_v(x, y, z, p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: z real(kind=SP), intent(in), DIMENSION(:) :: p Return Value real(kind=SP),\n  DIMENSION(size(x))","tags":"","loc":"interface/rj.html"},{"title":"rk4 – KORC-Full Orbit","text":"interface public subroutine rk4(y, dydx, x, h, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: h real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/rk4.html"},{"title":"rkck – KORC-Full Orbit","text":"interface public subroutine rkck(y, dydx, x, h, yout, yerr, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: h real(kind=SP), intent(out), DIMENSION(:) :: yout real(kind=SP), intent(out), DIMENSION(:) :: yerr subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/rkck.html"},{"title":"rkdumb – KORC-Full Orbit","text":"interface public subroutine rkdumb(vstart, x1, x2, nstep, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: vstart real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 integer(kind=I4B), intent(in) :: nstep subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/rkdumb.html"},{"title":"rkqs – KORC-Full Orbit","text":"interface public subroutine rkqs(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/rkqs.html"},{"title":"rlft2 – KORC-Full Orbit","text":"interface public subroutine rlft2(data, spec, speq, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: data complex(kind=SPC), intent(out), DIMENSION(:,:) :: spec complex(kind=SPC), intent(out), DIMENSION(:) :: speq integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/rlft2.html"},{"title":"rlft3 – KORC-Full Orbit","text":"interface public subroutine rlft3(data, spec, speq, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:,:) :: data complex(kind=SPC), intent(out), DIMENSION(:,:,:) :: spec complex(kind=SPC), intent(out), DIMENSION(:,:) :: speq integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/rlft3.html"},{"title":"rotate – KORC-Full Orbit","text":"interface public subroutine rotate(r, qt, i, a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:), TARGET :: r real(kind=SP), intent(inout), DIMENSION(:,:), TARGET :: qt integer(kind=I4B), intent(in) :: i real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b","tags":"","loc":"interface/rotate.html"},{"title":"rsolv – KORC-Full Orbit","text":"interface public subroutine rsolv(a, d, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:) :: b","tags":"","loc":"interface/rsolv.html"},{"title":"rstrct – KORC-Full Orbit","text":"interface public function rstrct(uf) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: uf Return Value real(kind=DP),\n  DIMENSION((size(uf,1)+1)/2,(size(uf,1)+1)/2)","tags":"","loc":"interface/rstrct.html"},{"title":"rtbis – KORC-Full Orbit","text":"interface public function rtbis(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP)","tags":"","loc":"interface/rtbis.html"},{"title":"rtflsp – KORC-Full Orbit","text":"interface public function rtflsp(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP)","tags":"","loc":"interface/rtflsp.html"},{"title":"rtnewt – KORC-Full Orbit","text":"interface public function rtnewt(funcd, x1, x2, xacc) Arguments Type Intent Optional Attributes Name subroutine funcd(x, fval, fderiv) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: fval real(kind=SP), intent(out) :: fderiv real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP)","tags":"","loc":"interface/rtnewt.html"},{"title":"rtsafe – KORC-Full Orbit","text":"interface public function rtsafe(funcd, x1, x2, xacc) Arguments Type Intent Optional Attributes Name subroutine funcd(x, fval, fderiv) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: fval real(kind=SP), intent(out) :: fderiv real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP)","tags":"","loc":"interface/rtsafe.html"},{"title":"rtsec – KORC-Full Orbit","text":"interface public function rtsec(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP)","tags":"","loc":"interface/rtsec.html"},{"title":"rzextr – KORC-Full Orbit","text":"interface public subroutine rzextr(iest, xest, yest, yz, dy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iest real(kind=SP), intent(in) :: xest real(kind=SP), intent(in), DIMENSION(:) :: yest real(kind=SP), intent(out), DIMENSION(:) :: yz real(kind=SP), intent(out), DIMENSION(:) :: dy","tags":"","loc":"interface/rzextr.html"},{"title":"savgol – KORC-Full Orbit","text":"interface public function savgol(nl, nrr, ld, m) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nl integer(kind=I4B), intent(in) :: nrr integer(kind=I4B), intent(in) :: ld integer(kind=I4B), intent(in) :: m Return Value real(kind=SP),\n  DIMENSION(nl+nrr+1)","tags":"","loc":"interface/savgol.html"},{"title":"scrsho – KORC-Full Orbit","text":"interface public subroutine scrsho(func) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP)","tags":"","loc":"interface/scrsho.html"},{"title":"select – KORC-Full Orbit","text":"interface public function select(k, arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k real(kind=SP), intent(inout), DIMENSION(:) :: arr Return Value real(kind=SP)","tags":"","loc":"interface/select.html"},{"title":"select_bypack – KORC-Full Orbit","text":"interface public function select_bypack(k, arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k real(kind=SP), intent(inout), DIMENSION(:) :: arr Return Value real(kind=SP)","tags":"","loc":"interface/select_bypack.html"},{"title":"select_heap – KORC-Full Orbit","text":"interface public subroutine select_heap(arr, heap) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(out), DIMENSION(:) :: heap","tags":"","loc":"interface/select_heap.html"},{"title":"select_inplace – KORC-Full Orbit","text":"interface public function select_inplace(k, arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value real(kind=SP)","tags":"","loc":"interface/select_inplace.html"},{"title":"simplx – KORC-Full Orbit","text":"interface public subroutine simplx(a, m1, m2, m3, icase, izrov, iposv) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 integer(kind=I4B), intent(in) :: m3 integer(kind=I4B), intent(out) :: icase integer(kind=I4B), intent(out), DIMENSION(:) :: izrov integer(kind=I4B), intent(out), DIMENSION(:) :: iposv","tags":"","loc":"interface/simplx.html"},{"title":"simpr – KORC-Full Orbit","text":"interface public subroutine simpr(y, dydx, dfdx, dfdy, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in), DIMENSION(:) :: dfdx real(kind=SP), intent(in), DIMENSION(:,:) :: dfdy real(kind=SP), intent(in) :: xs real(kind=SP), intent(in) :: htot integer(kind=I4B), intent(in) :: nstep real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/simpr.html"},{"title":"sinft – KORC-Full Orbit","text":"interface public subroutine sinft(y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y","tags":"","loc":"interface/sinft.html"},{"title":"slvsm2 – KORC-Full Orbit","text":"interface public subroutine slvsm2(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(3,3) :: u real(kind=DP), intent(in), DIMENSION(3,3) :: rhs","tags":"","loc":"interface/slvsm2.html"},{"title":"slvsml – KORC-Full Orbit","text":"interface public subroutine slvsml(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(3,3) :: u real(kind=DP), intent(in), DIMENSION(3,3) :: rhs","tags":"","loc":"interface/slvsml.html"},{"title":"sncndn – KORC-Full Orbit","text":"interface public subroutine sncndn(uu, emmc, sn, cn, dn) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: uu real(kind=SP), intent(in) :: emmc real(kind=SP), intent(out) :: sn real(kind=SP), intent(out) :: cn real(kind=SP), intent(out) :: dn","tags":"","loc":"interface/sncndn.html"},{"title":"snrm – KORC-Full Orbit","text":"interface public function snrm(sx, itol) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: sx integer(kind=I4B), intent(in) :: itol Return Value real(kind=DP)","tags":"","loc":"interface/snrm.html"},{"title":"sobseq – KORC-Full Orbit","text":"interface public subroutine sobseq(x, init) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x integer(kind=I4B), intent(in), optional :: init","tags":"","loc":"interface/sobseq.html"},{"title":"solvde – KORC-Full Orbit","text":"interface public subroutine solvde(itmax, conv, slowc, scalv, indexv, nb, y) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: itmax real(kind=SP), intent(in) :: conv real(kind=SP), intent(in) :: slowc real(kind=SP), intent(in), DIMENSION(:) :: scalv integer(kind=I4B), intent(in), DIMENSION(:) :: indexv integer(kind=I4B), intent(in) :: nb real(kind=SP), intent(inout), DIMENSION(:,:) :: y","tags":"","loc":"interface/solvde.html"},{"title":"sor – KORC-Full Orbit","text":"interface public subroutine sor(a, b, c, d, e, f, u, rjac) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: a real(kind=DP), intent(in), DIMENSION(:,:) :: b real(kind=DP), intent(in), DIMENSION(:,:) :: c real(kind=DP), intent(in), DIMENSION(:,:) :: d real(kind=DP), intent(in), DIMENSION(:,:) :: e real(kind=DP), intent(in), DIMENSION(:,:) :: f real(kind=DP), intent(inout), DIMENSION(:,:) :: u real(kind=DP), intent(in) :: rjac","tags":"","loc":"interface/sor.html"},{"title":"sort – KORC-Full Orbit","text":"interface public subroutine sort(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort.html"},{"title":"sort2 – KORC-Full Orbit","text":"interface public subroutine sort2(arr, slave) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr real(kind=SP), intent(inout), DIMENSION(:) :: slave","tags":"","loc":"interface/sort2.html"},{"title":"sort3 – KORC-Full Orbit","text":"interface public subroutine sort3(arr, slave1, slave2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr real(kind=SP), intent(inout), DIMENSION(:) :: slave1 real(kind=SP), intent(inout), DIMENSION(:) :: slave2","tags":"","loc":"interface/sort3.html"},{"title":"sort_bypack – KORC-Full Orbit","text":"interface public subroutine sort_bypack(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort_bypack.html"},{"title":"sort_byreshape – KORC-Full Orbit","text":"interface public subroutine sort_byreshape(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort_byreshape.html"},{"title":"sort_heap – KORC-Full Orbit","text":"interface public subroutine sort_heap(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort_heap.html"},{"title":"sort_pick – KORC-Full Orbit","text":"interface public subroutine sort_pick(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort_pick.html"},{"title":"sort_radix – KORC-Full Orbit","text":"interface public subroutine sort_radix(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort_radix.html"},{"title":"sort_shell – KORC-Full Orbit","text":"interface public subroutine sort_shell(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr","tags":"","loc":"interface/sort_shell.html"},{"title":"spctrm – KORC-Full Orbit","text":"interface public subroutine spctrm(p, k, ovrlap, unit, n_window) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: p integer(kind=I4B), intent(in) :: k logical(kind=LGT), intent(in) :: ovrlap integer(kind=I4B), intent(in), optional :: unit integer(kind=I4B), intent(in), optional :: n_window","tags":"","loc":"interface/spctrm.html"},{"title":"spear – KORC-Full Orbit","text":"interface public subroutine spear(data1, data2, d, zd, probd, rs, probrs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: zd real(kind=SP), intent(out) :: probd real(kind=SP), intent(out) :: rs real(kind=SP), intent(out) :: probrs","tags":"","loc":"interface/spear.html"},{"title":"sphbes – KORC-Full Orbit","text":"public interface sphbes Contents Subroutines sphbes_s sphbes_v Subroutines public subroutine sphbes_s(n, x, sj, sy, sjp, syp) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: sj real(kind=SP), intent(out) :: sy real(kind=SP), intent(out) :: sjp real(kind=SP), intent(out) :: syp public subroutine sphbes_v(n, x, sj, sy, sjp, syp) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: sj real(kind=SP), intent(out), DIMENSION(:) :: sy real(kind=SP), intent(out), DIMENSION(:) :: sjp real(kind=SP), intent(out), DIMENSION(:) :: syp","tags":"","loc":"interface/sphbes.html"},{"title":"splie2 – KORC-Full Orbit","text":"interface public subroutine splie2(x1a, x2a, ya, y2a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1a real(kind=SP), intent(in), DIMENSION(:) :: x2a real(kind=SP), intent(in), DIMENSION(:,:) :: ya real(kind=SP), intent(out), DIMENSION(:,:) :: y2a","tags":"","loc":"interface/splie2.html"},{"title":"splin2 – KORC-Full Orbit","text":"interface public function splin2(x1a, x2a, ya, y2a, x1, x2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1a real(kind=SP), intent(in), DIMENSION(:) :: x2a real(kind=SP), intent(in), DIMENSION(:,:) :: ya real(kind=SP), intent(in), DIMENSION(:,:) :: y2a real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 Return Value real(kind=SP)","tags":"","loc":"interface/splin2.html"},{"title":"spline – KORC-Full Orbit","text":"interface public subroutine spline(x, y, yp1, ypn, y2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in) :: yp1 real(kind=SP), intent(in) :: ypn real(kind=SP), intent(out), DIMENSION(:) :: y2","tags":"","loc":"interface/spline.html"},{"title":"splint – KORC-Full Orbit","text":"interface public function splint(xa, ya, y2a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya real(kind=SP), intent(in), DIMENSION(:) :: y2a real(kind=SP), intent(in) :: x Return Value real(kind=SP)","tags":"","loc":"interface/splint.html"},{"title":"sprsax – KORC-Full Orbit","text":"public interface sprsax Contents Subroutines sprsax_dp sprsax_sp Subroutines public subroutine sprsax_dp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_dp), intent(in) :: sa real(kind=DP), intent(in), DIMENSION (:) :: x real(kind=DP), intent(out), DIMENSION (:) :: b public subroutine sprsax_sp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(in) :: sa real(kind=SP), intent(in), DIMENSION (:) :: x real(kind=SP), intent(out), DIMENSION (:) :: b","tags":"","loc":"interface/sprsax.html"},{"title":"sprsdiag – KORC-Full Orbit","text":"public interface sprsdiag Contents Subroutines sprsdiag_dp sprsdiag_sp Subroutines public subroutine sprsdiag_dp(sa, b) Arguments Type Intent Optional Attributes Name type(sprs2_dp), intent(in) :: sa real(kind=DP), intent(out), DIMENSION(:) :: b public subroutine sprsdiag_sp(sa, b) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(in) :: sa real(kind=SP), intent(out), DIMENSION(:) :: b","tags":"","loc":"interface/sprsdiag.html"},{"title":"sprsin – KORC-Full Orbit","text":"public interface sprsin Contents Subroutines sprsin_sp sprsin_dp Subroutines public subroutine sprsin_sp(a, thresh, sa) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in) :: thresh type(sprs2_sp), intent(out) :: sa public subroutine sprsin_dp(a, thresh, sa) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: a real(kind=DP), intent(in) :: thresh type(sprs2_dp), intent(out) :: sa","tags":"","loc":"interface/sprsin.html"},{"title":"sprstp – KORC-Full Orbit","text":"interface public subroutine sprstp(sa) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(inout) :: sa","tags":"","loc":"interface/sprstp.html"},{"title":"sprstx – KORC-Full Orbit","text":"public interface sprstx Contents Subroutines sprstx_dp sprstx_sp Subroutines public subroutine sprstx_dp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_dp), intent(in) :: sa real(kind=DP), intent(in), DIMENSION (:) :: x real(kind=DP), intent(out), DIMENSION (:) :: b public subroutine sprstx_sp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(in) :: sa real(kind=SP), intent(in), DIMENSION (:) :: x real(kind=SP), intent(out), DIMENSION (:) :: b","tags":"","loc":"interface/sprstx.html"},{"title":"stifbs – KORC-Full Orbit","text":"interface public subroutine stifbs(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/stifbs.html"},{"title":"stiff – KORC-Full Orbit","text":"interface public subroutine stiff(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/stiff.html"},{"title":"stoerm – KORC-Full Orbit","text":"interface public subroutine stoerm(y, d2y, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: d2y real(kind=SP), intent(in) :: xs real(kind=SP), intent(in) :: htot integer(kind=I4B), intent(in) :: nstep real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx","tags":"","loc":"interface/stoerm.html"},{"title":"svbksb – KORC-Full Orbit","text":"public interface svbksb Contents Subroutines svbksb_dp svbksb_sp Subroutines public subroutine svbksb_dp(u, w, v, b, x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:) :: w real(kind=DP), intent(in), DIMENSION(:,:) :: v real(kind=DP), intent(in), DIMENSION(:) :: b real(kind=DP), intent(out), DIMENSION(:) :: x public subroutine svbksb_sp(u, w, v, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: u real(kind=SP), intent(in), DIMENSION(:) :: w real(kind=SP), intent(in), DIMENSION(:,:) :: v real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(out), DIMENSION(:) :: x","tags":"","loc":"interface/svbksb.html"},{"title":"svdcmp – KORC-Full Orbit","text":"public interface svdcmp Contents Subroutines svdcmp_dp svdcmp_sp Subroutines public subroutine svdcmp_dp(a, w, v) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: a real(kind=DP), intent(out), DIMENSION(:) :: w real(kind=DP), intent(out), DIMENSION(:,:) :: v public subroutine svdcmp_sp(a, w, v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(out), DIMENSION(:,:) :: v","tags":"","loc":"interface/svdcmp.html"},{"title":"svdfit – KORC-Full Orbit","text":"interface public subroutine svdfit(x, y, sig, a, v, w, chisq, funcs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(out), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:,:) :: v real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(out) :: chisq function funcs(x, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n)","tags":"","loc":"interface/svdfit.html"},{"title":"svdvar – KORC-Full Orbit","text":"interface public subroutine svdvar(v, w, cvm) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: v real(kind=SP), intent(in), DIMENSION(:) :: w real(kind=SP), intent(out), DIMENSION(:,:) :: cvm","tags":"","loc":"interface/svdvar.html"},{"title":"toeplz – KORC-Full Orbit","text":"interface public function toeplz(r, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(in), DIMENSION(:) :: y Return Value real(kind=SP),\n  DIMENSION(size(y))","tags":"","loc":"interface/toeplz.html"},{"title":"tptest – KORC-Full Orbit","text":"interface public subroutine tptest(data1, data2, t, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: t real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/tptest.html"},{"title":"tqli – KORC-Full Orbit","text":"interface public subroutine tqli(d, e, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:) :: e real(kind=SP), intent(inout), optional DIMENSION(:,:) :: z","tags":"","loc":"interface/tqli.html"},{"title":"trapzd – KORC-Full Orbit","text":"interface public subroutine trapzd(func, a, b, s, n) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n","tags":"","loc":"interface/trapzd.html"},{"title":"tred2 – KORC-Full Orbit","text":"interface public subroutine tred2(a, d, e, novectors) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: d real(kind=SP), intent(out), DIMENSION(:) :: e logical(kind=LGT), intent(in), optional :: novectors","tags":"","loc":"interface/tred2.html"},{"title":"tridag – KORC-Full Orbit","text":"public interface tridag Contents Subroutines tridag_par Subroutines public subroutine tridag_par(a, b, c, r, u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(out), DIMENSION(:) :: u","tags":"","loc":"interface/tridag.html"},{"title":"tridag_ser – KORC-Full Orbit","text":"interface public subroutine tridag_ser(a, b, c, r, u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(out), DIMENSION(:) :: u","tags":"","loc":"interface/tridag_ser.html"},{"title":"ttest – KORC-Full Orbit","text":"interface public subroutine ttest(data1, data2, t, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: t real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/ttest.html"},{"title":"tutest – KORC-Full Orbit","text":"interface public subroutine tutest(data1, data2, t, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: t real(kind=SP), intent(out) :: prob","tags":"","loc":"interface/tutest.html"},{"title":"twofft – KORC-Full Orbit","text":"interface public subroutine twofft(data1, data2, fft1, fft2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 complex(kind=SPC), intent(out), DIMENSION(:) :: fft1 complex(kind=SPC), intent(out), DIMENSION(:) :: fft2","tags":"","loc":"interface/twofft.html"},{"title":"vander – KORC-Full Orbit","text":"interface public function vander(x, q) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: q Return Value real(kind=DP),\n  DIMENSION(size(x))","tags":"","loc":"interface/vander.html"},{"title":"vegas – KORC-Full Orbit","text":"interface public subroutine vegas(region, func, init, ncall, itmx, nprn, tgral, sd, chi2a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: region function func(pt, wgt) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: pt real(kind=SP), intent(in) :: wgt Return Value real(kind=SP) integer(kind=I4B), intent(in) :: init integer(kind=I4B), intent(in) :: ncall integer(kind=I4B), intent(in) :: itmx integer(kind=I4B), intent(in) :: nprn real(kind=SP), intent(out) :: tgral real(kind=SP), intent(out) :: sd real(kind=SP), intent(out) :: chi2a","tags":"","loc":"interface/vegas.html"},{"title":"voltra – KORC-Full Orbit","text":"interface public subroutine voltra(t0, h, t, f, g, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: t0 real(kind=SP), intent(in) :: h real(kind=SP), intent(out), DIMENSION(:) :: t real(kind=SP), intent(out), DIMENSION(:,:) :: f function g(t) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: t Return Value real(kind=SP),\n  DIMENSION(:), POINTER function ak(t, s) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: t real(kind=SP), intent(in) :: s Return Value real(kind=SP),\n  DIMENSION(:,:), POINTER","tags":"","loc":"interface/voltra.html"},{"title":"wt1 – KORC-Full Orbit","text":"interface public subroutine wt1(a, isign, wtstep) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign subroutine wtstep(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/wt1.html"},{"title":"wtn – KORC-Full Orbit","text":"interface public subroutine wtn(a, nn, isign, wtstep) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: nn integer(kind=I4B), intent(in) :: isign subroutine wtstep(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign","tags":"","loc":"interface/wtn.html"},{"title":"wwghts – KORC-Full Orbit","text":"interface public function wwghts(n, h, kermom) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: h function kermom(y, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: y integer(kind=I4B), intent(in) :: m Return Value real(kind=DP),\n  DIMENSION(m) Return Value real(kind=SP),\n  DIMENSION(n)","tags":"","loc":"interface/wwghts.html"},{"title":"zbrac – KORC-Full Orbit","text":"interface public subroutine zbrac(func, x1, x2, succes) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(inout) :: x1 real(kind=SP), intent(inout) :: x2 logical(kind=LGT), intent(out) :: succes","tags":"","loc":"interface/zbrac.html"},{"title":"zbrak – KORC-Full Orbit","text":"interface public subroutine zbrak(func, x1, x2, n, xb1, xb2, nb) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 integer(kind=I4B), intent(in) :: n real(kind=SP), DIMENSION(:), POINTER :: xb1 real(kind=SP), DIMENSION(:), POINTER :: xb2 integer(kind=I4B), intent(out) :: nb","tags":"","loc":"interface/zbrak.html"},{"title":"zbrent – KORC-Full Orbit","text":"interface public function zbrent(func, x1, x2, tol) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: tol Return Value real(kind=SP)","tags":"","loc":"interface/zbrent.html"},{"title":"zrhqr – KORC-Full Orbit","text":"interface public subroutine zrhqr(a, rtr, rti) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: rtr real(kind=SP), intent(out), DIMENSION(:) :: rti","tags":"","loc":"interface/zrhqr.html"},{"title":"zriddr – KORC-Full Orbit","text":"interface public function zriddr(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP)","tags":"","loc":"interface/zriddr.html"},{"title":"zroots – KORC-Full Orbit","text":"interface public subroutine zroots(a, roots, polish) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(out), DIMENSION(:) :: roots logical(kind=LGT), intent(in) :: polish","tags":"","loc":"interface/zroots.html"},{"title":"bessik – KORC-Full Orbit","text":"public subroutine bessik(x, xnu, ri, rk, rip, rkp) Uses nrtype nrutil nr @brief Subroutine taken from \"Numerical Recipes\" that calculates the modified Bessel function of Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out) :: ri real(kind=SP), intent(out) :: rk real(kind=SP), intent(out) :: rip real(kind=SP), intent(out) :: rkp Contents Source Code bessik Source Code SUBROUTINE bessik ( x , xnu , ri , rk , rip , rkp ) USE nrtype REAL ( SP ), INTENT ( IN ) :: x , xnu REAL ( SP ), INTENT ( OUT ) :: ri , rk , rip , rkp END SUBROUTINE bessik","tags":"","loc":"proc/bessik.html"},{"title":"get_random – KORC-Full Orbit","text":"public function get_random() Uses omp_lib Arguments None Return Value real(kind=rp) Contents Source Code get_random Source Code FUNCTION get_random () USE omp_lib IMPLICIT NONE REAL ( rp ) :: get_random get_random = random_get_number_U ( states ( OMP_GET_THREAD_NUM ())) END FUNCTION get_random","tags":"","loc":"proc/get_random.html"},{"title":"get_random_U – KORC-Full Orbit","text":"public function get_random_U() Uses omp_lib Arguments None Return Value real(kind=rp) Contents Source Code get_random_U Source Code FUNCTION get_random_U () USE omp_lib IMPLICIT NONE REAL ( rp ) :: get_random_U get_random_U = random_get_number_U ( state ) END FUNCTION get_random_U","tags":"","loc":"proc/get_random_u.html"},{"title":"get_random_N – KORC-Full Orbit","text":"public function get_random_N() Uses omp_lib Arguments None Return Value real(kind=rp) Contents Source Code get_random_N Source Code FUNCTION get_random_N () USE omp_lib IMPLICIT NONE REAL ( rp ) :: get_random_N get_random_N = random_get_number_N ( state ) END FUNCTION get_random_N","tags":"","loc":"proc/get_random_n.html"},{"title":"initialize_random – KORC-Full Orbit","text":"public subroutine initialize_random(seed) Uses omp_lib Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed Contents Source Code initialize_random Source Code SUBROUTINE initialize_random ( seed ) USE omp_lib IMPLICIT NONE INTEGER , INTENT ( IN ) :: seed INTEGER :: num_threads INTEGER :: thread_num num_threads = OMP_GET_MAX_THREADS () IF (. NOT . ALLOCATED ( states )) THEN ALLOCATE ( states ( 0 : num_threads - 1 )) END IF !$OMP PARALLEL PRIVATE(thread_num) thread_num = OMP_GET_THREAD_NUM () states ( thread_num ) = random_construct_U ( seed + thread_num ) !$OMP END PARALLEL END SUBROUTINE initialize_random","tags":"","loc":"proc/initialize_random.html"},{"title":"initialize_random_U – KORC-Full Orbit","text":"public subroutine initialize_random_U(seed) Uses omp_lib Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed Contents Source Code initialize_random_U Source Code SUBROUTINE initialize_random_U ( seed ) USE omp_lib IMPLICIT NONE INTEGER , INTENT ( IN ) :: seed state = random_construct_U ( seed ) END SUBROUTINE initialize_random_U","tags":"","loc":"proc/initialize_random_u.html"},{"title":"initialize_random_N – KORC-Full Orbit","text":"public subroutine initialize_random_N(seed) Uses omp_lib Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed Contents Source Code initialize_random_N Source Code SUBROUTINE initialize_random_N ( seed ) USE omp_lib IMPLICIT NONE INTEGER , INTENT ( IN ) :: seed state = random_construct_N ( seed ) END SUBROUTINE initialize_random_N","tags":"","loc":"proc/initialize_random_n.html"},{"title":"random_construct_U – KORC-Full Orbit","text":"interface public function random_construct_U(seed) bind(C, NAME='random_construct_U') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), VALUE :: seed Return Value type(C_PTR)","tags":"","loc":"interface/random_construct_u.html"},{"title":"random_construct_N – KORC-Full Orbit","text":"interface public function random_construct_N(seed) bind(C, NAME='random_construct_N') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), VALUE :: seed Return Value type(C_PTR)","tags":"","loc":"interface/random_construct_n.html"},{"title":"random_get_number_U – KORC-Full Orbit","text":"interface public function random_get_number_U(r) bind(C, NAME='random_get_number_U') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/random_get_number_u.html"},{"title":"random_get_number_N – KORC-Full Orbit","text":"interface public function random_get_number_N(r) bind(C, NAME='random_get_number_N') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r Return Value real(kind=C_DOUBLE)","tags":"","loc":"interface/random_get_number_n.html"},{"title":"random_destroy_U – KORC-Full Orbit","text":"interface public subroutine random_destroy_U(r) bind(C, NAME=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r","tags":"","loc":"interface/random_destroy_u.html"},{"title":"random_destroy_N – KORC-Full Orbit","text":"interface public subroutine random_destroy_N(r) bind(C, NAME=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r","tags":"","loc":"interface/random_destroy_n.html"},{"title":"initialize_profiles – KORC-Full Orbit","text":"public subroutine initialize_profiles(params, P, F) Note Subroutine that initializes the parameters of analytical \n or pre-computed plasma profiles for being used in the\n simulation. KORC can run using either analytical and pre-computed plasma\n profiles. Pre-computed plasma profiles, as in the case of\n pre-computed electric or magnetic fields, are interpolated to\n electrons' position in korc_profiles . There are two types of analytical plasma profiles that can be\n used in KORC: 3rd degree polynomial radial plasma profiles, and radial plasma profiles with a dependency: , where is the radial coordinate in toroidal coordinates, is a given plasma parameter at the magnetic axis,\n and is the plasma radius as measured from the magnetic\n axis to the last closed flux surface. Notice that the larger is, the more uniform the radial profiles are. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PROFILES), intent(out) :: P An instance of KORC's derived type PROFILES containing all \n the information about the plasma profiles used in the\n simulation. See korc_types and korc_profiles . type(FIELDS), intent(in) :: F String containing the type of electron density profile \n to be used in the simulation. String containing the type of electron temperature profile \n to be used in the simulation. String containing the type of profile to be used\n in the simulation. Full path to the HDF5 file containing the pre-computed\n plasma profiles. Plasma radius as measured from the magnetic axis. Electron density at the magnetic axis . Electron temperature at the magnetic axis . at the magnetic axis . Exponent used in of the electron\n density profile. Exponent used in of the electron\n temperature profile. Exponent used in of the profile. Coefficients of the polynomial electron density profile. \n See detailed description above,\n a_ne=( , , , ). Coefficients of the polynomial electron temperature profile. \n See detailed description above,\n a_Te=( , , , ). Coefficients of the profile. See detailed\n description above, a_Zeff=( , , , ). Flag to indicate if the plasma profiles are axisymmetric. Contents Source Code initialize_profiles Source Code subroutine initialize_profiles ( params , P , F ) !! @note Subroutine that initializes the parameters of analytical !! or pre-computed plasma profiles for being used in the !! simulation. @endnote !! KORC can run using either analytical and pre-computed plasma !! profiles. Pre-computed plasma profiles, as in the case of !! pre-computed electric or magnetic fields, are interpolated to !! electrons' position in [[korc_profiles]]. !! !! There are two types of analytical plasma profiles that can be !! used in KORC: 3rd degree polynomial radial plasma profiles, !! !! f(r) = a_3r&#94;3 + a_2r&#94;2 +a_1r + a_0, !! !! and radial plasma profiles with a \\tanh(r) dependency: !! !! f(r) = f_0\\left[1 - \\tanh&#94;n\\left(\\frac{2r}{a}\\right)\\right], !! !! where r is the radial coordinate in toroidal coordinates, !! f_0 is a given plasma parameter at the magnetic axis, !! and a is the plasma radius as measured from the magnetic !! axis to the last closed flux surface. Notice that the larger !! n is, the more uniform the radial profiles are. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( OUT ) :: P !! An instance of KORC's derived type PROFILES containing all !! the information about the plasma profiles used in the !! simulation. See [[korc_types]] and [[korc_profiles]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !CHARACTER(MAX_STRING_LENGTH)    :: ne_profile !! String containing the type of electron density profile !! to be used in the simulation. !CHARACTER(MAX_STRING_LENGTH)    :: Te_profile !! String containing the type of electron temperature profile !! to be used in the simulation. !CHARACTER(MAX_STRING_LENGTH)    :: Zeff_profile !! String containing the type of Z_{eff} profile to be used !! in the simulation. !CHARACTER(MAX_STRING_LENGTH)    :: filename !! Full path to the HDF5 file containing the pre-computed !! plasma profiles. !REAL(rp)                        :: radius_profile !! Plasma radius a as measured from the magnetic axis. !REAL(rp)                        :: neo !! Electron density at the magnetic axis f_0 = n_{e,0}. !REAL(rp)                        :: Teo !! Electron temperature at the magnetic axis f_0 = T_{e,0}. !REAL(rp)                        :: Zeffo !! Z_{eff} at the magnetic axis f_0 = Z_{eff,0}. !REAL(rp)                        :: n_ne !! Exponent n used in \\tanh&#94;n(r) of the electron !! density profile. !REAL(rp)                        :: n_Te !! Exponent n used in \\tanh&#94;n(r) of the electron !! temperature profile. !REAL(rp)                        :: n_Zeff !! Exponent n used in \\tanh&#94;n(r) of the Z_{eff} profile. !REAL(rp), DIMENSION(4)          :: a_ne !! Coefficients of the polynomial electron density profile. !! See detailed description above, !! a_ne=(a_{0},a_{2},a_{3},a_{4}). !REAL(rp), DIMENSION(4)          :: a_Te !! Coefficients of the polynomial electron temperature profile. !! See detailed description above, !! a_Te=(a_{0},a_{2},a_{3},a_{4}). !REAL(rp), DIMENSION(4)          :: a_Zeff !! Coefficients of the Z_{eff} profile. See detailed !! description above, a_Zeff=(a_{0},a_{2},a_{3},a_{4}). !LOGICAL                         :: axisymmetric !! Flag to indicate if the plasma profiles are axisymmetric. INTEGER :: ii , kk !REAL(rp)  ::  n_REr0 !REAL(rp)  ::  n_tauion !REAL(rp)  ::  n_lamfront !REAL(rp)  ::  n_lamback,n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf REAL ( rp ) :: rm , r_a !,psiN_0 !NAMELIST /plasmaProfiles/ radius_profile,ne_profile,neo,n_ne,a_ne, & !     Te_profile,Teo,n_Te,a_Te,n_REr0,n_tauion,n_lamfront,n_lamback, & !     Zeff_profile,Zeffo,n_Zeff,a_Zeff,filename,axisymmetric, & !     n_lamshelf,n_shelfdelay,n_tauin,n_tauout,n_shelf,psiN_0 if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * INITIALIZING PROFILES * * * * * * * *\")' ) end if SELECT CASE ( TRIM ( params % profile_model )) CASE ( 'ANALYTICAL' ) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasmaProfiles) !close(default_unit_open) P % a = radius_profile P % R0 = F % Ro P % Z0 = F % Zo P % ne_profile = TRIM ( ne_profile ) P % neo = neo P % n_ne = n_ne P % a_ne = a_ne P % n_REr0 = n_REr0 P % n_tauion = n_tauion P % n_tauin = n_tauin P % n_tauout = n_tauout P % n_shelfdelay = n_shelfdelay P % n_lamfront = n_lamfront P % n_lamback = n_lamback P % n_lamshelf = n_lamshelf P % n_shelf = n_shelf P % psiN_0 = psiN_0 P % Te_profile = TRIM ( Te_profile ) P % Teo = Teo * C_E ! Converted to Joules P % n_Te = n_Te P % a_Te = a_Te P % Zeff_profile = TRIM ( Zeff_profile ) P % Zeffo = Zeffo P % n_Zeff = n_Zeff P % a_Zeff = a_Zeff if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"ANALYTICAL\")' ) write ( output_unit_write , '(\"ne profile: \",A20)' ) P % ne_profile write ( output_unit_write , '(\"Te profile: \",A20)' ) P % Te_profile write ( output_unit_write , '(\"Zeff profile: \",A20)' ) P % Zeff_profile end if if ( params % field_eval . eq . 'interp' ) then P % axisymmetric = axisymmetric P % dims ( 1 ) = F % dims ( 1 ) P % dims ( 3 ) = F % dims ( 3 ) call ALLOCATE_2D_PROFILES_ARRAYS ( P ) P % X % R = F % X % R P % X % Z = F % X % Z do ii = 1_idef , P % dims ( 1 ) do kk = 1_idef , P % dims ( 3 ) rm = sqrt (( P % X % R ( ii ) - P % R0 ) ** 2 + ( P % X % Z ( kk ) - P % Z0 ) ** 2 ) r_a = rm / P % a SELECT CASE ( TRIM ( P % ne_profile )) CASE ( 'FLAT' ) P % ne_2D ( ii , kk ) = P % neo CASE ( 'SPONG' ) P % ne_2D ( ii , kk ) = P % neo * ( 1._rp - 0.2 * r_a ** 8 ) + P % n_ne CASE ( 'RE-EVO' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO1' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO-PSI' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO-PSIN-SG' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE ( 'RE-EVO-PSIP-G' ) !flat profile placeholder, updates every timestep P % ne_2D ( ii , kk ) = P % neo CASE DEFAULT P % ne_2D ( ii , kk ) = P % neo END SELECT SELECT CASE ( TRIM ( P % Te_profile )) CASE ( 'FLAT' ) P % Te_2D ( ii , kk ) = P % Teo CASE ( 'SPONG' ) P % Te_2D ( ii , kk ) = ( P % Teo - P % n_Te ) * ( 1._rp - 0.6 * r_a ** 2 ) ** 2 + P % n_Te CASE DEFAULT P % Te_2D ( ii , kk ) = P % Teo END SELECT SELECT CASE ( TRIM ( P % Zeff_profile )) CASE ( 'FLAT' ) P % Zeff_2D ( ii , kk ) = P % Zeffo CASE ( 'SPONG' ) P % Zeff_2D ( ii , kk ) = P % Zeffo CASE DEFAULT P % Zeff_2D ( ii , kk ) = P % Zeffo END SELECT end do end do end if CASE ( 'EXTERNAL' ) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasmaProfiles) !close(default_unit_open) P % a = radius_profile P % R0 = F % Ro P % Z0 = F % Zo P % ne_profile = TRIM ( ne_profile ) P % neo = neo P % Te_profile = TRIM ( Te_profile ) P % Teo = Teo * C_E ! Converted to Joules P % Zeff_profile = TRIM ( Zeff_profile ) P % Zeffo = Zeffo if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"EXTERNAL\")' ) write ( output_unit_write , '(\"ne profile:\",A20)' ) P % ne_profile write ( output_unit_write , '(\"Te profile: \",A20)' ) P % Te_profile write ( output_unit_write , '(\"Zeff profile: \",A20)' ) P % Zeff_profile end if P % filename = TRIM ( filename ) P % axisymmetric = axisymmetric call load_profiles_data_from_hdf5 ( params , P ) CASE ( 'UNIFORM' ) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasmaProfiles) !close(default_unit_open) P % a = radius_profile P % R0 = F % Ro P % Z0 = F % Zo P % ne_profile = TRIM ( ne_profile ) P % neo = neo P % n_ne = 0.0_rp P % a_ne = ( / 0.0_rp , 0.0_rp , 0.0_rp , 0.0_rp / ) P % Te_profile = TRIM ( Te_profile ) P % Teo = Teo * C_E ! Converted to Joules P % n_Te = 0.0_rp P % a_Te = ( / 0.0_rp , 0.0_rp , 0.0_rp , 0.0_rp / ) P % Zeff_profile = TRIM ( Zeff_profile ) P % Zeffo = Zeffo P % n_Zeff = 0.0_rp P % a_Zeff = ( / 0.0_rp , 0.0_rp , 0.0_rp , 0.0_rp / ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"UNIFORM\")' ) write ( output_unit_write , '(\"ne profile: \",A20)' ) P % ne_profile write ( output_unit_write , '(\"Te profile: \",A20)' ) P % Te_profile write ( output_unit_write , '(\"Zeff profile: \",A20)' ) P % Zeff_profile end if CASE DEFAULT END SELECT if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * * *\")' ) end if end subroutine initialize_profiles","tags":"","loc":"proc/initialize_profiles.html"},{"title":"uniform_profiles – KORC-Full Orbit","text":"private subroutine uniform_profiles(vars, P) Note Subroutine that returns the value of uniform plasma p\n arameters. This subroutie is used only when the simulation is ran for a 'UNIFORM'\n plasma. As a convention, in a uniform plasma we set , , and . Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars An instance of PARTICLES containing the variables of a given species. type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the information\n about the plasma profiles used in the simulation. See korc_types and korc_profiles . Contents Source Code uniform_profiles Source Code subroutine uniform_profiles ( vars , P ) !! @note Subroutine that returns the value of uniform plasma p !! arameters. @endnote !! This subroutie is used only when the simulation is ran for a 'UNIFORM' !! plasma. As a convention, in a uniform plasma we set !! n_e = n_{e,0}, T_e = T_{e,0}, and Z_{eff} = Z_{eff,0}. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the information !! about the plasma profiles used in the simulation. See [[korc_types]] !! and [[korc_profiles]]. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of PARTICLES containing the variables of a given species. vars % ne = P % neo vars % Te = P % Teo vars % Zeff = P % Zeffo end subroutine uniform_profiles","tags":"","loc":"proc/uniform_profiles.html"},{"title":"analytical_profiles_p – KORC-Full Orbit","text":"public subroutine analytical_profiles_p(time, params, Y_R, Y_Z, P, F, ne, Te, Zeff, PSIp) Note Subroutine that calculates the analytical plasma profiles at\n the particles' position. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: time type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . type(FIELDS), intent(in) :: F real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne Background electron density seen by simulated particles. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: Te Backgroun temperature density seen by simulated particles. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: Zeff Effective atomic charge seen by simulated particles. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code analytical_profiles_p Source Code subroutine analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) !! @note Subroutine that calculates the analytical plasma profiles at !! the particles' position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_Z , PSIp REAL ( rp ), INTENT ( IN ) :: time TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne !! Background electron density seen by simulated particles. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: Te !! Backgroun temperature density seen by simulated particles. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: Zeff !! Effective atomic charge seen by simulated particles. INTEGER ( ip ) :: cc , pchunk !! Particle iterator. REAL ( rp ) :: R0 , Z0 , a , ne0 , n_ne , Te0 , n_Te , Zeff0 REAL ( rp ) :: R0_RE , Z0_RE , sigmaR_RE , sigmaZ_RE , psimax_RE REAL ( rp ) :: n_REr0 , n_tauion , n_lamfront , n_lamback , n_lamshelf REAL ( rp ) :: n_psifront , n_psiback , n_psishelf REAL ( rp ) :: n_tauin , n_tauout , n_shelfdelay , n_shelf REAL ( rp ) :: n0t , n_taut REAL ( rp ) :: PSIp0 , PSIp_lim , psiN_0 REAL ( rp ), DIMENSION ( params % pchunk ) :: r_a , rm , rm_RE , PSIpN , PSIp_temp pchunk = params % pchunk R0 = P % R0 Z0 = P % Z0 a = P % a ne0 = P % neo n_ne = P % n_ne Te0 = P % Teo n_Te = P % n_Te Zeff0 = P % Zeffo R0_RE = P % R0_RE Z0_RE = P % Z0_RE n_REr0 = P % n_REr0 n_tauion = P % n_tauion n_tauin = P % n_tauin n_tauout = P % n_tauout n_shelfdelay = P % n_shelfdelay n_lamfront = P % n_lamfront n_lamback = P % n_lamback n_lamshelf = P % n_lamshelf n_psifront = P % n_lamfront * params % cpp % length n_psiback = P % n_lamback * params % cpp % length n_psishelf = P % n_lamshelf * params % cpp % length n_shelf = P % n_shelf PSIp_lim = F % PSIp_lim PSIp0 = F % PSIP_min psiN_0 = P % psiN_0 !    write(output_unit_write,*) 'PSIp',PSIp(1)*(params%cpp%Bo*params%cpp%length**2) !    write(output_unit_write,*) 'PSIp_lim',PSIp_lim*(params%cpp%Bo*params%cpp%length**2) !    write(output_unit_write,*) 'PSIp0',PSIp0*(params%cpp%Bo*params%cpp%length**2) !    write(output_unit_write,'(\"R0_RE: \"E17.10)') R0_RE !    write(output_unit_write,'(\"Z0_RE: \"E17.10)') Z0_RE !    write(output_unit_write,'(\"n_REr0: \"E17.10)') n_REr0 SELECT CASE ( TRIM ( P % ne_profile )) CASE ( 'FLAT' ) !$OMP SIMD do cc = 1_idef , pchunk ne ( cc ) = ne0 end do !$OMP END SIMD CASE ( 'SPONG' ) !$OMP SIMD do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) ** 2 + ( Y_Z ( cc ) - Z0 ) ** 2 ) r_a ( cc ) = rm ( cc ) / a ne ( cc ) = ne0 * ( 1._rp - 0.2 * r_a ( cc ) ** 8 ) + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO' ) !$OMP SIMD do cc = 1_idef , pchunk rm_RE ( cc ) = sqrt (( Y_R ( cc ) - R0_RE ) ** 2 + ( Y_Z ( cc ) - Z0_RE ) ** 2 ) ne ( cc ) = ( ne0 - n_ne ) / 4._rp * ( 1 + tanh (( rm_RE ( cc ) + & n_REr0 * ( time / n_tauion - 1 )) / n_lamfront )) * & ( 1 + tanh ( - ( rm_RE ( cc ) - n_REr0 ) / n_lamback )) + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO1' ) !$OMP SIMD do cc = 1_idef , pchunk rm_RE ( cc ) = sqrt (( Y_R ( cc ) - R0_RE ) ** 2 + ( Y_Z ( cc ) - Z0_RE ) ** 2 ) ne ( cc ) = ( ne0 - n_ne ) / 8._rp * ( 1 + tanh (( rm_RE ( cc ) + & n_REr0 * ( time / n_tauion - 1 )) / n_lamfront )) * & ( 1 + tanh ( - ( rm_RE ( cc ) - n_REr0 ) / n_lamback )) * & ( 2 * ( n_shelf - n_ne ) / ( ne0 - n_ne ) + ( ne0 - n_shelf ) / ( ne0 - n_ne ) * & ( 1 - tanh (( rm_RE ( cc ) + n_REr0 * (( time - n_shelfdelay ) / n_tauin - 1 )) / & n_lamshelf ))) + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO-PSI' ) !$OMP SIMD do cc = 1_idef , pchunk PSIpN ( cc ) = ( PSIp ( cc ) - PSIp0 ) / ( PSIp_lim - PSIp0 ) ne ( cc ) = ( ne0 - n_ne ) / 8._rp * ( 1 + tanh (( sqrt ( abs ( PSIpN ( cc ))) + & sqrt ( abs ( psiN_0 )) * ( time / n_tauion - 1 )) / n_psifront )) * & ( 1 + tanh ( - ( sqrt ( abs ( PSIpN ( cc ))) - sqrt ( abs ( psiN_0 ))) / n_psiback )) * & ( 2 * ( n_shelf - n_ne ) / ( ne0 - n_ne ) + ( ne0 - n_shelf ) / ( ne0 - n_ne ) * & ( 1 - tanh (( sqrt ( abs ( PSIpN ( cc ))) + sqrt ( abs ( psiN_0 )) * & (( time - n_shelfdelay ) / n_tauin - 1 )) / n_psishelf ))) + n_ne end do !$OMP END SIMD !       write(output_unit_write,*) 'at time ',time*params%cpp%time, & !' ne: ',ne(1)/params%cpp%length**3 !       !$OMP SIMD !       do cc=1_idef,8 !          if(isnan(ne(cc))) then !             write(output_unit_write,*) 'PSIp: ',PSIp(cc) !             write(output_unit_write,*) 'PSIp0: ',PSIp0 !             write(output_unit_write,*) 'PSIp_lim: ',PSIp_lim !             write(output_unit_write,*) 'PSIpN: ',PSIpN(cc) !             stop 'ne_eval is a NaN' !          end if !       end do !       !$OMP END SIMD CASE ( 'RE-EVO-PSIN-SG' ) n0t = ( ne0 - n_ne ) / 2._rp * ( tanh ( time / n_tauin ) - & tanh (( time - n_shelfdelay ) / n_tauin )) n_taut = n_psishelf * erf (( time + params % dt / 10 0._rp ) / n_tauion ) !$OMP SIMD do cc = 1_idef , pchunk PSIpN ( cc ) = ( PSIp ( cc ) - PSIp0 ) / ( PSIp_lim - PSIp0 ) ne ( cc ) = n0t * exp ( - ( sqrt ( abs ( PSIpN ( cc ))) - sqrt ( abs ( psiN_0 ))) ** 2._rp / & ( 2._rp * n_taut ** 2._rp )) * ( 1._rp + erf ( - 1 0._rp * & ( sqrt ( abs ( PSIpN ( cc ))) - sqrt ( abs ( psiN_0 ))) / & ( sqrt ( 2._rp ) * n_taut ))) / 2._rp + n_ne end do !$OMP END SIMD CASE ( 'RE-EVO-PSIP-G' ) !       write(output_unit_write,*) 'time: ',time*params%cpp%time n0t = ( ne0 - n_ne ) / 2._rp * ( tanh (( time - n_tauin ) / n_tauin ) - & tanh (( time - n_shelfdelay ) / n_tauout )) n_taut = n_psishelf * erf (( time + params % dt / 10 0._rp ) / n_tauion ) !$OMP SIMD do cc = 1_idef , pchunk PSIp_temp ( cc ) = PSIp ( cc ) * ( params % cpp % Bo * params % cpp % length ** 2 ) ne ( cc ) = n0t * exp ( - ( sqrt ( abs ( PSIp_temp ( cc ))) - sqrt ( abs ( psiN_0 ))) ** 2._rp / & ( 2._rp * n_taut ** 2._rp )) + n_ne end do !$OMP END SIMD CASE DEFAULT !$OMP SIMD do cc = 1_idef , pchunk ne ( cc ) = ne0 end do !$OMP END SIMD END SELECT SELECT CASE ( TRIM ( P % Te_profile )) CASE ( 'FLAT' ) !$OMP SIMD do cc = 1_idef , pchunk Te ( cc ) = Te0 end do !$OMP END SIMD CASE ( 'SPONG' ) !$OMP SIMD do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) ** 2 + ( Y_Z ( cc ) - Z0 ) ** 2 ) r_a ( cc ) = rm ( cc ) / a Te ( cc ) = Te0 * ( 1._rp - 0.6 * r_a ( cc ) ** 2 ) ** 2 + Te0 * n_Te end do !$OMP END SIMD CASE DEFAULT !$OMP SIMD do cc = 1_idef , pchunk Te ( cc ) = P % Teo end do !$OMP END SIMD END SELECT SELECT CASE ( TRIM ( P % Zeff_profile )) CASE ( 'FLAT' ) !$OMP SIMD do cc = 1_idef , pchunk Zeff ( cc ) = P % Zeffo end do !$OMP END SIMD CASE ( 'SPONG' ) !$OMP SIMD do cc = 1_idef , pchunk Zeff ( cc ) = P % Zeffo end do !$OMP END SIMD CASE DEFAULT !$OMP SIMD do cc = 1_idef , pchunk Zeff ( cc ) = P % Zeffo end do !$OMP END SIMD END SELECT !    write(output_unit_write,*) PSIpN(1) !    write(output_unit_write,'(\"ne: \"E17.10)') ne(1)/params%cpp%length**3 !    write(output_unit_write,'(\"rm_RE: \"E17.10)') rm_RE(1) end subroutine analytical_profiles_p","tags":"","loc":"proc/analytical_profiles_p.html"},{"title":"get_analytical_profiles – KORC-Full Orbit","text":"private subroutine get_analytical_profiles(P, Y, ne, Te, Zeff, flag) Note Subroutine that calculates the analytical plasma profiles at\n the particles' position. Arguments Type Intent Optional Attributes Name type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in toroidal coordinates; Y(1,:) = , Y(2,:)\n = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: ne Background electron density seen by simulated particles. real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Te Backgroun temperature density seen by simulated particles. real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Zeff Effective atomic charge seen by simulated particles. integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed\n (flag=T) or not (flag=F). Contents Source Code get_analytical_profiles Source Code subroutine get_analytical_profiles ( P , Y , ne , Te , Zeff , flag ) !! @note Subroutine that calculates the analytical plasma profiles at !! the particles' position. @endnote TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in toroidal coordinates; Y(1,:) = r, Y(2,:) !! = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: ne !! Background electron density seen by simulated particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Te !! Backgroun temperature density seen by simulated particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Zeff !! Effective atomic charge seen by simulated particles. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed !! (flag=T) or not (flag=F). REAL ( rp ) :: r_a !! Normalized toroidal radial position of simulated particles !! r/a, where a is the plasma radius. REAL ( rp ) :: fr !! Calculated radial profile. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,fr,r_a) & !$OMP& SHARED(P,Y,ne,Te,Zeff,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then r_a = Y ( pp , 1 ) / P % a !          write(output_unit_write,'(\"r: \",E17.10)') r_a SELECT CASE ( TRIM ( P % ne_profile )) CASE ( 'TANH' ) fr = 1_ip - TANH ( 2.0_rp * r_a ) ** P % n_ne ne ( pp ) = P % neo * fr CASE ( 'FLAT' ) ne ( pp ) = P % neo CASE ( 'POLYNOMIAL' ) fr = P % a_ne ( 1 ) + P % a_ne ( 2 ) * r_a + P % a_ne ( 3 ) * r_a ** 2 + & P % a_ne ( 4 ) * r_a ** 3 ne ( pp ) = P % neo * fr CASE ( 'SPONG' ) fr = P % neo * ( 1._rp - 0.2 * r_a ** 8 ) + P % neo * P % n_ne ne ( pp ) = P % neo * fr CASE DEFAULT ne ( pp ) = P % neo END SELECT SELECT CASE ( TRIM ( P % Te_profile )) CASE ( 'TANH' ) fr = 1_ip - TANH ( 2.0_rp * r_a ) ** P % n_Te Te ( pp ) = P % Teo * fr CASE ( 'FLAT' ) Te ( pp ) = P % Teo CASE ( 'POLYNOMIAL' ) fr = P % a_Te ( 1 ) + P % a_Te ( 2 ) * r_a + P % a_Te ( 3 ) * r_a ** 2 + & P % a_Te ( 4 ) * r_a ** 3 Te ( pp ) = P % Teo * fr CASE ( 'SPONG' ) fr = P % Teo * ( 1._rp - 0.6 * r_a ** 2 ) ** 2 + P % Teo * P % n_Te ne ( pp ) = P % neo * fr CASE DEFAULT Te ( pp ) = P % Teo END SELECT SELECT CASE ( TRIM ( P % Zeff_profile )) CASE ( 'TANH' ) fr = 1_ip - TANH ( 2.0_rp * r_a ) ** P % n_Zeff Zeff ( pp ) = P % Zeffo * fr CASE ( 'FLAT' ) Zeff ( pp ) = P % Zeffo CASE ( 'POLYNOMIAL' ) fr = P % a_Zeff ( 1 ) + P % a_Zeff ( 2 ) * r_a + P % a_Zeff ( 3 ) * r_a ** 2 + & P % a_Zeff ( 4 ) * r_a ** 3 Zeff ( pp ) = P % Zeffo * fr CASE ( 'SPONG' ) Zeff ( pp ) = P % Zeffo CASE DEFAULT Zeff ( pp ) = P % Zeffo END SELECT end if end do !$OMP END PARALLEL DO end subroutine get_analytical_profiles","tags":"","loc":"proc/get_analytical_profiles.html"},{"title":"get_profiles – KORC-Full Orbit","text":"public subroutine get_profiles(params, vars, P, F) Note Subrotuine that calls the appropriate subroutine for calculating\n or interpolating the plasma profiles at the particles' position. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: vars An instance of PARTICLES containing the variables of a given species. type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all\n the information about the plasma profiles used in the\n simulation. See [[korc_types] and korc_profiles . type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code get_profiles Source Code subroutine get_profiles ( params , vars , P , F ) !! @note Subrotuine that calls the appropriate subroutine for calculating !! or interpolating the plasma profiles at the particles' position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of PARTICLES containing the variables of a given species. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all !! the information about the plasma profiles used in the !! simulation. See [[korc_types] and [[korc_profiles]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. SELECT CASE ( TRIM ( params % profile_model )) CASE ( 'ANALYTICAL' ) !       write(output_unit_write,'(\"Y in: \",E17.10)') vars%Y(1,:) call cyl_to_cart ( vars % Y , vars % X ) !       write(output_unit_write,'(\"X getprof: \",E17.10)') vars%X(1,:) call cart_to_tor_check_if_confined ( vars % X , F , vars % Y , vars % flagCon ) !       write(output_unit_write,'(\"flag: \",I15)') vars%flagCon(1) call get_analytical_profiles ( P , vars % Y , vars % ne , vars % Te , & vars % Zeff , vars % flagCon ) call cart_to_cyl ( vars % X , vars % Y ) !       write(output_unit_write,'(\"Y out: \",E17.10)') vars%Y(1,:) CASE ( 'EXTERNAL' ) call interp_profiles ( params , vars , P ) CASE ( 'UNIFORM' ) call uniform_profiles ( vars , P ) CASE DEFAULT END SELECT end subroutine get_profiles","tags":"","loc":"proc/get_profiles.html"},{"title":"load_profiles_data_from_hdf5 – KORC-Full Orbit","text":"private subroutine load_profiles_data_from_hdf5(params, P) Note Subroutine that loads pre-computed plasma profiles' data\n from an input HDF5 file. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PROFILES), intent(inout) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the\n simulation. See korc_types and korc_profiles . Contents Source Code load_profiles_data_from_hdf5 Source Code subroutine load_profiles_data_from_hdf5 ( params , P ) !! @note Subroutine that loads pre-computed plasma profiles' data !! from an input HDF5 file. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the !! simulation. See [[korc_types]] and [[korc_profiles]]. CHARACTER ( MAX_STRING_LENGTH ) :: filename !!String containing the name of the input HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: gname !! String containing the group name of a parameter in the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: subgname !! String containing the subgroup name of a parameter in the HDF5 file. CHARACTER ( MAX_STRING_LENGTH ) :: dset !!Name of data set to read from file. INTEGER ( HID_T ) :: h5file_id !! HDF5 file identifier. INTEGER ( HID_T ) :: group_id !! HDF5 group identifier. INTEGER ( HID_T ) :: subgroup_id !!HDF5 subgroup identifier. REAL ( rp ) :: rdatum !! INTEGER :: h5error !! HDF5 error status. filename = TRIM ( P % filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_profiles_data_from_hdf5 --> h5fopen_f\")' ) end if dset = \"/NR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) P % dims ( 1 ) = INT ( rdatum ) if ( P % axisymmetric ) then P % dims ( 2 ) = 0 else dset = \"/NPHI\" call load_from_hdf5 ( h5file_id , dset , rdatum ) P % dims ( 2 ) = INT ( rdatum ) end if dset = \"/NZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) P % dims ( 3 ) = INT ( rdatum ) if ( P % axisymmetric ) then call ALLOCATE_2D_PROFILES_ARRAYS ( P ) else call ALLOCATE_3D_PROFILES_ARRAYS ( P ) end if dset = \"/R\" call load_array_from_hdf5 ( h5file_id , dset , P % X % R ) if (. NOT . P % axisymmetric ) then dset = \"/PHI\" call load_array_from_hdf5 ( h5file_id , dset , P % X % PHI ) end if dset = \"/Z\" call load_array_from_hdf5 ( h5file_id , dset , P % X % Z ) dset = \"/FLAG\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % FLAG2D ) else call load_array_from_hdf5 ( h5file_id , dset , P % FLAG3D ) end if dset = \"/ne\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % ne_2D ) else call load_array_from_hdf5 ( h5file_id , dset , P % ne_3D ) end if dset = \"/Te\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % Te_2D ) P % Te_2D = P % Te_2D * C_E else call load_array_from_hdf5 ( h5file_id , dset , P % Te_3D ) P % Te_3D = P % Te_3D * C_E end if !write(output_unit_write,'(\"Te: \",E17.10)') P%Te_2D(1,1) dset = \"/Zeff\" if ( P % axisymmetric ) then call load_array_from_hdf5 ( h5file_id , dset , P % Zeff_2D ) else call load_array_from_hdf5 ( h5file_id , dset , P % Zeff_3D ) end if call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_profiles_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_profiles_data_from_hdf5","tags":"","loc":"proc/load_profiles_data_from_hdf5.html"},{"title":"ALLOCATE_2D_PROFILES_ARRAYS – KORC-Full Orbit","text":"private subroutine ALLOCATE_2D_PROFILES_ARRAYS(P) @brief Subroutine that allocates the mesh information and 2-D arrays for keeping the data of pre-computed plasma profiles. @param[out] P An instance of KORC's derived type PROFILES containing all the information about the plasma profiles used in the\n simulation. See korc_types.f90 and korc_profiles.f90. Arguments Type Intent Optional Attributes Name type(PROFILES), intent(inout) :: P Contents Source Code ALLOCATE_2D_PROFILES_ARRAYS Source Code subroutine ALLOCATE_2D_PROFILES_ARRAYS ( P ) TYPE ( PROFILES ), INTENT ( INOUT ) :: P ALLOCATE ( P % X % R ( P % dims ( 1 ))) ALLOCATE ( P % X % Z ( P % dims ( 3 ))) ALLOCATE ( P % FLAG2D ( P % dims ( 1 ), P % dims ( 3 ))) ALLOCATE ( P % ne_2D ( P % dims ( 1 ), P % dims ( 3 ))) ALLOCATE ( P % Te_2D ( P % dims ( 1 ), P % dims ( 3 ))) ALLOCATE ( P % Zeff_2D ( P % dims ( 1 ), P % dims ( 3 ))) end subroutine ALLOCATE_2D_PROFILES_ARRAYS","tags":"","loc":"proc/allocate_2d_profiles_arrays.html"},{"title":"ALLOCATE_3D_PROFILES_ARRAYS – KORC-Full Orbit","text":"private subroutine ALLOCATE_3D_PROFILES_ARRAYS(P) Note Subroutine that allocates the mesh information and 3-D arrays\n for keeping the data of pre-computed plasma profiles. Arguments Type Intent Optional Attributes Name type(PROFILES), intent(inout) :: P @param[out] P An instance of KORC's derived type PROFILES containing\n all the information about the plasma profiles used in the\n simulation. See korc_types and korc_profiles . Contents Source Code ALLOCATE_3D_PROFILES_ARRAYS Source Code subroutine ALLOCATE_3D_PROFILES_ARRAYS ( P ) !! @note Subroutine that allocates the mesh information and 3-D arrays !! for keeping the data of pre-computed plasma profiles. @endnote TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! @param[out] P An instance of KORC's derived type PROFILES containing !! all the information about the plasma profiles used in the !! simulation. See [[korc_types]] and [[korc_profiles]]. ALLOCATE ( P % X % R ( P % dims ( 1 ))) ALLOCATE ( P % X % PHI ( P % dims ( 2 ))) ALLOCATE ( P % X % Z ( P % dims ( 3 ))) ALLOCATE ( P % FLAG3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) ALLOCATE ( P % ne_3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) ALLOCATE ( P % Te_3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) ALLOCATE ( P % Zeff_3D ( P % dims ( 1 ), P % dims ( 2 ), P % dims ( 3 ))) end subroutine ALLOCATE_3D_PROFILES_ARRAYS","tags":"","loc":"proc/allocate_3d_profiles_arrays.html"},{"title":"fzero – KORC-Full Orbit","text":"private function fzero(r, a, ko, P) result(f) Note Function used to find the zeros of of \\ref\n korc_spatial_distribution.exponential_torus. @param f Value of function.\n @param r Guess value of radial position of the particles.\n @param a Minor radius of the toroidal distribution @param ko Decay rate of radial distribution, see of \\ref korc_spatial_distribution.exponential_torus.\n @param P Deviate of a random uniform distribution in the interval . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: ko real(kind=rp), intent(in) :: P Return Value real(kind=rp) Contents Source Code fzero Source Code FUNCTION fzero ( r , a , ko , P ) RESULT ( f ) REAL ( rp ) :: f REAL ( rp ), INTENT ( IN ) :: r REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: ko REAL ( rp ), INTENT ( IN ) :: P f = EXP ( - ko * r ) * ( 1.0_rp + r * ko ) + ( 1.0_rp - EXP ( - ko * a ) * ( 1.0_rp + a * ko ) ) * P - 1.0_rp END FUNCTION fzero","tags":"","loc":"proc/fzero.html"},{"title":"PSI_ROT – KORC-Full Orbit","text":"private function PSI_ROT(R, R0, sigR, Z, Z0, sigZ, theta) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R R-coordinate of MH sampled location real(kind=rp), intent(in) :: R0 R-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigR Variance of first dimension of 2D Gaussian real(kind=rp), intent(in) :: Z Z-coordinate of MH sampled location real(kind=rp), intent(in) :: Z0 Z-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigZ Variance of second dimension of 2D Gaussian real(kind=rp), intent(in) :: theta Angle of counter-clockwise rotation (in radians), of 2D Gaussian\n distribution relative to R,Z Return Value real(kind=rp) Argument of exponential comprising 2D Gaussian distribution Contents Source Code PSI_ROT Source Code FUNCTION PSI_ROT ( R , R0 , sigR , Z , Z0 , sigZ , theta ) REAL ( rp ), INTENT ( IN ) :: R !! R-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: R0 !! R-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigR !! Variance of first dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: Z !! Z-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: Z0 !! Z-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigZ !! Variance of second dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: theta !! Angle of counter-clockwise rotation (in radians), of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: PSI_ROT !! Argument of exponential comprising 2D Gaussian distribution PSI_ROT = ( R - R0 ) ** 2 * (( cos ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( sin ( theta )) ** 2 / ( 2 * sigZ ** 2 )) + & 2 * ( R - R0 ) * ( Z - Z0 ) * cos ( theta ) * sin ( theta ) * ( 1 / ( 2 * sigR ** 2 ) - 1 / ( 2 * sigZ ** 2 )) + & ( Z - Z0 ) ** 2 * (( sin ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( cos ( theta )) ** 2 / ( 2 * sigZ ** 2 )) END FUNCTION PSI_ROT","tags":"","loc":"proc/psi_rot.html"},{"title":"indicator – KORC-Full Orbit","text":"private function indicator(psi, psi_max) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: psi real(kind=rp), intent(in) :: psi_max Return Value real(kind=rp) Contents Source Code indicator Source Code FUNCTION indicator ( psi , psi_max ) REAL ( rp ), INTENT ( IN ) :: psi REAL ( rp ), INTENT ( IN ) :: psi_max REAL ( rp ) :: indicator IF ( psi . LT . psi_max ) THEN indicator = 1 ELSE indicator = 0 END IF END FUNCTION indicator","tags":"","loc":"proc/indicator.html"},{"title":"random_norm – KORC-Full Orbit","text":"public function random_norm(mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Contents Source Code random_norm Source Code FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = mean + sigma * SQRT ( - 2.0_rp * LOG ( rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm","tags":"","loc":"proc/random_norm~4.html"},{"title":"Spong_2D – KORC-Full Orbit","text":"private function Spong_2D(R0, b, w, dlam, R, Z, T) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: b real(kind=rp), intent(in) :: w real(kind=rp), intent(in) :: dlam real(kind=rp), intent(in) :: R real(kind=rp), intent(in) :: Z real(kind=rp), intent(in) :: T Return Value real(kind=rp) Contents Source Code Spong_2D Source Code function Spong_2D ( R0 , b , w , dlam , R , Z , T ) REAL ( rp ), INTENT ( IN ) :: R0 REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ), INTENT ( IN ) :: w REAL ( rp ), INTENT ( IN ) :: dlam REAL ( rp ), INTENT ( IN ) :: R REAL ( rp ), INTENT ( IN ) :: Z REAL ( rp ), INTENT ( IN ) :: T Real ( rp ) :: rm Real ( rp ) :: lam REAL ( rp ) :: Spong_2D rm = sqrt (( R - R0 ) ** 2 + Z ** 2 ) lam = ( sin ( deg2rad ( T ))) ** 2 Spong_2D = ( 1 - tanh (( rm - b ) / w )) / ( 1 - tanh ( - b / w )) * exp ( - ( lam / dlam ) ** 2 ) end function Spong_2D","tags":"","loc":"proc/spong_2d.html"},{"title":"uniform – KORC-Full Orbit","text":"private subroutine uniform(spp) Note Initializing to zero the particles' position when \n simulating a 'UNIFORM' plasma. Even though in a simulation of a uniform plasma the particles' \n position is not advanced, we initialize their position to zero. Todo Modify KORC for not allocating the particles' position \n spp%vars%X and to do not use it along the simulation. Arguments Type Intent Optional Attributes Name type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the \n parameters and simulation variables of the different\nspecies in the simulation. Contents Source Code uniform Source Code subroutine uniform ( spp ) !! @note Initializing to zero the particles' position when !! simulating a 'UNIFORM' plasma. @endnote !! Even though in a simulation of a uniform plasma the particles' !! position is not advanced, we initialize their position to zero. !! @todo Modify KORC for not allocating the particles' position !! spp%vars%X and to do not use it along the simulation. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the !! parameters and simulation variables of the different !!species in the simulation. spp % vars % X = 0.0_rp end subroutine uniform","tags":"","loc":"proc/uniform.html"},{"title":"disk – KORC-Full Orbit","text":"private subroutine disk(params, spp) Note Subrotuine for generating a uniform disk/ring as the \n initial spatial condition of a given species of particles in the simulation. This uniform disk/ring distribution is generated using the \n Inverse Transform Sampling method. In this case, the (toroidal) \n radial distribution function of the particles is: where and are the inner and outer \n radius of the uniform ring distribution, and is the \n cylindrical radial position of the center of the disk/ring distribution.\n This distribution is so that , where is the poloidal angle,\n and is the Jacobian of the \n transformation of Cartesian coordinates to toroidal coordinates.\n Notice that in the case of a disk . As a convention, \n this spatial distribution will be generated on the -plane.\n Using the Inverse Transform Sampling method we sample , \n and obtain the radial position of the particles as , where is a uniform deviate in . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all \n the parameters and simulation variables of the different \n species in the simulation. Contents Source Code disk Source Code subroutine disk ( params , spp ) !! @note Subrotuine for generating a uniform disk/ring as the !! initial spatial condition of a given species of particles !! in the simulation. @endnote !! This uniform disk/ring distribution is generated using the !! Inverse Transform Sampling method. In this case, the (toroidal) !! radial distribution function of the particles is: !! !! f(r) = \\left\\{ \\begin{array}{ll} 0 & r<r_{min} \\\\ !! \\frac{1}{2\\pi&#94;2(r_{max}&#94;2-r_{min}&#94;2)R_0} !! & r_{min}<r<r_{max} \\\\ 0 & r>r_{max} \\end{array} \\right., !! !! where r_{min} and r_{max} are the inner and outer !! radius of the uniform ring distribution, and R_0 is the !! cylindrical radial position of the center of the disk/ring distribution. !! This distribution is so that \\int_0&#94;{2\\pi}\\int_{r_{min}}&#94;{r_{max}} f(r) !! J(r,\\theta) drd\\theta = 1 , where \\theta is the poloidal angle, !! and J(r,\\theta)=r(R_0 + r\\cos\\theta) is the Jacobian of the !! transformation of Cartesian coordinates to toroidal coordinates. !! Notice that in the case of a disk r_{min}=0. As a convention, !! this spatial distribution will be generated on the xz-plane. !! Using the Inverse Transform Sampling method we sample f(r), !! and obtain the radial position of the particles as r = \\sqrt{(r_{max}&#94;2 !! - r_{min}&#94;2)U + r_{min}&#94;2}, where U is a uniform deviate in [0,1]. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all !! the parameters and simulation variables of the different !! species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r !! Radial position of the particles r. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform deviates in the range [0,2\\pi] representing !! the uniform poloidal angle \\theta distribution of the particles. ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) r = SQRT (( spp % r_outter ** 2 - spp % r_inner ** 2 ) * r + spp % r_inner ** 2 ) spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( spp % PHIo ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( spp % PHIo ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( r ) end subroutine disk","tags":"","loc":"proc/disk.html"},{"title":"torus – KORC-Full Orbit","text":"private subroutine torus(params, spp) Note Subrotuine for generating a uniform torus/torus \n shell as the initial spatial condition of a given species \n of particles in the simulation. This distribution is generated using the Inverse Transform \n Sampling method. This distribution follows the same radial \n distribution of a uniform disk/ring distribution, see the \n documentation of the disk subroutine. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES \n containing all the parameters and simulation variables of the \n different species in the simulation. Contents Source Code torus Source Code subroutine torus ( params , spp ) !! @note Subrotuine for generating a uniform torus/torus !! shell as the initial spatial condition of a given species !! of particles in the simulation.@endnote !! This distribution is generated using the Inverse Transform !! Sampling method. This distribution follows the same radial !! distribution of a uniform disk/ring distribution, see the !! documentation of the [[disk]] subroutine. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES !! containing all the parameters and simulation variables of the !! different species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r !! Radial position of the particles r. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform deviates in the range [0,2\\pi] !! representing the uniform poloidal angle \\theta !! distribution of the particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta !! Uniform deviates in the range [0,2\\pi] representing !! the uniform toroidal angle \\zeta distribution of the particles. INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( r ) r = SQRT (( spp % r_outter ** 2 - spp % r_inner ** 2 ) * r + spp % r_inner ** 2 ) spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( zeta ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( zeta ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine torus","tags":"","loc":"proc/torus.html"},{"title":"elliptic_torus – KORC-Full Orbit","text":"private subroutine elliptic_torus(params, spp) Note Subroutine for generating a uniform elliptic torus as the initial \n spatial condition of a given particle species in the simulation. An initial spatial distribution following the uniform distribution of torus is modified through a shear transformation and a rotation to \n generate a uniform spatial distribution on tori with elliptic cross sections. \n First, we obtain the uniform spatial distribution in a torus of minor radius , see torus . Then, we perform a shear transformation that changes \n the cross section of the torus from circular to a tilted ellipse. In \n cylindrical coordinates this shear transformation is given by: where is the shear factor of the transformation. \n Here, and are the radial and vertical position of the particles\n uniformly distributed in a circular torus, and are their\n new positions when following a uniform distribution in a torus with\n elliptic circular cross section. The center of the ellipse is , and , where and is the center of the initial circular torus. The major and minor semi-axes \n of the tilted ellipse cross section is: Finally, we rotate the ellipse cross section anticlockwise along by , so the major semi-axis is\n parallel to the -axis. Todo Modify this approximation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters \n and simulation variables of the different species in the simulation. Contents Source Code elliptic_torus Source Code subroutine elliptic_torus ( params , spp ) !! @note Subroutine for generating a uniform elliptic torus as the initial !! spatial condition of a given particle species in the simulation. @endnote !! An initial spatial distribution following the uniform distribution of !! [[torus]] is modified through a shear transformation and a rotation to !! generate a uniform spatial distribution on tori with elliptic cross sections. !! First, we obtain the uniform spatial distribution in a torus of minor radius !! r_0, see [[torus]]. Then, we perform a shear transformation that changes !! the cross section of the torus from circular to a tilted ellipse. In !! cylindrical coordinates this shear transformation is given by: !! !! R' = R + \\alpha Z, !! Z' = Z, !! !! where \\alpha is the shear factor of the transformation. !! Here, R and Z are the radial and vertical position of the particles !! uniformly distributed in a circular torus, R' and Z' are their !! new positions when following a uniform distribution in a torus with !! elliptic circular cross section. The center of the ellipse is !! R_0' = R_0 + \\alpha Z_0, and Z_0 = Z_0, where R_0 and Z_0 !! is the center of the initial circular torus. The major and minor semi-axes !! of the tilted ellipse cross section is: !! !! a' = \\left[ - \\frac{2r_0&#94;2}{\\alpha \\sqrt{\\alpha&#94;2 + 4} - (2+\\alpha&#94;2)} !!  \\right]&#94;{1/2}, !! b' = \\left[ \\frac{2r_0&#94;2}{\\alpha \\sqrt{\\alpha&#94;2 + 4} + (2+\\alpha&#94;2)} !!  \\right]&#94;{1/2}. !! !! Finally, we rotate the ellipse cross section anticlockwise along !! (R_0',Z_0') by \\Theta = \\cot&#94;{-1}(\\alpha/2)/2, so the major semi-axis is !! parallel to the Z-axis. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rotation_angle !! This is the angle \\Theta in the equations above. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform deviates in the range [0,2\\pi] representing the uniform !! poloidal angle \\theta distribution of the particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r !! Radial position of the particles r. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta !! Uniform deviates in the range [0,2\\pi] representing !! the uniform toroidal angle \\zeta distribution of the particles. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X !! Auxiliary vector used in the coordinate transformations. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y !! Auxiliary vector used in the coordinate transformations. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X1 !! Auxiliary vector used in the coordinate transformations. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y1 !! Auxiliary vector used in the coordinate transformations. ALLOCATE ( X1 ( spp % ppp )) ALLOCATE ( Y1 ( spp % ppp )) ALLOCATE ( X ( spp % ppp )) ALLOCATE ( Y ( spp % ppp )) ALLOCATE ( rotation_angle ( spp % ppp )) ALLOCATE ( theta ( spp % ppp )) ALLOCATE ( zeta ( spp % ppp )) ALLOCATE ( r ( spp % ppp )) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) r = SQRT (( spp % r_outter ** 2 - spp % r_inner ** 2 ) * r + spp % r_inner ** 2 ) Y = r * SIN ( theta ) X = r * COS ( theta ) + spp % shear_factor * Y !> @todo Modify this approximation. rotation_angle = 0.5_rp * C_PI - ATAN ( 1.0_rp , 1.0_rp + spp % shear_factor ); X1 = X * COS ( rotation_angle ) - Y * SIN ( rotation_angle ) + spp % Ro Y1 = X * SIN ( rotation_angle ) + Y * COS ( rotation_angle ) + spp % Zo spp % vars % X (:, 1 ) = X1 * SIN ( zeta ) spp % vars % X (:, 2 ) = X1 * COS ( zeta ) spp % vars % X (:, 3 ) = Y1 DEALLOCATE ( X1 ) DEALLOCATE ( Y1 ) DEALLOCATE ( X ) DEALLOCATE ( Y ) DEALLOCATE ( rotation_angle ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine elliptic_torus","tags":"","loc":"proc/elliptic_torus.html"},{"title":"exponential_torus – KORC-Full Orbit","text":"private subroutine exponential_torus(params, spp) @brief Subroutine that generates a exponentially decaying radial distribution of particles in a circular cross-section torus of\n major and minor radi and , respectively.\n @details We generate this exponentially decaying radial distribution following the same approach as in\n \\ref korc_spatial_distribution.disk, but this time, the radial distribution is given by: The radial position of the particles is obtained using the Inverse Trasnform Sampling method, finding numerically\n through the Newton-Raphson method. First, we calculate the particles' radial distribution in a disk centered at .\n Then, we transfor to a new set of coordinates where the disk is centered at . Finally, we generate the\n toroidal distribution by givin each particle a toroidal angle which follows a uniform distribution in the interval . @param[in] params Core KORC simulation parameters.\n @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different\n species in the simulation.\n @param fl Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param fr Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param fm Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rl Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rr Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rm Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param relerr Tolerance used to determine when to stop iterating the Newton-Raphson method for finding .\n @param r Radial position of the particles .\n @param theta Uniform deviates in the range representing the uniform poloidal angle distribution of the particles.\n @param zeta Uniform deviates in the range representing the uniform toroidal angle distribution of the particles.\n @param pp Particle iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp Contents Source Code exponential_torus Source Code subroutine exponential_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ) :: fl REAL ( rp ) :: fr REAL ( rp ) :: fm REAL ( rp ) :: rl REAL ( rp ) :: rr REAL ( rp ) :: rm REAL ( rp ) :: relerr REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta INTEGER :: pp ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a ! disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) ! Newton-Raphson applied here for finding the radial distribution do pp = 1_idef , spp % ppp rl = 0.0_rp rr = spp % r_outter fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if do while ( relerr . GT . 1.0_rp ) rm = 0.5_rp * ( rr - rl ) + rl fm = fzero ( rm , spp % r_outter , spp % falloff_rate , r ( pp )) if ( SIGN ( 1.0_rp , fm ). EQ . SIGN ( 1.0_rp , fr )) then rr = rm else rl = rm end if fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if end do r ( pp ) = rm end do spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( zeta ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( zeta ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine exponential_torus","tags":"","loc":"proc/exponential_torus.html"},{"title":"exponential_elliptic_torus – KORC-Full Orbit","text":"private subroutine exponential_elliptic_torus(params, spp) @brief Subroutine that generates an exponentially decaying radial distribution in an elliptic torus as the initial spatial\n condition of a given particle species in the simulation.\n @details As a first step, we generate an exponentially decaying radial distribution in a circular cross-section torus as in\n \\ref korc_spatial_distribution.exponential_torus. Then we transform this spatial distribution to a one in an torus with an\n elliptic cross section, this following the same approach as in \\ref korc_spatial_distribution.elliptic_torus. @param[in] params Core KORC simulation parameters.\n @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different\n species in the simulation.\n @param fl Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param fr Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param fm Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rl Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rr Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rm Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param relerr Tolerance used to determine when to stop iterating the Newton-Raphson method for finding .\n @param rotation_angle This is the angle in \\ref korc_spatial_distribution.elliptic_torus.\n @param r Radial position of the particles .\n @param theta Uniform deviates in the range representing the uniform poloidal angle distribution of the particles.\n @param zeta Uniform deviates in the range representing the uniform toroidal angle distribution of the particles.\n @param X Auxiliary vector used in the coordinate transformations.\n @param Y Auxiliary vector used in the coordinate transformations.\n @param X1 Auxiliary vector used in the coordinate transformations.\n @param Y1 Auxiliary vector used in the coordinate transformations.\n @param pp Particle iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp Contents Source Code exponential_elliptic_torus Source Code subroutine exponential_elliptic_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ) :: fl REAL ( rp ) :: fr REAL ( rp ) :: fm REAL ( rp ) :: rl REAL ( rp ) :: rr REAL ( rp ) :: rm REAL ( rp ) :: relerr REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rotation_angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X1 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y1 INTEGER :: pp ALLOCATE ( X1 ( spp % ppp )) ALLOCATE ( Y1 ( spp % ppp )) ALLOCATE ( X ( spp % ppp )) ALLOCATE ( Y ( spp % ppp )) ALLOCATE ( rotation_angle ( spp % ppp ) ) ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a ! disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) do pp = 1_idef , spp % ppp rl = 0.0_rp rr = spp % r_outter fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if do while ( relerr . GT . 1.0_rp ) rm = 0.5_rp * ( rr - rl ) + rl fm = fzero ( rm , spp % r_outter , spp % falloff_rate , r ( pp )) if ( SIGN ( 1.0_rp , fm ). EQ . SIGN ( 1.0_rp , fr )) then rr = rm else rl = rm end if fl = fzero ( rl , spp % r_outter , spp % falloff_rate , r ( pp )) fr = fzero ( rr , spp % r_outter , spp % falloff_rate , r ( pp )) if ( fl . GT . korc_zero ) then relerr = 100 * ABS ( fl - fr ) / fl else relerr = 100 * ABS ( fl - fr ) / fr end if end do r ( pp ) = rm end do Y = r * SIN ( theta ) X = r * COS ( theta ) + spp % shear_factor * Y rotation_angle = 0.5_rp * C_PI - ATAN ( 1.0_rp , 1.0_rp + spp % shear_factor ); X1 = X * COS ( rotation_angle ) - Y * SIN ( rotation_angle ) + spp % Ro Y1 = X * SIN ( rotation_angle ) + Y * COS ( rotation_angle ) + spp % Zo spp % vars % X (:, 1 ) = X1 * SIN ( zeta ) spp % vars % X (:, 2 ) = X1 * COS ( zeta ) spp % vars % X (:, 3 ) = Y1 DEALLOCATE ( X1 ) DEALLOCATE ( Y1 ) DEALLOCATE ( X ) DEALLOCATE ( Y ) DEALLOCATE ( rotation_angle ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine exponential_elliptic_torus","tags":"","loc":"proc/exponential_elliptic_torus.html"},{"title":"gaussian_elliptic_torus – KORC-Full Orbit","text":"private subroutine gaussian_elliptic_torus(params, spp) @brief Subroutine that generates a Gaussian radial distribution in an elliptic torus as the initial spatial\n condition of a given particle species in the simulation.\n @details As a first step, we generate an Gaussian radial distribution in a circular cross-section torus as in\n \\ref korc_spatial_distribution.gaussian_torus. Then we transform this spatial distribution to a one in an torus with an\n elliptic cross section, this following the same approach as in \\ref korc_spatial_distribution.elliptic_torus. @param[in] params Core KORC simulation parameters.\n @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different\n species in the simulation.\n @param rotation_angle This is the angle in \\ref korc_spatial_distribution.elliptic_torus.\n @param r Radial position of the particles .\n @param theta Uniform deviates in the range representing the uniform poloidal angle distribution of the particles.\n @param zeta Uniform deviates in the range representing the uniform toroidal angle distribution of the particles.\n @param X Auxiliary vector used in the coordinate transformations.\n @param Y Auxiliary vector used in the coordinate transformations.\n @param X1 Auxiliary vector used in the coordinate transformations.\n @param Y1 Auxiliary vector used in the coordinate transformations.\n @param sigma Standard deviation of the radial distribution function.\n @param pp Particle iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp Contents Source Code gaussian_elliptic_torus Source Code subroutine gaussian_elliptic_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: rotation_angle REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y REAL ( rp ), DIMENSION (:), ALLOCATABLE :: X1 REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Y1 REAL ( rp ) :: sigma INTEGER :: pp ALLOCATE ( X1 ( spp % ppp )) ALLOCATE ( Y1 ( spp % ppp )) ALLOCATE ( X ( spp % ppp )) ALLOCATE ( Y ( spp % ppp )) ALLOCATE ( rotation_angle ( spp % ppp ) ) ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a ! disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) sigma = 1.0_rp / SQRT ( 2.0_rp * ( spp % falloff_rate / params % cpp % length )) sigma = sigma / params % cpp % length r = sigma * SQRT ( - 2.0_rp * LOG ( 1.0_rp - ( 1.0_rp - & EXP ( - 0.5_rp * spp % r_outter ** 2 / sigma ** 2 )) * r )) !  spp%vars%X(:,1) = ( spp%Ro + r*COS(theta) )*SIN(zeta) !  spp%vars%X(:,2) = ( spp%Ro + r*COS(theta) )*COS(zeta) !  spp%vars%X(:,3) = spp%Zo + r*SIN(theta) Y = r * SIN ( theta ) X = r * COS ( theta ) + spp % shear_factor * Y rotation_angle = 0.5_rp * C_PI - ATAN ( 1.0_rp , 1.0_rp + spp % shear_factor ); X1 = X * COS ( rotation_angle ) - Y * SIN ( rotation_angle ) + spp % Ro Y1 = X * SIN ( rotation_angle ) + Y * COS ( rotation_angle ) + spp % Zo spp % vars % X (:, 1 ) = X1 * SIN ( zeta ) spp % vars % X (:, 2 ) = X1 * COS ( zeta ) spp % vars % X (:, 3 ) = Y1 DEALLOCATE ( X1 ) DEALLOCATE ( Y1 ) DEALLOCATE ( X ) DEALLOCATE ( Y ) DEALLOCATE ( rotation_angle ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine gaussian_elliptic_torus","tags":"","loc":"proc/gaussian_elliptic_torus.html"},{"title":"MH_gaussian_elliptic_torus – KORC-Full Orbit","text":"private subroutine MH_gaussian_elliptic_torus(params, spp) Note Subroutine that generates a 2D Gaussian distribution in an \n elliptic torus as the initial spatial condition of a given particle \n species in the simulation. *rand_unif Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Contents Source Code MH_gaussian_elliptic_torus Source Code subroutine MH_gaussian_elliptic_torus ( params , spp ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples !! REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! REAL ( rp ), DIMENSION (:), ALLOCATABLE :: ZETA_samples !! REAL ( rp ) :: psi_max_buff !! REAL ( rp ) :: theta_rad !! REAL ( rp ) :: R_buffer !! REAL ( rp ) :: Z_buffer !! REAL ( rp ) :: R_test !! REAL ( rp ) :: Z_test !! REAL ( rp ) :: psi0 !! REAL ( rp ) :: psi1 !! REAL ( rp ) :: rand_unif !! REAL ( rp ) :: ratio !! INTEGER :: nsamples !! INTEGER :: ii !! Particle iterator. INTEGER :: mpierr LOGICAL :: accepted nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.1_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( ZETA_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo ii = 2_idef do while ( ii . LE . 1000_idef ) R_test = R_buffer + random_norm ( 0.0_rp , spp % sigmaR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % sigmaZ ) psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , spp % sigmaZ , theta_rad ) ratio = indicator ( psi1 , spp % psi_max ) * R_test * EXP ( - psi1 ) / ( R_buffer * EXP ( - psi0 )) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) R_test = R_buffer + random_norm ( 0.0_rp , spp % sigmaR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % sigmaZ ) psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , spp % sigmaZ , theta_rad ) ratio = indicator ( psi1 , psi_max_buff ) * R_test * EXP ( - psi1 ) / ( R_buffer * EXP ( - psi0 )) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test end if end if IF ( INT ( indicator ( psi1 , spp % psi_max )). EQ . 1. and . accepted ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer !           call RANDOM_NUMBER(rand_unif) ZETA_samples ( ii ) = 2.0_rp * C_PI !!*rand_unif ii = ii + 1_idef END IF end do end if CALL MPI_SCATTER ( R_samples * sin ( ZETA_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( R_samples * cos ( ZETA_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , spp % vars % X (:, 3 ), & spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( ZETA_samples ) end if end subroutine MH_gaussian_elliptic_torus","tags":"","loc":"proc/mh_gaussian_elliptic_torus.html"},{"title":"gaussian_torus – KORC-Full Orbit","text":"private subroutine gaussian_torus(params, spp) @brief Subroutine that generates a Gaussian radial distribution of particles in a circular cross-section torus of\n major and minor radi and , respectively.\n @details We generate this exponentially decaying radial distribution following the same approach as in\n \\ref korc_spatial_distribution.disk, but this time, the radial distribution is given by: The radial position of the particles is obtained using the Inverse Trasnform Sampling method, finding numerically\n through the Newton-Raphson method. First, we calculate the particles' radial distribution in a disk centered at .\n Then, we transfor to a new set of coordinates where the disk is centered at . Finally, we generate the\n toroidal distribution by givin each particle a toroidal angle which follows a uniform distribution in the interval . @param[in] params Core KORC simulation parameters.\n @param[in,out] spp An instance of the derived type SPECIES containing all the parameters and simulation variables of the different\n species in the simulation.\n @param fl Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param fr Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param fm Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rl Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rr Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param rm Variable used in the Newton-Raphson method for finding the radial position of each particle.\n @param relerr Tolerance used to determine when to stop iterating the Newton-Raphson method for finding .\n @param r Radial position of the particles .\n @param theta Uniform deviates in the range representing the uniform poloidal angle distribution of the particles.\n @param zeta Uniform deviates in the range representing the uniform toroidal angle distribution of the particles.\n @param pp Particle iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp Contents Source Code gaussian_torus Source Code subroutine gaussian_torus ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: zeta REAL ( rp ), DIMENSION (:), ALLOCATABLE :: r ! temporary vars REAL ( rp ) :: sigma ALLOCATE ( theta ( spp % ppp ) ) ALLOCATE ( zeta ( spp % ppp ) ) ALLOCATE ( r ( spp % ppp ) ) ! Initial condition of uniformly distributed particles on a disk in the xz-plane ! A unique velocity direction call init_u_random ( 10986546 _ 8 ) call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta call init_random_seed () call RANDOM_NUMBER ( zeta ) zeta = 2.0_rp * C_PI * zeta ! Uniform distribution on a disk at a fixed azimuthal theta call init_random_seed () call RANDOM_NUMBER ( r ) sigma = 1.0_rp / SQRT ( 2.0_rp * ( spp % falloff_rate / params % cpp % length )) sigma = sigma / params % cpp % length r = sigma * SQRT ( - 2.0_rp * LOG ( 1.0_rp - ( 1.0_rp - & EXP ( - 0.5_rp * spp % r_outter ** 2 / sigma ** 2 )) * r )) spp % vars % X (:, 1 ) = ( spp % Ro + r * COS ( theta ) ) * SIN ( zeta ) spp % vars % X (:, 2 ) = ( spp % Ro + r * COS ( theta ) ) * COS ( zeta ) spp % vars % X (:, 3 ) = spp % Zo + r * SIN ( theta ) DEALLOCATE ( theta ) DEALLOCATE ( zeta ) DEALLOCATE ( r ) end subroutine gaussian_torus","tags":"","loc":"proc/gaussian_torus.html"},{"title":"Spong_3D – KORC-Full Orbit","text":"private subroutine Spong_3D(params, spp) Note Subroutine that generates a 2D Gaussian distribution in an \n elliptic torus as the initial spatial condition of a given particle \n species in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. An instance of the KORC derived type FIELDS. Contents Source Code Spong_3D Source Code subroutine Spong_3D ( params , spp ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: T_samples !! Pitch angle of all samples REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: T_buffer !! Previous sample of pitch angle REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: T_test !! Present sample of pitch angle REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: f0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: f1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.1_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp ! buffer at minimum pitch angle boundary if ( spp % etao_lims ( 1 ). GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = spp % etao_lims ( 1 ) - REAL ( ii , rp ) * & ( spp % etao_lims ( 2 ) - spp % etao_lims ( 1 )) / 100_rp if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = spp % etao_lims ( 1 ) end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = spp % etao_lims ( 2 ) + REAL ( ii , rp ) * & ( spp % etao_lims ( 2 ) - spp % etao_lims ( 1 )) / 100_rp if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( T_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo call RANDOM_NUMBER ( rand_unif ) T_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * rand_unif !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length ii = 1_idef do while ( ii . LE . 1000_idef ) !        write(output_unit_write,'(\"burn:\",I15)') ii R_test = R_buffer + random_norm ( 0.0_rp , spp % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % dZ ) T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) ! Test that pitch angle and momentum are within chosen boundary do while (( T_test . GT . spp % etao_lims ( 2 )). OR . & ( T_test . LT . spp % etao_lims ( 1 ))) T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) f0 = Spong_2D ( spp % Ro , spp % Spong_b , spp % Spong_w , spp % Spong_dlam , & R_buffer , Z_buffer , T_buffer ) else psi0 = psi1 f0 = f1 end if psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) f1 = Spong_2D ( spp % Ro , spp % Spong_b , spp % Spong_w , spp % Spong_dlam , & R_test , Z_test , T_test ) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 !        write(output_unit_write,'(\"f0: \",E17.10)') f0 !        write(output_unit_write,'(\"f1: \",E17.10)') f1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator ( psi1 , spp % psi_max ) * R_test * EXP ( - psi1 ) * f1 / & ( R_buffer * EXP ( - psi0 ) * f0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , 10000 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if R_test = R_buffer + random_norm ( 0.0_rp , spp % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , spp % dZ ) T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) ! Selection boundary is set with buffer region do while (( T_test . GT . max_pitch_angle ). OR . & ( T_test . LT . min_pitch_angle )) if ( T_test . lt . 0 ) then T_test = abs ( T_test ) exit end if T_test = T_buffer + random_norm ( 0.0_rp , spp % dth ) end do psi0 = psi1 f0 = f1 psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) f1 = Spong_2D ( spp % Ro , spp % Spong_b , spp % Spong_w , spp % Spong_dlam , & R_test , Z_test , T_test ) ratio = indicator ( psi1 , psi_max_buff ) * R_test * EXP ( - psi1 ) * f1 / & ( R_buffer * EXP ( - psi0 ) * f0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test T_buffer = T_test end if end if ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator ( psi1 , spp % psi_max )). EQ . 1 ). AND . & ( T_buffer . LE . spp % etao_lims ( 2 )). AND . & ( T_buffer . GE . spp % etao_lims ( 1 ))) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer T_samples ( ii ) = T_buffer ! Sample phi location uniformly call RANDOM_NUMBER ( rand_unif ) PHI_samples ( ii ) = 2.0_rp * C_PI * rand_unif ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length end if CALL MPI_SCATTER ( R_samples * cos ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( R_samples * sin ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) !  CALL MPI_SCATTER(T_samples,spp%ppp,MPI_REAL8, & !       spp%vars%eta,spp%ppp,MPI_REAL8,0,MPI_COMM_WORLD,mpierr) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( T_samples ) end if end subroutine Spong_3D","tags":"","loc":"proc/spong_3d.html"},{"title":"MH_psi – KORC-Full Orbit","text":"private subroutine MH_psi(params, spp, F) Note Subroutine that generates a 2D Gaussian distribution in an \n elliptic torus as the initial spatial condition of a given particle \n species in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code MH_psi Source Code subroutine MH_psi ( params , spp , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples , X_samples , Y_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ) :: min_R , max_R REAL ( rp ) :: min_Z , max_Z REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: psi_max , psi_max_buff REAL ( rp ) :: PSIp_lim , PSIP0 , PSIN , PSIN0 , PSIN1 , sigma , psi0 , psi1 REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator LOGICAL :: accepted INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , * ) '*** START SAMPLING ***' end if nsamples = spp % ppp * params % mpi_params % nmpi params % GC_coords = . TRUE . PSIp_lim = F % PSIp_lim if ( params % field_model . eq . 'M3D_C1' ) then min_R = params % rmin / params % cpp % length max_R = params % rmax / params % cpp % length min_Z = params % Zmin / params % cpp % length max_Z = params % Zmax / params % cpp % length PSIp0 = F % PSIp_0 psi_max = spp % psi_max psi_max_buff = spp % psi_max else min_R = minval ( F % X % R ) max_R = maxval ( F % X % R ) min_Z = minval ( F % X % Z ) max_Z = maxval ( F % X % Z ) PSIp0 = F % PSIP_min psi_max = spp % psi_max psi_max_buff = spp % psi_max * 2._rp end if sigma = spp % sigmaR * params % cpp % length !write(output_unit_write,*) min_R,max_R !write(output_unit_write,*) min_Z,max_Z ALLOCATE ( R_samples ( nsamples )) ALLOCATE ( X_samples ( nsamples )) ALLOCATE ( Y_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes if ( params % mpi_params % rank . EQ . 0_idef ) then ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if write ( output_unit_write , '(\"Begin burn: \",I10)' ) accepted = . false . ii = 1_idef do while ( ii . LE . 1000_idef ) if ( modulo ( ii , 100 ). eq . 0 ) then write ( output_unit_write , '(\"Burn: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then spp % vars % Y ( 1 , 1 ) = R_buffer spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_buffer !write(6,*) 'R',R_buffer !write(6,*) 'Z',Z_buffer if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_vector_potential ( spp % vars , F , params ) else call get_fields ( params , spp % vars , F ) end if spp % vars % flagCon = 1_is !write(6,*) 'may have crashed' !write(6,*) 'R',R_buffer !write(6,*) 'Z',Z_buffer !write(6,*) 'PSIlim',PSIp_lim !write(6,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI1',psi1 !write(6,*) 'PSI0',psi0 !write(output_unit_write,*) 'PSIN1',PSIN1 !write(6,*) 'PSIN0',PSIN0 psi0 = spp % vars % PSI_P ( 1 ) PSIN0 = ( psi0 - PSIp0 ) / ( PSIp_lim - PSIp0 ) end if if ( accepted ) then PSIN0 = PSIN1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0._rp spp % vars % Y ( 1 , 3 ) = Z_test if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_vector_potential ( spp % vars , F , params ) else call get_fields ( params , spp % vars , F ) end if spp % vars % flagCon = 1_is psi1 = spp % vars % PSI_P ( 1 ) !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI',psi1 PSIN1 = ( psi1 - PSIp0 ) / ( PSIp_lim - PSIp0 ) !write(output_unit_write,*) 'R',R_test !write(output_unit_write,*) 'Z',Z_test !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI1',psi1 !write(output_unit_write,*) 'PSI0',psi0 !write(output_unit_write,*) 'PSIN',PSIN1 !write(output_unit_write,*) 'PSIN0',PSIN0 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator ( PSIN1 , psi_max ) * & R_test * EXP ( - PSIN1 / sigma ) / & ( R_buffer * EXP ( - PSIN0 / sigma )) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef !write(output_unit_write,*) 'PSIN',PSIN1 else !           call RANDOM_NUMBER(rand_unif) !           if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test ii = ii + 1_idef !write(output_unit_write,*) 'PSIN',PSIN1 end if end if end do ! Transient ! write ( output_unit_write , '(\"Begin sample: \",I10)' ) ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do if ( accepted ) then PSIN0 = PSIN1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_vector_potential ( spp % vars , F , params ) else call get_fields ( params , spp % vars , F ) end if spp % vars % flagCon = 1_is psi1 = spp % vars % PSI_P ( 1 ) !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI',psi1 PSIN1 = ( psi1 - PSIp0 ) / ( PSIp_lim - PSIp0 ) !write(output_unit_write,*) 'R',R_test !write(output_unit_write,*) 'Z',Z_test !write(output_unit_write,*) 'PSIlim',PSIp_lim !write(output_unit_write,*) 'PSI0',PSIp0 !write(output_unit_write,*) 'PSI1',psi1 !write(output_unit_write,*) 'PSI0',psi0 !write(output_unit_write,*) 'PSIN',PSIN1 !write(output_unit_write,*) 'PSIN0',PSIN0 ratio = indicator ( PSIN1 , psi_max_buff ) * & R_test * EXP ( - PSIN1 / sigma ) / & ( R_buffer * EXP ( - PSIN0 / sigma )) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test else !call RANDOM_NUMBER(rand_unif) !if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test end if end if !        write(output_unit_write,'(\"R: \",E17.10)') R_buffer !        write(output_unit_write,'(\"Z: \",E17.10)') Z_buffer ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator ( PSIN1 , psi_max )). EQ . 1 ). AND . & ACCEPTED ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer !write(output_unit_write,*) 'PSIN',PSIN1 !           write(output_unit_write,*) 'RS',R_buffer ! Sample phi location uniformly !call RANDOM_NUMBER(rand_unif) !PHI_samples(ii) = 2.0_rp*C_PI*rand_unif !PHI_samples(ii) = 2.0_rp*C_PI*get_random_mkl_U() PHI_samples ( ii ) = 2.0_rp * C_PI * get_random_U () ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length X_samples = R_samples * cos ( PHI_samples ) Y_samples = R_samples * sin ( PHI_samples ) !     write(output_unit_write,*) 'R_samples',R_samples !     write(output_unit_write,*) 'PHI_samples',PHI_samples !     write(output_unit_write,*) 'Z_samples',Z_samples !     write(output_unit_write,*) 'G_samples',G_samples !     write(output_unit_write,*) 'eta_samples',eta_samples end if params % GC_coords = . FALSE . call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( X_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Y_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) DEALLOCATE ( R_samples ) DEALLOCATE ( X_samples ) DEALLOCATE ( Y_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) end subroutine MH_psi","tags":"","loc":"proc/mh_psi.html"},{"title":"intitial_spatial_distribution – KORC-Full Orbit","text":"public subroutine intitial_spatial_distribution(params, spp, P, F) Note Subroutine that contains calls to the different subroutines \n for initializing the simulated particles with various\n spatial distribution functions. In addition to spatial distribution function, Avalanche_4D samples the avalanche distribution function used to initialize\n the components of velocity for all particles. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters and \n simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code intitial_spatial_distribution Source Code subroutine intitial_spatial_distribution ( params , spp , P , F ) !! @note Subroutine that contains calls to the different subroutines !! for initializing the simulated particles with various !! spatial distribution functions. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters and !! simulation variables of the different species in the simulation. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. INTEGER :: ss !! Species iterator. INTEGER :: mpierr do ss = 1_idef , params % num_species SELECT CASE ( TRIM ( spp ( ss )% spatial_distribution )) CASE ( 'UNIFORM' ) call uniform ( spp ( ss )) CASE ( 'DISK' ) call disk ( params , spp ( ss )) CASE ( 'TORUS' ) call torus ( params , spp ( ss )) CASE ( 'EXPONENTIAL-TORUS' ) call exponential_torus ( params , spp ( ss )) CASE ( 'GAUSSIAN-TORUS' ) call gaussian_torus ( params , spp ( ss )) CASE ( 'ELLIPTIC-TORUS' ) call elliptic_torus ( params , spp ( ss )) CASE ( 'EXPONENTIAL-ELLIPTIC-TORUS' ) call exponential_elliptic_torus ( params , spp ( ss )) CASE ( 'GAUSSIAN-ELLIPTIC-TORUS' ) call gaussian_elliptic_torus ( params , spp ( ss )) CASE ( '2D-GAUSSIAN-ELLIPTIC-TORUS-MH' ) call MH_gaussian_elliptic_torus ( params , spp ( ss )) CASE ( 'AVALANCHE-4D' ) call get_Avalanche_4D ( params , spp ( ss ), P , F ) !! In addition to spatial distribution function, [[Avalanche_4D]] !! samples the avalanche distribution function used to initialize !! the components of velocity for all particles. CASE ( 'TRACER' ) spp ( ss )% vars % X (:, 1 ) = spp ( ss )% Xtrace ( 1 ) spp ( ss )% vars % X (:, 2 ) = spp ( ss )% Xtrace ( 2 ) spp ( ss )% vars % X (:, 3 ) = spp ( ss )% Xtrace ( 3 ) CASE ( 'SPONG-3D' ) call Spong_3D ( params , spp ( ss )) CASE ( 'HOLLMANN-3D' ) call get_Hollmann_distribution_3D ( params , spp ( ss ), F ) CASE ( 'HOLLMANN-3D-PSI' ) call get_Hollmann_distribution_3D_psi ( params , spp ( ss ), F ) CASE ( 'MH_psi' ) if ( spp ( ss )% ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) & 'num_samples need to be atleast 10 but is only: ' , & spp ( ss )% ppp * params % mpi_params % nmpi end if call korc_abort end if call MH_psi ( params , spp ( ss ), F ) CASE DEFAULT call torus ( params , spp ( ss )) END SELECT end do end subroutine intitial_spatial_distribution","tags":"","loc":"proc/intitial_spatial_distribution.html"},{"title":"fth_3V – KORC-Full Orbit","text":"private function fth_3V(Vth, V) Note Function used to sample the probability density function of a \n thermal plasma in the 3-dimensional velocity space. This function returns , \n where is\n the temperature of the thermal electrons, and is the speed of the sampled electron. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Vth Thermal velocity of the background electrons . real(kind=rp), intent(in), DIMENSION(3) :: V Velocity of the sampled electron . Return Value real(kind=rp) Value of . Contents Source Code fth_3V Source Code FUNCTION fth_3V ( Vth , V ) !! @note Function used to sample the probability density function of a !! thermal plasma in the 3-dimensional velocity space. @endnote !! This function returns f_{T_e}(v) = \\exp{\\left( v&#94;2/2v_{T_e}&#94;2 \\right)}, !! where v_{T_e} = \\sqrt{T_e/m_e} is !! the temperature of the thermal electrons, and v = |\\mathbf{v}| !! is the speed of the sampled electron. REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: V !! Velocity of the sampled electron \\mathbf{v}. REAL ( rp ), INTENT ( IN ) :: Vth !! Thermal velocity of the background electrons v_{T_e}. REAL ( rp ) :: fth_3V !! Value of f_{T_e}(v). fth_3V = EXP ( - 0.5_rp * DOT_PRODUCT ( V , V ) / Vth ** 2.0_rp ) END FUNCTION fth_3V","tags":"","loc":"proc/fth_3v.html"},{"title":"random_norm – KORC-Full Orbit","text":"private function random_norm(mu, sigma) Note Gaussian random number generator. This function returns a deviate of a Gaussian distribution with mean , and standard deviation . We use the Inverse Transform Sampling Method for sampling . \n With this method we get ,\n where and are uniform random numbers in the interval . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mu Mean value of the Gaussian distribution. real(kind=rp), intent(in) :: sigma Standard deviation of the Gaussian distribution. Return Value real(kind=rp) Sampled number from the Gaussian distribution . Contents Source Code random_norm Source Code FUNCTION random_norm ( mu , sigma ) !! @note Gaussian random number generator. @endnote !! This function returns a deviate of a Gaussian distribution !! f_G(x;\\mu,\\sigma) = !! \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp{\\left( -(x-\\mu)&#94;2/2\\sigma&#94;2 \\right)}, !! !! with mean \\mu, and standard deviation \\sigma. !! !! We use the Inverse Transform Sampling Method for sampling x. !! With this method we get x = \\sqrt{-2\\log{(1-y)}}\\cos(2\\pi z), !! where y and z are uniform random numbers in the interval [0,1]. REAL ( rp ), INTENT ( IN ) :: mu !! Mean value \\mu of the Gaussian distribution. REAL ( rp ), INTENT ( IN ) :: sigma !! Standard deviation \\sigma of the Gaussian distribution. REAL ( rp ) :: random_norm !! Sampled number x from the Gaussian distribution f_G(x;\\mu,\\sigma). REAL ( rp ) :: rand1 !! Uniform random number in the interval [0,1]. REAL ( rp ) :: rand2 !! Uniform random number in the interval [0,1]. call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = SQRT ( - 2.0_rp * LOG ( 1.0_rp - rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm","tags":"","loc":"proc/random_norm.html"},{"title":"thermal_distribution – KORC-Full Orbit","text":"public subroutine thermal_distribution(params, spp) Note Subroutine that samples a thermal distribution function\n of electrons for generating the initial condition of a set of\n simulated particles. This subroutine uses the Inverse Transform Sampling Method along\n with the  Metropolis-Hastings algorithm to generate an\n initial condition of the velocity distribution that follows a\n 3-dimensional (in velocity space) thermal distribution. Todo Check that the gyro-distribution is initialized right in\n this function. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the\n parameters and simulation variables of the different species\n in the simulation. Contents Source Code thermal_distribution Source Code subroutine thermal_distribution ( params , spp ) !! @note Subroutine that samples a thermal distribution function !! of electrons for generating the initial condition of a set of !! simulated particles. @endnote !! This subroutine uses the Inverse Transform Sampling Method along !! with the  Metropolis-Hastings algorithm to generate an !! initial condition of the velocity distribution that follows a !! 3-dimensional (in velocity space) thermal distribution. !! @todo Check that the gyro-distribution is initialized right in !! this function. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the !! parameters and simulation variables of the different species !! in the simulation. REAL ( rp ) :: Vmax !! Velocity cutoff where we stop sampling the tail of the thermal !! distribution. REAL ( rp ) :: vsq !! REAL ( rp ) :: Vth !! Thermal velocity of the sampled distribution v_{T_e} = !! \\sqrt{T_e/m_e}. REAL ( rp ) :: sv !! Step to sample the velocity space using the Metropolis-Hastings !! algorithm. REAL ( rp ) :: ratio !! Ratio used to accept or reject a sampling in the Metropolis-Hastings !! algorithm. REAL ( rp ) :: rand_unif !! Uniform random deviate in the interval  [0,1]. REAL ( rp ), DIMENSION ( 3 ) :: V !! Sampled velocity. REAL ( rp ), DIMENSION ( 3 ) :: U !! Sampled velocity. REAL ( rp ), DIMENSION ( 3 ) :: b = ( / 1.0_rp , 0.0_rp , 0.0_rp / ) !! Temporary variable representing a unit vector along the x-axis. INTEGER :: ii !! Iterator. INTEGER :: ppp !! Number of particles per species. Vmax = 0.9_rp Vth = SQRT ( spp % Eo * ABS ( spp % q ) / spp % m ) ppp = spp % ppp V = ( / 0.0_rp , 0.0_rp , 0.0_rp / ) sv = Vth / 1 0.0_rp ii = 2_idef do while ( ii . LE . 1000_idef ) U ( 1 ) = V ( 1 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 1 )) . GT . Vmax ) U ( 1 ) = V ( 1 ) + random_norm ( 0.0_rp , sv ) end do U ( 2 ) = V ( 2 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 2 )) . GT . Vmax ) U ( 2 ) = V ( 2 ) + random_norm ( 0.0_rp , sv ) end do U ( 3 ) = V ( 3 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 3 )) . GT . Vmax ) U ( 3 ) = V ( 3 ) + random_norm ( 0.0_rp , sv ) end do ratio = fth_3V ( Vth , U ) / fth_3V ( Vth , V ) if ( ratio . GE . 1.0_rp ) then V = U ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( ratio . GT . rand_unif ) then V = U ii = ii + 1_idef end if end if end do spp % vars % V ( 1 , 1 ) = V ( 1 ) spp % vars % V ( 1 , 2 ) = V ( 2 ) spp % vars % V ( 1 , 3 ) = V ( 3 ) ii = 2_idef do while ( ii . LE . ppp ) U ( 1 ) = spp % vars % V ( ii - 1 , 1 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 1 )) . GT . Vmax ) U ( 1 ) = spp % vars % V ( ii - 1 , 1 ) + random_norm ( 0.0_rp , sv ) end do U ( 2 ) = spp % vars % V ( ii - 1 , 2 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 2 )) . GT . Vmax ) U ( 2 ) = spp % vars % V ( ii - 1 , 2 ) + random_norm ( 0.0_rp , sv ) end do U ( 3 ) = spp % vars % V ( ii - 1 , 3 ) + random_norm ( 0.0_rp , sv ) do while ( ABS ( U ( 3 )) . GT . Vmax ) U ( 3 ) = spp % vars % V ( ii - 1 , 3 ) + random_norm ( 0.0_rp , sv ) end do ratio = fth_3V ( Vth , U ) / fth_3V ( Vth , spp % vars % V ( ii - 1 ,:)) if ( ratio . GE . 1.0_rp ) then spp % vars % V ( ii , 1 ) = U ( 1 ) spp % vars % V ( ii , 2 ) = U ( 2 ) spp % vars % V ( ii , 3 ) = U ( 3 ) ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( ratio . GT . rand_unif ) then spp % vars % V ( ii , 1 ) = U ( 1 ) spp % vars % V ( ii , 2 ) = U ( 2 ) spp % vars % V ( ii , 3 ) = U ( 3 ) ii = ii + 1_idef end if end if end do do ii = 1_idef , ppp vsq = spp % vars % V ( ii , 1 ) * spp % vars % V ( ii , 1 ) & + spp % vars % V ( ii , 2 ) * spp % vars % V ( ii , 2 ) & + spp % vars % V ( ii , 3 ) * spp % vars % V ( ii , 3 ) spp % vars % g ( ii ) = 1.0_rp / SQRT ( 1.0_rp - vsq ) spp % vars % eta ( ii ) = ACOS ( spp % vars % V ( ii , 1 ) / SQRT ( vsq )) end do spp % go = spp % Eo / ( spp % m * C_C ** 2 ) spp % etao = 9 0.0_rp end subroutine thermal_distribution","tags":"","loc":"proc/thermal_distribution.html"},{"title":"initial_energy_pitch_dist – KORC-Full Orbit","text":"public subroutine initial_energy_pitch_dist(params, spp) Note Subroutine that calls subroutines of different modules to \n initialize the energy and pitch-angle distribution in various ways. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters and \n simulation variables of the different species in the simulation. Contents Source Code initial_energy_pitch_dist Source Code subroutine initial_energy_pitch_dist ( params , spp ) !! @note Subroutine that calls subroutines of different modules to !! initialize the energy and pitch-angle distribution in various ways. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters and !! simulation variables of the different species in the simulation. INTEGER :: ii !! Species iterator. INTEGER :: mpierr !! MPI error status. do ii = 1_idef , params % num_species if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * SPECIES: \",I2,\" * * * * * * * * * * *\")' ) ii write ( output_unit_write , '(\"Particles per MPI process: \",I16)' ) spp ( ii )% ppp write ( output_unit_write , '(\"Energy distribution is: \",A20)' ) & TRIM ( spp ( ii )% energy_distribution ) write ( output_unit_write , '(\"Pitch-angle distribution is: \",A20)' ) & TRIM ( spp ( ii )% pitch_distribution ) write ( output_unit_write , '(\"Spatial distribution is: \",A20)' ) & TRIM ( spp ( ii )% spatial_distribution ) write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if SELECT CASE ( TRIM ( spp ( ii )% energy_distribution )) CASE ( 'MONOENERGETIC' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergetic spp ( ii )% Eo_lims = ( / spp ( ii )% Eo , spp ( ii )% Eo / ) CASE ( 'THERMAL' ) call thermal_distribution ( params , spp ( ii )) spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) - & spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'AVALANCHE' ) call get_avalanche_distribution ( params , spp ( ii )% vars % g , & spp ( ii )% vars % eta , spp ( ii )% go , spp ( ii )% etao ) spp ( ii )% Eo = spp ( ii )% m * C_C ** 2 * spp ( ii )% go - spp ( ii )% m * C_C ** 2 spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'HOLLMANN' ) call get_Hollmann_distribution ( params , spp ( ii )) !          spp(ii)%Eo = spp(ii)%m*C_C**2*spp(ii)%go - spp(ii)%m*C_C**2 spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'EXPERIMENTAL-GAMMA' ) call get_experimentalG_distribution ( params , spp ( ii )% vars % g , & spp ( ii )% vars % eta , & spp ( ii )% go , spp ( ii )% etao ) spp ( ii )% Eo = spp ( ii )% m * C_C ** 2 * spp ( ii )% go - spp ( ii )% m * C_C ** 2 spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'GAMMA' ) call get_gamma_distribution ( params , spp ( ii )% vars % g , spp ( ii )% go ) spp ( ii )% Eo = spp ( ii )% m * C_C ** 2 * spp ( ii )% go - spp ( ii )% m * C_C ** 2 spp ( ii )% Eo_lims = ( / spp ( ii )% m * C_C ** 2 * MINVAL ( spp ( ii )% vars % g ) & - spp ( ii )% m * C_C ** 2 , & spp ( ii )% m * C_C ** 2 * MAXVAL ( spp ( ii )% vars % g ) - spp ( ii )% m * C_C ** 2 / ) CASE ( 'UNIFORM' ) spp ( ii )% Eo = spp ( ii )% Eo_lims ( 1 ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) call generate_2D_hammersley_sequence ( params % mpi_params % rank , & params % mpi_params % nmpi , spp ( ii )% vars % g , spp ( ii )% vars % eta ) spp ( ii )% vars % g = ( spp ( ii )% Eo_lims ( 2 ) - & spp ( ii )% Eo_lims ( 1 )) * spp ( ii )% vars % g / ( spp ( ii )% m * C_C ** 2 ) + & ( spp ( ii )% Eo_lims ( 1 ) + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) CASE ( 'AVALANCHE-4D' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergy from input file until sampled in Avalanche_4D CASE ( 'HOLLMANN-3D' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergy from input file until sampled in Hollmann_3D CASE ( 'HOLLMANN-3D-PSI' ) spp ( ii )% go = ( spp ( ii )% Eo + spp ( ii )% m * C_C ** 2 ) / ( spp ( ii )% m * C_C ** 2 ) spp ( ii )% vars % g = spp ( ii )% go ! Monoenergy from input file until sampled in Hollmann_3D CASE DEFAULT ! Something to be done END SELECT call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) SELECT CASE ( TRIM ( spp ( ii )% pitch_distribution )) CASE ( 'MONOPITCH' ) spp ( ii )% vars % eta = spp ( ii )% etao ! Mono-pitch-angle if ( spp ( ii )% spatial_distribution . ne . 'SPONG-3D' ) then spp ( ii )% etao_lims = ( / spp ( ii )% etao , spp ( ii )% etao / ) end if CASE ( 'THERMAL' ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ), & MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'AVALANCHE' ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ), & MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'HOLLMANN' ) !          spp(ii)%vars%eta = spp(ii)%etao !          spp(ii)%etao_lims = (/MINVAL(spp(ii)%vars%eta), & !               MAXVAL(spp(ii)%vars%eta)/) CASE ( 'EXPERIMENTAL-GAMMA' ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ), & MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'UNIFORM' ) spp ( ii )% etao = spp ( ii )% etao_lims ( 1 ) spp ( ii )% vars % eta = ( spp ( ii )% etao_lims ( 2 ) - & spp ( ii )% etao_lims ( 1 )) * spp ( ii )% vars % eta + spp ( ii )% etao_lims ( 1 ) CASE ( 'SIMPLE-EQUILIBRIUM' ) call get_equilibrium_distribution ( params , spp ( ii )% vars % eta , & spp ( ii )% go , spp ( ii )% etao ) spp ( ii )% etao_lims = ( / MINVAL ( spp ( ii )% vars % eta ),& MAXVAL ( spp ( ii )% vars % eta ) / ) CASE ( 'AVALANCHE-4D' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Avalanche_4D CASE ( 'HOLLMANN-3D' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Hollmann_3D CASE ( 'HOLLMANN-3D-PSI' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Hollmann_3D CASE ( 'SPONG-3D' ) spp ( ii )% vars % eta = spp ( ii )% etao !Monopitch from input file until sampled in Spong_3D CASE DEFAULT ! Something to be done END SELECT call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) end do end subroutine initial_energy_pitch_dist","tags":"","loc":"proc/initial_energy_pitch_dist.html"},{"title":"gyro_distribution – KORC-Full Orbit","text":"private subroutine gyro_distribution(params, F, spp) Note Subroutine that initializes the gyro-angle distribution \n of the particles. When evolving the particles in the 6-D phase space, in addition to \n the position (3 degrees of freedom), energy (one degree of freedom), \n pitch angle (one degree of freedom), we need to define the gyro-angle \n of the particle (one degree of freedom), which is given by the pitch \n angle and the direction of the local magnetic field. By default, this \n subroutine generates a uniform gyro-angle distribution. Note Notice that all the simulation variables are normalized\n here. Call to subroutine unitVectors in korc_fields . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. This structure \n has the information of the magnetic field. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the\n parameters and \n simulation variables of the different species in the simulation. Contents Source Code gyro_distribution Source Code subroutine gyro_distribution ( params , F , spp ) !! @Note Subroutine that initializes the gyro-angle distribution !! of the particles. @endnote !! When evolving the particles in the 6-D phase space, in addition to !! the position (3 degrees of freedom), energy (one degree of freedom), !! pitch angle (one degree of freedom), we need to define the gyro-angle !! of the particle (one degree of freedom), which is given by the pitch !! angle and the direction of the local magnetic field. By default, this !! subroutine generates a uniform gyro-angle distribution. !! @note Notice that all the simulation variables are normalized !! here. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. This structure !! has the information of the magnetic field. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the !! parameters and !! simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: b1 !! Basis vector pointing along the local magnetic field, that is, !!  along \\mathbf{b} = \\mathbf{B}/B. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: b2 !! Basis vector perpendicular to b1 REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: b3 !! Basis vector perpendicular to b1 and b2. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Vo !! Initial particle speed. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V1 !!  Velocity component along b1. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V2 !! Velocity component along b2. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: V3 !! Velocity component along b3. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: theta !! Uniform random number in the interval [0,2\\pi] !! representing the gyro-angle. INTEGER :: jj !! Particle iterator. ALLOCATE ( Vo ( spp % ppp )) ALLOCATE ( V1 ( spp % ppp )) ALLOCATE ( V2 ( spp % ppp )) ALLOCATE ( V3 ( spp % ppp )) ALLOCATE ( b1 ( spp % ppp , 3 )) ALLOCATE ( b2 ( spp % ppp , 3 )) ALLOCATE ( b3 ( spp % ppp , 3 )) ALLOCATE ( theta ( spp % ppp ) ) ! * * * * INITIALIZE VELOCITY * * * * call init_random_seed () call RANDOM_NUMBER ( theta ) theta = 2.0_rp * C_PI * theta if ( spp % spatial_distribution . eq . 'TRACER' ) theta = 2.0 * C_PI Vo = SQRT ( 1.0_rp - 1.0_rp / ( spp % vars % g (:) ** 2 ) ) V1 = Vo * COS ( C_PI * spp % vars % eta / 18 0.0_rp ) V2 = Vo * SIN ( C_PI * spp % vars % eta / 18 0.0_rp ) * COS ( theta ) V3 = Vo * SIN ( C_PI * spp % vars % eta / 18 0.0_rp ) * SIN ( theta ) call unitVectors ( params , spp % vars % X , F , b1 , b2 , b3 , spp % vars % flagCon , & spp % vars % cart , spp % vars % hint ) !! Call to subroutine [[unitVectors]] in [[korc_fields]]. !write(output_unit_write,*) 'X',spp%vars%X !write(output_unit_write,*) 'b-hat',b1 do jj = 1_idef , spp % ppp if ( spp % vars % flagCon ( jj ) . EQ . 1_idef ) then spp % vars % V ( jj , 1 ) = V1 ( jj ) * b1 ( jj , 1 ) + V2 ( jj ) * b2 ( jj , 1 ) + V3 ( jj ) * b3 ( jj , 1 ) spp % vars % V ( jj , 2 ) = V1 ( jj ) * b1 ( jj , 2 ) + V2 ( jj ) * b2 ( jj , 2 ) + V3 ( jj ) * b3 ( jj , 2 ) spp % vars % V ( jj , 3 ) = V1 ( jj ) * b1 ( jj , 3 ) + V2 ( jj ) * b2 ( jj , 3 ) + V3 ( jj ) * b3 ( jj , 3 ) end if end do !    write(output_unit_write,'(\"Vx: \",E17.10)') spp%vars%V(:,1) !    write(output_unit_write,'(\"Vy: \",E17.10)') spp%vars%V(:,2) !    write(output_unit_write,'(\"Vz: \",E17.10)') spp%vars%V(:,3) DEALLOCATE ( theta ) DEALLOCATE ( Vo ) DEALLOCATE ( V1 ) DEALLOCATE ( V2 ) DEALLOCATE ( V3 ) DEALLOCATE ( b1 ) DEALLOCATE ( b2 ) DEALLOCATE ( b3 ) end subroutine gyro_distribution","tags":"","loc":"proc/gyro_distribution.html"},{"title":"initial_gyro_distribution – KORC-Full Orbit","text":"public subroutine initial_gyro_distribution(params, F, spp) Note Subroutine that works as an interface for initializing various \n gyro-angle distributions for the different simulated particle\n species. Todo At this moment this subroutine only calls the subroutine\n to generate \n a uniform gyro-angle distribution. This will be modified later. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. This structure has \n the information of the magnetic field. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters \n and simulation variables of the different species in the simulation. Contents Source Code initial_gyro_distribution Source Code subroutine initial_gyro_distribution ( params , F , spp ) !! @note Subroutine that works as an interface for initializing various !! gyro-angle distributions for the different simulated particle !! species. @endnote !! @todo At this moment this subroutine only calls the subroutine !! to generate !! a uniform gyro-angle distribution. This will be modified later. @endtodo TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. This structure has !! the information of the magnetic field. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. INTEGER :: ss !! Species iterator. do ss = 1_idef , params % num_species SELECT CASE ( TRIM ( spp ( ss )% energy_distribution )) CASE ( 'THERMAL' ) !Nothing, all was done in initialize_particles through !thermal_distribution CASE DEFAULT call gyro_distribution ( params , F , spp ( ss )) END SELECT end do end subroutine initial_gyro_distribution","tags":"","loc":"proc/initial_gyro_distribution.html"},{"title":"prime – KORC-Full Orbit","text":"private function prime(n) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 PRIME returns any of the first PRIME_MAX prime numbers. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n Return Value integer(kind=4) Contents Source Code prime Source Code function prime ( n ) !*****************************************************************************80 ! !! PRIME returns any of the first PRIME_MAX prime numbers. ! !  Discussion: ! !    PRIME_MAX is 1600, and the largest prime stored is 13499. ! !    Thanks to Bart Vandewoestyne for pointing out a typo, 18 February 2005. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 February 2005 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    Milton Abramowitz, Irene Stegun, !    Handbook of Mathematical Functions, !    US Department of Commerce, 1964, pages 870-873. ! !    Daniel Zwillinger, !    CRC Standard Mathematical Tables and Formulae, !    30th Edition, !    CRC Press, 1996, pages 95-98. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the index of the desired prime number. !    In general, is should be true that 0 <= N <= PRIME_MAX. !    N = -1 returns PRIME_MAX, the index of the largest prime available. !    N = 0 is legal, returning PRIME = 1. ! !    Output, integer ( kind = 4 ) PRIME, the N-th prime.  If N is out of range, !    PRIME is returned as -1. ! implicit none integer ( kind = 4 ), parameter :: prime_max = 1600 integer ( kind = 4 ), save :: icall = 0 integer ( kind = 4 ) n integer ( kind = 4 ), save , dimension ( prime_max ) :: npvec integer ( kind = 4 ) prime if ( icall == 0 ) then icall = 1 npvec ( 1 : 100 ) = ( / & 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , & 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , & 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , & 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , & 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , & 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , & 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , & 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , & 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , & 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 / ) npvec ( 101 : 200 ) = ( / & 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , & 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , & 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , & 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , & 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , & 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , & 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , & 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , & 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , & 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 / ) npvec ( 201 : 300 ) = ( / & 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , & 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , & 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , & 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , & 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , & 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , & 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , & 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , & 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , & 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 / ) npvec ( 301 : 400 ) = ( / & 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , & 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , & 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , & 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , & 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , & 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , & 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , & 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , & 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , & 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 / ) npvec ( 401 : 500 ) = ( / & 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , & 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , & 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , & 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , & 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , & 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , & 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , & 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , & 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , & 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 / ) npvec ( 501 : 600 ) = ( / & 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , & 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , & 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , & 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , & 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , & 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , & 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , & 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , & 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , & 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 / ) npvec ( 601 : 700 ) = ( / & 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , & 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , & 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , & 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , & 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , & 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , & 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , & 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , & 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , & 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 / ) npvec ( 701 : 800 ) = ( / & 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , & 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , & 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , & 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , & 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , & 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , & 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , & 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , & 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , & 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 / ) npvec ( 801 : 900 ) = ( / & 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , & 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , & 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , & 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , & 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , & 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , & 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , & 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , & 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , & 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 / ) npvec ( 901 : 1000 ) = ( / & 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , & 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , & 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , & 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , & 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , & 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , & 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , & 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , & 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , & 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 / ) npvec ( 1001 : 1100 ) = ( / & 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , & 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , & 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , & 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , & 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , & 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , & 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , & 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , & 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , & 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 / ) npvec ( 1101 : 1200 ) = ( / & 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , & 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , & 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , & 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , & 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , & 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , & 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , & 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , & 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , & 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 / ) npvec ( 1201 : 1300 ) = ( / & 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , & 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , & 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , & 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , & 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , & 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , & 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , & 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , & 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , & 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 / ) npvec ( 1301 : 1400 ) = ( / & 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , & 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , & 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , & 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , & 11069 , 11071 , 11083 , 11087 , 11093 , 11113 , 11117 , 11119 , 11131 , 11149 , & 11159 , 11161 , 11171 , 11173 , 11177 , 11197 , 11213 , 11239 , 11243 , 11251 , & 11257 , 11261 , 11273 , 11279 , 11287 , 11299 , 11311 , 11317 , 11321 , 11329 , & 11351 , 11353 , 11369 , 11383 , 11393 , 11399 , 11411 , 11423 , 11437 , 11443 , & 11447 , 11467 , 11471 , 11483 , 11489 , 11491 , 11497 , 11503 , 11519 , 11527 , & 11549 , 11551 , 11579 , 11587 , 11593 , 11597 , 11617 , 11621 , 11633 , 11657 / ) npvec ( 1401 : 1500 ) = ( / & 11677 , 11681 , 11689 , 11699 , 11701 , 11717 , 11719 , 11731 , 11743 , 11777 , & 11779 , 11783 , 11789 , 11801 , 11807 , 11813 , 11821 , 11827 , 11831 , 11833 , & 11839 , 11863 , 11867 , 11887 , 11897 , 11903 , 11909 , 11923 , 11927 , 11933 , & 11939 , 11941 , 11953 , 11959 , 11969 , 11971 , 11981 , 11987 , 12007 , 12011 , & 12037 , 12041 , 12043 , 12049 , 12071 , 12073 , 12097 , 12101 , 12107 , 12109 , & 12113 , 12119 , 12143 , 12149 , 12157 , 12161 , 12163 , 12197 , 12203 , 12211 , & 12227 , 12239 , 12241 , 12251 , 12253 , 12263 , 12269 , 12277 , 12281 , 12289 , & 12301 , 12323 , 12329 , 12343 , 12347 , 12373 , 12377 , 12379 , 12391 , 12401 , & 12409 , 12413 , 12421 , 12433 , 12437 , 12451 , 12457 , 12473 , 12479 , 12487 , & 12491 , 12497 , 12503 , 12511 , 12517 , 12527 , 12539 , 12541 , 12547 , 12553 / ) npvec ( 1501 : 1600 ) = ( / & 12569 , 12577 , 12583 , 12589 , 12601 , 12611 , 12613 , 12619 , 12637 , 12641 , & 12647 , 12653 , 12659 , 12671 , 12689 , 12697 , 12703 , 12713 , 12721 , 12739 , & 12743 , 12757 , 12763 , 12781 , 12791 , 12799 , 12809 , 12821 , 12823 , 12829 , & 12841 , 12853 , 12889 , 12893 , 12899 , 12907 , 12911 , 12917 , 12919 , 12923 , & 12941 , 12953 , 12959 , 12967 , 12973 , 12979 , 12983 , 13001 , 13003 , 13007 , & 13009 , 13033 , 13037 , 13043 , 13049 , 13063 , 13093 , 13099 , 13103 , 13109 , & 13121 , 13127 , 13147 , 13151 , 13159 , 13163 , 13171 , 13177 , 13183 , 13187 , & 13217 , 13219 , 13229 , 13241 , 13249 , 13259 , 13267 , 13291 , 13297 , 13309 , & 13313 , 13327 , 13331 , 13337 , 13339 , 13367 , 13381 , 13397 , 13399 , 13411 , & 13417 , 13421 , 13441 , 13451 , 13457 , 13463 , 13469 , 13477 , 13487 , 13499 / ) end if if ( n == - 1 ) then prime = prime_max else if ( n == 0 ) then prime = 1 else if ( n <= prime_max ) then prime = npvec ( n ) else prime = - 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'PRIME - Fatal error!' write ( * , '(a,i8)' ) '  Illegal prime index N = ' , n write ( * , '(a,i8)' ) '  N should be between 1 and PRIME_MAX =' , prime_max stop 1 end if return end function prime","tags":"","loc":"proc/prime.html"},{"title":"generate_2D_hammersley_sequence – KORC-Full Orbit","text":"public subroutine generate_2D_hammersley_sequence(ID, NMPIS, X, Y) @brief Subroutine for generating a 2-D Hammersley sequence.\n @details This subroutine uses the algorithm for generating a 1-D Hammersley sequence.\n Each MPI process in KORC generates a (different) subset of pairs (X,Y) of a 2-D Hammersley sequence. The total number of pairs (X,Y)\n is NMPIS*N, where NMPIS is the number of MPI processes in the simulation and N is the number of particles followed by each MPI process.\n Each subset of pairs (X,Y) has N elements. @param[in,out] X 1-D array with elements of a 2-D Hammersley sequence.\n @param[in,out] Y 1-D array with elements of a 2-D Hammersley sequence.\n @param[in] ID MPI rank of MPI process.\n @param[in] NMPIS Total number of MPI processes in the simulation.\n @param N Number of particles per MPI process.\n @param offset An offset to indicate the subroutine what subset of the 2-D Harmmersley sequence will be generated.\n @param ii Particle iterator. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ID integer, intent(in) :: NMPIS real(kind=rp), intent(inout), DIMENSION(:) :: X real(kind=rp), intent(inout), DIMENSION(:) :: Y Contents Source Code generate_2D_hammersley_sequence Source Code subroutine generate_2D_hammersley_sequence ( ID , NMPIS , X , Y ) REAL ( rp ), DIMENSION (:), INTENT ( INOUT ) :: X REAL ( rp ), DIMENSION (:), INTENT ( INOUT ) :: Y INTEGER , INTENT ( IN ) :: ID INTEGER , INTENT ( IN ) :: NMPIS INTEGER ( 4 ) :: N INTEGER ( 4 ) :: offset REAL ( 8 ), DIMENSION ( 2 ) :: R INTEGER ( 4 ) :: ii N = INT ( SIZE ( X ), 4 ) offset = ( INT ( ID + 1_idef , 4 ) - 1 _ 4 ) * N !\twrite(output_unit_write,'(\"MPI process: \",I5,\" offset: \",I5)') ID, offset do ii = 1 _ 4 , N call hammersley ( ii + INT ( offset , 4 ), 2 _ 4 , N * INT ( NMPIS , 4 ), R ) X ( ii ) = REAL ( R ( 1 ), rp ) Y ( ii ) = REAL ( R ( 2 ), rp ) end do end subroutine generate_2D_hammersley_sequence","tags":"","loc":"proc/generate_2d_hammersley_sequence.html"},{"title":"hammersley – KORC-Full Orbit","text":"public subroutine hammersley(i, m, n, r) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 HAMMERSLEY computes an element of a Hammersley sequence. Arguments Type Intent Optional Attributes Name integer(kind=4) :: i integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: r (m) Contents Source Code hammersley Source Code subroutine hammersley ( i , m , n , r ) !*****************************************************************************80 ! !! HAMMERSLEY computes an element of a Hammersley sequence. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    20 August 2016 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    John Hammersley, !    Monte Carlo methods for solving multivariable problems, !    Proceedings of the New York Academy of Science, !    Volume 86, 1960, pages 844-874. ! !  Parameters: ! !    Input, integer ( kind = 4 ) I, the index of the element of the sequence. !    0 <= I. ! !    Input, integer ( kind = 4 ) M, the spatial dimension. ! !    Input, integer ( kind = 4 ) N, the \"base\" for the first component. !    1 <= N. ! !    Output, real ( kind = 8 ) R(M), the element of the sequence with index I. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) d integer ( kind = 4 ) i integer ( kind = 4 ) i1 integer ( kind = 4 ) j integer ( kind = 4 ) n !  integer ( kind = 4 ) prime real ( kind = 8 ) prime_inv ( 2 : m ) real ( kind = 8 ) r ( m ) integer ( kind = 4 ) t ( 2 : m ) t ( 2 : m ) = abs ( i ) ! !  Carry out the computation. ! do i1 = 2 , m prime_inv ( i1 ) = 1.0D+00 / real ( prime ( i1 - 1 ), kind = 8 ) end do r ( 1 ) = real ( mod ( i , n + 1 ), kind = 8 ) / real ( n , kind = 8 ) r ( 2 : m ) = 0.0D+00 do while ( any ( t ( 2 : m ) /= 0 ) ) do j = 2 , m d = mod ( t ( j ), prime ( j - 1 ) ) r ( j ) = r ( j ) + real ( d , kind = 8 ) * prime_inv ( j ) prime_inv ( j ) = prime_inv ( j ) / real ( prime ( j - 1 ), kind = 8 ) t ( j ) = ( t ( j ) / prime ( j - 1 ) ) end do end do return end subroutine hammersley","tags":"","loc":"proc/hammersley.html"},{"title":"hammersley_inverse – KORC-Full Orbit","text":"private subroutine hammersley_inverse(r, m, n, i) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 HAMMERSLEY_INVERSE inverts an element of the Hammersley sequence. Arguments Type Intent Optional Attributes Name real(kind=8) :: r (m) integer(kind=4) :: m integer(kind=4) :: n integer(kind=4) :: i Contents Source Code hammersley_inverse Source Code subroutine hammersley_inverse ( r , m , n , i ) !*****************************************************************************80 ! !! HAMMERSLEY_INVERSE inverts an element of the Hammersley sequence. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    20 August 2016 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, real ( kind = 8 ) R(M), the I-th element of the Hammersley sequence. !    0 <= R < 1.0 ! !    Input, integer ( kind = 4 ) M, the spatial dimension. ! !    Input, integer ( kind = 4 ) N, the \"base\" for the first component. !    1 <= N. ! !    Output, integer ( kind = 4 ) I, the index of the element of the sequence. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) d integer ( kind = 4 ) i integer ( kind = 4 ) n integer ( kind = 4 ) p real ( kind = 8 ) r ( m ) real ( kind = 8 ) t if ( any ( r ( 1 : m ) < 0.0D+00 ) . or . any ( 1.0D+00 < r ( 1 : m ) ) ) then write ( * , '(a)' ) '' write ( * , '(a)' ) 'HAMMERSLEY_INVERSE - Fatal error!' write ( * , '(a)' ) '  0 <= R <= 1.0 is required.' stop 1 end if if ( m < 1 ) then write ( * , '(a)' ) '' write ( * , '(a)' ) 'HAMMERSLEY_INVERSE - Fatal error!' write ( * , '(a)' ) '  1 <= M is required.' stop 1 end if if ( n < 1 ) then write ( * , '(a)' ) '' write ( * , '(a)' ) 'HAMMERSLEY_INVERSE - Fatal error!' write ( * , '(a)' ) '  1 <= N is required.' stop 1 end if ! !  Invert using the second component only, because working with base !  2 is accurate. ! if ( 2 <= m ) then i = 0 t = r ( 2 ) p = 1 do while ( t /= 0.0D+00 ) t = t * 2.0D+00 d = int ( t ) i = i + d * p p = p * 2 t = mod ( t , 1.0D+00 ) end do else i = nint ( real ( n , kind = 8 ) * r ( 1 ) ) end if return end subroutine hammersley_inverse","tags":"","loc":"proc/hammersley_inverse.html"},{"title":"hammersley_sequence – KORC-Full Orbit","text":"private subroutine hammersley_sequence(i1, i2, m, n, r) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 HAMMERSLEY_SEQUENCE computes elements I1 through I2 of a Hammersley sequence. Arguments Type Intent Optional Attributes Name integer(kind=4) :: i1 integer(kind=4) :: i2 integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: r (m,abs(i1-i2)+1) Contents Source Code hammersley_sequence Source Code subroutine hammersley_sequence ( i1 , i2 , m , n , r ) !*****************************************************************************80 ! !! HAMMERSLEY_SEQUENCE computes elements I1 through I2 of a Hammersley sequence. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    20 August 2016 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    John Hammersley, !    Monte Carlo methods for solving multivariable problems, !    Proceedings of the New York Academy of Science, !    Volume 86, 1960, pages 844-874. ! !  Parameters: ! !    Input, integer ( kind = 4 ) I1, I2, the indices of the first and last !    elements of the sequence.  0 <= I1, I2. ! !    Input, integer ( kind = 4 ) M, the spatial dimension. ! !    Input, integer ( kind = 4 ) N, the \"base\" for the first component. !    1 <= N. ! !    Output, real ( kind = 8 ) R(M,abs(I1-I2)+1), the elements of the sequence !    with indices I1 through I2. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) d integer ( kind = 4 ) i integer ( kind = 4 ) i1 integer ( kind = 4 ) i2 integer ( kind = 4 ) i3 integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) n !  integer ( kind = 4 ) prime real ( kind = 8 ) prime_inv ( 2 : m ) real ( kind = 8 ) r ( m , abs ( i1 - i2 ) + 1 ) integer ( kind = 4 ) t ( 2 : m ) if ( i1 <= i2 ) then i3 = + 1 else i3 = - 1 end if l = abs ( i2 - i1 ) + 1 r ( 1 : m , 1 : l ) = 0.0D+00 k = 0 do i = i1 , i2 , i3 t ( 2 : m ) = i ! !  Carry out the computation. ! do j = 2 , m prime_inv ( j ) = 1.0D+00 / real ( prime ( j - 1 ), kind = 8 ) end do k = k + 1 ; r ( 1 , k ) = real ( mod ( i , n + 1 ), kind = 8 ) / real ( n , kind = 8 ) do while ( any ( t ( 2 : m ) /= 0 ) ) do j = 2 , m d = mod ( t ( j ), prime ( j - 1 ) ) r ( j , k ) = r ( j , k ) + real ( d , kind = 8 ) * prime_inv ( j ) prime_inv ( j ) = prime_inv ( j ) / real ( prime ( j - 1 ), kind = 8 ) t ( j ) = ( t ( j ) / prime ( j - 1 ) ) end do end do end do return end subroutine hammersley_sequence","tags":"","loc":"proc/hammersley_sequence.html"},{"title":"r8mat_print – KORC-Full Orbit","text":"private subroutine r8mat_print(m, n, a, title) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Contents Source Code r8mat_print Source Code subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows in A. ! !    Input, integer ( kind = 4 ) N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print","tags":"","loc":"proc/r8mat_print.html"},{"title":"r8mat_print_some – KORC-Full Orbit","text":"private subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Contents Source Code r8mat_print_some Source Code subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    10 September 2009 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ( kind = 4 ) ILO, JLO, the first row and column to print. ! !    Input, integer ( kind = 4 ) IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) if ( m <= 0 . or . n <= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  (None)' return end if do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j end do write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) end if end do write ( * , '(i5,a,5a14)' ) i , ':' , ( ctemp ( j ), j = 1 , inc ) end do end do return end subroutine r8mat_print_some","tags":"","loc":"proc/r8mat_print_some.html"},{"title":"timestamp – KORC-Full Orbit","text":"private subroutine timestamp() @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None Contents Source Code timestamp Source Code subroutine timestamp ( ) !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    31 May 2001   9:45:54.872 AM ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 May 2013 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return end subroutine timestamp","tags":"","loc":"proc/timestamp.html"},{"title":"deg2rad – KORC-Full Orbit","text":"private function deg2rad(x) @brief Function that converts @f$x@f$ from degrees to radians. @param x Angle @f$x@f$ in degrees.\n @param deg2rad Angle @f$x@f$ converted to radians. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code deg2rad Source Code FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad","tags":"","loc":"proc/deg2rad.html"},{"title":"fGamma – KORC-Full Orbit","text":"private function fGamma(x, k, t) @brief Function that calculates the value of the Gamma distribution @f$f_\\Gamma(x,\\kappa,\\theta) =\n \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. @param x Variable @f$x@f$ of @f$f_\\Gamma(x,\\kappa,\\theta)@f$.\n @param k Shape factor @f$\\kappa@f$ of @f$f_\\Gamma(x,\\kappa,\\theta)@f$.\n @param t Scale factor @f$\\theta@f$ of @f$f_\\Gamma(x,\\kappa,\\theta)@f$.\n @param fGamma Computed value of @f$f_\\Gamma(x,\\kappa,\\theta)@f$. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: k real(kind=rp), intent(in) :: t Return Value real(kind=rp) Contents Source Code fGamma Source Code FUNCTION fGamma ( x , k , t ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ), INTENT ( IN ) :: k REAL ( rp ), INTENT ( IN ) :: t REAL ( rp ) :: fGamma fGamma = x ** ( k - 1.0_rp ) * EXP ( - x / t ) / ( GAMMA ( k ) * t ** k ) END FUNCTION fGamma","tags":"","loc":"proc/fgamma.html"},{"title":"fRE – KORC-Full Orbit","text":"private function fRE(p) Evaluation of the energy distribution function @f$f_{RE}(\\mathcal{E})@f$ of runaway electrons as function of the normalized momentum\n @f$p' = p/m_ec@f$. Here, @f$p'@f$ is the normalized momentum and @f$m_e@f$ and @f$c@f$ are the electron mass and the speed of light. @param p Normalized momentum @f$p' = p/m_ec@f$ of a given electron in the simulation.\n @param fRE Computed value of the energy distribution function of runaway electrons.\n @param Eo Normalized energy @f$\\mathcal{E}' = \\sqrt{1 + p'}@f$ of the the electron with normalized momentum @f$p'@f$. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: p Return Value real(kind=rp) Contents Source Code fRE Source Code FUNCTION fRE ( p ) REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRE REAL ( rp ) :: Eo ! In units of mc&#94;2 Eo = SQRT ( p ** 2.0_rp + 1.0_rp ) fRE = fGamma ( Eo , gamma_pdf_params % k , gamma_pdf_params % t * co ) END FUNCTION fRE","tags":"","loc":"proc/fre.html"},{"title":"random_norm – KORC-Full Orbit","text":"private function random_norm(mean, sigma) @brief Gaussian random number generator.\n @details This function returns a deviate of a Gaussian distribution @f$f_G(x;\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp{\\left( -(x-\\mu)&#94;2/2\\sigma&#94;2 \\right)}@f$,\n with mean @f$\\mu@f$, and standard deviation @f$\\sigma@f$. We use the Inverse Transform Sampling Method for sampling @f$x@f$. With this method we get @f$x = \\sqrt{-2\\log{(1-y)}}\\cos(2\\pi z)@f$,\n where @f$y@f$ and @f$z@f$ are uniform random numbers in the interval @f$[0,1]@f$. @param[in] mu Mean value @f$\\mu@f$ of the Gaussian distribution.\n @param[in] mu Standard deviation @f$\\sigma@f$ of the Gaussian distribution.\n @param random_norm Sampled number @f$x@f$ from the Gaussian distribution @f$f_G(x;\\mu,\\sigma)@f$.\n @param rand1 Uniform random number in the interval @f$[0,1]@f$.\n @param rand2 Uniform random number in the interval @f$[0,1]@f$. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Contents Source Code random_norm Source Code FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 REAL ( rp ) :: rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = SQRT ( - 2.0_rp * LOG ( 1.0_rp - rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm","tags":"","loc":"proc/random_norm~2.html"},{"title":"get_gamma_distribution – KORC-Full Orbit","text":"public subroutine get_gamma_distribution(params, g, go) @brief Subroutine that contains calls to subroutine to generate a gamma distribution for the energy distribution of a given\n species in the simulation. @param[in] params Core KORC simulation parameters.\n @param[in,out] g Relativistic gamma factor @f$\\gamma@f$ of the particles in a given species in the simulation. These are so that, they follow\n a Gamma distribution in energy. The parameters of the Gamma distributions are given by the user.\n @param[out] go Mean value of @f$\\gamma@f$ of the particles in a given species. used to calculate the minimum required time step to\n resolve in detail the full-orbit dynamics of the particles. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(out) :: go Contents Source Code get_gamma_distribution Source Code SUBROUTINE get_gamma_distribution ( params , g , go ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), INTENT ( OUT ) :: go call initialize_gamma_params ( params ) call save_gamma_params ( params ) call sample_gamma_distribution ( params , g , go ) END SUBROUTINE get_gamma_distribution","tags":"","loc":"proc/get_gamma_distribution.html"},{"title":"initialize_gamma_params – KORC-Full Orbit","text":"private subroutine initialize_gamma_params(params) @brief Subroutine that reads from the input file the parameters of the Gamma distribution\n @f$f_\\Gamma(x,\\kappa,\\theta) = \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. @param[in] params Core KORC simulation parameters.\n @param max_energy Maximum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV.\n @param min_energy Minimum energy of sampled @f$f_\\Gamma(x,\\kappa,\\theta)@f$ in MeV.\n @param k Shape factor @f$\\kappa@f$.\n @param t Scale factor @f$\\theta@f$. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code initialize_gamma_params Source Code SUBROUTINE initialize_gamma_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ) :: max_energy REAL ( rp ) :: min_energy REAL ( rp ) :: k REAL ( rp ) :: t !NAMELIST /EnergyGammaPDF/ max_energy,min_energy,k,t !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=EnergyGammaPDF) !close(default_unit_open) gamma_pdf_params % min_energy = min_energy_gamma * C_E ! In Joules gamma_pdf_params % max_energy = max_energy_gamma * C_E ! In Joules gamma_pdf_params % k = k_gamma gamma_pdf_params % t = t_gamma gamma_pdf_params % max_p = SQRT (( gamma_pdf_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc gamma_pdf_params % min_p = SQRT (( gamma_pdf_params % min_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc END SUBROUTINE initialize_gamma_params","tags":"","loc":"proc/initialize_gamma_params.html"},{"title":"sample_gamma_distribution – KORC-Full Orbit","text":"private subroutine sample_gamma_distribution(params, g, go) @brief Subroutine that samples a Gamma distribution representing the runaways' (marginal) energy distribution function.\n @details This subroutine uses the Metropolis-Hastings method for sampling the Gamma distribution representing the runaways'\n (marginal) energy distribution function. Unlike the typical Metropolis-Hasting method, after setting the boundaries of the region\n we want to sample, we perform a sampling in a larger region that contains the original sampling area plus a buffer region.\n After finishing the first sampling, we only keep the particles in the original sampling region, the particles in the p_buffer\n are sampled again until all of them lie within the original sampling region. This method ensures that the boundaries are\n well sampled. @param[in] params Core KORC simulation parameters.\n @param[in,out] g Relativistic gamma factor @f$\\gamma@f$ of the particles in a given species in the simulation. These are so that,\n they follow a Gamma distribution in energy. The parameters of the Gamma distributions are given by the user.\n @param[out] go Mean value of @f$\\gamma@f$ of the particles in a given species. used to calculate the minimum required time step to\n resolve in detail the full-orbit dynamics of the particles.\n @param p Sampled normalized momentum @f$p' = p/m_ec@f$ of particles in a given particle species.\n @param p_buffer Size along the momentum axis of the buffer used in the Metropolis-Hastings method.\n @param p_test The test value of the normalized momentum used in the Metropolis-Hastings method.\n @param ratio Ratio of probabilities used to determine when a move in during the sampling is kept as part of the sampled chain.\n @param rand_unif A deviate of a uniform random distribution in the interval @f$[0,1]@f$.\n @param p_samples Temporary array to keep the sampled normalized momentum.\n @param deta Step size along the pitch-angle direction of the random walk used in the Metropolis-Hastings sampling.\n @param dp  Step size along the momentum direction of the random walk used in the Metropolis-Hastings sampling.\n @param ii Iterator.\n @param ppp Number of particles per MPI processes.\n @param nsamples Number of total samples in the initial condition of a given simulation.\n @param mpierr MPI error status. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(out) :: go Contents Source Code sample_gamma_distribution Source Code SUBROUTINE sample_gamma_distribution ( params , g , go ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: p_buffer REAL ( rp ) :: p_test REAL ( rp ) :: ratio REAL ( rp ) :: rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_samples REAL ( rp ) :: deta REAL ( rp ) :: dp INTEGER :: ii INTEGER :: ppp INTEGER :: nsamples INTEGER :: mpierr ppp = SIZE ( g ) nsamples = ppp * params % mpi_params % nmpi ALLOCATE ( p ( ppp )) dp = 1.0_rp if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( p_samples ( nsamples )) ! Number of samples to distribute among all MPI processes call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) p_buffer = gamma_pdf_params % min_p + ( gamma_pdf_params % max_p - gamma_pdf_params % min_p ) * rand_unif ii = 2_idef do while ( ii . LE . 1000000_idef ) p_test = p_buffer + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . gamma_pdf_params % min_p ). OR .( p_test . GT . gamma_pdf_params % max_p )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( p_test ) / fRE ( p_buffer ) if ( ratio . GE . 1.0_rp ) then p_buffer = p_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_buffer = p_test ii = ii + 1_idef end if end if end do call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) p_samples ( 1 ) = p_buffer ii = 2_idef do while ( ii . LE . nsamples ) p_test = p_samples ( ii - 1 ) + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . gamma_pdf_params % min_p ). OR .( p_test . GT . gamma_pdf_params % max_p )) p_test = p_samples ( ii - 1 ) + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( p_test ) / fRE ( p_samples ( ii - 1 )) if ( ratio . GE . 1.0_rp ) then p_samples ( ii ) = p_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_samples ( ii ) = p_test ii = ii + 1_idef end if end if end do go = SUM ( SQRT ( 1.0_rp + p_samples ** 2 )) / nsamples end if CALL MPI_SCATTER ( p_samples , ppp , MPI_REAL8 , p , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( go , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) g = SQRT ( 1.0_rp + p ** 2 ) DEALLOCATE ( p ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( p_samples ) end if END SUBROUTINE sample_gamma_distribution","tags":"","loc":"proc/sample_gamma_distribution.html"},{"title":"save_gamma_params – KORC-Full Orbit","text":"private subroutine save_gamma_params(params) @brief Surboutine that saves the Gamma distribution parameters to the HDF5 file gamma_distribution_parameters.h5 . @param[in] params Core KORC simulation parameters.\n @param filename String containing the name of the HDF5 file.\n @param gname String containing the group name of a set of KORC parameters.\n @param attr_array An 1-D array with attributes of 1-D real or integer arrays that are passed to KORC interfaces of HDF5 I/O subroutines.\n @param dset Name of data set to be saved to file.\n @param attr A single attributes of real or integer data that is passed to KORC interfaces of HDF5 I/O subroutines.\n @param h5file_id HDF5 file identifier.\n @param group_id HDF5 group identifier.\n @param h5error HDF5 error status.\n @param units Temporary variable used to add physical units to KORC parameters. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_gamma_params Source Code SUBROUTINE save_gamma_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"gamma_distribution_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * gamma_pdf_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * gamma_pdf_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % max_p , attr ) dset = TRIM ( gname ) // \"/min_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % min_p , attr ) dset = TRIM ( gname ) // \"/k\" attr = \"Shape factor\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % k , attr ) dset = TRIM ( gname ) // \"/t\" attr = \"Scale factor\" call save_to_hdf5 ( h5file_id , dset , gamma_pdf_params % t , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_gamma_params","tags":"","loc":"proc/save_gamma_params.html"},{"title":"cross – KORC-Full Orbit","text":"private pure function cross(a, b) Note Function that calculates and returns the cross product . These vectors are in Cartesian\n coordinates. Note Notice that all the variables in this subroutine have been\n normalized using the characteristic scales in korc_units . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: a Vector . real(kind=rp), intent(in), DIMENSION(3) :: b Vector . Return Value real(kind=rp),\n  DIMENSION(3) Value of Contents Source Code cross Source Code pure function cross ( a , b ) !! @note Function that calculates and returns the cross product !! \\mathbf{a}\\times \\mathbf{b}. These vectors are in Cartesian !! coordinates. @endnote !! @note Notice that all the variables in this subroutine have been !! normalized using the characteristic scales in [[korc_units]]. @endnote REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: a !! Vector \\mathbf{a}. REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: b !! Vector \\mathbf{b}. REAL ( rp ), DIMENSION ( 3 ) :: cross !!Value of \\mathbf{a}\\times \\mathbf{b} cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross","tags":"","loc":"proc/cross.html"},{"title":"deg2rad – KORC-Full Orbit","text":"public function deg2rad(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code deg2rad Source Code FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad","tags":"","loc":"proc/deg2rad~3.html"},{"title":"rad2deg – KORC-Full Orbit","text":"public function rad2deg(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code rad2deg Source Code FUNCTION rad2deg ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: rad2deg rad2deg = x * 18 0.0_rp / C_PI END FUNCTION rad2deg","tags":"","loc":"proc/rad2deg~2.html"},{"title":"initialize_particle_pusher – KORC-Full Orbit","text":"public subroutine initialize_particle_pusher(params) Note This subroutine initializes all the variables needed for advancing\n the particles' position and velocity. This subroutine is specially useful when we need to define or initialize\n values of parameters used to calculate derived quantities.\n The intent of this subroutine is to work as a constructor of the module. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. Contents Source Code initialize_particle_pusher Source Code subroutine initialize_particle_pusher ( params ) !! @note This subroutine initializes all the variables needed for advancing !! the particles' position and velocity. @endnote !! This subroutine is specially useful when we need to define or initialize !! values of parameters used to calculate derived quantities. !! The intent of this subroutine is to work as a constructor of the module. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. E0 = C_E0 * ( params % cpp % mass ** 2 * params % cpp % velocity ** 3 ) / & ( params % cpp % charge ** 3 * params % cpp % Bo ) end subroutine initialize_particle_pusher","tags":"","loc":"proc/initialize_particle_pusher.html"},{"title":"radiation_force_p – KORC-Full Orbit","text":"private subroutine radiation_force_p(pchunk, q_cache, m_cache, U_X, U_Y, U_Z, E_X, E_Y, E_Z, B_X, B_Y, B_Z, Frad_X, Frad_Y, Frad_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(pchunk) :: U_X , where is the\n particle's velocity. real(kind=rp), intent(in), DIMENSION(pchunk) :: U_Y , where is the\n particle's velocity. real(kind=rp), intent(in), DIMENSION(pchunk) :: U_Z , where is the\n particle's velocity. real(kind=rp), intent(in), DIMENSION(pchunk) :: E_X Electric field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: E_Y Electric field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: E_Z Electric field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: B_X Magnetic field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: B_Y Magnetic field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: B_Z Magnetic field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(out), DIMENSION(pchunk) :: Frad_X The calculated synchrotron radiation reaction force . real(kind=rp), intent(out), DIMENSION(pchunk) :: Frad_Y The calculated synchrotron radiation reaction force . real(kind=rp), intent(out), DIMENSION(pchunk) :: Frad_Z The calculated synchrotron radiation reaction force . Contents Source Code radiation_force_p Source Code subroutine radiation_force_p ( pchunk , q_cache , m_cache , U_X , U_Y , U_Z , E_X , E_Y , E_Z , & B_X , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: U_X , U_Y , U_Z !! \\mathbf{u} = \\gamma \\mathbf{v}, where \\mathbf{v} is the !! particle's velocity. REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z !! Electric field \\mathbf{E} seen by each particle. This is given !! in Cartesian coordinates. REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z !! Magnetic field \\mathbf{B} seen by each particle. This is given !! in Cartesian coordinates. REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Frad_X , Frad_Y , Frad_Z !! The calculated synchrotron radiation reaction force \\mathbf{F}_R. REAL ( rp ), DIMENSION ( 3 ) :: F1 !! The component \\mathbf{F}_1 of \\mathbf{F}_R. REAL ( rp ), DIMENSION ( pchunk ) :: F2_X , F2_Y , F2_Z !! The component \\mathbf{F}_2 of \\mathbf{F}_R. REAL ( rp ), DIMENSION ( pchunk ) :: F3_X , F3_Y , F3_Z !! The component \\mathbf{F}_3 of \\mathbf{F}_R. REAL ( rp ), DIMENSION ( pchunk ) :: V_X , V_Y , V_Z !! The particle's velocity \\mathbf{v}. REAL ( rp ), DIMENSION ( pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( pchunk ) :: cross_EB_X , cross_EB_Y , cross_EB_Z REAL ( rp ), DIMENSION ( pchunk ) :: cross_BV_X , cross_BV_Y , cross_BV_Z REAL ( rp ), DIMENSION ( pchunk ) :: cross_BBV_X , cross_BBV_Y , cross_BBV_Z REAL ( rp ), DIMENSION ( pchunk ) :: dot_EV , dot_vecvec !! An auxiliary 3-D vector. REAL ( rp ), DIMENSION ( pchunk ) :: g !! The relativistic \\gamma factor of the particle. REAL ( rp ) :: tmp INTEGER :: cc !$OMP SIMD !    !$OMP& aligned(g,U_X,U_Y,U_Z,V_X,V_Y,V_Z, & !    !$OMP& cross_EB_X,cross_EB_Y,cross_EB_Z,E_X,E_Y,E_Z,B_X,B_Y,B_Z, & !    !$OMP& dot_EV,cross_BV_X,cross_BV_Y,cross_BV_Z, & !    !$OMP& cross_BBV_X,cross_BBV_Y,cross_BBV_Z,F2_X,F2_Y,F2_Z, & !    !$OMP& vec_X,vec_Y,vec_Z,dot_vecvec,F3_X,F3_Y,F3_Z, & !    !$OMP& Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g ( cc ) = SQRT ( 1.0_rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) tmp = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_EB_X ( cc ) = E_Y ( cc ) * B_Z ( cc ) - E_Z ( cc ) * B_Y ( cc ) cross_EB_Y ( cc ) = E_Z ( cc ) * B_X ( cc ) - E_X ( cc ) * B_Z ( cc ) cross_EB_Z ( cc ) = E_X ( cc ) * B_Y ( cc ) - E_Y ( cc ) * B_X ( cc ) dot_EV ( cc ) = E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc ) cross_BV_X ( cc ) = B_Y ( cc ) * V_Z ( cc ) - B_Z ( cc ) * V_Y ( cc ) cross_BV_Y ( cc ) = B_Z ( cc ) * V_X ( cc ) - B_X ( cc ) * V_Z ( cc ) cross_BV_Z ( cc ) = B_X ( cc ) * V_Y ( cc ) - B_Y ( cc ) * V_X ( cc ) cross_BBV_X ( cc ) = B_Y ( cc ) * cross_BV_Z ( cc ) - B_Z ( cc ) * cross_BV_Y ( cc ) cross_BBV_Y ( cc ) = B_Z ( cc ) * cross_BV_X ( cc ) - B_X ( cc ) * cross_BV_Z ( cc ) cross_BBV_Z ( cc ) = B_X ( cc ) * cross_BV_Y ( cc ) - B_Y ( cc ) * cross_BV_X ( cc ) F2_X ( cc ) = tmp * ( dot_EV ( cc ) * E_X ( cc ) + cross_EB_X ( cc ) + cross_BBV_X ( cc ) ) F2_Y ( cc ) = tmp * ( dot_EV ( cc ) * E_Y ( cc ) + cross_EB_Y ( cc ) + cross_BBV_Y ( cc ) ) F2_Z ( cc ) = tmp * ( dot_EV ( cc ) * E_Z ( cc ) + cross_EB_Z ( cc ) + cross_BBV_Z ( cc ) ) vec_X ( cc ) = E_X ( cc ) - cross_BV_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) - cross_BV_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) - cross_BV_Z ( cc ) dot_vecvec ( cc ) = vec_X ( cc ) * vec_X ( cc ) + vec_Y ( cc ) * vec_Y ( cc ) + vec_Z ( cc ) * vec_Z ( cc ) F3_X ( cc ) = ( tmp * g ( cc ) ** 2 ) * ( dot_EV ( cc ) ** 2 - dot_vecvec ( cc ) ) * V_X ( cc ) F3_Y ( cc ) = ( tmp * g ( cc ) ** 2 ) * ( dot_EV ( cc ) ** 2 - dot_vecvec ( cc ) ) * V_Y ( cc ) F3_Z ( cc ) = ( tmp * g ( cc ) ** 2 ) * ( dot_EV ( cc ) ** 2 - dot_vecvec ( cc ) ) * V_Z ( cc ) Frad_X ( cc ) = F2_X ( cc ) + F3_X ( cc ) Frad_Y ( cc ) = F2_Y ( cc ) + F3_Y ( cc ) Frad_Z ( cc ) = F2_Z ( cc ) + F3_Z ( cc ) end do !$OMP END SIMD end subroutine radiation_force_p","tags":"","loc":"proc/radiation_force_p.html"},{"title":"FO_init – KORC-Full Orbit","text":"public subroutine FO_init(params, F, spp, output, step) Calls get_fields in korc_fields . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. logical, intent(in) :: output logical, intent(in) :: step Contents Source Code FO_init Source Code subroutine FO_init ( params , F , spp , output , step ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: Prad !! Total radiated power of each particle. REAL ( rp ) :: Bmag1 !! Magnitude of the magnetic field seen by each particle . REAL ( rp ) :: v !! Speed of each particle. REAL ( rp ) :: vpar !! Parallel velocity v_\\parallel = \\mathbf{v}\\cdot \\hat{b}. REAL ( rp ) :: vperp !! Perpendicular velocity v_\\parallel = |\\mathbf{v} - (\\mathbf{v}\\cdot !! \\hat{b})\\hat{b}|. REAL ( rp ) :: tmp !! Temporary variable used for various computations. REAL ( rp ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( 3 ) :: Frad !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( 3 ) :: vec !! Auxiliary vector used in various computations. REAL ( rp ), DIMENSION ( 3 ) :: b_unit !! Unitary vector pointing along the local magnetic field \\hat{b}. INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. LOGICAL , intent ( in ) :: output LOGICAL , intent ( in ) :: step REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , lam , R0 , q0 , ar TYPE ( C_PTR ), DIMENSION ( params % pchunk ) :: hint INTEGER ( is ) , DIMENSION ( params % pchunk ) :: flagCon , flagCol pchunk = params % pchunk B0 = F % Bo EF0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo ar = F % AB % a do ii = 1_idef , params % num_species m_cache = spp ( ii )% m q_cache = spp ( ii )% q if ( output ) then !$OMP PARALLEL DO default(none) & !$OMP firstprivate(m_cache,q_cache,B0,EF0,lam,R0,q0,ar,pchunk) & !$OMP& shared(params,ii,spp,F) & !$OMP& PRIVATE(pp,cc,X_X,X_Y,X_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,Y_R,Y_PHI,Y_Z,flagCon,flagCol,PSIp,hint) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) B_X ( cc ) = 0._rp B_Y ( cc ) = 0._rp B_Z ( cc ) = 0._rp E_X ( cc ) = 0._rp E_Y ( cc ) = 0._rp E_Z ( cc ) = 0._rp PSIp ( cc ) = 10 0._rp flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if ( params % field_model . eq . 'M3D_C1' ) then !$OMP SIMD do cc = 1_idef , pchunk hint ( cc ) = spp ( ii )% vars % hint ( pp - 1 + cc ) end do !$OMP END SIMD end if call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) if ( params % field_model ( 1 : 3 ). eq . 'ANA' ) then call analytical_fields_p ( pchunk , B0 , EF0 , R0 , q0 , lam , ar , & X_X , X_Y , X_Z , & B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon ) else if ( params % orbit_model ( 3 : 5 ). eq . 'new' ) then call interp_FOfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) else if ( params % orbit_model ( 3 : 5 ). eq . 'old' ) then call interp_FOfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) else if ( params % field_model . eq . 'M3D_C1' ) then call get_m3d_c1_FOmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_X , B_Y , B_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_FOelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_X , E_Y , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) end if !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD if ( params % field_model . eq . 'M3D_C1' ) then !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % hint ( pp - 1 + cc ) = hint ( cc ) end do !$OMP END SIMD end if end do !$OMP END PARALLEL DO !! Calls [[get_fields]] in [[korc_fields]]. ! Interpolates fields at local particles' position and keeps in ! spp%vars. Fields in (R,\\phi,Z) coordinates. !          write(output_unit_write,'(\"korc_ppusher\")') !          write(output_unit_write,'(\"B_X: \",E17.10)') spp(ii)%vars%B(:,1) !          write(output_unit_write,'(\"B_Z: \",E17.10)') spp(ii)%vars%B(:,2) !          write(output_unit_write,'(\"B_Y: \",E17.10)') spp(ii)%vars%B(:,3) !$OMP PARALLEL DO DEFAULT(none) SHARED(ii,spp) & !$OMP& FIRSTPRIVATE(E0) & !$OMP& PRIVATE(pp,b_unit,Bmag1,vpar,v,vperp,vec,tmp) do pp = 1_idef , spp ( ii )% ppp Bmag1 = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) ! Parallel unit vector b_unit = spp ( ii )% vars % B ( pp ,:) / Bmag1 !write(output_unit_write,*) 'X',spp(1)%vars%X !write(output_unit_write,*) 'b-hat',b_unit v = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % V ( pp ,:), spp ( ii )% vars % V ( pp ,:))) if ( v . GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar = DOT_PRODUCT ( spp ( ii )% vars % V ( pp ,:), b_unit ) vperp = DOT_PRODUCT ( spp ( ii )% vars % V ( pp ,:), & spp ( ii )% vars % V ( pp ,:)) & - vpar ** 2 if ( vperp . GE . korc_zero ) then vperp = SQRT ( vperp ) else vperp = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp ) = 18 0.0_rp * MODULO ( ATAN2 ( vperp , vpar ), & 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp ) = 0.5_rp * spp ( ii )% m * & spp ( ii )% vars % g ( pp ) ** 2 * vperp ** 2 / Bmag1 ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp = spp ( ii )% q ** 4 / ( 6.0_rp * C_PI * E0 * spp ( ii )% m ** 2 ) vec = spp ( ii )% vars % E ( pp ,:) + cross ( spp ( ii )% vars % V ( pp ,:), & spp ( ii )% vars % B ( pp ,:)) spp ( ii )% vars % Prad ( pp ) = tmp * ( DOT_PRODUCT ( spp ( ii )% & vars % E ( pp ,:), & spp ( ii )% vars % E ( pp ,:)) + & DOT_PRODUCT ( cross ( spp ( ii )% vars % V ( pp ,:), & spp ( ii )% vars % B ( pp ,:)), spp ( ii )% vars % E ( pp ,:)) + & spp ( ii )% vars % g ( pp ) ** 2 * & ( DOT_PRODUCT ( spp ( ii )% vars % E ( pp ,:), & spp ( ii )% vars % V ( pp ,:)) ** 2 - DOT_PRODUCT ( vec , vec )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp ) = spp ( ii )% q * DOT_PRODUCT ( & spp ( ii )% vars % E ( pp ,:), spp ( ii )% vars % V ( pp ,:)) else spp ( ii )% vars % eta ( pp ) = 0.0_rp spp ( ii )% vars % mu ( pp ) = 0.0_rp spp ( ii )% vars % Prad ( pp ) = 0.0_rp spp ( ii )% vars % Pin ( pp ) = 0.0_rp end if end do ! loop over particles on an mpi process !$OMP END PARALLEL DO end if !(if output) if ( step . and .(. not . params % FokPlan )) then dt = 0.5_rp * params % dt !$OMP PARALLEL DO FIRSTPRIVATE(dt) PRIVATE(pp,cc) & !$OMP& SHARED(ii,spp,params) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) + & dt * spp ( ii )% vars % V ( pp - 1 + cc , 1 ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) + & dt * spp ( ii )% vars % V ( pp - 1 + cc , 2 ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) + & dt * spp ( ii )% vars % V ( pp - 1 + cc , 3 ) end do !$OMP END SIMD end do !$OMP END PARALLEL DO end if !(if step) end do ! over species end subroutine FO_init","tags":"","loc":"proc/fo_init.html"},{"title":"adv_FOeqn_top – KORC-Full Orbit","text":"public subroutine adv_FOeqn_top(params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Contents Source Code adv_FOeqn_top Source Code subroutine adv_FOeqn_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: v , vpar , vperp REAL ( rp ), DIMENSION ( params % pchunk ) :: tmp REAL ( rp ), DIMENSION ( params % pchunk ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z , PSIp INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: B0 , EF0 , R0 , q0 , lam , ar REAL ( rp ) :: a , m_cache , q_cache REAL ( rp ) :: ne0 , Te0 , Zeff0 INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk m_cache = spp ( ii )% m q_cache = spp ( ii )% q a = q_cache * params % dt / m_cache B0 = F % Bo EF0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo ar = F % AB % a !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(E0,a,m_cache,q_cache,B0,EF0,lam,R0,q0,ar,pchunk)& !$OMP& shared(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,X_X,X_Y,X_Z,V_X,V_Y,V_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,b_unit_X,b_unit_Y,b_unit_Z,v,vpar,vperp,tmp, & !$OMP& cross_X,cross_Y,cross_Z,vec_X,vec_Y,vec_Z,g,flagCon,flagCol,PSIp) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) V_X ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_Y ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) V_Z ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 3 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) g ( cc ) = spp ( ii )% vars % g ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call analytical_fields_p ( pchunk , B0 , EF0 , R0 , q0 , lam , ar , X_X , X_Y , X_Z , & B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon ) call advance_FOeqn_vars ( tt , a , q_cache , m_cache , params , & X_X , X_Y , X_Z , V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & P , F , g , flagCon , flagCol , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = X_X ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = X_Y ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = X_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) end do !$OMP END SIMD else !$OMP SIMD do cc = 1_idef , pchunk B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) end do !$OMP END SIMD call advance_FP3Deqn_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , & g , m_cache , B0 , lam , R0 , q0 , EF0 , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & P , F , flagCon , flagCol , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD end if !$OMP SIMD !          !$OMP& aligned(Bmag,B_X,B_Y,B_Z, & !          !$OMP& b_unit_X,b_unit_Y,b_unit_Z,v,V_X,V_Y,V_Z,vpar, & !          !$OMP& vperp,tmp,cross_X,cross_Y,cross_Z, & !          !$OMP& vec_X,vec_Y,vec_Z,E_X,E_Y,E_Z) do cc = 1_idef , pchunk !Derived output data Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Parallel unit vector b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) v ( cc ) = SQRT ( V_X ( cc ) * V_X ( cc ) + V_Y ( cc ) * V_Y ( cc ) + V_Z ( cc ) * V_Z ( cc )) if ( v ( cc ). GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar ( cc ) = ( V_X ( cc ) * b_unit_X ( cc ) + V_Y ( cc ) * b_unit_Y ( cc ) + & V_Z ( cc ) * b_unit_Z ( cc )) vperp ( cc ) = v ( cc ) ** 2 - vpar ( cc ) ** 2 if ( vperp ( cc ) . GE . korc_zero ) then vperp ( cc ) = SQRT ( vperp ( cc ) ) else vperp ( cc ) = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp - 1 + cc ) = 18 0.0_rp * & MODULO ( ATAN2 ( vperp ( cc ), vpar ( cc )), 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.5_rp * m_cache * & g ( cc ) ** 2 * vperp ( cc ) ** 2 / Bmag ( cc ) ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp ( cc ) = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) vec_X ( cc ) = E_X ( cc ) + cross_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) + cross_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) + cross_Z ( cc ) spp ( ii )% vars % Prad ( pp - 1 + cc ) = tmp ( cc ) * & ( E_X ( cc ) * E_X ( cc ) + E_Y ( cc ) * E_Y ( cc ) + E_Z ( cc ) * E_Z ( cc ) + & cross_X ( cc ) * E_X ( cc ) + cross_Y ( cc ) * E_Y ( cc ) + & cross_Z ( cc ) * E_Z ( cc ) + g ( cc ) ** 2 * & (( E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) ** 2 & - vec_X ( cc ) * vec_X ( cc ) - vec_Y ( cc ) * vec_Y ( cc ) - & vec_Z ( cc ) * vec_Z ( cc )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp - 1 + cc ) = q_cache * ( E_X ( cc ) * V_X ( cc ) + & E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) else spp ( ii )% vars % eta ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Prad ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Pin ( pp - 1 + cc ) = 0.0_rp end if end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_FOeqn_top","tags":"","loc":"proc/adv_foeqn_top.html"},{"title":"advance_FOeqn_vars – KORC-Full Orbit","text":"public subroutine advance_FOeqn_vars(tt, a, q_cache, m_cache, params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, P, F, g, flagCon, flagCol, PSIp) Calls radiation_force in korc_ppusher . Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: a This variable is used to simplify notation in the code, and\n is given by , real(kind=rp), intent(in) :: q_cache Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: m_cache Time step used in the leapfrog step ( ). type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FOeqn_vars Source Code subroutine advance_FOeqn_vars ( tt , a , q_cache , m_cache , params , X_X , X_Y , X_Z , & V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , P , F , g , flagCon , flagCol , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. INTEGER ( ip ), INTENT ( IN ) :: tt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), INTENT ( in ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( params % pchunk ) :: sigma !! This variable is \\sigma = \\gamma'&#94;2 - \\tau&#94;2 in the above equations. REAL ( rp ), DIMENSION ( params % pchunk ) :: us !! This variable is u&#94;{*} = p&#94;{*}/m where  p&#94;{*} = !! \\mathbf{p}'\\cdot \\mathbf{\\tau}/mc. !! Variable 'u&#94;*' in Vay, J.-L. PoP (200params%pchunk). REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: gp , g0 !! Relativistic factor \\gamma. REAL ( rp ), DIMENSION ( params % pchunk ) :: s !! This variable is s = 1/(1+t&#94;2) in the equations above. !! Variable 's' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ) :: U_hs_X , U_hs_Y , U_hs_Z !! Is \\mathbf{u}=\\mathbf{p}/m at half-time step (i+1/2) in !! the absence of radiation losses or collisions. \\mathbf{u}&#94;{i+1/2} = !! \\mathbf{u}&#94;i + \\frac{q\\Delta t}{2m}\\left( \\mathbf{E}&#94;{i+1/2} + !! \\mathbf{v}&#94;i\\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: tau_X , tau_Y , tau_Z !! This variable is \\mathbf{\\tau} = (q\\Delta t/2)\\mathbf{B}&#94;{i+1/2}. REAL ( rp ), DIMENSION ( params % pchunk ) :: up_X , up_Y , up_Z !! This variable is \\mathbf{u}'= \\mathbf{p}'/m, where \\mathbf{p}' !! = \\mathbf{p}&#94;i + q\\Delta t \\left( \\mathbf{E}&#94;{i+1/2} + !! \\frac{\\mathbf{v}&#94;i}{2} \\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: t_X , t_Y , t_Z !! This variable is \\mathbf{t} = {\\mathbf \\tau}/\\gamma&#94;{i+1}. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: U_L_X , U_L_Y , U_L_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_RC_X , U_RC_Y , U_RC_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_os_X , U_os_Y , U_os_Z !! This variable is \\mathbf{u}&#94;{i+1}= \\mathbf{p}&#94;{i+1}/m. REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Frad_X , Frad_Y , Frad_Z !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff , Y_R , Y_PHI , Y_Z INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( inout ) :: flagCon , flagCol dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(g0,g,U_X,U_Y,U_Z,V_X,V_Y,V_Z,Bmag,B_X,B_Y,B_Z, & !    !$OMP& U_L_X,U_L_Y,U_L_Z,U_RC_X,U_RC_Y,U_RC_Z, & !    !$OMP& cross_X,cross_Y,cross_Z,U_hs_X,U_hs_Y,U_hs_Z,E_X,E_Y,E_Z, & !    !$OMP& tau_X,tau_Y,tau_Z,up_X,up_Y,up_Z,gp,sigma,us,t_X,t_Y,t_Z,s, & !    !$OMP& U_os_X,U_os_Y,U_os_Z,Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g0 ( cc ) = g ( cc ) U_X ( cc ) = g ( cc ) * V_X ( cc ) U_Y ( cc ) = g ( cc ) * V_Y ( cc ) U_Z ( cc ) = g ( cc ) * V_Z ( cc ) ! Magnitude of magnetic field Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) U_L_X ( cc ) = U_X ( cc ) U_L_Y ( cc ) = U_Y ( cc ) U_L_Z ( cc ) = U_Z ( cc ) U_RC_X ( cc ) = U_X ( cc ) U_RC_Y ( cc ) = U_Y ( cc ) U_RC_Z ( cc ) = U_Z ( cc ) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) U_hs_X ( cc ) = U_L_X ( cc ) + 0.5_rp * a * ( E_X ( cc ) + cross_X ( cc )) U_hs_Y ( cc ) = U_L_Y ( cc ) + 0.5_rp * a * ( E_Y ( cc ) + cross_Y ( cc )) U_hs_Z ( cc ) = U_L_Z ( cc ) + 0.5_rp * a * ( E_Z ( cc ) + cross_Z ( cc )) tau_X ( cc ) = 0.5_rp * a * B_X ( cc ) tau_Y ( cc ) = 0.5_rp * a * B_Y ( cc ) tau_Z ( cc ) = 0.5_rp * a * B_Z ( cc ) up_X ( cc ) = U_hs_X ( cc ) + 0.5_rp * a * E_X ( cc ) up_Y ( cc ) = U_hs_Y ( cc ) + 0.5_rp * a * E_Y ( cc ) up_Z ( cc ) = U_hs_Z ( cc ) + 0.5_rp * a * E_Z ( cc ) gp ( cc ) = SQRT ( 1.0_rp + up_X ( cc ) * up_X ( cc ) + up_Y ( cc ) * up_Y ( cc ) + & up_Z ( cc ) * up_Z ( cc ) ) sigma ( cc ) = gp ( cc ) * gp ( cc ) - ( tau_X ( cc ) * tau_X ( cc ) + & tau_Y ( cc ) * tau_Y ( cc ) + tau_Z ( cc ) * tau_Z ( cc )) us ( cc ) = up_X ( cc ) * tau_X ( cc ) + up_Y ( cc ) * tau_Y ( cc ) + & up_Z ( cc ) * tau_Z ( cc ) ! variable 'u&#94;*' in Vay, J.-L. PoP (2008) g ( cc ) = SQRT ( 0.5_rp * ( sigma ( cc ) + SQRT ( sigma ( cc ) * sigma ( cc ) + & 4.0_rp * ( tau_X ( cc ) * tau_X ( cc ) + tau_Y ( cc ) * tau_Y ( cc ) + & tau_Z ( cc ) * tau_Z ( cc ) + us ( cc ) * us ( cc )))) ) t_X ( cc ) = tau_X ( cc ) / g ( cc ) t_Y ( cc ) = tau_Y ( cc ) / g ( cc ) t_Z ( cc ) = tau_Z ( cc ) / g ( cc ) s ( cc ) = 1.0_rp / ( 1.0_rp + t_X ( cc ) * t_X ( cc ) + t_Y ( cc ) * t_Y ( cc ) + & t_Z ( cc ) * t_Z ( cc )) ! variable 's' in Vay, J.-L. PoP (2008) cross_X ( cc ) = up_Y ( cc ) * t_Z ( cc ) - up_Z ( cc ) * t_Y ( cc ) cross_Y ( cc ) = up_Z ( cc ) * t_X ( cc ) - up_X ( cc ) * t_Z ( cc ) cross_Z ( cc ) = up_X ( cc ) * t_Y ( cc ) - up_Y ( cc ) * t_X ( cc ) U_L_X ( cc ) = s ( cc ) * ( up_X ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_X ( cc ) + cross_X ( cc )) U_L_Y ( cc ) = s ( cc ) * ( up_Y ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Y ( cc ) + cross_Y ( cc )) U_L_Z ( cc ) = s ( cc ) * ( up_Z ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Z ( cc ) + cross_Z ( cc )) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! U_os_X ( cc ) = 0.5_rp * ( U_L_X ( cc ) + U_X ( cc )) U_os_Y ( cc ) = 0.5_rp * ( U_L_Y ( cc ) + U_Y ( cc )) U_os_Z ( cc ) = 0.5_rp * ( U_L_Z ( cc ) + U_Z ( cc )) ! Splitting operator for including radiation if ( params % radiation ) then !! Calls [[radiation_force]] in [[korc_ppusher]]. call radiation_force_p ( pchunk , q_cache , m_cache , U_os_X , U_os_Y , U_os_Z , & E_X , E_Y , E_Z , B_Z , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) U_RC_X ( cc ) = U_RC_X ( cc ) + a * Frad_X ( cc ) / q_cache U_RC_Y ( cc ) = U_RC_Y ( cc ) + a * Frad_Y ( cc ) / q_cache U_RC_Z ( cc ) = U_RC_Z ( cc ) + a * Frad_Z ( cc ) / q_cache end if ! Splitting operator for including radiation U_X ( cc ) = U_L_X ( cc ) + U_RC_X ( cc ) - U_X ( cc ) U_Y ( cc ) = U_L_Y ( cc ) + U_RC_Y ( cc ) - U_Y ( cc ) U_Z ( cc ) = U_L_Z ( cc ) + U_RC_Z ( cc ) - U_Z ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end if if ( params % radiation . or . params % collisions ) then !$OMP SIMD !       !$OMP& aligned(g,U_X,U_Y,U_Z) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) end do !$OMP END SIMD end if !$OMP SIMD !    !$OMP& aligned(g,g0,V_X,V_Y,V_Z,U_X,U_Y,U_Z,X_X,X_Y,X_Z,flagCon,flagCol) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then g ( cc ) = g0 ( cc ) else V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end if X_X ( cc ) = X_X ( cc ) + dt * V_X ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Y ( cc ) = X_Y ( cc ) + dt * V_Y ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Z ( cc ) = X_Z ( cc ) + dt * V_Z ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) end do !$OMP END SIMD end subroutine advance_FOeqn_vars","tags":"","loc":"proc/advance_foeqn_vars.html"},{"title":"advance_FP3Deqn_vars – KORC-Full Orbit","text":"public subroutine advance_FP3Deqn_vars(params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, g, m_cache, B0, lam, R0, q0, EF0, B_X, B_Y, B_Z, E_X, E_Y, E_Z, P, F, flagCon, flagCol, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in) :: B0 real(kind=rp), intent(in) :: lam real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: q0 real(kind=rp), intent(in) :: EF0 real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FP3Deqn_vars Source Code subroutine advance_FP3Deqn_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , g , & m_cache , B0 , lam , R0 , q0 , EF0 , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & P , F , flagCon , flagCol , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon , flagCol REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), intent ( in ) :: B0 , EF0 , R0 , q0 , lam , m_cache pchunk = params % pchunk !    call analytical_fields_p(B0,EF0,R0,q0,lam,X_X,X_Y,X_Z, & !         B_X,B_Y,B_Z,E_X,E_Y,E_Z) !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk U_X ( cc ) = V_X ( cc ) * g ( cc ) U_Y ( cc ) = V_Y ( cc ) * g ( cc ) U_Z ( cc ) = V_Z ( cc ) * g ( cc ) end do !$OMP END SIMD do tt = 1_ip , params % t_skip call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end do !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end do !$OMP END SIMD end subroutine advance_FP3Deqn_vars","tags":"","loc":"proc/advance_fp3deqn_vars.html"},{"title":"adv_FOm3dc1_top – KORC-Full Orbit","text":"public subroutine adv_FOm3dc1_top(params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Contents Source Code adv_FOm3dc1_top Source Code subroutine adv_FOm3dc1_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: v , vpar , vperp REAL ( rp ), DIMENSION ( params % pchunk ) :: tmp REAL ( rp ), DIMENSION ( params % pchunk ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp TYPE ( C_PTR ), DIMENSION ( params % pchunk ) :: hint INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: a , m_cache , q_cache INTEGER :: ii !! Species iterator. INTEGER :: pp , pchunk !! Particles iterator. INTEGER :: cc !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk m_cache = spp ( ii )% m q_cache = spp ( ii )% q a = q_cache * params % dt / m_cache !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(a,m_cache,q_cache,E0,pchunk) & !$OMP& shared(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,X_X,X_Y,X_Z,V_X,V_Y,V_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,b_unit_X,b_unit_Y,b_unit_Z,v,vpar,vperp,tmp, & !$OMP& cross_X,cross_Y,cross_Z,vec_X,vec_Y,vec_Z,g, & !$OMP& Y_R,Y_PHI,Y_Z,flagCon,flagCol,PSIp,hint) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) V_X ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_Y ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) V_Z ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 3 ) B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) hint ( cc ) = spp ( ii )% vars % hint ( pp - 1 + cc ) g ( cc ) = spp ( ii )% vars % g ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'Yin: ',Y_R,Y_PHI,Y_Z !write(output_unit_write,*) 'Bin: ',B_X,B_Y,B_Z if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) call get_m3d_c1_FOmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_X , B_Y , B_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_FOelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_X , E_Y , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call advance_FOm3dc1_vars ( tt , a , q_cache , m_cache , params , & X_X , X_Y , X_Z , V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & g , flagCon , flagCol , P , F , PSIp ) end do !timestep iterator call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) !write(output_unit_write,*) 'Yout: ',Y_R,Y_PHI,Y_Z !write(output_unit_write,*) 'Bout: ',B_X,B_Y,B_Z !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = X_X ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = X_Y ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = X_Z ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % hint ( pp - 1 + cc ) = hint ( cc ) end do !$OMP END SIMD else !$OMP SIMD do cc = 1_idef , pchunk B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) end do !$OMP END SIMD call advance_FP3Dinterp_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , & g , m_cache , B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon , flagCol , P , F , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) end do !$OMP END SIMD end if !$OMP SIMD !          !$OMP& aligned(Bmag,B_X,B_Y,B_Z, & !          !$OMP& b_unit_X,b_unit_Y,b_unit_Z,v,V_X,V_Y,V_Z,vpar, & !          !$OMP& vperp,tmp,cross_X,cross_Y,cross_Z, & !          !$OMP& vec_X,vec_Y,vec_Z,E_X,E_Y,E_Z) do cc = 1_idef , pchunk !Derived output data Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Parallel unit vector b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) v ( cc ) = SQRT ( V_X ( cc ) * V_X ( cc ) + V_Y ( cc ) * V_Y ( cc ) + V_Z ( cc ) * V_Z ( cc )) if ( v ( cc ). GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar ( cc ) = ( V_X ( cc ) * b_unit_X ( cc ) + V_Y ( cc ) * b_unit_Y ( cc ) + & V_Z ( cc ) * b_unit_Z ( cc )) vperp ( cc ) = v ( cc ) ** 2 - vpar ( cc ) ** 2 if ( vperp ( cc ) . GE . korc_zero ) then vperp ( cc ) = SQRT ( vperp ( cc ) ) else vperp ( cc ) = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp - 1 + cc ) = 18 0.0_rp * & MODULO ( ATAN2 ( vperp ( cc ), vpar ( cc )), 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.5_rp * m_cache * & g ( cc ) ** 2 * vperp ( cc ) ** 2 / Bmag ( cc ) ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp ( cc ) = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) vec_X ( cc ) = E_X ( cc ) + cross_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) + cross_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) + cross_Z ( cc ) spp ( ii )% vars % Prad ( pp - 1 + cc ) = tmp ( cc ) * & ( E_X ( cc ) * E_X ( cc ) + E_Y ( cc ) * E_Y ( cc ) + E_Z ( cc ) * E_Z ( cc ) + & cross_X ( cc ) * E_X ( cc ) + cross_Y ( cc ) * E_Y ( cc ) + & cross_Z ( cc ) * E_Z ( cc ) + g ( cc ) ** 2 * & (( E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) ** 2 & - vec_X ( cc ) * vec_X ( cc ) + vec_Y ( cc ) * vec_Y ( cc ) + & vec_Z ( cc ) * vec_Z ( cc )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp - 1 + cc ) = q_cache * ( E_X ( cc ) * V_X ( cc ) + & E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) else spp ( ii )% vars % eta ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Prad ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Pin ( pp - 1 + cc ) = 0.0_rp end if end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_FOm3dc1_top","tags":"","loc":"proc/adv_fom3dc1_top.html"},{"title":"adv_FOinterp_top – KORC-Full Orbit","text":"public subroutine adv_FOinterp_top(params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Contents Source Code adv_FOinterp_top Source Code subroutine adv_FOinterp_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: b_unit_X , b_unit_Y , b_unit_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: v , vpar , vperp REAL ( rp ), DIMENSION ( params % pchunk ) :: tmp REAL ( rp ), DIMENSION ( params % pchunk ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: vec_X , vec_Y , vec_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: a , m_cache , q_cache INTEGER :: ii !! Species iterator. INTEGER :: pp , pchunk !! Particles iterator. INTEGER :: cc !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk m_cache = spp ( ii )% m q_cache = spp ( ii )% q a = q_cache * params % dt / m_cache !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(a,m_cache,q_cache,pchunk) & !$OMP& shared(params,ii,spp,P,F) & !$OMP& PRIVATE(E0,pp,tt,Bmag,cc,X_X,X_Y,X_Z,V_X,V_Y,V_Z,B_X,B_Y,B_Z, & !$OMP& E_X,E_Y,E_Z,b_unit_X,b_unit_Y,b_unit_Z,v,vpar,vperp,tmp, & !$OMP& cross_X,cross_Y,cross_Z,vec_X,vec_Y,vec_Z,g, & !$OMP& Y_R,Y_PHI,Y_Z,flagCon,flagCol,PSIp) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk X_X ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 1 ) X_Y ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 2 ) X_Z ( cc ) = spp ( ii )% vars % X ( pp - 1 + cc , 3 ) V_X ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_Y ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) V_Z ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 3 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) g ( cc ) = spp ( ii )% vars % g ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) if ( params % orbit_model ( 3 : 5 ). eq . 'new' ) then call interp_FOfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) else if ( params % orbit_model ( 3 : 5 ). eq . 'old' ) then call interp_FOfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flagCon ) end if !               write(output_unit_write,'(\"B_X: \",E17.10)') B_X(1) !               write(output_unit_write,'(\"B_Y: \",E17.10)') B_Y(1) !               write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z(1) call advance_FOinterp_vars ( tt , a , q_cache , m_cache , params , & X_X , X_Y , X_Z , V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , & g , flagCon , flagCol , P , F , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % X ( pp - 1 + cc , 1 ) = X_X ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 2 ) = X_Y ( cc ) spp ( ii )% vars % X ( pp - 1 + cc , 3 ) = X_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_X ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_Y ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_X ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_Y ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else !$OMP SIMD do cc = 1_idef , pchunk B_X ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_Y ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_X ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_Y ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) end do !$OMP END SIMD call advance_FP3Dinterp_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , & g , m_cache , B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon , flagCol , P , F , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_X ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_Y ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 3 ) = V_Z ( cc ) spp ( ii )% vars % g ( pp - 1 + cc ) = g ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) end do !$OMP END SIMD end if !$OMP SIMD !          !$OMP& aligned(Bmag,B_X,B_Y,B_Z, & !          !$OMP& b_unit_X,b_unit_Y,b_unit_Z,v,V_X,V_Y,V_Z,vpar, & !          !$OMP& vperp,tmp,cross_X,cross_Y,cross_Z, & !          !$OMP& vec_X,vec_Y,vec_Z,E_X,E_Y,E_Z) do cc = 1_idef , pchunk !Derived output data Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) ! Parallel unit vector b_unit_X ( cc ) = B_X ( cc ) / Bmag ( cc ) b_unit_Y ( cc ) = B_Y ( cc ) / Bmag ( cc ) b_unit_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) v ( cc ) = SQRT ( V_X ( cc ) * V_X ( cc ) + V_Y ( cc ) * V_Y ( cc ) + V_Z ( cc ) * V_Z ( cc )) if ( v ( cc ). GT . korc_zero ) then ! Parallel and perpendicular components of velocity vpar ( cc ) = ( V_X ( cc ) * b_unit_X ( cc ) + V_Y ( cc ) * b_unit_Y ( cc ) + & V_Z ( cc ) * b_unit_Z ( cc )) vperp ( cc ) = v ( cc ) ** 2 - vpar ( cc ) ** 2 if ( vperp ( cc ) . GE . korc_zero ) then vperp ( cc ) = SQRT ( vperp ( cc ) ) else vperp ( cc ) = 0.0_rp end if ! Pitch angle spp ( ii )% vars % eta ( pp - 1 + cc ) = 18 0.0_rp * & MODULO ( ATAN2 ( vperp ( cc ), vpar ( cc )), 2.0_rp * C_PI ) / C_PI ! Magnetic moment spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.5_rp * m_cache * & g ( cc ) ** 2 * vperp ( cc ) ** 2 / Bmag ( cc ) ! See Northrop's book (The adiabatic motion of charged ! particles) ! Radiated power tmp ( cc ) = q_cache ** 4 / ( 6.0_rp * C_PI * E0 * m_cache ** 2 ) cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) vec_X ( cc ) = E_X ( cc ) + cross_X ( cc ) vec_Y ( cc ) = E_Y ( cc ) + cross_Y ( cc ) vec_Z ( cc ) = E_Z ( cc ) + cross_Z ( cc ) spp ( ii )% vars % Prad ( pp - 1 + cc ) = tmp ( cc ) * & ( E_X ( cc ) * E_X ( cc ) + E_Y ( cc ) * E_Y ( cc ) + E_Z ( cc ) * E_Z ( cc ) + & cross_X ( cc ) * E_X ( cc ) + cross_Y ( cc ) * E_Y ( cc ) + & cross_Z ( cc ) * E_Z ( cc ) + g ( cc ) ** 2 * & (( E_X ( cc ) * V_X ( cc ) + E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) ** 2 & - vec_X ( cc ) * vec_X ( cc ) + vec_Y ( cc ) * vec_Y ( cc ) + & vec_Z ( cc ) * vec_Z ( cc )) ) ! Input power due to electric field spp ( ii )% vars % Pin ( pp - 1 + cc ) = q_cache * ( E_X ( cc ) * V_X ( cc ) + & E_Y ( cc ) * V_Y ( cc ) + E_Z ( cc ) * V_Z ( cc )) else spp ( ii )% vars % eta ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % mu ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Prad ( pp - 1 + cc ) = 0.0_rp spp ( ii )% vars % Pin ( pp - 1 + cc ) = 0.0_rp end if end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_FOinterp_top","tags":"","loc":"proc/adv_fointerp_top.html"},{"title":"advance_FOinterp_vars – KORC-Full Orbit","text":"public subroutine advance_FOinterp_vars(tt, a, q_cache, m_cache, params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, g, flagCon, flagCol, P, F, PSIp) Calls radiation_force in korc_ppusher . Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: a This variable is used to simplify notation in the code, and\n is given by , real(kind=rp), intent(in) :: q_cache Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: m_cache Time step used in the leapfrog step ( ). type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FOinterp_vars Source Code subroutine advance_FOinterp_vars ( tt , a , q_cache , m_cache , params , X_X , X_Y , X_Z , & V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , g , flagCon , flagCol , P , F , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ), INTENT ( IN ) :: tt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), INTENT ( in ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( params % pchunk ) :: sigma !! This variable is \\sigma = \\gamma'&#94;2 - \\tau&#94;2 in the above equations. REAL ( rp ), DIMENSION ( params % pchunk ) :: us !! This variable is u&#94;{*} = p&#94;{*}/m where  p&#94;{*} = !! \\mathbf{p}'\\cdot \\mathbf{\\tau}/mc. !! Variable 'u&#94;*' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: gp , g0 !! Relativistic factor \\gamma. REAL ( rp ), DIMENSION ( params % pchunk ) :: s !! This variable is s = 1/(1+t&#94;2) in the equations above. !! Variable 's' in Vay, J.-L. PoP (200params%pchunk). REAL ( rp ), DIMENSION ( params % pchunk ) :: U_hs_X , U_hs_Y , U_hs_Z !! Is \\mathbf{u}=\\mathbf{p}/m at half-time step (i+1/2) in !! the absence of radiation losses or collisions. \\mathbf{u}&#94;{i+1/2} = !! \\mathbf{u}&#94;i + \\frac{q\\Delta t}{2m}\\left( \\mathbf{E}&#94;{i+1/2} + !! \\mathbf{v}&#94;i\\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: tau_X , tau_Y , tau_Z !! This variable is \\mathbf{\\tau} = (q\\Delta t/2)\\mathbf{B}&#94;{i+1/2}. REAL ( rp ), DIMENSION ( params % pchunk ) :: up_X , up_Y , up_Z !! This variable is \\mathbf{u}'= \\mathbf{p}'/m, where \\mathbf{p}' !! = \\mathbf{p}&#94;i + q\\Delta t \\left( \\mathbf{E}&#94;{i+1/2} + !! \\frac{\\mathbf{v}&#94;i}{2} \\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: t_X , t_Y , t_Z !! This variable is \\mathbf{t} = {\\mathbf \\tau}/\\gamma&#94;{i+1}. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: U_L_X , U_L_Y , U_L_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_RC_X , U_RC_Y , U_RC_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_os_X , U_os_Y , U_os_Z !! This variable is \\mathbf{u}&#94;{i+1}= \\mathbf{p}&#94;{i+1}/m. REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Frad_X , Frad_Y , Frad_Z !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( is ) , DIMENSION ( params % pchunk ), intent ( inout ) :: flagCon , flagCol dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(g0,g,U_X,U_Y,U_Z,V_X,V_Y,V_Z,Bmag,B_X,B_Y,B_Z, & !    !$OMP& U_L_X,U_L_Y,U_L_Z,U_RC_X,U_RC_Y,U_RC_Z, & !    !$OMP& cross_X,cross_Y,cross_Z,U_hs_X,U_hs_Y,U_hs_Z,E_X,E_Y,E_Z, & !    !$OMP& tau_X,tau_Y,tau_Z,up_X,up_Y,up_Z,gp,sigma,us,t_X,t_Y,t_Z,s, & !    !$OMP& U_os_X,U_os_Y,U_os_Z,Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g0 ( cc ) = g ( cc ) U_X ( cc ) = g ( cc ) * V_X ( cc ) U_Y ( cc ) = g ( cc ) * V_Y ( cc ) U_Z ( cc ) = g ( cc ) * V_Z ( cc ) ! Magnitude of magnetic field Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) U_L_X ( cc ) = U_X ( cc ) U_L_Y ( cc ) = U_Y ( cc ) U_L_Z ( cc ) = U_Z ( cc ) U_RC_X ( cc ) = U_X ( cc ) U_RC_Y ( cc ) = U_Y ( cc ) U_RC_Z ( cc ) = U_Z ( cc ) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) U_hs_X ( cc ) = U_L_X ( cc ) + 0.5_rp * a * ( E_X ( cc ) + cross_X ( cc )) U_hs_Y ( cc ) = U_L_Y ( cc ) + 0.5_rp * a * ( E_Y ( cc ) + cross_Y ( cc )) U_hs_Z ( cc ) = U_L_Z ( cc ) + 0.5_rp * a * ( E_Z ( cc ) + cross_Z ( cc )) tau_X ( cc ) = 0.5_rp * a * B_X ( cc ) tau_Y ( cc ) = 0.5_rp * a * B_Y ( cc ) tau_Z ( cc ) = 0.5_rp * a * B_Z ( cc ) up_X ( cc ) = U_hs_X ( cc ) + 0.5_rp * a * E_X ( cc ) up_Y ( cc ) = U_hs_Y ( cc ) + 0.5_rp * a * E_Y ( cc ) up_Z ( cc ) = U_hs_Z ( cc ) + 0.5_rp * a * E_Z ( cc ) gp ( cc ) = SQRT ( 1.0_rp + up_X ( cc ) * up_X ( cc ) + up_Y ( cc ) * up_Y ( cc ) + & up_Z ( cc ) * up_Z ( cc ) ) sigma ( cc ) = gp ( cc ) * gp ( cc ) - ( tau_X ( cc ) * tau_X ( cc ) + & tau_Y ( cc ) * tau_Y ( cc ) + tau_Z ( cc ) * tau_Z ( cc )) us ( cc ) = up_X ( cc ) * tau_X ( cc ) + up_Y ( cc ) * tau_Y ( cc ) + & up_Z ( cc ) * tau_Z ( cc ) ! variable 'u&#94;*' in Vay, J.-L. PoP (2008) g ( cc ) = SQRT ( 0.5_rp * ( sigma ( cc ) + SQRT ( sigma ( cc ) * sigma ( cc ) + & 4.0_rp * ( tau_X ( cc ) * tau_X ( cc ) + tau_Y ( cc ) * tau_Y ( cc ) + & tau_Z ( cc ) * tau_Z ( cc ) + us ( cc ) * us ( cc )))) ) t_X ( cc ) = tau_X ( cc ) / g ( cc ) t_Y ( cc ) = tau_Y ( cc ) / g ( cc ) t_Z ( cc ) = tau_Z ( cc ) / g ( cc ) s ( cc ) = 1.0_rp / ( 1.0_rp + t_X ( cc ) * t_X ( cc ) + t_Y ( cc ) * t_Y ( cc ) + & t_Z ( cc ) * t_Z ( cc )) ! variable 's' in Vay, J.-L. PoP (2008) cross_X ( cc ) = up_Y ( cc ) * t_Z ( cc ) - up_Z ( cc ) * t_Y ( cc ) cross_Y ( cc ) = up_Z ( cc ) * t_X ( cc ) - up_X ( cc ) * t_Z ( cc ) cross_Z ( cc ) = up_X ( cc ) * t_Y ( cc ) - up_Y ( cc ) * t_X ( cc ) U_L_X ( cc ) = s ( cc ) * ( up_X ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_X ( cc ) + cross_X ( cc )) U_L_Y ( cc ) = s ( cc ) * ( up_Y ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Y ( cc ) + cross_Y ( cc )) U_L_Z ( cc ) = s ( cc ) * ( up_Z ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Z ( cc ) + cross_Z ( cc )) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! U_os_X ( cc ) = 0.5_rp * ( U_L_X ( cc ) + U_X ( cc )) U_os_Y ( cc ) = 0.5_rp * ( U_L_Y ( cc ) + U_Y ( cc )) U_os_Z ( cc ) = 0.5_rp * ( U_L_Z ( cc ) + U_Z ( cc )) ! Splitting operator for including radiation if ( params % radiation ) then !! Calls [[radiation_force]] in [[korc_ppusher]]. call radiation_force_p ( pchunk , q_cache , m_cache , U_os_X , U_os_Y , U_os_Z , & E_X , E_Y , E_Z , B_Z , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) U_RC_X ( cc ) = U_RC_X ( cc ) + a * Frad_X ( cc ) / q_cache U_RC_Y ( cc ) = U_RC_Y ( cc ) + a * Frad_Y ( cc ) / q_cache U_RC_Z ( cc ) = U_RC_Z ( cc ) + a * Frad_Z ( cc ) / q_cache end if ! Splitting operator for including radiation U_X ( cc ) = U_L_X ( cc ) + U_RC_X ( cc ) - U_X ( cc ) U_Y ( cc ) = U_L_Y ( cc ) + U_RC_Y ( cc ) - U_Y ( cc ) U_Z ( cc ) = U_L_Z ( cc ) + U_RC_Z ( cc ) - U_Z ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end if if ( params % radiation . or . params % collisions ) then !$OMP SIMD !       !$OMP& aligned(g,U_X,U_Y,U_Z) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) end do !$OMP END SIMD end if !$OMP SIMD !    !$OMP& aligned(g,g0,V_X,V_Y,V_Z,U_X,U_Y,U_Z,X_X,X_Y,X_Z,flagCon,flagCol) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then g ( cc ) = g0 ( cc ) else V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end if X_X ( cc ) = X_X ( cc ) + dt * V_X ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Y ( cc ) = X_Y ( cc ) + dt * V_Y ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Z ( cc ) = X_Z ( cc ) + dt * V_Z ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) end do !$OMP END SIMD end subroutine advance_FOinterp_vars","tags":"","loc":"proc/advance_fointerp_vars.html"},{"title":"advance_FOm3dc1_vars – KORC-Full Orbit","text":"public subroutine advance_FOm3dc1_vars(tt, a, q_cache, m_cache, params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, g, flagCon, flagCol, P, F, PSIp) Calls radiation_force in korc_ppusher . Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: a This variable is used to simplify notation in the code, and\n is given by , real(kind=rp), intent(in) :: q_cache Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: m_cache Time step used in the leapfrog step ( ). type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FOm3dc1_vars Source Code subroutine advance_FOm3dc1_vars ( tt , a , q_cache , m_cache , params , X_X , X_Y , X_Z , & V_X , V_Y , V_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , g , flagCon , flagCol , P , F , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ), INTENT ( IN ) :: tt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), INTENT ( IN ) :: m_cache , q_cache !! Time step used in the leapfrog step (\\Delta t). REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), INTENT ( in ) :: a !! This variable is used to simplify notation in the code, and !! is given by a=q\\Delta t/m, REAL ( rp ), DIMENSION ( params % pchunk ) :: sigma !! This variable is \\sigma = \\gamma'&#94;2 - \\tau&#94;2 in the above equations. REAL ( rp ), DIMENSION ( params % pchunk ) :: us !! This variable is u&#94;{*} = p&#94;{*}/m where  p&#94;{*} = !! \\mathbf{p}'\\cdot \\mathbf{\\tau}/mc. !! Variable 'u&#94;*' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION ( params % pchunk ) :: gp , g0 !! Relativistic factor \\gamma. REAL ( rp ), DIMENSION ( params % pchunk ) :: s !! This variable is s = 1/(1+t&#94;2) in the equations above. !! Variable 's' in Vay, J.-L. PoP (2008). REAL ( rp ), DIMENSION ( params % pchunk ) :: U_hs_X , U_hs_Y , U_hs_Z !! Is \\mathbf{u}=\\mathbf{p}/m at half-time step (i+1/2) in !! the absence of radiation losses or collisions. \\mathbf{u}&#94;{i+1/2} = !! \\mathbf{u}&#94;i + \\frac{q\\Delta t}{2m}\\left( \\mathbf{E}&#94;{i+1/2} + !! \\mathbf{v}&#94;i\\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: tau_X , tau_Y , tau_Z !! This variable is \\mathbf{\\tau} = (q\\Delta t/2)\\mathbf{B}&#94;{i+1/2}. REAL ( rp ), DIMENSION ( params % pchunk ) :: up_X , up_Y , up_Z !! This variable is \\mathbf{u}'= \\mathbf{p}'/m, where \\mathbf{p}' !! = \\mathbf{p}&#94;i + q\\Delta t \\left( \\mathbf{E}&#94;{i+1/2} + !! \\frac{\\mathbf{v}&#94;i}{2} \\times \\mathbf{B}&#94;{i+1/2} \\right). REAL ( rp ), DIMENSION ( params % pchunk ) :: t_X , t_Y , t_Z !! This variable is \\mathbf{t} = {\\mathbf \\tau}/\\gamma&#94;{i+1}. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: U_L_X , U_L_Y , U_L_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_RC_X , U_RC_Y , U_RC_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_os_X , U_os_Y , U_os_Z !! This variable is \\mathbf{u}&#94;{i+1}= \\mathbf{p}&#94;{i+1}/m. REAL ( rp ), DIMENSION ( params % pchunk ) :: cross_X , cross_Y , cross_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Frad_X , Frad_Y , Frad_Z !! Synchrotron radiation reaction force of each particle. REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( is ) , DIMENSION ( params % pchunk ), intent ( inout ) :: flagCon , flagCol dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(g0,g,U_X,U_Y,U_Z,V_X,V_Y,V_Z,Bmag,B_X,B_Y,B_Z, & !    !$OMP& U_L_X,U_L_Y,U_L_Z,U_RC_X,U_RC_Y,U_RC_Z, & !    !$OMP& cross_X,cross_Y,cross_Z,U_hs_X,U_hs_Y,U_hs_Z,E_X,E_Y,E_Z, & !    !$OMP& tau_X,tau_Y,tau_Z,up_X,up_Y,up_Z,gp,sigma,us,t_X,t_Y,t_Z,s, & !    !$OMP& U_os_X,U_os_Y,U_os_Z,Frad_X,Frad_Y,Frad_Z) do cc = 1_idef , pchunk g0 ( cc ) = g ( cc ) U_X ( cc ) = g ( cc ) * V_X ( cc ) U_Y ( cc ) = g ( cc ) * V_Y ( cc ) U_Z ( cc ) = g ( cc ) * V_Z ( cc ) ! Magnitude of magnetic field Bmag ( cc ) = SQRT ( B_X ( cc ) * B_X ( cc ) + B_Y ( cc ) * B_Y ( cc ) + B_Z ( cc ) * B_Z ( cc )) U_L_X ( cc ) = U_X ( cc ) U_L_Y ( cc ) = U_Y ( cc ) U_L_Z ( cc ) = U_Z ( cc ) U_RC_X ( cc ) = U_X ( cc ) U_RC_Y ( cc ) = U_Y ( cc ) U_RC_Z ( cc ) = U_Z ( cc ) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! cross_X ( cc ) = V_Y ( cc ) * B_Z ( cc ) - V_Z ( cc ) * B_Y ( cc ) cross_Y ( cc ) = V_Z ( cc ) * B_X ( cc ) - V_X ( cc ) * B_Z ( cc ) cross_Z ( cc ) = V_X ( cc ) * B_Y ( cc ) - V_Y ( cc ) * B_X ( cc ) U_hs_X ( cc ) = U_L_X ( cc ) + 0.5_rp * a * ( E_X ( cc ) + cross_X ( cc )) U_hs_Y ( cc ) = U_L_Y ( cc ) + 0.5_rp * a * ( E_Y ( cc ) + cross_Y ( cc )) U_hs_Z ( cc ) = U_L_Z ( cc ) + 0.5_rp * a * ( E_Z ( cc ) + cross_Z ( cc )) tau_X ( cc ) = 0.5_rp * a * B_X ( cc ) tau_Y ( cc ) = 0.5_rp * a * B_Y ( cc ) tau_Z ( cc ) = 0.5_rp * a * B_Z ( cc ) up_X ( cc ) = U_hs_X ( cc ) + 0.5_rp * a * E_X ( cc ) up_Y ( cc ) = U_hs_Y ( cc ) + 0.5_rp * a * E_Y ( cc ) up_Z ( cc ) = U_hs_Z ( cc ) + 0.5_rp * a * E_Z ( cc ) gp ( cc ) = SQRT ( 1.0_rp + up_X ( cc ) * up_X ( cc ) + up_Y ( cc ) * up_Y ( cc ) + & up_Z ( cc ) * up_Z ( cc ) ) sigma ( cc ) = gp ( cc ) * gp ( cc ) - ( tau_X ( cc ) * tau_X ( cc ) + & tau_Y ( cc ) * tau_Y ( cc ) + tau_Z ( cc ) * tau_Z ( cc )) us ( cc ) = up_X ( cc ) * tau_X ( cc ) + up_Y ( cc ) * tau_Y ( cc ) + & up_Z ( cc ) * tau_Z ( cc ) ! variable 'u&#94;*' in Vay, J.-L. PoP (2008) g ( cc ) = SQRT ( 0.5_rp * ( sigma ( cc ) + SQRT ( sigma ( cc ) * sigma ( cc ) + & 4.0_rp * ( tau_X ( cc ) * tau_X ( cc ) + tau_Y ( cc ) * tau_Y ( cc ) + & tau_Z ( cc ) * tau_Z ( cc ) + us ( cc ) * us ( cc )))) ) t_X ( cc ) = tau_X ( cc ) / g ( cc ) t_Y ( cc ) = tau_Y ( cc ) / g ( cc ) t_Z ( cc ) = tau_Z ( cc ) / g ( cc ) s ( cc ) = 1.0_rp / ( 1.0_rp + t_X ( cc ) * t_X ( cc ) + t_Y ( cc ) * t_Y ( cc ) + & t_Z ( cc ) * t_Z ( cc )) ! variable 's' in Vay, J.-L. PoP (2008) cross_X ( cc ) = up_Y ( cc ) * t_Z ( cc ) - up_Z ( cc ) * t_Y ( cc ) cross_Y ( cc ) = up_Z ( cc ) * t_X ( cc ) - up_X ( cc ) * t_Z ( cc ) cross_Z ( cc ) = up_X ( cc ) * t_Y ( cc ) - up_Y ( cc ) * t_X ( cc ) U_L_X ( cc ) = s ( cc ) * ( up_X ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_X ( cc ) + cross_X ( cc )) U_L_Y ( cc ) = s ( cc ) * ( up_Y ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Y ( cc ) + cross_Y ( cc )) U_L_Z ( cc ) = s ( cc ) * ( up_Z ( cc ) + ( up_X ( cc ) * t_X ( cc ) + & up_Y ( cc ) * t_Y ( cc ) + up_Z ( cc ) * t_Z ( cc )) * t_Z ( cc ) + cross_Z ( cc )) ! LEAP-FROG SCHEME FOR LORENTZ FORCE ! U_os_X ( cc ) = 0.5_rp * ( U_L_X ( cc ) + U_X ( cc )) U_os_Y ( cc ) = 0.5_rp * ( U_L_Y ( cc ) + U_Y ( cc )) U_os_Z ( cc ) = 0.5_rp * ( U_L_Z ( cc ) + U_Z ( cc )) ! Splitting operator for including radiation if ( params % radiation ) then !! Calls [[radiation_force]] in [[korc_ppusher]]. call radiation_force_p ( pchunk , q_cache , m_cache , U_os_X , U_os_Y , U_os_Z , & E_X , E_Y , E_Z , B_Z , B_Y , B_Z , Frad_X , Frad_Y , Frad_Z ) U_RC_X ( cc ) = U_RC_X ( cc ) + a * Frad_X ( cc ) / q_cache U_RC_Y ( cc ) = U_RC_Y ( cc ) + a * Frad_Y ( cc ) / q_cache U_RC_Z ( cc ) = U_RC_Z ( cc ) + a * Frad_Z ( cc ) / q_cache end if ! Splitting operator for including radiation U_X ( cc ) = U_L_X ( cc ) + U_RC_X ( cc ) - U_X ( cc ) U_Y ( cc ) = U_L_Y ( cc ) + U_RC_Y ( cc ) - U_Y ( cc ) U_Z ( cc ) = U_L_Z ( cc ) + U_RC_Z ( cc ) - U_Z ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end if if ( params % radiation . or . params % collisions ) then !$OMP SIMD !       !$OMP& aligned(g,U_X,U_Y,U_Z) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) end do !$OMP END SIMD end if !$OMP SIMD !    !$OMP& aligned(g,g0,V_X,V_Y,V_Z,U_X,U_Y,U_Z,X_X,X_Y,X_Z,flagCon,flagCol) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then g ( cc ) = g0 ( cc ) else V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end if X_X ( cc ) = X_X ( cc ) + dt * V_X ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Y ( cc ) = X_Y ( cc ) + dt * V_Y ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) X_Z ( cc ) = X_Z ( cc ) + dt * V_Z ( cc ) * REAL ( flagCon ( cc )) * REAL ( flagCol ( cc )) end do !$OMP END SIMD end subroutine advance_FOm3dc1_vars","tags":"","loc":"proc/advance_fom3dc1_vars.html"},{"title":"advance_FP3Dinterp_vars – KORC-Full Orbit","text":"public subroutine advance_FP3Dinterp_vars(params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, g, m_cache, B_X, B_Y, B_Z, E_X, E_Y, E_Z, flagCon, flagCol, P, F, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FP3Dinterp_vars Source Code subroutine advance_FP3Dinterp_vars ( params , X_X , X_Y , X_Z , V_X , V_Y , V_Z , g , & m_cache , B_X , B_Y , B_Z , E_X , E_Y , E_Z , flagCon , flagCol , P , F , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: X_X , X_Y , X_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: E_X , E_Y , E_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: U_X , U_Y , U_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_X , V_Y , V_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: g INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( in ) :: m_cache pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk U_X ( cc ) = V_X ( cc ) * g ( cc ) U_Y ( cc ) = V_Y ( cc ) * g ( cc ) U_Z ( cc ) = V_Z ( cc ) * g ( cc ) end do !$OMP END SIMD do tt = 1_ip , params % t_skip call include_CoulombCollisions_FO_p ( tt , params , X_X , X_Y , X_Z , & U_X , U_Y , U_Z , B_X , B_Y , B_Z , m_cache , P , F , flagCon , flagCol , PSIp ) end do !$OMP SIMD !    !$OMP& aligned(U_X,U_Y,U_Z,V_X,V_Y,V_Z,g) do cc = 1_idef , pchunk g ( cc ) = sqrt ( 1._rp + U_X ( cc ) * U_X ( cc ) + U_Y ( cc ) * U_Y ( cc ) + U_Z ( cc ) * U_Z ( cc )) V_X ( cc ) = U_X ( cc ) / g ( cc ) V_Y ( cc ) = U_Y ( cc ) / g ( cc ) V_Z ( cc ) = U_Z ( cc ) / g ( cc ) end do !$OMP END SIMD end subroutine advance_FP3Dinterp_vars","tags":"","loc":"proc/advance_fp3dinterp_vars.html"},{"title":"GC_init – KORC-Full Orbit","text":"public subroutine GC_init(params, F, spp) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both.\n Calls get_fields in korc_fields . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Contents Source Code GC_init Source Code subroutine GC_init ( params , F , spp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. REAL ( rp ) :: Bmag1 , pmag REAL ( rp ) :: Bmagc REAL ( rp ) :: rm REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: RAphi REAL ( rp ), DIMENSION ( 3 ) :: bhat REAL ( rp ), DIMENSION ( 3 ) :: bhatc REAL ( rp ), DIMENSION ( params % pchunk ) :: E_PHI REAL ( rp ), DIMENSION (:), ALLOCATABLE :: RVphi REAL ( rp ), DIMENSION ( params % pchunk ) :: rm8 , Y_R , Y_Z , V_PLL , vpll , gam real ( rp ), dimension ( F % dim_1D ) :: Vpart , Vpartave , VpartOMP real ( rp ) :: dr integer :: rind !    write(output_unit_write,'(\"eta\",E17.10)') spp(ii)%vars%eta(pp) !    write(output_unit_write,'(\"gam\",E17.10)') spp(ii)%vars%g(pp) do ii = 1_idef , params % num_species pchunk = params % pchunk if ( spp ( ii )% spatial_distribution . eq . 'TRACER' . and . & params % FO_GC_compare ) then call get_fields ( params , spp ( ii )% vars , F ) !! Calls [[get_fields]] in [[korc_fields]]. ! Interpolates fields at local particles' position and keeps in ! spp%vars. Fields in (R,\\phi,Z) coordinates. ALLOCATE ( RAphi ( spp ( ii )% ppp , 2 )) ALLOCATE ( RVphi ( spp ( ii )% ppp )) RAphi = 0.0_rp call cart_to_cyl ( spp ( ii )% vars % X , spp ( ii )% vars % Y ) !$OMP PARALLEL DO SHARED(params,ii,spp,F,RAphi,RVphi) & !$OMP&  PRIVATE(pp,Bmag1,bhat,rm) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then RVphi ( pp ) = ( - sin ( spp ( ii )% vars % Y ( pp , 2 )) * spp ( ii )% vars % V ( pp , 1 ) + & cos ( spp ( ii )% vars % Y ( pp , 2 )) * spp ( ii )% vars % V ( pp , 2 )) * & spp ( ii )% vars % Y ( pp , 1 ) Bmag1 = SQRT ( spp ( ii )% vars % B ( pp , 1 ) * spp ( ii )% vars % B ( pp , 1 ) + & spp ( ii )% vars % B ( pp , 2 ) * spp ( ii )% vars % B ( pp , 2 ) + & spp ( ii )% vars % B ( pp , 3 ) * spp ( ii )% vars % B ( pp , 3 )) !             write(output_unit_write,'(\"pp: \",I16)') pp !             write(output_unit_write,'(\"Bmag: \",E17.10)') Bmag bhat = spp ( ii )% vars % B ( pp ,:) / Bmag1 if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then rm = sqrt (( spp ( ii )% vars % Y ( pp , 1 ) - F % AB % Ro ) ** 2 + & ( spp ( ii )% vars % Y ( pp , 3 )) ** 2 ) RAphi ( pp , 1 ) =- F % AB % lambda ** 2 * F % AB % Bo / ( 2 * F % AB % qo ) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then RAphi ( pp , 1 ) = spp ( ii )% vars % PSI_P ( pp ) / ( 2 * C_PI ) end if !             write(output_unit_write,'(\"bhat: \",E17.10)') bhat !             write(output_unit_write,'(\"V: \",E17.10)') spp(ii)%vars%V(pp,:) spp ( ii )% vars % X ( pp ,:) = spp ( ii )% vars % X ( pp ,:) - & spp ( ii )% m * spp ( ii )% vars % g ( pp ) * & cross ( bhat , spp ( ii )% vars % V ( pp ,:)) / ( spp ( ii )% q * Bmag1 ) ! transforming from particle location to associated ! GC location end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO call cart_to_cyl ( spp ( ii )% vars % X , spp ( ii )% vars % Y ) call get_fields ( params , spp ( ii )% vars , F ) !$OMP PARALLEL DO SHARED(params,ii,spp,F,RAphi,RVphi) & !$OMP&  PRIVATE(pp,rm) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then rm = sqrt (( spp ( ii )% vars % Y ( pp , 1 ) - F % AB % Ro ) ** 2 + & ( spp ( ii )% vars % Y ( pp , 3 )) ** 2 ) RAphi ( pp , 2 ) =- F % AB % lambda ** 2 * F % AB % Bo / ( 2 * F % AB % qo ) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then RAphi ( pp , 2 ) = spp ( ii )% vars % PSI_P ( pp ) / ( 2 * C_PI ) end if write ( output_unit_write , '(\"RAphi1: \",E17.10)' ) RAphi ( pp , 1 ) write ( output_unit_write , '(\"RAphi2: \",E17.10)' ) RAphi ( pp , 2 ) spp ( ii )% vars % V ( pp , 1 ) = ( spp ( ii )% m * spp ( ii )% vars % g ( pp ) * & RVphi ( pp ) + spp ( ii )% q * ( RAphi ( pp , 1 ) - RAphi ( pp , 2 ))) / & spp ( ii )% vars % Y ( pp , 1 ) !GC ppar end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO !$OMP PARALLEL DO SHARED(ii,spp) PRIVATE(pp,Bmagc,bhatc) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then Bmagc = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) bhatc = spp ( ii )% vars % B ( pp ,:) / Bmagc spp ( ii )% vars % V ( pp , 1 ) = spp ( ii )% vars % V ( pp , 1 ) / & bhatc ( 2 ) !GC ppar spp ( ii )% vars % V ( pp , 2 ) = spp ( ii )% m / ( 2 * Bmagc ) * & ( spp ( ii )% vars % g ( pp ) ** 2 - & ( 1 + ( spp ( ii )% vars % V ( pp , 1 ) / spp ( ii )% m ) ** 2 )) !GC mu end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO params % GC_coords = . TRUE . DEALLOCATE ( RAphi ) DEALLOCATE ( RVphi ) !Preparing Output Data call get_fields ( params , spp ( ii )% vars , F ) !$OMP PARALLEL DO shared(F,params,spp) & !$OMP& PRIVATE(cc,pp,E_PHI,Y_R) firstprivate(pchunk) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) end do !$OMP END SIMD call add_analytical_E_p ( params , 0_ip , F , E_PHI , Y_R ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end do !$OMP END PARALLEL DO !$OMP PARALLEL DO SHARED(ii,spp) PRIVATE(pp,Bmag1) ! Call OpenMP to calculate p_par and mu for each particle and ! put into spp%vars%V do pp = 1_idef , spp ( ii )% ppp if ( spp ( ii )% vars % flagCon ( pp ) . EQ . 1_is ) then Bmag1 = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) spp ( ii )% vars % g ( pp ) = sqrt ( 1 + ( spp ( ii )% vars % V ( pp , 1 )) ** 2 + & 2 * spp ( ii )% vars % V ( pp , 2 ) * Bmag1 ) !                write(output_unit_write,'(\"Bmag:\",E17.10)') Bmag1 !                write(output_unit_write,'(\"PPLL:\",E17.10)') spp(ii)%vars%V(pp,1) !                write(output_unit_write,'(\"MU:\",E17.10)') spp(ii)%vars%V(pp,2) spp ( ii )% vars % eta ( pp ) = atan2 ( sqrt ( 2 * spp ( ii )% m * Bmag1 * & spp ( ii )% vars % V ( pp , 2 )), spp ( ii )% vars % V ( pp , 1 )) * 18 0.0_rp / C_PI !                             write(output_unit_write,'(\"BR\",E17.10)') spp(ii)%vars%B(pp,1) !                             write(output_unit_write,'(\"BPHI\",E17.10)') spp(ii)%vars%B(pp,2) !                             write(output_unit_write,'(\"BZ\",E17.10)') spp(ii)%vars%B(pp,3) !             write(output_unit_write,'(\"ppll\",E17.10)') spp(ii)%vars%V(pp,1) !             write(output_unit_write,'(\"pperp\",E17.10)') sqrt(2*spp(ii)%m*Bmag1* & !                  spp(ii)%vars%V(pp,2)) !                             write(output_unit_write,'(\"eta GCinit\",E17.10)') spp(ii)%vars%eta(pp) !             write(output_unit_write,'(\"gam\",E17.10)') spp(ii)%vars%g(pp) end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO else if (( spp ( ii )% spatial_distribution . eq . 'TRACER' ). or . & ( spp ( ii )% spatial_distribution . eq . 'TORUS' ). or . & ( spp ( ii )% spatial_distribution . eq . & '2D-GAUSSIAN-ELLIPTIC-TORUS-MH' )) & call cart_to_cyl ( spp ( ii )% vars % X , spp ( ii )% vars % Y ) params % GC_coords = . TRUE . do pp = 1_idef , spp ( ii )% ppp spp ( ii )% vars % E ( pp , 1 ) = 0._rp spp ( ii )% vars % E ( pp , 2 ) = 0._rp spp ( ii )% vars % E ( pp , 3 ) = 0._rp end do call get_fields ( params , spp ( ii )% vars , F ) !write(output_unit_write,*) spp(1)%vars%PSI_P !$OMP PARALLEL DO SHARED(ii,spp) PRIVATE(pp,Bmag1) do pp = 1_idef , spp ( ii )% ppp !             if ( spp(ii)%vars%flagCon(pp) .EQ. 1_is ) then !                write(output_unit_write,'(\"BR: \",E17.10)') spp(ii)%vars%B(pp,1) !                write(output_unit_write,'(\"BPHI: \",E17.10)') spp(ii)%vars%B(pp,2) !                write(output_unit_write,'(\"BZ: \",E17.10)') spp(ii)%vars%B(pp,3) Bmag1 = SQRT ( DOT_PRODUCT ( spp ( ii )% vars % B ( pp ,:), & spp ( ii )% vars % B ( pp ,:))) pmag = sqrt ( spp ( ii )% vars % g ( pp ) ** 2 - 1 ) spp ( ii )% vars % V ( pp , 1 ) = pmag * cos ( deg2rad ( spp ( ii )% vars % eta ( pp ))) spp ( ii )% vars % V ( pp , 2 ) = ( pmag * & sin ( deg2rad ( spp ( ii )% vars % eta ( pp )))) ** 2 / & ( 2 * spp ( ii )% m * Bmag1 ) !    write(output_unit_write,'(\"BR\",E17.10)') spp(ii)%vars%B(pp,1) !    write(output_unit_write,'(\"BPHI\",E17.10)') spp(ii)%vars%B(pp,2) !    write(output_unit_write,'(\"BZ\",E17.10)') spp(ii)%vars%B(pp,3) !write(output_unit_write,'(\"ppll\",E17.10)') spp(ii)%vars%V(pp,1) !write(output_unit_write,'(\"mu\",E17.10)') spp(ii)%vars%V(pp,2) !     write(output_unit_write,'(\"eta\",E17.10)') spp(ii)%vars%eta(pp) !     write(output_unit_write,'(\"gam\",E17.10)') spp(ii)%vars%g(pp) !             end if ! if particle in domain, i.e. spp%vars%flagCon==1 end do ! loop over particles on an mpi process !$OMP END PARALLEL DO !$OMP PARALLEL DO shared(F,params,spp) & !$OMP& PRIVATE(pp,cc,E_PHI,Y_R) firstprivate(pchunk) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) end do !$OMP END SIMD if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then call add_analytical_E_p ( params , 0_ip , F , E_PHI , Y_R ) end if !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end do !$OMP END PARALLEL DO end if end do ! loop over particle species end subroutine GC_init","tags":"","loc":"proc/gc_init.html"},{"title":"adv_GCeqn_top – KORC-Full Orbit","text":"public subroutine adv_GCeqn_top(params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Contents Source Code adv_GCeqn_top Source Code subroutine adv_GCeqn_top ( params , F , P , spp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z , E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ) :: B0 , EF0 , R0 , q0 , lam , ar , m_cache , q_cache , ne0 , Te0 , Zeff0 INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol LOGICAL :: ss_collisions !! Logical variable that indicates if collisions are included in !! the simulation. INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. real ( rp ), dimension ( F % dim_1D ) :: Vden , Vdenave , VdenOMP do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m do ttt = 1_ip , params % t_it_SC VdenOMP = 0._rp !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(E0,q_cache,m_cache,pchunk) & !$OMP& shared(F,P,params,ii,spp) & !$OMP& PRIVATE(pp,tt,ttt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !$OMP& flagCon,flagCol,B_R,B_PHI,B_Z,E_PHI,PSIp, & !$OMP& Vden,Vdenave) & !$OMP& REDUCTION(+:VdenOMP) do pp = 1_idef , spp ( ii )% ppp , pchunk !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_p ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then Vdenave = 0._rp do tt = 1_ip , params % t_skip !                   write(output_unit_write,*) params%mpi_params%rank,'Y_R',Y_R call advance_GCeqn_vars ( spp ( ii )% vars , pp , & tt + params % t_skip * ( ttt - 1 ), params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , flagCon , flagCol , q_cache , m_cache , & B_R , B_PHI , B_Z , F , P , PSIp , E_PHI ) !                   write(output_unit_write,*) params%mpi_params%rank,'Y_R',Y_R if ( params % SC_E ) then call calculate_SC_p ( params , F , B_R , B_PHI , B_Z , Y_R , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , Vden ) Vdenave = ( Vdenave * REAL ( tt - 1_ip ) + Vden ) / REAL ( tt ) end if end do !timestep iterator VdenOMP = VdenOMP + Vdenave !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPeqn_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , flagCon , flagCol , m_cache , & F , P , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) end do !$OMP END SIMD end if call analytical_fields_Bmag_p ( pchunk , F , Y_R , Y_PHI , Y_Z , & Bmag , E_PHI ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc ) * m_cache ) spp ( ii )% vars % eta ( pp - 1 + cc ) = rad2deg ( atan2 ( sqrt ( 2 * m_cache * & Bmag ( cc ) * spp ( ii )% vars % V ( pp - 1 + cc , 2 )), & spp ( ii )% vars % V ( pp - 1 + cc , 1 ))) end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO if ( params % SC_E ) then call calculate_SC_E1D ( params , F , VdenOMP ) end if end do end do !species iterator end subroutine adv_GCeqn_top","tags":"","loc":"proc/adv_gceqn_top.html"},{"title":"advance_GCeqn_vars – KORC-Full Orbit","text":"public subroutine advance_GCeqn_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, flagCon, flagCol, q_cache, m_cache, B_R, B_PHI, B_Z, F, P, PSIp, E_PHI) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU integer(kind=is), intent(inout), dimension(params%pchunk) :: flagCon integer(kind=is), intent(inout), dimension(params%pchunk) :: flagCol real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z type(FIELDS), intent(in) :: F An instance of the KORC derived type PROFILES. type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI Contents Source Code advance_GCeqn_vars Source Code subroutine advance_GCeqn_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , & flagCon , flagCol , q_cache , m_cache , B_R , B_PHI , B_Z , F , P , PSIp , E_PHI ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type PROFILES. REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), INTENT ( IN ) :: tt !! time iterator. INTEGER , INTENT ( IN ) :: pp REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , V0 , E_Z , E_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , ne , Te , Zeff INTEGER ( is ), dimension ( params % pchunk ), intent ( inout ) :: flagCon , flagCol REAL ( rp ) :: ar , R0 REAL ( rp ), intent ( IN ) :: q_cache , m_cache ar = F % AB % a R0 = F % AB % Ro pchunk = params % pchunk dt = params % dt !    write(output_unit_write,'(\"Y_R 0: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 0: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 0: \",E17.10)') Y_Z(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0 ( cc ) = V_PLL ( cc ) end do !$OMP END SIMD call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if !    write(output_unit_write,'(\"ER:\",E17.10)') E_R !    write(output_unit_write,'(\"EPHI:\",E17.10)') E_PHI !    write(output_unit_write,'(\"EZ:\",E17.10)') E_Z call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k1_R,k1_PHI,k1_Z,k1_PLL) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) !       vars%RHS(pp-1+cc,1)=RHS_R(cc) !       vars%RHS(pp-1+cc,2)=RHS_PHI(cc) !       vars%RHS(pp-1+cc,3)=RHS_Z(cc) !       vars%RHS(pp-1+cc,4)=RHS_PLL(cc) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a1 * k1_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 1: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 1: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 1: \",E17.10)') Y_Z(1) !    write(output_unit_write,'(\"k1R: \",E17.10)') k1_R(1) !    write(output_unit_write,'(\"k1PHI: \",E17.10)') k1_PHI(1) !    write(output_unit_write,'(\"k1Z: \",E17.10)') k1_Z(1) !    write(output_unit_write,'(\"k1PLL: \",E17.10)') k1_PLL(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k2_R,k2_PHI,k2_Z,k2_PLL) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 2: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 2: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 2: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k3_R,k3_PHI,k3_Z,k3_PLL) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 3: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 3: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 3: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k4_R,k4_PHI,k4_Z,k4_PLL) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 4: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 4: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 4: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k5_R,k5_PHI,k5_Z,k5_PLL) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 5: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 5: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 5: \",E17.10)') Y_Z(1) call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if call GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0,Y_R,Y_PHI,Y_Z,V_PLL, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,k6_R,k6_PHI,k6_Z,k6_PLL) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) end do !$OMP END SIMD !    write(output_unit_write,'(\"Y_R 6: \",E17.10)') Y_R(1) !    write(output_unit_write,'(\"Y_PHI 6: \",E17.10)') Y_PHI(1) !    write(output_unit_write,'(\"Y_Z 6: \",E17.10)') Y_Z(1) call cyl_check_if_confined_p ( pchunk , ar , R0 , Y_R , Y_Z , flagCon ) !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,Y0_R,Y0_PHI,Y0_Z,V0) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0 ( cc ) end if end do !$OMP END SIMD call analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) if ( params % SC_E_add ) then call add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) end if if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCeqn_vars","tags":"","loc":"proc/advance_gceqn_vars.html"},{"title":"advance_FPeqn_vars – KORC-Full Orbit","text":"public subroutine advance_FPeqn_vars(params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, flagCon, flagCol, m_cache, F, P, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in) :: m_cache type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FPeqn_vars Source Code subroutine advance_FPeqn_vars ( params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , flagCon , flagCol , & m_cache , F , P , PSIp ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: E_PHI INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( in ) :: m_cache REAL ( rp ), DIMENSION ( params % pchunk ) :: ne do tt = 1_ip , params % t_skip call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !       write(output_unit_write,'(\"Collision Loop in FP\")') end do end subroutine advance_FPeqn_vars","tags":"","loc":"proc/advance_fpeqn_vars.html"},{"title":"adv_GCinterp_psi_top_FS – KORC-Full Orbit","text":"public subroutine adv_GCinterp_psi_top_FS(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F Contents Source Code adv_GCinterp_psi_top_FS Source Code subroutine adv_GCinterp_psi_top_FS ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. real ( rp ), dimension ( F % dim_1D ) :: Vden , Vdenave , VdenOMP !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m do ttt = 1_ip , params % t_it_SC VdenOMP = 0._rp !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne, & !$OMP& Vden,Vdenave) & !$OMP& REDUCTION(+:VdenOMP) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then Vdenave = 0._rp do tt = 1_ip , params % t_skip call advance_GCinterp_psi_vars_FS ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z ) call calculate_SC_p_FS ( params , F , B_R , B_PHI , B_Z , PSIp , & V_PLL , V_MU , m_cache , flagCon , flagCol , Vden ) !                   write(output_unit_write,*) 'pre-Vdenave',Vdenave(F%dim_1D) Vdenave = ( Vdenave * REAL ( tt - 1_ip ) + Vden ) / REAL ( tt ) !                   write(output_unit_write,*) 'Vden',Vden(F%dim_1D) !                   write(output_unit_write,*) 'post-Vdenave',Vdenave(F%dim_1D) !                   if (pp.eq.9_idef) write(output_unit_write,*) 'Vdenave',Vdenave(F%dim_1D) end do !timestep iterator !                write(output_unit_write,*) 'Vdenave',Vdenave(F%dim_1D) VdenOMP = VdenOMP + Vdenave !                write(output_unit_write,*) 'VdenOMP',VdenOMP(F%dim_1D) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO !write(output_unit_write,*) 'VdenOMP',VdenOMP(F%dim_1D) call calculate_SC_E1D_FS ( params , F , VdenOMP ) end do end do !species iterator end subroutine adv_GCinterp_psi_top_FS","tags":"","loc":"proc/adv_gcinterp_psi_top_fs.html"},{"title":"adv_GCinterp_psi_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_psi_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F Contents Source Code adv_GCinterp_psi_top Source Code subroutine adv_GCinterp_psi_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,E_R,E_Z) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_psi_vars ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else if ( params % FokPlan . and . params % collisions ) then call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else do tt = 1_ip , params % t_skip call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) end do !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_psi_top","tags":"","loc":"proc/adv_gcinterp_psi_top.html"},{"title":"adv_GCinterp_m3dc1_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_m3dc1_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F Contents Source Code adv_GCinterp_m3dc1_top Source Code subroutine adv_GCinterp_m3dc1_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar TYPE ( C_PTR ), DIMENSION ( params % pchunk ) :: hint INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,Te,E_R,E_Z,hint) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) E_R ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 1 ) E_PHI ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 2 ) E_Z ( cc ) = spp ( ii )% vars % E ( pp - 1 + cc , 3 ) gradB_R ( cc ) = spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) gradB_PHI ( cc ) = spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) gradB_Z ( cc ) = spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) curlb_R ( cc ) = spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) curlb_PHI ( cc ) = spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) curlb_Z ( cc ) = spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) hint ( cc ) = spp ( ii )% vars % hint ( pp - 1 + cc ) ne ( cc ) = spp ( ii )% vars % ne ( pp - 1 + cc ) Te ( cc ) = spp ( ii )% vars % Te ( pp - 1 + cc ) end do !$OMP END SIMD do tt = 1_ip , params % t_skip call advance_GCinterp_m3dc1_vars ( spp ( ii )% vars , pp , tt , & params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , & flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne , Te , hint ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 1 ) = E_R ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 3 ) = E_Z ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) spp ( ii )% vars % Te ( pp - 1 + cc ) = Te ( cc ) spp ( ii )% vars % hint ( pp - 1 + cc ) = hint ( cc ) end do !$OMP END SIMD !$OMP SIMD do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_m3dc1_top","tags":"","loc":"proc/adv_gcinterp_m3dc1_top.html"},{"title":"adv_GCinterp_psiwE_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_psiwE_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F Contents Source Code adv_GCinterp_psiwE_top Source Code subroutine adv_GCinterp_psiwE_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,E_R,E_Z) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_psiwE_vars ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else if ( params % FokPlan . and . params % collisions ) then call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else do tt = 1_ip , params % t_skip call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp ) end do !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_psiwE_top","tags":"","loc":"proc/adv_gcinterp_psiwe_top.html"},{"title":"adv_GCinterp_psi2x1t_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_psi2x1t_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F Contents Source Code adv_GCinterp_psi2x1t_top Source Code subroutine adv_GCinterp_psi2x1t_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar , time INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt INTEGER ( ip ) :: ttt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,time,E_R,E_Z) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_psi2x1t_vars ( spp ( ii )% vars , pp , tt , & params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , curlb_R , curlb_PHI , & curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else if ( params % FokPlan . and . params % collisions ) then call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % ne ( pp - 1 + cc ) = ne ( cc ) end do !$OMP END SIMD else do tt = 1_ip , params % t_skip time = params % init_time + ( params % it - 1 + tt ) * & params % dt call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , flagCon , PSIp , time ) end do !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_psi2x1t_top","tags":"","loc":"proc/adv_gcinterp_psi2x1t_top.html"},{"title":"adv_GCinterp_B_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_B_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F Contents Source Code adv_GCinterp_B_top Source Code subroutine adv_GCinterp_B_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_B_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_B_top","tags":"","loc":"proc/adv_gcinterp_b_top.html"},{"title":"adv_GCinterp_B2D_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_B2D_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F Contents Source Code adv_GCinterp_B2D_top Source Code subroutine adv_GCinterp_B2D_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_B2D_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_B2D_top","tags":"","loc":"proc/adv_gcinterp_b2d_top.html"},{"title":"adv_GCinterp_2DBdB_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_2DBdB_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F Contents Source Code adv_GCinterp_2DBdB_top Source Code subroutine adv_GCinterp_2DBdB_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species pchunk = params % pchunk q_cache = spp ( ii )% q m_cache = spp ( ii )% m !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_2DBdB_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_2DBdB_top","tags":"","loc":"proc/adv_gcinterp_2dbdb_top.html"},{"title":"adv_GCinterp_3DBdB1_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_3DBdB1_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F Contents Source Code adv_GCinterp_3DBdB1_top Source Code subroutine adv_GCinterp_3DBdB1_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species q_cache = spp ( ii )% q m_cache = spp ( ii )% m pchunk = params % pchunk !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,PSIp,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_3DBdB1_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) spp ( ii )% vars % PSI_P ( pp - 1 + cc ) = PSIp ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_3DBdB1_top","tags":"","loc":"proc/adv_gcinterp_3dbdb1_top.html"},{"title":"adv_GCinterp_3DBdB_top – KORC-Full Orbit","text":"public subroutine adv_GCinterp_3DBdB_top(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F Contents Source Code adv_GCinterp_3DBdB_top Source Code subroutine adv_GCinterp_3DBdB_top ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ), DIMENSION ( params % pchunk ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff REAL ( rp ), DIMENSION ( params % pchunk ) :: V_PLL , V_MU , PSIp REAL ( rp ), DIMENSION ( params % pchunk ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: gradB_R , gradB_PHI , gradB_Z INTEGER ( is ), DIMENSION ( params % pchunk ) :: flagCon , flagCol REAL ( rp ) :: m_cache , q_cache , B0 , EF0 , R0 , q0 , lam , ar INTEGER :: ii !! Species iterator. INTEGER :: pp !! Particles iterator. INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ) :: tt !! time iterator. do ii = 1_idef , params % num_species q_cache = spp ( ii )% q m_cache = spp ( ii )% m pchunk = params % pchunk !$OMP PARALLEL DO default(none) & !$OMP& FIRSTPRIVATE(q_cache,m_cache,pchunk) & !$OMP& SHARED(params,ii,spp,P,F) & !$OMP& PRIVATE(pp,tt,Bmag,cc,Y_R,Y_PHI,Y_Z,V_PLL,V_MU,B_R,B_PHI,B_Z, & !$OMP& flagCon,flagCol,E_PHI,curlb_R,curlb_PHI,curlb_Z, & !$OMP& gradB_R,gradB_PHI,gradB_Z,ne,PSIp) do pp = 1_idef , spp ( ii )% ppp , pchunk !          write(output_unit_write,'(\"pp: \",I16)') pp !$OMP SIMD do cc = 1_idef , pchunk Y_R ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) Y_PHI ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) Y_Z ( cc ) = spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) V_PLL ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 1 ) V_MU ( cc ) = spp ( ii )% vars % V ( pp - 1 + cc , 2 ) PSIp ( cc ) = spp ( ii )% vars % PSI_P ( pp - 1 + cc ) flagCon ( cc ) = spp ( ii )% vars % flagCon ( pp - 1 + cc ) flagCol ( cc ) = spp ( ii )% vars % flagCol ( pp - 1 + cc ) end do !$OMP END SIMD if (. not . params % FokPlan ) then do tt = 1_ip , params % t_skip call advance_GCinterp_3DBdB_vars ( spp ( ii )% vars , pp , tt , params , & Y_R , Y_PHI , Y_Z , V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , & F , P , B_R , B_PHI , B_Z , E_PHI , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , PSIp ) end do !timestep iterator !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % Y ( pp - 1 + cc , 1 ) = Y_R ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 2 ) = Y_PHI ( cc ) spp ( ii )% vars % Y ( pp - 1 + cc , 3 ) = Y_Z ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCon ( pp - 1 + cc ) = flagCon ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 1 ) = B_R ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 2 ) = B_PHI ( cc ) spp ( ii )% vars % B ( pp - 1 + cc , 3 ) = B_Z ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 1 ) = gradB_R ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 2 ) = gradB_PHI ( cc ) spp ( ii )% vars % gradB ( pp - 1 + cc , 3 ) = gradB_Z ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 1 ) = curlb_R ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 2 ) = curlb_PHI ( cc ) spp ( ii )% vars % curlb ( pp - 1 + cc , 3 ) = curlb_Z ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD else call advance_FPinterp_vars ( params , Y_R , Y_PHI , & Y_Z , V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !$OMP SIMD do cc = 1_idef , pchunk spp ( ii )% vars % V ( pp - 1 + cc , 1 ) = V_PLL ( cc ) spp ( ii )% vars % V ( pp - 1 + cc , 2 ) = V_MU ( cc ) spp ( ii )% vars % flagCol ( pp - 1 + cc ) = flagCol ( cc ) spp ( ii )% vars % E ( pp - 1 + cc , 2 ) = E_PHI ( cc ) end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk B_R ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 1 ) B_PHI ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 2 ) B_Z ( cc ) = spp ( ii )% vars % B ( pp - 1 + cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) spp ( ii )% vars % g ( pp - 1 + cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc )) spp ( ii )% vars % eta ( pp - 1 + cc ) = atan2 ( sqrt ( 2 * m_cache * Bmag ( cc ) * & spp ( ii )% vars % V ( pp - 1 + cc , 2 )), spp ( ii )% vars % V ( pp - 1 + cc , 1 )) * & 18 0.0_rp / C_PI end do !$OMP END SIMD end do !particle chunk iterator !$OMP END PARALLEL DO end do !species iterator end subroutine adv_GCinterp_3DBdB_top","tags":"","loc":"proc/adv_gcinterp_3dbdb_top.html"},{"title":"advance_GCinterp_psi_vars_FS – KORC-Full Orbit","text":"public subroutine advance_GCinterp_psi_vars_FS(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z Contents Source Code advance_GCinterp_psi_vars_FS Source Code subroutine advance_GCinterp_psi_vars_FS ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !    write(output_unit_write,*) 'R',Y_R(1) !    write(output_unit_write,*) 'PHI',Y_PHI(1) !    write(output_unit_write,*) 'Z',Y_Z(1) !    write(output_unit_write,*) 'PPLL',V_PLL(1) !    write(output_unit_write,*) 'MU',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % SC_E_add ) then call add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) end if call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psi_vars_FS","tags":"","loc":"proc/advance_gcinterp_psi_vars_fs.html"},{"title":"advance_GCinterp_psi_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_psi_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne Contents Source Code advance_GCinterp_psi_vars Source Code subroutine advance_GCinterp_psi_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'R0',Y_R(1) !write(output_unit_write,*) 'PHI0',Y_PHI(1) !write(output_unit_write,*) 'Z0',Y_Z(1) !write(output_unit_write,*) 'PPLL0',V_PLL(1) !write(output_unit_write,*) 'MU0',V_MU(1) !write(output_unit_write,*) 'ER',E_R(1) !write(output_unit_write,*) 'EPHI',E_PHI(1) !write(output_unit_write,*) 'EZ',E_Z(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) !write(output_unit_write,*) 'ER',E_R(1) !write(output_unit_write,*) 'EPHI',E_PHI(1) !write(output_unit_write,*) 'EZ',E_Z(1) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) !write(output_unit_write,*) 'ER',E_R(1) !write(output_unit_write,*) 'EPHI',E_PHI(1) !write(output_unit_write,*) 'EZ',E_Z(1) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R0',Y_R(1) !write(output_unit_write,*) 'PHI0',Y_PHI(1) !write(output_unit_write,*) 'Z0',Y_Z(1) !write(output_unit_write,*) 'PPLL0',V_PLL(1) !write(output_unit_write,*) 'MU0',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'ER',E_R(1) !    write(output_unit_write,*) 'EPHI',E_PHI(1) !    write(output_unit_write,*) 'EZ',E_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD ! write(output_unit_write,*) 'R1',Y_R(1) ! write(output_unit_write,*) 'PHI1',Y_PHI(1) ! write(output_unit_write,*) 'Z1',Y_Z(1) ! write(output_unit_write,*) 'PPLL1',V_PLL(1) ! write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psi_vars","tags":"","loc":"proc/advance_gcinterp_psi_vars.html"},{"title":"advance_GCinterp_m3dc1_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_m3dc1_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne, Te, hint) Uses omp_lib Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Te type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code advance_GCinterp_m3dc1_vars Source Code subroutine advance_GCinterp_m3dc1_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , PSIp ,& curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne , Te , hint ) USE omp_lib IMPLICIT NONE !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI , E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: ne , Te REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER :: thread_num thread_num = OMP_GET_THREAD_NUM () dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'R0',Y_R(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'PHI0',Y_PHI(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'Z0',Y_Z(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'PPLL0',V_PLL(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'MU0',V_MU(1) call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'B',B_R(1),B_PHI(1),B_Z(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'gradB',gradB_R(1),gradB_PHI(1) !write(output_unit_write,*) 'MPI',params%mpi_params%rank,'OMP',thread_num,'curlB',curlB_R(1),curlB_PHI(1),curlB_Z(1) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !write(output_unit_write,*) 'R1',Y_R(1) !write(output_unit_write,*) 'PHI1',Y_PHI(1) !write(output_unit_write,*) 'Z1',Y_Z(1) !write(output_unit_write,*) 'PPLL1',V_PLL(1) !write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flagCon , hint ) if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_GCelectric_fields_p ( params , F , & Y_R , Y_PHI , Y_Z , E_R , E_PHI , E_Z , flagCon , hint ) end if call get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flagCon , hint ) call GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , te , flagCon , hint ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD !write(6,*) E_PHI if ( params % collisions ) then call include_CoulombCollisions_GCm3dc1_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , Te , PSIp , hint ) end if !write(6,*) E_PHI end subroutine advance_GCinterp_m3dc1_vars","tags":"","loc":"proc/advance_gcinterp_m3dc1_vars.html"},{"title":"advance_GCinterp_psiwE_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_psiwE_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both.\n    write(output_unit_write,*) 'Z1',Y_Z(1) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne Contents Source Code advance_GCinterp_psiwE_vars Source Code subroutine advance_GCinterp_psiwE_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R1',Y_R(1) !    write(output_unit_write,*) 'PHI1',Y_PHI(1) !!    write(output_unit_write,*) 'Z1',Y_Z(1) !   write(output_unit_write,*) 'PPLL1',V_PLL(1) !   write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psiwE_vars","tags":"","loc":"proc/advance_gcinterp_psiwe_vars.html"},{"title":"advance_GCinterp_psi2x1t_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_psi2x1t_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both.\n    write(output_unit_write,*) 'Z1',Y_Z(1) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne Contents Source Code advance_GCinterp_psi2x1t_vars Source Code subroutine advance_GCinterp_psi2x1t_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , PSIp , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , ne ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt , time !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk time = params % init_time + ( params % it - 1 + tt ) * params % dt !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !    write(output_unit_write,*) 'R0',Y_R(1) !    write(output_unit_write,*) 'PHI0',Y_PHI(1) !    write(output_unit_write,*) 'Z0',Y_Z(1) !    write(output_unit_write,*) 'PPLL0',V_PLL(1) !    write(output_unit_write,*) 'MU0',V_MU(1) !    write(output_unit_write,*) 'BR',B_R(1) !    write(output_unit_write,*) 'BPHI',B_PHI(1) !    write(output_unit_write,*) 'BZ',B_Z(1) !    write(output_unit_write,*) 'gradBR',gradB_R(1) !    write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !    write(output_unit_write,*) 'gradBZ',gradB_Z(1) !    write(output_unit_write,*) 'curlBR',curlB_R(1) !    write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !    write(output_unit_write,*) 'curlBZ',curlB_Z(1) !    write(output_unit_write,*) 'dt',params%dt !    write(output_unit_write,*) 'RHS_R',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU',RHS_MU(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'R1',Y_R(1) !    write(output_unit_write,*) 'PHI1',Y_PHI(1) !!    write(output_unit_write,*) 'Z1',Y_Z(1) !   write(output_unit_write,*) 'PPLL1',V_PLL(1) !   write(output_unit_write,*) 'MU1',V_MU(1) !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD !    call interp_fields_p(F,Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,E_R,E_PHI, & call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp , time ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_psi2x1t_vars","tags":"","loc":"proc/advance_gcinterp_psi2x1t_vars.html"},{"title":"advance_GCinterp_B2D_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_B2D_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_GCinterp_B2D_vars Source Code subroutine advance_GCinterp_B2D_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_B2D_vars","tags":"","loc":"proc/advance_gcinterp_b2d_vars.html"},{"title":"advance_GCinterp_2DBdB_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_2DBdB_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_GCinterp_2DBdB_vars Source Code subroutine advance_GCinterp_2DBdB_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !write(output_unit_write,*) 'gradBR',gradB_R(1) !write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !write(output_unit_write,*) 'gradBZ',gradB_Z(1) !write(output_unit_write,*) 'curlBR',curlB_R(1) !write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !write(output_unit_write,*) 'curlBZ',curlB_Z(1) !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_2DBdB_vars","tags":"","loc":"proc/advance_gcinterp_2dbdb_vars.html"},{"title":"advance_GCinterp_3DBdB_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_3DBdB_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_GCinterp_3DBdB_vars Source Code subroutine advance_GCinterp_3DBdB_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !write(output_unit_write,*) 'gradBR',gradB_R(1) !write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !write(output_unit_write,*) 'gradBZ',gradB_Z(1) !write(output_unit_write,*) 'curlBR',curlB_R(1) !write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !write(output_unit_write,*) 'curlBZ',curlB_Z(1) !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_3DBdB_vars","tags":"","loc":"proc/advance_gcinterp_3dbdb_vars.html"},{"title":"advance_GCinterp_3DBdB1_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_3DBdB1_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_GCinterp_3DBdB1_vars Source Code subroutine advance_GCinterp_3DBdB1_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !write(output_unit_write,*) 'R',Y_R(1) !write(output_unit_write,*) 'PHI',Y_PHI(1) !write(output_unit_write,*) 'Z',Y_Z(1) !write(output_unit_write,*) 'PPLL',V_PLL(1) !write(output_unit_write,*) 'MU',V_MU(1) !write(output_unit_write,*) 'BR',B_R(1) !write(output_unit_write,*) 'BPHI',B_PHI(1) !write(output_unit_write,*) 'BZ',B_Z(1) !write(output_unit_write,*) 'gradBR',gradB_R(1) !write(output_unit_write,*) 'gradBPHI',gradB_PHI(1) !write(output_unit_write,*) 'gradBZ',gradB_Z(1) !write(output_unit_write,*) 'curlBR',curlB_R(1) !write(output_unit_write,*) 'curlBPHI',curlB_PHI(1) !write(output_unit_write,*) 'curlBZ',curlB_Z(1) !write(output_unit_write,*) 'RHS_R',RHS_R(1) !write(output_unit_write,*) 'RHS_PHI',RHS_PHI(1) !write(output_unit_write,*) 'RHS_Z',RHS_Z(1) !write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon , PSIp ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_3DBdB1_vars","tags":"","loc":"proc/advance_gcinterp_3dbdb1_vars.html"},{"title":"advance_GCinterp_B_vars – KORC-Full Orbit","text":"public subroutine advance_GCinterp_B_vars(vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Note Subroutine to advance GC variables Comment this section further with evolution equations, numerical\n methods, and descriptions of both. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_GCinterp_B_vars Source Code subroutine advance_GCinterp_B_vars ( vars , pp , tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , q_cache , m_cache , flagCon , flagCol , F , P , B_R , B_PHI , B_Z , E_PHI , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , PSIp ) !! @note Subroutine to advance GC variables ({\\bf X},p_\\parallel) !! @endnote !! Comment this section further with evolution equations, numerical !! methods, and descriptions of both. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: dt !! Time step used in the leapfrog step (\\Delta t). INTEGER :: cc , pchunk !! Chunk iterator. INTEGER ( ip ), intent ( in ) :: tt !! time iterator. INTEGER , intent ( in ) :: pp REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag REAL ( rp ) :: a1 = 1. / 5._rp REAL ( rp ) :: a21 = 3. / 4 0._rp , a22 = 9. / 4 0._rp REAL ( rp ) :: a31 = 3. / 1 0._rp , a32 =- 9. / 1 0._rp , a33 = 6. / 5._rp REAL ( rp ) :: a41 = - 1 1. / 5 4._rp , a42 = 5. / 2._rp , a43 =- 7 0. / 2 7._rp , a44 = 3 5. / 2 7._rp REAL ( rp ) :: a51 = 163 1. / 5529 6._rp , a52 = 17 5. / 51 2._rp , a53 = 57 5. / 1382 4._rp , a54 = 4427 5. / 11059 2._rp , a55 = 25 3. / 409 6._rp REAL ( rp ) :: b1 = 3 7. / 37 8._rp , b2 = 0._rp , b3 = 25 0. / 62 1._rp , b4 = 12 5. / 59 4._rp , b5 = 0._rp , b6 = 51 2. / 177 1._rp REAL ( rp ), DIMENSION ( params % pchunk ) :: k1_R , k1_PHI , k1_Z , k1_PLL , k1_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k2_R , k2_PHI , k2_Z , k2_PLL , k2_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k3_R , k3_PHI , k3_Z , k3_PLL , k3_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k4_R , k4_PHI , k4_Z , k4_PLL , k4_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k5_R , k5_PHI , k5_Z , k5_PLL , k5_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: k6_R , k6_PHI , k6_Z , k6_PLL , k6_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: Y0_R , Y0_PHI , Y0_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: Y_R , Y_PHI , Y_Z , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: E_R , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: V0_PLL , V0_MU REAL ( rp ), DIMENSION ( params % pchunk ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), intent ( IN ) :: q_cache , m_cache dt = params % dt pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU) do cc = 1_idef , pchunk Y0_R ( cc ) = Y_R ( cc ) Y0_PHI ( cc ) = Y_PHI ( cc ) Y0_Z ( cc ) = Y_Z ( cc ) V0_PLL ( cc ) = V_PLL ( cc ) V0_MU ( cc ) = V_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k1_R,k1_PHI,k1_Z,k1_PLL,k1_MU) do cc = 1_idef , pchunk k1_R ( cc ) = dt * RHS_R ( cc ) k1_PHI ( cc ) = dt * RHS_PHI ( cc ) k1_Z ( cc ) = dt * RHS_Z ( cc ) k1_PLL ( cc ) = dt * RHS_PLL ( cc ) k1_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a1 * k1_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a1 * k1_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a1 * k1_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a1 * k1_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a1 * k1_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k2_R,k2_PHI,k2_Z,k2_PLL,k2_MU) do cc = 1_idef , pchunk k2_R ( cc ) = dt * RHS_R ( cc ) k2_PHI ( cc ) = dt * RHS_PHI ( cc ) k2_Z ( cc ) = dt * RHS_Z ( cc ) k2_PLL ( cc ) = dt * RHS_PLL ( cc ) k2_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a21 * k1_R ( cc ) + a22 * k2_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a21 * k1_PHI ( cc ) + a22 * k2_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a21 * k1_Z ( cc ) + a22 * k2_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a21 * k1_PLL ( cc ) + a22 * k2_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a21 * k1_MU ( cc ) + a22 * k2_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k3_R,k3_PHI,k3_Z,k3_PLL,k3_MU) do cc = 1_idef , pchunk k3_R ( cc ) = dt * RHS_R ( cc ) k3_PHI ( cc ) = dt * RHS_PHI ( cc ) k3_Z ( cc ) = dt * RHS_Z ( cc ) k3_PLL ( cc ) = dt * RHS_PLL ( cc ) k3_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a31 * k1_R ( cc ) + a32 * k2_R ( cc ) + a33 * k3_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a31 * k1_PHI ( cc ) + a32 * k2_PHI ( cc ) + & a33 * k3_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a31 * k1_Z ( cc ) + a32 * k2_Z ( cc ) + a33 * k3_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a31 * k1_PLL ( cc ) + a32 * k2_PLL ( cc ) + a33 * k3_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a31 * k1_MU ( cc ) + a32 * k2_MU ( cc ) + a33 * k3_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k4_R,k4_PHI,k4_Z,k4_PLL,k4_MU) do cc = 1_idef , pchunk k4_R ( cc ) = dt * RHS_R ( cc ) k4_PHI ( cc ) = dt * RHS_PHI ( cc ) k4_Z ( cc ) = dt * RHS_Z ( cc ) k4_PLL ( cc ) = dt * RHS_PLL ( cc ) k4_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a41 * k1_R ( cc ) + a42 * k2_R ( cc ) + a43 * k3_R ( cc ) + & a44 * k4_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a41 * k1_PHI ( cc ) + a42 * k2_PHI ( cc ) + & a43 * k3_PHI ( cc ) + a44 * k4_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a41 * k1_Z ( cc ) + a42 * k2_Z ( cc ) + a43 * k3_Z ( cc ) + & a44 * k4_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a41 * k1_PLL ( cc ) + a42 * k2_PLL ( cc ) + & a43 * k3_PLL ( cc ) + a44 * k4_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a41 * k1_MU ( cc ) + a42 * k2_MU ( cc ) + & a43 * k3_MU ( cc ) + a44 * k4_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k5_R,k5_PHI,k5_Z,k5_PLL,k5_MU) do cc = 1_idef , pchunk k5_R ( cc ) = dt * RHS_R ( cc ) k5_PHI ( cc ) = dt * RHS_PHI ( cc ) k5_Z ( cc ) = dt * RHS_Z ( cc ) k5_PLL ( cc ) = dt * RHS_PLL ( cc ) k5_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + a51 * k1_R ( cc ) + a52 * k2_R ( cc ) + a53 * k3_R ( cc ) + & a54 * k4_R ( cc ) + a55 * k5_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + a51 * k1_PHI ( cc ) + a52 * k2_PHI ( cc ) + & a53 * k3_PHI ( cc ) + a54 * k4_PHI ( cc ) + a55 * k5_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + a51 * k1_Z ( cc ) + a52 * k2_Z ( cc ) + a53 * k3_Z ( cc ) + & a54 * k4_Z ( cc ) + a55 * k5_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + a51 * k1_PLL ( cc ) + a52 * k2_PLL ( cc ) + & a53 * k3_PLL ( cc ) + a54 * k4_PLL ( cc ) + a55 * k5_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + a51 * k1_MU ( cc ) + a52 * k2_MU ( cc ) + & a53 * k3_MU ( cc ) + a54 * k4_MU ( cc ) + a55 * k5_MU ( cc ) end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD !    !$OMP& aligned(Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU,Y_R,Y_PHI,Y_Z,V_PLL,V_MU, & !    !$OMP& RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& k6_R,k6_PHI,k6_Z,k6_PLL,k6_MU) do cc = 1_idef , pchunk k6_R ( cc ) = dt * RHS_R ( cc ) k6_PHI ( cc ) = dt * RHS_PHI ( cc ) k6_Z ( cc ) = dt * RHS_Z ( cc ) k6_PLL ( cc ) = dt * RHS_PLL ( cc ) k6_MU ( cc ) = dt * RHS_MU ( cc ) Y_R ( cc ) = Y0_R ( cc ) + b1 * k1_R ( cc ) + b2 * k2_R ( cc ) + & b3 * k3_R ( cc ) + b4 * k4_R ( cc ) + b5 * k5_R ( cc ) + b6 * k6_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) + b1 * k1_PHI ( cc ) + b2 * k2_PHI ( cc ) + & b3 * k3_PHI ( cc ) + b4 * k4_PHI ( cc ) + b5 * k5_PHI ( cc ) + b6 * k6_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) + b1 * k1_Z ( cc ) + b2 * k2_Z ( cc ) + & b3 * k3_Z ( cc ) + b4 * k4_Z ( cc ) + b5 * k5_Z ( cc ) + b6 * k6_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) + b1 * k1_PLL ( cc ) + b2 * k2_PLL ( cc ) + & b3 * k3_PLL ( cc ) + b4 * k4_PLL ( cc ) + b5 * k5_PLL ( cc ) + b6 * k6_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) + b1 * k1_MU ( cc ) + b2 * k2_MU ( cc ) + & b3 * k3_MU ( cc ) + b4 * k4_MU ( cc ) + b5 * k5_MU ( cc ) + b6 * k6_MU ( cc ) end do !$OMP END SIMD !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,V_PLL,V_MU,Y0_R,Y0_PHI,Y0_Z,V0_PLL,V0_MU) do cc = 1_idef , pchunk if (( flagCon ( cc ). eq . 0_is ). or .( flagCol ( cc ). eq . 0_is )) then Y_R ( cc ) = Y0_R ( cc ) Y_PHI ( cc ) = Y0_PHI ( cc ) Y_Z ( cc ) = Y0_Z ( cc ) V_PLL ( cc ) = V0_PLL ( cc ) V_MU ( cc ) = V0_MU ( cc ) end if end do !$OMP END SIMD call interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , & E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flagCon ) call GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) !$OMP SIMD do cc = 1_idef , pchunk vars % RHS ( pp - 1 + cc , 1 ) = RHS_R ( cc ) vars % RHS ( pp - 1 + cc , 2 ) = RHS_PHI ( cc ) vars % RHS ( pp - 1 + cc , 3 ) = RHS_Z ( cc ) vars % RHS ( pp - 1 + cc , 4 ) = RHS_PLL ( cc ) vars % RHS ( pp - 1 + cc , 5 ) = RHS_MU ( cc ) end do !$OMP END SIMD call add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) if ( params % collisions ) then call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) end if end subroutine advance_GCinterp_B_vars","tags":"","loc":"proc/advance_gcinterp_b_vars.html"},{"title":"advance_FPinterp_vars – KORC-Full Orbit","text":"public subroutine advance_FPinterp_vars(params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, m_cache, flagCon, flagCol, F, P, E_PHI, ne, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp Contents Source Code advance_FPinterp_vars Source Code subroutine advance_FPinterp_vars ( params , Y_R , Y_PHI , Y_Z , V_PLL , V_MU , & m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ) :: tt !! time iterator. REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: V_PLL , V_MU , PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_PHI REAL ( rp ), intent ( in ) :: m_cache INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flagCon , flagCol REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne !    write(output_unit_write,'(\"E_PHI_FP: \",E17.10)') E_PHI do tt = 1_ip , params % t_skip call include_CoulombCollisions_GC_p ( tt , params , Y_R , Y_PHI , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , F , P , E_PHI , ne , PSIp ) !       write(output_unit_write,'(\"Collision Loop in FP\")') end do !    write(output_unit_write,'(\"V_PLL: \",E17.10)') V_PLL !    write(output_unit_write,'(\"V_MU: \",E17.10)') V_MU end subroutine advance_FPinterp_vars","tags":"","loc":"proc/advance_fpinterp_vars.html"},{"title":"GCEoM_p – KORC-Full Orbit","text":"private subroutine GCEoM_p(params, RHS_R, RHS_PHI, RHS_Z, RHS_PLL, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, V_PLL, V_MU, Y_R, q_cache, m_cache) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache Contents Source Code GCEoM_p Source Code subroutine GCEoM_p ( params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , B_R , B_PHI , & B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , & gradB_Z , V_PLL , V_MU , Y_R , q_cache , m_cache ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , bhat_R , bhat_PHI , bhat_Z , Bst_R , Bst_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: BstdotE , BstdotgradB , EcrossB_R , EcrossB_PHI , bdotBst REAL ( rp ), DIMENSION ( params % pchunk ) :: bcrossgradB_R , bcrossgradB_PHI , bcrossgradB_Z , gamgc REAL ( rp ), DIMENSION ( params % pchunk ) :: EcrossB_Z , Bst_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: pm , xi , tau_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: gradB_R , gradB_PHI , gradB_Z , curlb_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: curlb_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_R , RHS_PHI , RHS_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_PLL REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: V_PLL , V_MU , Y_R , curlb_PHI REAL ( rp ), INTENT ( in ) :: q_cache , m_cache INTEGER ( ip ) :: cc , pchunk pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(gradB_R,gradB_PHI,gradB_Z,curlb_R,curlb_Z, & !    !$OMP& B_R,B_PHI,B_Z,E_R,E_PHI,E_Z,RHS_R,RHS_PHI,RHS_Z,RHS_PLL, & !    !$OMP& V_PLL,V_MU,Y_R,curlb_PHI) do cc = 1_idef , pchunk Bmag ( cc ) = SQRT ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) bhat_R ( cc ) = B_R ( cc ) / Bmag ( cc ) bhat_PHI ( cc ) = B_PHI ( cc ) / Bmag ( cc ) bhat_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) Bst_R ( cc ) = q_cache * B_R ( cc ) + V_PLL ( cc ) * curlb_R ( cc ) Bst_PHI ( cc ) = q_cache * B_PHI ( cc ) + V_PLL ( cc ) * curlb_PHI ( cc ) Bst_Z ( cc ) = q_cache * B_Z ( cc ) + V_PLL ( cc ) * curlb_Z ( cc ) bdotBst ( cc ) = bhat_R ( cc ) * Bst_R ( cc ) + bhat_PHI ( cc ) * Bst_PHI ( cc ) + & bhat_Z ( cc ) * Bst_Z ( cc ) BstdotE ( cc ) = Bst_R ( cc ) * E_R ( cc ) + Bst_PHI ( cc ) * E_PHI ( cc ) + Bst_Z ( cc ) * E_Z ( cc ) BstdotgradB ( cc ) = Bst_R ( cc ) * gradB_R ( cc ) + Bst_PHI ( cc ) * gradB_PHI ( cc ) + & Bst_Z ( cc ) * gradB_Z ( cc ) Ecrossb_R ( cc ) = E_PHI ( cc ) * bhat_Z ( cc ) - E_Z ( cc ) * bhat_PHI ( cc ) Ecrossb_PHI ( cc ) = E_Z ( cc ) * bhat_R ( cc ) - E_R ( cc ) * bhat_Z ( cc ) Ecrossb_Z ( cc ) = E_R ( cc ) * bhat_PHI ( cc ) - E_PHI ( cc ) * bhat_R ( cc ) bcrossgradB_R ( cc ) = bhat_PHI ( cc ) * gradB_Z ( cc ) - bhat_Z ( cc ) * gradB_PHI ( cc ) bcrossgradB_PHI ( cc ) = bhat_Z ( cc ) * gradB_R ( cc ) - bhat_R ( cc ) * gradB_Z ( cc ) bcrossgradB_Z ( cc ) = bhat_R ( cc ) * gradB_PHI ( cc ) - bhat_PHI ( cc ) * gradB_R ( cc ) gamgc ( cc ) = sqrt ( 1 + V_PLL ( cc ) * V_PLL ( cc ) + 2 * V_MU ( cc ) * Bmag ( cc )) pm ( cc ) = sqrt ( gamgc ( cc ) ** 2 - 1 ) xi ( cc ) = V_PLL ( cc ) / pm ( cc ) RHS_R ( cc ) = ( q_cache * Ecrossb_R ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_R ( cc ) + V_PLL ( cc ) * Bst_R ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PHI ( cc ) = ( q_cache * Ecrossb_PHI ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_PHI ( cc ) + V_PLL ( cc ) * Bst_PHI ( cc )) / ( m_cache * gamgc ( cc ))) / & ( Y_R ( cc ) * bdotBst ( cc )) RHS_Z ( cc ) = ( q_cache * Ecrossb_Z ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_Z ( cc ) + V_PLL ( cc ) * Bst_Z ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PLL ( cc ) = ( q_cache * BstdotE ( cc ) - V_MU ( cc ) * BstdotgradB ( cc ) / gamgc ( cc )) / & bdotBst ( cc ) end do !$OMP END SIMD !    write(output_unit_write,*) 'RHS_R: ',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI: ',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z: ',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL: ',RHS_PLL(1) end subroutine GCEoM_p","tags":"","loc":"proc/gceom_p.html"},{"title":"GCEoM1_p – KORC-Full Orbit","text":"private subroutine GCEoM1_p(tt, P, F, params, RHS_R, RHS_PHI, RHS_Z, RHS_PLL, RHS_MU, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, V_PLL, V_MU, Y_R, Y_Z, q_cache, m_cache, PSIp, ne) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PLL real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne Contents Source Code GCEoM1_p Source Code subroutine GCEoM1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_Z , q_cache , m_cache , PSIp , ne ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( PROFILES ), INTENT ( IN ) :: P REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , bhat_R , bhat_PHI , bhat_Z , Bst_R , Bst_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: BstdotE , BstdotgradB , EcrossB_R , EcrossB_PHI , bdotBst REAL ( rp ), DIMENSION ( params % pchunk ) :: bcrossgradB_R , bcrossgradB_PHI , bcrossgradB_Z , gamgc REAL ( rp ), DIMENSION ( params % pchunk ) :: EcrossB_Z , Bst_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: pm , xi , tau_R REAL ( rp ), DIMENSION ( params % pchunk ) :: SR_PLL , SR_MU , BREM_PLL , BREM_MU , BREM_P REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: gradB_R , gradB_PHI , gradB_Z , curlb_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: curlb_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_R , RHS_PHI , RHS_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: V_PLL , V_MU , Y_R , Y_Z , curlb_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: PSIp REAL ( rp ), INTENT ( in ) :: q_cache , m_cache INTEGER ( ip ) :: cc , pchunk INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ) :: time , re_cache , alpha_cache REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff , Te REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(gradB_R,gradB_PHI,gradB_Z,curlb_R,curlb_Z, & !    !$OMP& B_R,B_PHI,B_Z,E_R,E_PHI,E_Z,RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& V_PLL,V_MU,Y_R,curlb_PHI,tau_R) do cc = 1_idef , pchunk ne ( cc ) =- 1._rp Te ( cc ) =- 1._rp Zeff ( cc ) =- 1._rp Bmag ( cc ) = SQRT ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) bhat_R ( cc ) = B_R ( cc ) / Bmag ( cc ) bhat_PHI ( cc ) = B_PHI ( cc ) / Bmag ( cc ) bhat_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) Bst_R ( cc ) = q_cache * B_R ( cc ) + V_PLL ( cc ) * curlb_R ( cc ) Bst_PHI ( cc ) = q_cache * B_PHI ( cc ) + V_PLL ( cc ) * curlb_PHI ( cc ) Bst_Z ( cc ) = q_cache * B_Z ( cc ) + V_PLL ( cc ) * curlb_Z ( cc ) ! write(output_unit_write,*) 'bmag',Bmag(cc),'bhat',bhat_R(cc),bhat_PHI(cc),bhat_Z(cc),'Bst',Bst_R(cc),Bst_PHI(cc),Bst_Z(cc) bdotBst ( cc ) = bhat_R ( cc ) * Bst_R ( cc ) + bhat_PHI ( cc ) * Bst_PHI ( cc ) + & bhat_Z ( cc ) * Bst_Z ( cc ) BstdotE ( cc ) = Bst_R ( cc ) * E_R ( cc ) + Bst_PHI ( cc ) * E_PHI ( cc ) + Bst_Z ( cc ) * E_Z ( cc ) BstdotgradB ( cc ) = Bst_R ( cc ) * gradB_R ( cc ) + Bst_PHI ( cc ) * gradB_PHI ( cc ) + & Bst_Z ( cc ) * gradB_Z ( cc ) !write(output_unit_write,*) 'bdotBst',bdotBst(cc),BstdotE(cc),BstdotgradB(cc) Ecrossb_R ( cc ) = E_PHI ( cc ) * bhat_Z ( cc ) - E_Z ( cc ) * bhat_PHI ( cc ) Ecrossb_PHI ( cc ) = E_Z ( cc ) * bhat_R ( cc ) - E_R ( cc ) * bhat_Z ( cc ) Ecrossb_Z ( cc ) = E_R ( cc ) * bhat_PHI ( cc ) - E_PHI ( cc ) * bhat_R ( cc ) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(cc),Ecrossb_PHI(cc),Ecrossb_Z(cc) bcrossgradB_R ( cc ) = bhat_PHI ( cc ) * gradB_Z ( cc ) - bhat_Z ( cc ) * gradB_PHI ( cc ) bcrossgradB_PHI ( cc ) = bhat_Z ( cc ) * gradB_R ( cc ) - bhat_R ( cc ) * gradB_Z ( cc ) bcrossgradB_Z ( cc ) = bhat_R ( cc ) * gradB_PHI ( cc ) - bhat_PHI ( cc ) * gradB_R ( cc ) ! write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(cc),bcrossgradB_PHI(cc),bcrossgradB_Z(cc) gamgc ( cc ) = sqrt ( 1 + V_PLL ( cc ) * V_PLL ( cc ) + 2 * V_MU ( cc ) * Bmag ( cc )) pm ( cc ) = sqrt ( gamgc ( cc ) ** 2 - 1 ) xi ( cc ) = V_PLL ( cc ) / pm ( cc ) RHS_R ( cc ) = ( q_cache * Ecrossb_R ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_R ( cc ) + V_PLL ( cc ) * Bst_R ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PHI ( cc ) = ( q_cache * Ecrossb_PHI ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_PHI ( cc ) + V_PLL ( cc ) * Bst_PHI ( cc )) / ( m_cache * gamgc ( cc ))) / & ( Y_R ( cc ) * bdotBst ( cc )) RHS_Z ( cc ) = ( q_cache * Ecrossb_Z ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_Z ( cc ) + V_PLL ( cc ) * Bst_Z ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PLL ( cc ) = ( q_cache * BstdotE ( cc ) - V_MU ( cc ) * BstdotgradB ( cc ) / gamgc ( cc )) / & bdotBst ( cc ) RHS_MU ( cc ) = 0._rp end do !$OMP END SIMD !write(output_unit_write,*) 'bmag',Bmag(1),'bhat',bhat_R(1),bhat_PHI(1),bhat_Z(1),'Bst',Bst_R(1),Bst_PHI(1),Bst_Z(1) !write(output_unit_write,*) 'bdotBst',bdotBst(1),BstdotE(1),BstdotgradB(1) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(1),Ecrossb_PHI(1),Ecrossb_Z(1) !write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(1),bcrossgradB_PHI(1),bcrossgradB_Z(1) !    !$OMP SIMD !    do cc=1_idef,8 !       if(isnan(RHS_R(cc))) stop 'RHS_R0 is a NaN' !       if(isnan(RHS_PHI(cc))) stop 'RHS_PHI0 is a NaN' !       if(isnan(RHS_Z(cc))) stop 'RHS_Z0 is a NaN' !       if(isnan(RHS_PLL(cc))) stop 'RHS_PLL0 is a NaN' !       if(isnan(RHS_MU(cc))) stop 'RHS_MU0 is a NaN' !    end do !    !$OMP END SIMD if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !       write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) re_cache = C_RE / params % cpp % length alpha_cache = C_a time = params % init_time + ( params % it - 1 + tt ) * params % dt call analytical_profiles_p ( time , params , Y_R , Y_Z , P , F , ne , Te , Zeff , PSIp ) !$OMP SIMD !       !$OMP& aligned(tau_R,Bmag,RHS_PLL,V_PLL,xi,gamgc,RHS_MU,V_MU) do cc = 1_idef , pchunk tau_R ( cc ) = 6 * C_PI * E0 / ( Bmag ( cc ) * Bmag ( cc )) SR_PLL ( cc ) = V_PLL ( cc ) * ( 1._rp - xi ( cc ) * xi ( cc )) / tau_R ( cc ) * & ( 1._rp / gamgc ( cc ) - gamgc ( cc )) SR_MU ( cc ) =- 2._rp * V_MU ( cc ) / tau_R ( cc ) * & ( gamgc ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) + xi ( cc ) * xi ( cc ) / gamgc ( cc )) !Normalizations done here BREM_P ( cc ) =- 4._rp * re_cache ** 2 * ne ( cc ) * & Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * alpha_cache * & ( gamgc ( cc ) - 1._rp ) * ( log ( 2._rp * gamgc ( cc )) - 1._rp / 3._rp ) BREM_PLL ( cc ) = xi ( cc ) * BREM_P ( cc ) BREM_MU ( cc ) = ( 1._rp - xi ( cc ) * xi ( cc )) * V_PLL ( cc ) / & ( Bmag ( cc ) * xi ( cc )) * BREM_P ( cc ) RHS_PLL ( cc ) = RHS_PLL ( cc ) + SR_PLL ( cc ) + BREM_PLL ( cc ) RHS_MU ( cc ) = SR_MU ( cc ) + BREM_MU ( cc ) end do !$OMP END SIMD end if if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( ne ( cc ))) stop 'ne is a NaN' if ( isnan ( Zeff ( cc ))) stop 'Zeff is a NaN' if ( isnan ( BREM_P ( cc ))) stop 'BREM_P is a NaN' if ( isnan ( BREM_PLL ( cc ))) stop 'BREM_PLL is a NaN' if ( isnan ( BREM_MU ( cc ))) stop 'BREM_MU is a NaN' if ( isnan ( SR_PLL ( cc ))) stop 'SR_PLL is a NaN' if ( isnan ( SR_MU ( cc ))) stop 'SR_MU is a NaN' end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( gamgc ( cc ))) stop 'gamgc is a NaN' if ( isnan ( RHS_R ( cc ))) stop 'RHS_R1 is a NaN' if ( isnan ( RHS_PHI ( cc ))) stop 'RHS_PHI1 is a NaN' if ( isnan ( RHS_Z ( cc ))) stop 'RHS_Z1 is a NaN' if ( isnan ( RHS_PLL ( cc ))) stop 'RHS_PLL1 is a NaN' if ( isnan ( RHS_MU ( cc ))) stop 'RHS_MU1 is a NaN' end do !$OMP END SIMD !    write(output_unit_write,*) 'RHS_R: ',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI: ',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z: ',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL: ',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU: ',RHS_MU(1) end subroutine GCEoM1_p","tags":"","loc":"proc/gceom1_p.html"},{"title":"GCEoM1_m3dc1_p – KORC-Full Orbit","text":"public subroutine GCEoM1_m3dc1_p(tt, P, F, params, RHS_R, RHS_PHI, RHS_Z, RHS_PLL, RHS_MU, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, V_PLL, V_MU, Y_R, Y_PHI, Y_Z, q_cache, m_cache, PSIp, ne, Te, flag, hint) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PLL real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(out), DIMENSION(params%pchunk) :: Te integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code GCEoM1_m3dc1_p Source Code subroutine GCEoM1_m3dc1_p ( tt , P , F , params , RHS_R , RHS_PHI , RHS_Z , RHS_PLL , RHS_MU , & B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , & gradB_R , gradB_PHI , gradB_Z , V_PLL , V_MU , Y_R , Y_PHI , Y_Z , q_cache , m_cache , PSIp , & ne , Te , flag , hint ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( PROFILES ), INTENT ( IN ) :: P REAL ( rp ), DIMENSION ( params % pchunk ) :: Bmag , bhat_R , bhat_PHI , bhat_Z , Bst_R , Bst_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: BstdotE , BstdotgradB , EcrossB_R , EcrossB_PHI , bdotBst REAL ( rp ), DIMENSION ( params % pchunk ) :: bcrossgradB_R , bcrossgradB_PHI , bcrossgradB_Z , gamgc REAL ( rp ), DIMENSION ( params % pchunk ) :: EcrossB_Z , Bst_Z REAL ( rp ), DIMENSION ( params % pchunk ) :: pm , xi , tau_R REAL ( rp ), DIMENSION ( params % pchunk ) :: SR_PLL , SR_MU , BREM_PLL , BREM_MU , BREM_P REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: gradB_R , gradB_PHI , gradB_Z , curlb_R REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( in ) :: curlb_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_R , RHS_PHI , RHS_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: RHS_PLL , RHS_MU REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: V_PLL , V_MU , Y_R , Y_PHI , Y_Z , curlb_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: PSIp REAL ( rp ), INTENT ( in ) :: q_cache , m_cache INTEGER ( ip ) :: cc , pchunk INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ) :: time , re_cache , alpha_cache REAL ( rp ), DIMENSION ( params % pchunk ) :: Zeff REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: ne , Te TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( is ), DIMENSION ( params % pchunk ), intent ( INOUT ) :: flag pchunk = params % pchunk !$OMP SIMD !    !$OMP& aligned(gradB_R,gradB_PHI,gradB_Z,curlb_R,curlb_Z, & !    !$OMP& B_R,B_PHI,B_Z,E_R,E_PHI,E_Z,RHS_R,RHS_PHI,RHS_Z,RHS_PLL,RHS_MU, & !    !$OMP& V_PLL,V_MU,Y_R,curlb_PHI,tau_R) do cc = 1_idef , pchunk ne ( cc ) =- 1._rp Te ( cc ) =- 1._rp Zeff ( cc ) =- 1._rp Bmag ( cc ) = SQRT ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) bhat_R ( cc ) = B_R ( cc ) / Bmag ( cc ) bhat_PHI ( cc ) = B_PHI ( cc ) / Bmag ( cc ) bhat_Z ( cc ) = B_Z ( cc ) / Bmag ( cc ) Bst_R ( cc ) = q_cache * B_R ( cc ) + V_PLL ( cc ) * curlb_R ( cc ) Bst_PHI ( cc ) = q_cache * B_PHI ( cc ) + V_PLL ( cc ) * curlb_PHI ( cc ) Bst_Z ( cc ) = q_cache * B_Z ( cc ) + V_PLL ( cc ) * curlb_Z ( cc ) ! write(output_unit_write,*) 'bmag',Bmag(cc),'bhat',bhat_R(cc),bhat_PHI(cc),bhat_Z(cc),'Bst',Bst_R(cc),Bst_PHI(cc),Bst_Z(cc) bdotBst ( cc ) = bhat_R ( cc ) * Bst_R ( cc ) + bhat_PHI ( cc ) * Bst_PHI ( cc ) + & bhat_Z ( cc ) * Bst_Z ( cc ) BstdotE ( cc ) = Bst_R ( cc ) * E_R ( cc ) + Bst_PHI ( cc ) * E_PHI ( cc ) + Bst_Z ( cc ) * E_Z ( cc ) BstdotgradB ( cc ) = Bst_R ( cc ) * gradB_R ( cc ) + Bst_PHI ( cc ) * gradB_PHI ( cc ) + & Bst_Z ( cc ) * gradB_Z ( cc ) !write(output_unit_write,*) 'bdotBst',bdotBst(cc),BstdotE(cc),BstdotgradB(cc) Ecrossb_R ( cc ) = E_PHI ( cc ) * bhat_Z ( cc ) - E_Z ( cc ) * bhat_PHI ( cc ) Ecrossb_PHI ( cc ) = E_Z ( cc ) * bhat_R ( cc ) - E_R ( cc ) * bhat_Z ( cc ) Ecrossb_Z ( cc ) = E_R ( cc ) * bhat_PHI ( cc ) - E_PHI ( cc ) * bhat_R ( cc ) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(cc),Ecrossb_PHI(cc),Ecrossb_Z(cc) bcrossgradB_R ( cc ) = bhat_PHI ( cc ) * gradB_Z ( cc ) - bhat_Z ( cc ) * gradB_PHI ( cc ) bcrossgradB_PHI ( cc ) = bhat_Z ( cc ) * gradB_R ( cc ) - bhat_R ( cc ) * gradB_Z ( cc ) bcrossgradB_Z ( cc ) = bhat_R ( cc ) * gradB_PHI ( cc ) - bhat_PHI ( cc ) * gradB_R ( cc ) ! write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(cc),bcrossgradB_PHI(cc),bcrossgradB_Z(cc) gamgc ( cc ) = sqrt ( 1 + V_PLL ( cc ) * V_PLL ( cc ) + 2 * V_MU ( cc ) * Bmag ( cc )) pm ( cc ) = sqrt ( gamgc ( cc ) ** 2 - 1 ) xi ( cc ) = V_PLL ( cc ) / pm ( cc ) RHS_R ( cc ) = ( q_cache * Ecrossb_R ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_R ( cc ) + V_PLL ( cc ) * Bst_R ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PHI ( cc ) = ( q_cache * Ecrossb_PHI ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_PHI ( cc ) + V_PLL ( cc ) * Bst_PHI ( cc )) / ( m_cache * gamgc ( cc ))) / & ( Y_R ( cc ) * bdotBst ( cc )) RHS_Z ( cc ) = ( q_cache * Ecrossb_Z ( cc ) + ( m_cache * V_MU ( cc ) * & bcrossgradB_Z ( cc ) + V_PLL ( cc ) * Bst_Z ( cc )) / ( m_cache * gamgc ( cc ))) / & bdotBst ( cc ) RHS_PLL ( cc ) = ( q_cache * BstdotE ( cc ) - V_MU ( cc ) * BstdotgradB ( cc ) / gamgc ( cc )) / & bdotBst ( cc ) RHS_MU ( cc ) = 0._rp end do !$OMP END SIMD !write(output_unit_write,*) 'bmag',Bmag(1),'bhat',bhat_R(1),bhat_PHI(1),bhat_Z(1),'Bst',Bst_R(1),Bst_PHI(1),Bst_Z(1) !write(output_unit_write,*) 'bdotBst',bdotBst(1),BstdotE(1),BstdotgradB(1) !write(output_unit_write,*) 'Ecrossb',Ecrossb_R(1),Ecrossb_PHI(1),Ecrossb_Z(1) !write(output_unit_write,*) 'bcrossgradB',bcrossgradB_R(1),bcrossgradB_PHI(1),bcrossgradB_Z(1) !    !$OMP SIMD !    do cc=1_idef,8 !       if(isnan(RHS_R(cc))) stop 'RHS_R0 is a NaN' !       if(isnan(RHS_PHI(cc))) stop 'RHS_PHI0 is a NaN' !       if(isnan(RHS_Z(cc))) stop 'RHS_Z0 is a NaN' !       if(isnan(RHS_PLL(cc))) stop 'RHS_PLL0 is a NaN' !       if(isnan(RHS_MU(cc))) stop 'RHS_MU0 is a NaN' !    end do !    !$OMP END SIMD if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !       write(output_unit_write,*) 'RHS_PLL',RHS_PLL(1) re_cache = C_RE / params % cpp % length alpha_cache = C_a call get_m3d_c1_profile_p ( params , P , Y_R , Y_PHI , Y_Z , & ne , Te , flag , hint ) !$OMP SIMD !       !$OMP& aligned(tau_R,Bmag,RHS_PLL,V_PLL,xi,gamgc,RHS_MU,V_MU) do cc = 1_idef , pchunk tau_R ( cc ) = 6 * C_PI * E0 / ( Bmag ( cc ) * Bmag ( cc )) SR_PLL ( cc ) = V_PLL ( cc ) * ( 1._rp - xi ( cc ) * xi ( cc )) / tau_R ( cc ) * & ( 1._rp / gamgc ( cc ) - gamgc ( cc )) SR_MU ( cc ) =- 2._rp * V_MU ( cc ) / tau_R ( cc ) * & ( gamgc ( cc ) * ( 1 - xi ( cc ) * xi ( cc )) + xi ( cc ) * xi ( cc ) / gamgc ( cc )) !Normalizations done here BREM_P ( cc ) =- 4._rp * re_cache ** 2 * ne ( cc ) * & Zeff ( cc ) * ( Zeff ( cc ) + 1._rp ) * alpha_cache * & ( gamgc ( cc ) - 1._rp ) * ( log ( 2._rp * gamgc ( cc )) - 1._rp / 3._rp ) BREM_PLL ( cc ) = xi ( cc ) * BREM_P ( cc ) BREM_MU ( cc ) = ( 1._rp - xi ( cc ) * xi ( cc )) * V_PLL ( cc ) / & ( Bmag ( cc ) * xi ( cc )) * BREM_P ( cc ) RHS_PLL ( cc ) = RHS_PLL ( cc ) + SR_PLL ( cc ) + BREM_PLL ( cc ) RHS_MU ( cc ) = SR_MU ( cc ) + BREM_MU ( cc ) end do !$OMP END SIMD end if if ( params % radiation . and .( params % GC_rad_model . eq . 'SDE' )) then !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( ne ( cc ))) stop 'ne is a NaN' if ( isnan ( Zeff ( cc ))) stop 'Zeff is a NaN' if ( isnan ( BREM_P ( cc ))) stop 'BREM_P is a NaN' if ( isnan ( BREM_PLL ( cc ))) stop 'BREM_PLL is a NaN' if ( isnan ( BREM_MU ( cc ))) stop 'BREM_MU is a NaN' if ( isnan ( SR_PLL ( cc ))) stop 'SR_PLL is a NaN' if ( isnan ( SR_MU ( cc ))) stop 'SR_MU is a NaN' end do !$OMP END SIMD end if !$OMP SIMD do cc = 1_idef , pchunk if ( isnan ( gamgc ( cc ))) stop 'gamgc is a NaN' if ( isnan ( RHS_R ( cc ))) stop 'RHS_R1 is a NaN' if ( isnan ( RHS_PHI ( cc ))) stop 'RHS_PHI1 is a NaN' if ( isnan ( RHS_Z ( cc ))) stop 'RHS_Z1 is a NaN' if ( isnan ( RHS_PLL ( cc ))) stop 'RHS_PLL1 is a NaN' if ( isnan ( RHS_MU ( cc ))) stop 'RHS_MU1 is a NaN' end do !$OMP END SIMD !    write(output_unit_write,*) 'RHS_R: ',RHS_R(1) !    write(output_unit_write,*) 'RHS_PHI: ',RHS_PHI(1) !    write(output_unit_write,*) 'RHS_Z: ',RHS_Z(1) !    write(output_unit_write,*) 'RHS_PLL: ',RHS_PLL(1) !    write(output_unit_write,*) 'RHS_MU: ',RHS_MU(1) end subroutine GCEoM1_m3dc1_p","tags":"","loc":"proc/gceom1_m3dc1_p.html"},{"title":"aux_fields – KORC-Full Orbit","text":"private subroutine aux_fields(pp, spp, gradB, curlb, Bmag) Arguments Type Intent Optional Attributes Name integer :: pp type(SPECIES), intent(in) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. real(kind=rp), intent(inout), DIMENSION(3) :: gradB real(kind=rp), intent(inout), DIMENSION(3) :: curlb real(kind=rp), intent(in) :: Bmag Contents Source Code aux_fields Source Code subroutine aux_fields ( pp , spp , gradB , curlb , Bmag ) TYPE ( SPECIES ), INTENT ( IN ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. REAL ( rp ), DIMENSION ( 3 ), INTENT ( INOUT ) :: gradB REAL ( rp ), DIMENSION ( 3 ), INTENT ( INOUT ) :: curlb REAL ( rp ), INTENT ( IN ) :: Bmag REAL ( rp ) :: dRB REAL ( rp ) :: dPHIB REAL ( rp ) :: dZB INTEGER :: pp dRB = ( spp % vars % B ( pp , 1 ) * spp % vars % BR ( pp , 1 ) + & spp % vars % B ( pp , 2 ) * spp % vars % BPHI ( pp , 1 ) + & spp % vars % B ( pp , 3 ) * spp % vars % BZ ( pp , 1 )) / Bmag dPHIB = ( spp % vars % B ( pp , 1 ) * spp % vars % BR ( pp , 2 ) + & spp % vars % B ( pp , 2 ) * spp % vars % BPHI ( pp , 2 ) + & spp % vars % B ( pp , 3 ) * spp % vars % BZ ( pp , 2 )) / Bmag dZB = ( spp % vars % B ( pp , 1 ) * spp % vars % BR ( pp , 3 ) + & spp % vars % B ( pp , 2 ) * spp % vars % BPHI ( pp , 3 ) + & spp % vars % B ( pp , 3 ) * spp % vars % BZ ( pp , 3 )) / Bmag gradB ( 1 ) = dRB gradB ( 2 ) = dPHIB / spp % vars % Y ( pp , 1 ) gradB ( 3 ) = dZB curlb ( 1 ) = (( Bmag * spp % vars % BZ ( pp , 2 ) - spp % vars % B ( pp , 3 ) * dPHIB ) / spp % vars % Y ( pp , 1 ) - & ( Bmag * spp % vars % BPHI ( pp , 3 ) - spp % vars % B ( pp , 2 ) * dZB )) / Bmag ** 2 curlb ( 2 ) = (( Bmag * spp % vars % BR ( pp , 3 ) - spp % vars % B ( pp , 1 ) * dZB ) - & ( Bmag * spp % vars % BZ ( pp , 1 ) - spp % vars % B ( pp , 3 ) * dRB )) / Bmag ** 2 curlb ( 3 ) = (( Bmag * spp % vars % BPHI ( pp , 1 ) - spp % vars % B ( pp , 2 ) * dRB ) - & ( Bmag * spp % vars % BPHI ( pp , 1 ) - spp % vars % B ( pp , 1 ) * dPHIB ) / & spp % vars % Y ( pp , 1 )) / Bmag ** 2 + & spp % vars % B ( pp , 2 ) / ( Bmag * spp % vars % Y ( pp , 1 )) end subroutine aux_fields","tags":"","loc":"proc/aux_fields.html"},{"title":"initialize_fields_interpolant – KORC-Full Orbit","text":"public subroutine initialize_fields_interpolant(params, F) Note Subroutine that initializes fields interpolants. This subroutine initializes either 2-D or 3-D PSPLINE interpolants\n using the data of fields in the KORC-dervied-type variable F. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation.\n See korc_types and korc_fields . Contents Source Code initialize_fields_interpolant Source Code subroutine initialize_fields_interpolant ( params , F ) !! @note Subroutine that initializes fields interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of fields in the KORC-dervied-type variable F. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. integer :: ii , jj if ((( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ). or . & ( params % field_eval . eq . 'interp' )). and . & (. not . params % field_model . eq . 'M3D_C1' )) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING FIELDS INTERPOLANT * * * *\")' ) end if ! * * * * * * * * MAGNETIC FIELD * * * * * * * * ! if ( F % Bflux . or . F % ReInterp_2x1t ) then if ( F % ReInterp_2x1t ) then if (. not .( EZspline_allocated ( bfield_2d % A ))) then bfield_2d % NR = F % dims ( 1 ) bfield_2d % NZ = F % dims ( 3 ) ! Initializing poloidal flux interpolant call EZspline_init ( bfield_2d % A , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % A % x1 = F % X % R bfield_2d % A % x2 = F % X % Z end if !write(output_unit_write,'(\"R\",E17.10)') F%X%R !write(output_unit_write,'(\"Z\",E17.10)') F%X%Z call EZspline_setup ( bfield_2d % A , F % PSIp3D (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) !write(output_unit_write,'(\"bfield_2d%A: \",E17.10)') bfield_2d%A%fspl(1,:,:) if (. not . ALLOCATED ( fields_domain % FLAG2D )) & ALLOCATE ( fields_domain % FLAG2D ( bfield_2d % NR , bfield_2d % NZ )) fields_domain % FLAG2D = F % FLAG3D (:, F % ind_2x1t ,:) fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) F % Bflux3D = . FALSE . else if ( EZspline_allocated ( bfield_2d % A )) & call Ezspline_free ( bfield_2d % A , ezerr ) bfield_2d % NR = F % dims ( 1 ) bfield_2d % NZ = F % dims ( 3 ) ! Initializing poloidal flux interpolant call EZspline_init ( bfield_2d % A , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % A % x1 = F % X % R bfield_2d % A % x2 = F % X % Z !write(output_unit_write,'(\"R\",E17.10)') F%X%R !write(output_unit_write,'(\"Z\",E17.10)') F%X%Z call EZspline_setup ( bfield_2d % A , F % PSIp , ezerr , . TRUE .) call EZspline_error ( ezerr ) !write(output_unit_write,'(\"bfield_2d%A: \",E17.10)') bfield_2d%A%fspl(1,:,:) if (. not . ALLOCATED ( fields_domain % FLAG2D )) & ALLOCATE ( fields_domain % FLAG2D ( bfield_2d % NR , bfield_2d % NZ )) fields_domain % FLAG2D = F % FLAG2D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) endif end if if ( F % Bflux3D ) then if ( F % Dim2x1t ) then bfield_2X1T % NR = F % dims ( 1 ) bfield_2X1T % NT = F % dims ( 2 ) bfield_2X1T % NZ = F % dims ( 3 ) call EZspline_init ( bfield_2X1T % A , bfield_2X1T % NR , bfield_2X1T % NT , & bfield_2X1T % NZ ,& bfield_2X1T % BCSR , bfield_2X1T % BCST , bfield_2X1T % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2X1T % A % x1 = F % X % R bfield_2X1T % A % x2 = F % X % PHI bfield_2X1T % A % x3 = F % X % Z !write(output_unit_write,*) F%X%PHI call EZspline_setup ( bfield_2X1T % A , F % PSIp3D , ezerr , . TRUE .) call EZspline_error ( ezerr ) if (. not . ALLOCATED ( fields_domain % FLAG3D )) & ALLOCATE ( fields_domain % FLAG3D ( bfield_2X1T % NR , bfield_2X1T % NT , & bfield_2X1T % NZ )) fields_domain % FLAG3D = F % FLAG3D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DT = ABS ( F % X % PHI ( 2 ) - F % X % PHI ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) fields_domain % To = F % X % PHI ( 1 ) else bfield_3d % NR = F % dims ( 1 ) bfield_3d % NPHI = F % dims ( 2 ) bfield_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( bfield_3d % A , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % A % x1 = F % X % R ! bfield_3d%R%x2 = F%X%PHI bfield_3d % A % x3 = F % X % Z call EZspline_setup ( bfield_3d % A , F % PSIp3D , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if end if if ( F % Bfield ) then if ( F % axisymmetric_fields ) then bfield_2d % NR = F % dims ( 1 ) bfield_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( bfield_2d % R , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % R % x1 = F % X % R bfield_2d % R % x2 = F % X % Z call EZspline_setup ( bfield_2d % R , F % B_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( bfield_2d % PHI , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % PHI % x1 = F % X % R bfield_2d % PHI % x2 = F % X % Z call EZspline_setup ( bfield_2d % PHI , F % B_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( bfield_2d % Z , bfield_2d % NR , bfield_2d % NZ , & bfield_2d % BCSR , bfield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_2d % Z % x1 = F % X % R bfield_2d % Z % x2 = F % X % Z call EZspline_setup ( bfield_2d % Z , F % B_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) !             do ii=1_idef,bfield_2d%PHI%n1 !                do jj=1_idef,bfield_2d%PHI%n2 !                   write(output_unit_write,'(\"BPHI_spline1 at R \",E17.10,\", Z \",E17.10,\": \",E17.10)') & !                        bfield_2d%PHI%x1(ii)*params%cpp%length, & !                        bfield_2d%PHI%x2(jj)*params%cpp%length, & !                        bfield_2d%PHI%fspl(1,ii,jj)*params%cpp%Bo !                end do !             end do if ( params % orbit_model . eq . 'GCpre' ) then gradB_2d % NR = F % dims ( 1 ) gradB_2d % NZ = F % dims ( 3 ) ! Initializing GRADBR component call EZspline_init ( gradB_2d % R , gradB_2d % NR , gradB_2d % NZ , & gradB_2d % BCSR , gradB_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_2d % R % x1 = F % X % R gradB_2d % R % x2 = F % X % Z call EZspline_setup ( gradB_2d % R , F % gradB_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBPHI component call EZspline_init ( gradB_2d % PHI , gradB_2d % NR , gradB_2d % NZ , & gradB_2d % BCSR , gradB_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_2d % PHI % x1 = F % X % R gradB_2d % PHI % x2 = F % X % Z call EZspline_setup ( gradB_2d % PHI , F % gradB_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBZ component call EZspline_init ( gradB_2d % Z , gradB_2d % NR , gradB_2d % NZ , & gradB_2d % BCSR , gradB_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_2d % Z % x1 = F % X % R gradB_2d % Z % x2 = F % X % Z call EZspline_setup ( gradB_2d % Z , F % gradB_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) curlb_2d % NR = F % dims ( 1 ) curlb_2d % NZ = F % dims ( 3 ) ! Initializing CURLBR component call EZspline_init ( curlb_2d % R , curlb_2d % NR , curlb_2d % NZ , & curlb_2d % BCSR , curlb_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_2d % R % x1 = F % X % R curlb_2d % R % x2 = F % X % Z call EZspline_setup ( curlb_2d % R , F % curlb_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBPHI component call EZspline_init ( curlb_2d % PHI , curlb_2d % NR , curlb_2d % NZ , & curlb_2d % BCSR , curlb_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_2d % PHI % x1 = F % X % R curlb_2d % PHI % x2 = F % X % Z call EZspline_setup ( curlb_2d % PHI , F % curlb_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBZ component call EZspline_init ( curlb_2d % Z , curlb_2d % NR , curlb_2d % NZ , & curlb_2d % BCSR , curlb_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_2d % Z % x1 = F % X % R curlb_2d % Z % x2 = F % X % Z call EZspline_setup ( curlb_2d % Z , F % curlb_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if if (. not . ALLOCATED ( fields_domain % FLAG2D )) & ALLOCATE ( fields_domain % FLAG2D ( bfield_2d % NR , bfield_2d % NZ )) fields_domain % FLAG2D = F % FLAG2D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) else bfield_3d % NR = F % dims ( 1 ) bfield_3d % NPHI = F % dims ( 2 ) bfield_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( bfield_3d % R , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % R % x1 = F % X % R bfield_3d % R % x2 = F % X % PHI bfield_3d % R % x3 = F % X % Z call EZspline_setup ( bfield_3d % R , F % B_3D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( bfield_3d % PHI , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % PHI % x1 = F % X % R bfield_3d % PHI % x2 = F % X % PHI bfield_3d % PHI % x3 = F % X % Z call EZspline_setup ( bfield_3d % PHI , F % B_3D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) !write(output_unit_write,*) bfield_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( bfield_3d % Z , bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ ,& bfield_3d % BCSR , bfield_3d % BCSPHI , bfield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) bfield_3d % Z % x1 = F % X % R bfield_3d % Z % x2 = F % X % PHI bfield_3d % Z % x3 = F % X % Z call EZspline_setup ( bfield_3d % Z , F % B_3D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) if ( params % orbit_model . eq . 'GCpre' ) then gradB_3d % NR = F % dims ( 1 ) gradB_3d % NPHI = F % dims ( 2 ) gradB_3d % NZ = F % dims ( 3 ) ! Initializing GRADBR component call EZspline_init ( gradB_3d % R , gradB_3d % NR , gradB_3d % NPHI ,& gradB_3d % NZ , gradB_3d % BCSR , gradB_3d % BCSPHI , & gradB_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_3d % R % x1 = F % X % R !gradB_3d%R%x2 = F%X%PHI gradB_3d % R % x3 = F % X % Z call EZspline_setup ( gradB_3d % R , F % gradB_3D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBPHI component call EZspline_init ( gradB_3d % PHI , gradB_3d % NR , gradB_3d % NPHI ,& gradB_3d % NZ , gradB_3d % BCSR , gradB_3d % BCSPHI , & gradB_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_3d % PHI % x1 = F % X % R !gradB_3d%PHI%x2 = F%X%PHI gradB_3d % PHI % x3 = F % X % Z call EZspline_setup ( gradB_3d % PHI , F % gradB_3D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing GRADBZ component call EZspline_init ( gradB_3d % Z , gradB_3d % NR , gradB_3d % NPHI ,& gradB_3d % NZ , gradB_3d % BCSR , gradB_3d % BCSPHI , & gradB_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) gradB_3d % Z % x1 = F % X % R !gradB_3d%Z%x2 = F%X%PHI gradB_3d % Z % x3 = F % X % Z call EZspline_setup ( gradB_3d % Z , F % gradB_3D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) curlb_3d % NR = F % dims ( 1 ) curlb_3d % NPHI = F % dims ( 2 ) curlb_3d % NZ = F % dims ( 3 ) ! Initializing CURLBR component call EZspline_init ( curlb_3d % R , curlb_3d % NR , curlb_3d % NPHI ,& curlb_3d % NZ , curlb_3d % BCSR , curlb_3d % BCSPHI , & curlb_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_3d % R % x1 = F % X % R !curlb_3d%R%x2 = F%X%PHI curlb_3d % R % x3 = F % X % Z call EZspline_setup ( curlb_3d % R , F % curlb_3D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBPHI component call EZspline_init ( curlb_3d % PHI , curlb_3d % NR , curlb_3d % NPHI ,& curlb_3d % NZ , curlb_3d % BCSR , curlb_3d % BCSPHI , & curlb_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_3d % PHI % x1 = F % X % R !curlb_3d%PHI%x2 = F%X%PHI curlb_3d % PHI % x3 = F % X % Z call EZspline_setup ( curlb_3d % PHI , F % curlb_3D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing CURLBZ component call EZspline_init ( curlb_3d % Z , curlb_3d % NR , curlb_3d % NPHI ,& curlb_3d % NZ , curlb_3d % BCSR , curlb_3d % BCSPHI , & curlb_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) curlb_3d % Z % x1 = F % X % R !curlb_3d%Z%x2 = F%X%PHI curlb_3d % Z % x3 = F % X % Z call EZspline_setup ( curlb_3d % Z , F % curlb_3D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if ALLOCATE ( fields_domain % FLAG3D ( bfield_3d % NR , bfield_3d % NPHI , & bfield_3d % NZ )) fields_domain % FLAG3D = F % FLAG3D fields_domain % DR = ABS ( F % X % R ( 2 ) - F % X % R ( 1 )) fields_domain % DPHI = 2.0_rp * C_PI / bfield_3d % NPHI fields_domain % DZ = ABS ( F % X % Z ( 2 ) - F % X % Z ( 1 )) end if end if if ( F % dBfield ) then if ( F % axisymmetric_fields ) then ! dBdR dbdR_2d % NR = F % dims ( 1 ) dbdR_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( dbdR_2d % R , dbdR_2d % NR , dbdR_2d % NZ , & dbdR_2d % BCSR , dbdR_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_2d % R % x1 = F % X % R dbdR_2d % R % x2 = F % X % Z call EZspline_setup ( dbdR_2d % R , F % dBdR_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( dbdR_2d % PHI , dbdR_2d % NR , dbdR_2d % NZ , & dbdR_2d % BCSR , dbdR_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_2d % PHI % x1 = F % X % R dbdR_2d % PHI % x2 = F % X % Z call EZspline_setup ( dbdR_2d % PHI , F % dBdR_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( dbdR_2d % Z , dbdR_2d % NR , dbdR_2d % NZ , & dbdR_2d % BCSR , dbdR_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_2d % Z % x1 = F % X % R dbdR_2d % Z % x2 = F % X % Z call EZspline_setup ( dbdR_2d % Z , F % dBdR_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) !dBdPHI dbdPHI_2d % NR = F % dims ( 1 ) dbdPHI_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( dbdPHI_2d % R , dbdPHI_2d % NR , dbdPHI_2d % NZ , & dbdPHI_2d % BCSR , dbdPHI_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_2d % R % x1 = F % X % R dbdPHI_2d % R % x2 = F % X % Z call EZspline_setup ( dbdPHI_2d % R , F % dBdPHI_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( dbdPHI_2d % PHI , dbdPHI_2d % NR , dbdPHI_2d % NZ , & dbdPHI_2d % BCSR , dbdPHI_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_2d % PHI % x1 = F % X % R dbdPHI_2d % PHI % x2 = F % X % Z call EZspline_setup ( dbdPHI_2d % PHI , F % dBdPHI_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( dbdPHI_2d % Z , dbdPHI_2d % NR , dbdPHI_2d % NZ , & dbdPHI_2d % BCSR , dbdPHI_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_2d % Z % x1 = F % X % R dbdPHI_2d % Z % x2 = F % X % Z call EZspline_setup ( dbdPHI_2d % Z , F % dBdPHI_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) !dBdZ dbdZ_2d % NR = F % dims ( 1 ) dbdZ_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( dbdZ_2d % R , dbdZ_2d % NR , dbdZ_2d % NZ , & dbdZ_2d % BCSR , dbdZ_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_2d % R % x1 = F % X % R dbdZ_2d % R % x2 = F % X % Z call EZspline_setup ( dbdZ_2d % R , F % dBdZ_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( dbdZ_2d % PHI , dbdZ_2d % NR , dbdZ_2d % NZ , & dbdZ_2d % BCSR , dbdZ_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_2d % PHI % x1 = F % X % R dbdZ_2d % PHI % x2 = F % X % Z call EZspline_setup ( dbdZ_2d % PHI , F % dBdZ_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( dbdZ_2d % Z , dbdZ_2d % NR , dbdZ_2d % NZ , & dbdZ_2d % BCSR , dbdZ_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_2d % Z % x1 = F % X % R dbdZ_2d % Z % x2 = F % X % Z call EZspline_setup ( dbdZ_2d % Z , F % dBdZ_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) else ! dBdR dbdR_3d % NR = F % dims ( 1 ) dbdR_3d % NPHI = F % dims ( 2 ) dbdR_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( dbdR_3d % R , dbdR_3d % NR , dbdR_3d % NPHI , & dbdR_3d % NZ ,& dbdR_3d % BCSR , dbdR_3d % BCSPHI , dbdR_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_3d % R % x1 = F % X % R ! dbdR_3d%R%x2 = F%X%PHI dbdR_3d % R % x3 = F % X % Z call EZspline_setup ( dbdR_3d % R , F % dBdR_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( dbdR_3d % PHI , dbdR_3d % NR , dbdR_3d % NPHI , & dbdR_3d % NZ ,& dbdR_3d % BCSR , dbdR_3d % BCSPHI , dbdR_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_3d % PHI % x1 = F % X % R ! dbdR_3d%PHI%x2 = F%X%PHI dbdR_3d % PHI % x3 = F % X % Z call EZspline_setup ( dbdR_3d % PHI , F % dBdR_3D % PHI , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,*) dbdR_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( dbdR_3d % Z , dbdR_3d % NR , dbdR_3d % NPHI , & dbdR_3d % NZ ,& dbdR_3d % BCSR , dbdR_3d % BCSPHI , dbdR_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdR_3d % Z % x1 = F % X % R ! dbdR_3d%Z%x2 = F%X%PHI dbdR_3d % Z % x3 = F % X % Z call EZspline_setup ( dbdR_3d % Z , F % dBdR_3D % Z , ezerr ) call EZspline_error ( ezerr ) !dBdPHI dbdPHI_3d % NR = F % dims ( 1 ) dbdPHI_3d % NPHI = F % dims ( 2 ) dbdPHI_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( dbdPHI_3d % R , dbdPHI_3d % NR , dbdPHI_3d % NPHI , & dbdPHI_3d % NZ ,& dbdPHI_3d % BCSR , dbdPHI_3d % BCSPHI , dbdPHI_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_3d % R % x1 = F % X % R ! dbdPHI_3d%R%x2 = F%X%PHI dbdPHI_3d % R % x3 = F % X % Z call EZspline_setup ( dbdPHI_3d % R , F % dBdPHI_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( dbdPHI_3d % PHI , dbdPHI_3d % NR , dbdPHI_3d % NPHI , & dbdPHI_3d % NZ ,& dbdPHI_3d % BCSR , dbdPHI_3d % BCSPHI , dbdPHI_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_3d % PHI % x1 = F % X % R ! dbdPHI_3d%PHI%x2 = F%X%PHI dbdPHI_3d % PHI % x3 = F % X % Z call EZspline_setup ( dbdPHI_3d % PHI , F % dBdPHI_3D % PHI , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,*) dbdPHI_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( dbdPHI_3d % Z , dbdPHI_3d % NR , dbdPHI_3d % NPHI , & dbdPHI_3d % NZ ,& dbdPHI_3d % BCSR , dbdPHI_3d % BCSPHI , dbdPHI_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdPHI_3d % Z % x1 = F % X % R ! dbdPHI_3d%Z%x2 = F%X%PHI dbdPHI_3d % Z % x3 = F % X % Z call EZspline_setup ( dbdPHI_3d % Z , F % dBdPHI_3D % Z , ezerr ) call EZspline_error ( ezerr ) !dBdZ dbdZ_3d % NR = F % dims ( 1 ) dbdZ_3d % NPHI = F % dims ( 2 ) dbdZ_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( dbdZ_3d % R , dbdZ_3d % NR , dbdZ_3d % NPHI , & dbdZ_3d % NZ ,& dbdZ_3d % BCSR , dbdZ_3d % BCSPHI , dbdZ_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_3d % R % x1 = F % X % R ! dbdZ_3d%R%x2 = F%X%PHI dbdZ_3d % R % x3 = F % X % Z call EZspline_setup ( dbdZ_3d % R , F % dBdZ_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( dbdZ_3d % PHI , dbdZ_3d % NR , dbdZ_3d % NPHI , & dbdZ_3d % NZ ,& dbdZ_3d % BCSR , dbdZ_3d % BCSPHI , dbdZ_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_3d % PHI % x1 = F % X % R ! dbdZ_3d%PHI%x2 = F%X%PHI dbdZ_3d % PHI % x3 = F % X % Z call EZspline_setup ( dbdZ_3d % PHI , F % dBdZ_3D % PHI , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,*) dbdZ_3d%PHI%x2 ! Initializing Z component of interpolant call EZspline_init ( dbdZ_3d % Z , dbdZ_3d % NR , dbdZ_3d % NPHI , & dbdZ_3d % NZ ,& dbdZ_3d % BCSR , dbdZ_3d % BCSPHI , dbdZ_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) dbdZ_3d % Z % x1 = F % X % R ! dbdZ_3d%Z%x2 = F%X%PHI dbdZ_3d % Z % x3 = F % X % Z call EZspline_setup ( dbdZ_3d % Z , F % dBdZ_3D % Z , ezerr ) call EZspline_error ( ezerr ) end if end if fields_domain % Ro = F % X % R ( 1 ) fields_domain % Zo = F % X % Z ( 1 ) ! * * * * * * * * ELECTRIC FIELD * * * * * * * * ! if ( F % Efield . AND .( params % field_eval . eq . 'interp' )) then if ( F % axisymmetric_fields ) then if ( F % ReInterp_2x1t ) then if (. not .( EZspline_allocated ( efield_2d % PHI ))) then efield_2d % NR = F % dims ( 1 ) efield_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( efield_2d % R , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % R % x1 = F % X % R efield_2d % R % x2 = F % X % Z ! Initializing PHI component call EZspline_init ( efield_2d % PHI , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % PHI % x1 = F % X % R efield_2d % PHI % x2 = F % X % Z ! Initializing Z component call EZspline_init ( efield_2d % Z , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % Z % x1 = F % X % R efield_2d % Z % x2 = F % X % Z end if call EZspline_setup ( efield_2d % R , F % E_3D % R (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) call EZspline_setup ( efield_2d % PHI , F % E_3D % PHI (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) call EZspline_setup ( efield_2d % Z , F % E_3D % Z (:, F % ind_2x1t ,:), & ezerr , . TRUE .) call EZspline_error ( ezerr ) !                write(output_unit_write,'(\"efield_2d%PHI: \",E17.10)') efield_2d%PHI%fspl(1,:,:) else efield_2d % NR = F % dims ( 1 ) efield_2d % NZ = F % dims ( 3 ) ! Initializing R component call EZspline_init ( efield_2d % R , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % R % x1 = F % X % R efield_2d % R % x2 = F % X % Z call EZspline_setup ( efield_2d % R , F % E_2D % R , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing PHI component call EZspline_init ( efield_2d % PHI , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % PHI % x1 = F % X % R efield_2d % PHI % x2 = F % X % Z call EZspline_setup ( efield_2d % PHI , F % E_2D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Z component call EZspline_init ( efield_2d % Z , efield_2d % NR , efield_2d % NZ , & efield_2d % BCSR , efield_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_2d % Z % x1 = F % X % R efield_2d % Z % x2 = F % X % Z call EZspline_setup ( efield_2d % Z , F % E_2D % Z , ezerr , . TRUE .) call EZspline_error ( ezerr ) end if else efield_3d % NR = F % dims ( 1 ) efield_3d % NPHI = F % dims ( 2 ) efield_3d % NZ = F % dims ( 3 ) ! Initializing R component of interpolant call EZspline_init ( efield_3d % R , efield_3d % NR , efield_3d % NPHI , efield_3d % NZ ,& efield_3d % BCSR , efield_3d % BCSPHI , efield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_3d % R % x1 = F % X % R ! efield_3d%R%x2 = F%X%PHI efield_3d % R % x3 = F % X % Z call EZspline_setup ( efield_3d % R , F % E_3D % R , ezerr ) call EZspline_error ( ezerr ) ! Initializing PHI component of interpolant call EZspline_init ( efield_3d % PHI , efield_3d % NR , efield_3d % NPHI , & efield_3d % NZ , efield_3d % BCSR , efield_3d % BCSPHI , efield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_3d % PHI % x1 = F % X % R ! efield_3d%PHI%x2 = F%X%PHI efield_3d % PHI % x3 = F % X % Z call EZspline_setup ( efield_3d % PHI , F % E_3D % PHI , ezerr ) call EZspline_error ( ezerr ) ! Initializing Z component of interpolant call EZspline_init ( efield_3d % Z , efield_3d % NR , efield_3d % NPHI , efield_3d % NZ ,& efield_3d % BCSR , efield_3d % BCSPHI , efield_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) efield_3d % Z % x1 = F % X % R ! efield_3d%Z%x2 = F%X%PHI efield_3d % Z % x3 = F % X % Z call EZspline_setup ( efield_3d % Z , F % E_3D % Z , ezerr ) call EZspline_error ( ezerr ) end if end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * INTERPOLANT INITIALIZED * * * * * *\",/)' ) end if else if ( params % field_model ( 1 : 10 ) . EQ . 'ANALYTICAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * USING ANALYTICAL MAGNETIC FIELD * * * *\",/)' ) end if else if ( params % field_model . EQ . 'UNIFORM' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * USING UNIFORM MAGNETIC FIELD * * * *\",/)' ) end if end if end subroutine initialize_fields_interpolant","tags":"","loc":"proc/initialize_fields_interpolant.html"},{"title":"initialize_SC1D_field_interpolant – KORC-Full Orbit","text":"public subroutine initialize_SC1D_field_interpolant(params, F) Note Subroutine that initializes fields interpolants. This subroutine initializes either 2-D or 3-D PSPLINE interpolants\n using the data of fields in the KORC-dervied-type variable F. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation.\n See korc_types and korc_fields . Contents Source Code initialize_SC1D_field_interpolant Source Code subroutine initialize_SC1D_field_interpolant ( params , F ) !! @note Subroutine that initializes fields interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of fields in the KORC-dervied-type variable F. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. integer :: ii , jj !    if (EZspline_allocated(efield_SC1d%PHI)) & !         call Ezspline_free(efield_SC1d%PHI, ezerr) if (. not .( EZspline_allocated ( efield_SC1d % PHI ))) then efield_SC1d % Nrm = F % dim_1D call EZspline_init ( efield_SC1d % PHI , efield_SC1d % Nrm , & efield_SC1d % BCSrm , ezerr ) call EZspline_error ( ezerr ) efield_SC1d % PHI % x1 = F % r_1D / params % cpp % length end if call EZspline_setup ( efield_SC1d % PHI , F % E_SC_1D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) if (. not . ALLOCATED ( fields_domain % FLAG1D )) & ALLOCATE ( fields_domain % FLAG1D ( efield_SC1d % Nrm )) fields_domain % Drm = ABS ( F % r_1D ( 2 ) - F % r_1D ( 1 )) end subroutine initialize_SC1D_field_interpolant","tags":"","loc":"proc/initialize_sc1d_field_interpolant.html"},{"title":"initialize_SC1D_field_interpolant_FS – KORC-Full Orbit","text":"public subroutine initialize_SC1D_field_interpolant_FS(params, F) Note Subroutine that initializes fields interpolants. This subroutine initializes either 2-D or 3-D PSPLINE interpolants\n using the data of fields in the KORC-dervied-type variable F. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation.\n See korc_types and korc_fields . Contents Source Code initialize_SC1D_field_interpolant_FS Source Code subroutine initialize_SC1D_field_interpolant_FS ( params , F ) !! @note Subroutine that initializes fields interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of fields in the KORC-dervied-type variable F. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. integer :: ii , jj !    if (EZspline_allocated(efield_SC1d%PHI)) & !         call Ezspline_free(efield_SC1d%PHI, ezerr) if (. not .( EZspline_allocated ( efield_SC1d % PHI ))) then efield_SC1d % NPSIP = F % dim_1D call EZspline_init ( efield_SC1d % PHI , efield_SC1d % NPSIP , & efield_SC1d % BCSPSIP , ezerr ) call EZspline_error ( ezerr ) efield_SC1d % PHI % x1 = F % PSIP_1D / ( params % cpp % Bo * params % cpp % length ** 2 ) end if call EZspline_setup ( efield_SC1d % PHI , F % E_SC_1D % PHI , ezerr , . TRUE .) call EZspline_error ( ezerr ) if (. not . ALLOCATED ( fields_domain % FLAG1D )) & ALLOCATE ( fields_domain % FLAG1D ( efield_SC1d % Nrm )) fields_domain % DPSIP = ABS ( F % PSIP_1D ( 2 ) - F % PSIP_1D ( 1 )) end subroutine initialize_SC1D_field_interpolant_FS","tags":"","loc":"proc/initialize_sc1d_field_interpolant_fs.html"},{"title":"check_if_in_fields_domain – KORC-Full Orbit","text":"private subroutine check_if_in_fields_domain(F, Y, flag) Note Subrotuine that checks if particles in the simulation are within\n the spatial domain where interpolants and fields are known. External fields and interpolants can have different spatial domains where\n they are defined. Therefore, it is necessary to\n check if a given particle has left these spatial domains to stop\n following it, otherwise this will cause an error in the simulation. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that determines whether particles are followed in the\n simulation (flag=1), or not (flag=0). Contents Source Code check_if_in_fields_domain Source Code subroutine check_if_in_fields_domain ( F , Y , flag ) !! @note Subrotuine that checks if particles in the simulation are within !! the spatial domain where interpolants and fields are known. @endnote !! External fields and interpolants can have different spatial domains where !! they are defined. Therefore, it is necessary to !! check if a given particle has left these spatial domains to stop !! following it, otherwise this will cause an error in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed in the !! simulation (flag=1), or not (flag=0). INTEGER :: IR !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the radial position of the particles. INTEGER :: IPHI !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the azimuthal position of the particles. INTEGER :: IZ !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the vertical position of the particles. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if !    write(output_unit_write,'(\"R: \",E15.10)') Y(1,1) !    write(output_unit_write,'(\"PHI: \",E15.10)') Y(2,1) !    write(output_unit_write,'(\"Z: \",E15.10)') Y(1,3) !    write(output_unit_write,*) 'Flag',flag(1) if ( ALLOCATED ( fields_domain % FLAG3D )) then if ( F % Dim2x1t ) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_2X1T) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( fields_domain % FLAG3D ( IR , 1 , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_2X1T % NR ). OR .( IZ . GT . bfield_2X1T % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IPHI,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_3d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y ( pp , 2 ) + 0.5_rp * fields_domain % DPHI ) / & fields_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( fields_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_3d % NR ). OR .( IZ . GT . bfield_3d % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if end do !$OMP END PARALLEL DO end if else if ( ALLOCATED ( fields_domain % FLAG2D )) then if ( F % Dim2x1t ) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_2d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( IR . lt . 0 ). or .( IZ . lt . 0 ). or .( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ )) then !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ if (( fields_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR .(( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ ))) then !write(output_unit_write,*) 'here' flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,fields_domain,bfield_2d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - fields_domain % Ro + 0.5_rp * & fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( fields_domain % Zo ) + 0.5_rp * & fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( IR . lt . 0 ). or .( IZ . lt . 0 ). or .( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ )) then !write(output_unit_write,'(\"YR:\",E17.10)') Y(1,1) !write(output_unit_write,'(\"YZ:\",E17.10)') Y(1,3) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IZ: \",I16)') IZ end if if (( fields_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR .(( IR . GT . & bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO endif end if end subroutine check_if_in_fields_domain","tags":"","loc":"proc/check_if_in_fields_domain.html"},{"title":"check_if_in_fields_domain_p – KORC-Full Orbit","text":"private subroutine check_if_in_fields_domain_p(pchunk, F, Y_R, Y_PHI, Y_Z, flag) Note Subrotuine that checks if particles in the simulation are within\n the spatial domain where interpolants and fields are known. External fields and interpolants can have different spatial domains where\n they are defined. Therefore, it is necessary to\n check if a given particle has left these spatial domains to\n stop following it, otherwise this will cause an error in the simulation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag Flag that determines whether particles are followed in the\n simulation (flag=1), or not (flag=0). Contents Source Code check_if_in_fields_domain_p Source Code subroutine check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag ) !! @note Subrotuine that checks if particles in the simulation are within !! the spatial domain where interpolants and fields are known. @endnote !! External fields and interpolants can have different spatial domains where !! they are defined. Therefore, it is necessary to !! check if a given particle has left these spatial domains to !! stop following it, otherwise this will cause an error in the simulation. INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed in the !! simulation (flag=1), or not (flag=0). INTEGER :: IR !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the radial position of the particles. INTEGER :: IPHI !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the azimuthal position of the particles. INTEGER :: IZ !! Variable used to localize the grid cell in the (R,\\phi,Z) !! or (R,Z) grid containing the fields data that corresponds !! to the vertical position of the particles. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Species iterator. !    write(output_unit_write,'(\"YR:\",E17.10)') Y_R !    write(output_unit_write,'(\"YPHI:\",E17.10)') Y_PHI !    write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z !    write(output_unit_write,'(\"Ro:\",E17.10)') fields_domain%Ro !    write(output_unit_write,'(\"Zo:\",E17.10)') fields_domain%Zo !    write(output_unit_write,'(\"DR:\",E17.10)') fields_domain%DR !    write(output_unit_write,'(\"DZ:\",E17.10)') fields_domain%DZ !    write(output_unit_write,'(\"DT:\",E17.10)') fields_domain%DT if ( ALLOCATED ( fields_domain % FLAG3D )) then if ( F % Dim2x1t ) then !$OMP SIMD !       !$OMP&  aligned(IR,IPHI,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - fields_domain % Ro + & 0.5_rp * fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y_PHI ( pp ) - fields_domain % To & + 0.5_rp * fields_domain % DT ) / fields_domain % DT ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( fields_domain % Zo ) + & 0.5_rp * fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) !             write(output_unit_write,'(\"IR: \",I16)') IR !             write(output_unit_write,'(\"IPHI: \",I16)') IPHI !             write(output_unit_write,'(\"IZ: \",I16)') IZ if (( fields_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_2X1T % NR ). OR .( IZ . GT . bfield_2X1T % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y_R(pp) !write(output_unit_write,'(\"YPHI:\",E17.10)') Y_PHI(pp) !write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z(pp) !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"IZ: \",I16)') IZ !call KORC_ABORT() end if !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"flag: \",I16)') flag(pp) end do !$OMP END SIMD else !$OMP SIMD !       !$OMP&  aligned(IR,IPHI,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - fields_domain % Ro + & 0.5_rp * fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y_PHI ( pp ) + 0.5_rp * fields_domain % DPHI ) / & fields_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( fields_domain % Zo ) + & 0.5_rp * fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) if (( fields_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_3d % NR ). OR .( IZ . GT . bfield_3d % NZ ))) then flag ( pp ) = 0_is !write(output_unit_write,'(\"YR:\",E17.10)') Y_R !write(output_unit_write,'(\"YPHI:\",E17.10)') Y_PHI !write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z !write(output_unit_write,'(\"IR: \",I16)') IR !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"IZ: \",I16)') IZ !call KORC_ABORT() end if !write(output_unit_write,'(\"IPHI: \",I16)') IPHI !write(output_unit_write,'(\"flag: \",I16)') flag(pp) end do !$OMP END SIMD end if else if ( ALLOCATED ( fields_domain % FLAG2D )) then !$OMP SIMD !       !$OMP& aligned(IR,IZ) do pp = 1_idef , pchunk !write(output_unit_write,*) Y_R(pp),Y_Z(pp),fields_domain%Ro,fields_domain%DR,fields_domain%Zo,fields_domain%DZ IR = INT ( FLOOR (( Y_R ( pp ) - fields_domain % Ro + & 0.5_rp * fields_domain % DR ) / fields_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( fields_domain % Zo ) + & 0.5_rp * fields_domain % DZ ) / fields_domain % DZ ) + 1.0_rp , idef ) !          write(output_unit_write,*) pp !          write(output_unit_write,'(\"Size of fields_domain R: \",I16)') & !               size(fields_domain%FLAG2D,1) !          write(output_unit_write,'(\"Size of fields_domain Z: \",I16)') & !               size(fields_domain%FLAG2D,2) !          if ((IR.lt.0).or.(IZ.lt.0)) then !             write(output_unit_write,'(\"YR:\",E17.10)') Y_R(pp) !             write(output_unit_write,'(\"YZ:\",E17.10)') Y_Z(pp) !             write(output_unit_write,'(\"IR: \",I16)') IR !             write(output_unit_write,'(\"IZ: \",I16)') IZ !          end if if (( fields_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR . & (( IR . GT . bfield_2d % NR ). OR .( IZ . GT . bfield_2d % NZ ))) then flag ( pp ) = 0_is !             write(output_unit_write,'(\"Shit''s fucked.\")') end if end do !$OMP END SIMD !       write(output_unit_write,'(\"Shit''s not fucked.\")') end if end subroutine check_if_in_fields_domain_p","tags":"","loc":"proc/check_if_in_fields_domain_p.html"},{"title":"initialize_profiles_interpolant – KORC-Full Orbit","text":"public subroutine initialize_profiles_interpolant(params, P) Note Subroutine that initializes plasma profiles interpolants. This subroutine initializes either 2-D or 3-D PSPLINE interpolants\n using the data of plasma profiles in the KORC-dervied-type variable P. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PROFILES), intent(inout) :: P An instance of KORC's derived type PROFILES containing\n all the information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . Contents Source Code initialize_profiles_interpolant Source Code subroutine initialize_profiles_interpolant ( params , P ) !! @note Subroutine that initializes plasma profiles interpolants. @endnote !! This subroutine initializes either 2-D or 3-D PSPLINE interpolants !! using the data of plasma profiles in the KORC-dervied-type variable P. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! An instance of KORC's derived type PROFILES containing !! all the information about the plasma profiles used in the simulation. !! See [[korc_types]] and [[korc_profiles]]. !#ifdef M3D_C1 !    P%M3D_C1_ne = -1 !    P%M3D_C1_te = -1 !    P%M3D_C1_zeff = -1 !#endif if ( params % collisions ) then if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING PROFILES INTERPOLANT * * * *\")' ) end if if ( P % axisymmetric ) then profiles_2d % NR = P % dims ( 1 ) profiles_2d % NZ = P % dims ( 3 ) !             write(output_unit_write,'(\"NR\",I15)') profiles_2d%NR !             write(output_unit_write,'(\"NZ\",I15)') profiles_2d%NR ! Initializing ne !\t\t\tcall EZspline_init(profiles_2d%ne,profiles_2d%NR, & !profiles_2d%NZ,profiles_2d%BCSR,profiles_2d%BCSZ,ezerr) call EZspline_init ( profiles_2d % ne , profiles_2d % NR , profiles_2d % NZ , & profiles_2d % BCSR , profiles_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_2d % ne % x1 = P % X % R profiles_2d % ne % x2 = P % X % Z call EZspline_setup ( profiles_2d % ne , P % ne_2D , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Te !\t\t\tcall EZspline_init(profiles_2d%Te,profiles_2d%NR, & !profiles_2d%NZ,profiles_2d%BCSR,profiles_2d%BCSZ,ezerr) call EZspline_init ( profiles_2d % Te , profiles_2d % NR , profiles_2d % NZ , & profiles_2d % BCSR , profiles_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_2d % Te % x1 = P % X % R profiles_2d % Te % x2 = P % X % Z !             write(output_unit_write,'(\"Te_interp_R\",E17.10)') profiles_2d%Te%x1 !             write(output_unit_write,'(\"Te_interp_Z\",E17.10)') profiles_2d%Te%x2 !             write(output_unit_write,'(\"Te\",E17.10)') P%Te_2D(10,:) call EZspline_setup ( profiles_2d % Te , P % Te_2D , ezerr , . TRUE .) call EZspline_error ( ezerr ) ! Initializing Zeff !\t\t\tcall EZspline_init(profiles_2d%Zeff, & !profiles_2d%NR,profiles_2d%NZ,profiles_2d%BCSR,profiles_2d%BCSZ,ezerr) call EZspline_init ( profiles_2d % Zeff , profiles_2d % NR , & profiles_2d % NZ , profiles_2d % BCSR , profiles_2d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_2d % Zeff % x1 = P % X % R profiles_2d % Zeff % x2 = P % X % Z call EZspline_setup ( profiles_2d % Zeff , P % Zeff_2D , ezerr , . TRUE .) call EZspline_error ( ezerr ) ALLOCATE ( profiles_domain % FLAG2D ( profiles_2d % NR , profiles_2d % NZ )) profiles_domain % FLAG2D = P % FLAG2D profiles_domain % DR = ABS ( P % X % R ( 2 ) - P % X % R ( 1 )) profiles_domain % DZ = ABS ( P % X % Z ( 2 ) - P % X % Z ( 1 )) else profiles_3d % NR = P % dims ( 1 ) profiles_3d % NPHI = P % dims ( 2 ) profiles_3d % NZ = P % dims ( 3 ) ! Initializing ne call EZspline_init ( profiles_3d % ne , profiles_3d % NR , & profiles_3d % NPHI , profiles_3d % NZ ,& profiles_3d % BCSR , profiles_3d % BCSPHI , profiles_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_3d % ne % x1 = P % X % R ! profiles_3d%ne%x2 = P%X%PHI profiles_3d % ne % x3 = P % X % Z call EZspline_setup ( profiles_3d % ne , P % ne_3D , ezerr ) call EZspline_error ( ezerr ) ! Initializing Te call EZspline_init ( profiles_3d % Te , profiles_3d % NR , & profiles_3d % NPHI , profiles_3d % NZ ,& profiles_3d % BCSR , profiles_3d % BCSPHI , profiles_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_3d % Te % x1 = P % X % R ! profiles_3d%Te%x2 = P%X%PHI profiles_3d % Te % x3 = P % X % Z call EZspline_setup ( profiles_3d % Te , P % Te_3D , ezerr ) call EZspline_error ( ezerr ) ! Initializing Zeff call EZspline_init ( profiles_3d % Zeff , profiles_3d % NR , & profiles_3d % NPHI , profiles_3d % NZ ,& profiles_3d % BCSR , profiles_3d % BCSPHI , profiles_3d % BCSZ , ezerr ) call EZspline_error ( ezerr ) profiles_3d % Zeff % x1 = P % X % R ! profiles_3d%Zeff%x2 = P%X%PHI profiles_3d % Zeff % x3 = P % X % Z call EZspline_setup ( profiles_3d % Zeff , P % Zeff_3D , ezerr ) call EZspline_error ( ezerr ) ALLOCATE ( profiles_domain % FLAG3D ( profiles_3d % NR , profiles_3d % NPHI , & profiles_3d % NZ )) profiles_domain % FLAG3D = P % FLAG3D profiles_domain % DR = ABS ( P % X % R ( 2 ) - P % X % R ( 1 )) profiles_domain % DPHI = 2.0_rp * C_PI / profiles_3d % NPHI profiles_domain % DZ = ABS ( P % X % Z ( 2 ) - P % X % Z ( 1 )) end if profiles_domain % Ro = P % X % R ( 1 ) profiles_domain % Zo = P % X % Z ( 1 ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * INTERPOLANT   INITIALIZED * * * * * *\",/)' ) end if else if ( params % profile_model ( 1 : 10 ) . EQ . 'ANALYTICAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * USING ANALYTICAL PROFILES * * * *\",/)' ) end if else if ( params % profile_model . EQ . 'UNIFORM' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * UNIFORM PLASMA: NO PROFILES USED * * * *\",/)' ) end if end if end if end subroutine initialize_profiles_interpolant","tags":"","loc":"proc/initialize_profiles_interpolant.html"},{"title":"check_if_in_profiles_domain – KORC-Full Orbit","text":"private subroutine check_if_in_profiles_domain(Y, flag) Note Subrotuine that checks if particles in the simulation are\n within the spatial domain where interpolants and plasma profiles\n are known. External plasma profiles and interpolants can have different spatial\n domains where they are defined. Therefore, it is necessary to check\n if a given particle has left these spatial domains to stop following\n it, otherwise this will cause an error in the simulation. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that determines whether particles are followed\n in the simulation (flag=1), or not (flag=0). Contents Source Code check_if_in_profiles_domain Source Code subroutine check_if_in_profiles_domain ( Y , flag ) !! @note Subrotuine that checks if particles in the simulation are !! within the spatial domain where interpolants and plasma profiles !! are known. @endnote !!External plasma profiles and interpolants can have different spatial !! domains where they are defined. Therefore, it is necessary to check !! if a given particle has left these spatial domains to stop following !! it, otherwise this will cause an error in the simulation. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed !! in the simulation (flag=1), or not (flag=0). INTEGER :: IR !! @param IR Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the radial position of the particles. INTEGER :: IPHI !! @param IPHI Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the azimuthal position of the particles. INTEGER :: IZ !! @param IZ Variable used to localize the grid cell in the !! (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the vertical position of the particles. INTEGER ( ip ) :: pp !! @param pp Particle iterator. INTEGER ( ip ) :: ss !! @param ss Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if if ( ALLOCATED ( profiles_domain % FLAG3D )) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IPHI,IZ) & !$OMP& SHARED(Y,flag,profiles_domain,profiles_3d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y ( pp , 2 ) + 0.5_rp * profiles_domain % DPHI ) / & profiles_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_3d % NR ). OR .( IZ . GT . profiles_3d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,IR,IZ) & !$OMP& SHARED(Y,flag,profiles_domain,profiles_2d) do pp = 1_idef , ss IR = INT ( FLOOR (( Y ( pp , 1 ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y ( pp , 3 ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_2d % NR ). OR .( IZ . GT . profiles_2d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END PARALLEL DO end if end subroutine check_if_in_profiles_domain","tags":"","loc":"proc/check_if_in_profiles_domain.html"},{"title":"check_if_in_profiles_domain_p – KORC-Full Orbit","text":"private subroutine check_if_in_profiles_domain_p(pchunk, Y_R, Y_PHI, Y_Z, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(8) :: Y_R real(kind=rp), intent(in), DIMENSION(8) :: Y_PHI real(kind=rp), intent(in), DIMENSION(8) :: Y_Z integer(kind=is), intent(inout), DIMENSION(8) :: flag Flag that determines whether particles are followed\n in the simulation (flag=1), or not (flag=0). Contents Source Code check_if_in_profiles_domain_p Source Code subroutine check_if_in_profiles_domain_p ( pchunk , Y_R , Y_PHI , Y_Z , flag ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( 8 ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z INTEGER ( is ), DIMENSION ( 8 ), INTENT ( INOUT ) :: flag !! Flag that determines whether particles are followed !! in the simulation (flag=1), or not (flag=0). INTEGER :: IR !! @param IR Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the radial position of the particles. INTEGER :: IPHI !! @param IPHI Variable used to localize the grid cell in !! the (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the azimuthal position of the particles. INTEGER :: IZ !! @param IZ Variable used to localize the grid cell in the !! (R,\\phi,Z) or (R,Z) grid containing the fields data that !! corresponds to the vertical position of the particles. INTEGER ( ip ) :: pp !! @param pp Particle iterator. INTEGER ( ip ) :: ss !! @param ss Species iterator. if ( ALLOCATED ( profiles_domain % FLAG3D )) then !$OMP SIMD !       !$OMP& aligned(IR,IPHI,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IPHI = INT ( FLOOR (( Y_PHI ( pp ) + 0.5_rp * profiles_domain % DPHI ) / & profiles_domain % DPHI ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG3D ( IR , IPHI , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_3d % NR ). OR .( IZ . GT . profiles_3d % NZ ))) then flag ( pp ) = 0_is end if end do !$OMP END SIMD else !$OMP SIMD !       !$OMP& aligned(IR,IZ) do pp = 1_idef , pchunk IR = INT ( FLOOR (( Y_R ( pp ) - profiles_domain % Ro + & 0.5_rp * profiles_domain % DR ) / profiles_domain % DR ) + 1.0_rp , idef ) IZ = INT ( FLOOR (( Y_Z ( pp ) + ABS ( profiles_domain % Zo ) + & 0.5_rp * profiles_domain % DZ ) / profiles_domain % DZ ) + 1.0_rp , idef ) if (( profiles_domain % FLAG2D ( IR , IZ ). NE . 1_is ). OR . & (( IR . GT . profiles_2d % NR ). OR .( IZ . GT . profiles_2d % NZ ))) then flag ( pp ) = 0_is !             write(output_unit_write,'(\"Shit''s fucked.\")') end if end do !$OMP END SIMD !       write(output_unit_write,'(\"Shit''s not fucked.\")') end if end subroutine check_if_in_profiles_domain_p","tags":"","loc":"proc/check_if_in_profiles_domain_p.html"},{"title":"interp_2D_bfields – KORC-Full Orbit","text":"private subroutine interp_2D_bfields(params, Y, B, flag) Note Subroutine for interpolating the pre-computed, axisymmetric magnetic\n field to the particles' position. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Cartesian components of interpolated magnetic field components.\n B(1,:)= , B(2,:)= , and B(3,:)= . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). Contents Source Code interp_2D_bfields Source Code subroutine interp_2D_bfields ( params , Y , B , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric magnetic !! field to the particles' position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Cartesian components of interpolated magnetic field components. !! B(1,:)=B_x, B(2,:)=B_y, and B(3,:)=B_z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,B,flag,bfield_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( bfield_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( bfield_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( bfield_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then B ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = F ( pp , 3 ) else B ( pp , 1 ) = F ( pp , 1 ) B ( pp , 2 ) = F ( pp , 2 ) B ( pp , 3 ) = F ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_bfields","tags":"","loc":"proc/interp_2d_bfields.html"},{"title":"gradient_2D_Bfields – KORC-Full Orbit","text":"private subroutine gradient_2D_Bfields(Y, BR, BPHI, BZ, flag) Note Subroutine for interpolating the pre-computed, axisymmetric\n gradient of the magnitude of themagnetic field to the particles'\n position. Stored as cylindrical components of field. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: BR Cylindrical components of gradient of R-component of magnetic field. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: BPHI Cylindrical components of gradient of R-component of magnetic field. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: BZ Cylindrical components of gradient of R-component of magnetic field. integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). Contents Source Code gradient_2D_Bfields Source Code subroutine gradient_2D_Bfields ( Y , BR , BPHI , BZ , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! gradient of the magnitude of themagnetic field to the particles' !! position. Stored as cylindrical components of field. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: BR !! Cylindrical components of gradient of R-component of magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: BPHI !! Cylindrical components of gradient of R-component of magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: BZ !! Cylindrical components of gradient of R-component of magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( 2 , ss )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(Y,BR,BPHI,BZ,flag,bfield_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_gradient ( bfield_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F (:, pp ), ezerr ) call EZspline_error ( ezerr ) BR ( pp , 1 ) = F ( pp , 1 ) BR ( pp , 2 ) = 0._rp BR ( pp , 3 ) = F ( pp , 2 ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_gradient ( bfield_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F (:, pp ), & ezerr ) call EZspline_error ( ezerr ) BPHI ( pp , 1 ) = F ( pp , 1 ) BPHI ( pp , 2 ) = 0._rp BPHI ( pp , 3 ) = F ( pp , 2 ) call EZspline_gradient ( bfield_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F (:, pp ), ezerr ) call EZspline_error ( ezerr ) BZ ( pp , 1 ) = F ( pp , 1 ) BZ ( pp , 2 ) = 0._rp BZ ( pp , 3 ) = F ( pp , 2 ) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine gradient_2D_Bfields","tags":"","loc":"proc/gradient_2d_bfields.html"},{"title":"interp_2D_gradBfields – KORC-Full Orbit","text":"private subroutine interp_2D_gradBfields(Y, gradB, flag) Note Subroutine for interpolating the pre-computed, axisymmetric\n gradient of the magnitude of themagnetic field to the particles'\n position. Stored as cylindrical components of field. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: gradB Cylindirical components of interpolated gradient of magnitude of\n magnetic field. integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). Contents Source Code interp_2D_gradBfields Source Code subroutine interp_2D_gradBfields ( Y , gradB , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! gradient of the magnitude of themagnetic field to the particles' !! position. Stored as cylindrical components of field. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: gradB !! Cylindirical components of interpolated gradient of magnitude of !! magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,gradB,flag,gradB_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( gradB_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( gradB_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( gradB_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"PS R-gradB \",E17.10)') F(pp,1) !        write(output_unit_write,'(\"PS PHI-gradB \",E17.10)') F(pp,2) !        write(output_unit_write,'(\"PS Z-gradB \",E17.10)') F(pp,3) gradB ( pp , 1 ) = F ( pp , 1 ) gradB ( pp , 2 ) = F ( pp , 2 ) gradB ( pp , 3 ) = F ( pp , 3 ) !        write(output_unit_write,'(\"PHI-gradB \",E17.10)') gradB(2,1) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_gradBfields","tags":"","loc":"proc/interp_2d_gradbfields.html"},{"title":"interp_2D_curlbfields – KORC-Full Orbit","text":"private subroutine interp_2D_curlbfields(Y, curlb, flag) Note Subroutine for interpolating the pre-computed, axisymmetric\n curl of the magnetic field unit vector to the particles'\n position. Stored as cylindrical components of field. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: curlb Cylindirical components of interpolated curl of direction of\n magnetic field. integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). Contents Source Code interp_2D_curlbfields Source Code subroutine interp_2D_curlbfields ( Y , curlb , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! curl of the magnetic field unit vector to the particles' !! position. Stored as cylindrical components of field. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, Y(1,:) = R, !! Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: curlb !! Cylindirical components of interpolated curl of direction of !! magnetic field. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F !! Cylindrical components of interpolated magnetic field components. !! F(1,:)=B_R, F(2,:)=B_\\phi, and F(3,:)=B_Z. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the simulation !! (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,curlb,flag,curlb_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( curlb_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( curlb_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( curlb_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) curlb ( pp , 1 ) = F ( pp , 1 ) curlb ( pp , 2 ) = F ( pp , 2 ) curlb ( pp , 3 ) = F ( pp , 3 ) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_curlbfields","tags":"","loc":"proc/interp_2d_curlbfields.html"},{"title":"interp_FOfields_p – KORC-Full Orbit","text":"public subroutine interp_FOfields_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, PSIp, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_X real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code interp_FOfields_p Source Code subroutine interp_FOfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , & E_X , E_Y , E_Z , PSIp , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( pchunk ) :: B_R , B_PHI REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: E_R , E_PHI REAL ( rp ), DIMENSION ( pchunk ) :: cP , sP !  INTEGER(ip) :: ezerr INTEGER :: cc !! Particle chunk iterator. INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % A , pchunk , Y_R , Y_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , efield_2d % R , & efield_2d % PHI , efield_2d % Z , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD !  !$OMP& aligned (cP,sP,B_X,B_Y,E_X,E_Y,Y_PHI,B_R,B_PHI,E_R,E_PHI) do cc = 1_idef , pchunk cP ( cc ) = cos ( Y_PHI ( cc )) sP ( cc ) = sin ( Y_PHI ( cc )) B_X ( cc ) = B_R ( cc ) * cP ( cc ) - B_PHI ( cc ) * sP ( cc ) B_Y ( cc ) = B_R ( cc ) * sP ( cc ) + B_PHI ( cc ) * cP ( cc ) E_X ( cc ) = E_R ( cc ) * cP ( cc ) - E_PHI ( cc ) * sP ( cc ) E_Y ( cc ) = E_R ( cc ) * sP ( cc ) + E_PHI ( cc ) * cP ( cc ) end do !$OMP END SIMD end subroutine interp_FOfields_p","tags":"","loc":"proc/interp_fofields_p.html"},{"title":"interp_FOfields1_p – KORC-Full Orbit","text":"public subroutine interp_FOfields1_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, PSIp, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_X real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code interp_FOfields1_p Source Code subroutine interp_FOfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_X , B_Y , B_Z , E_X , E_Y , E_Z , PSIp , & flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_X , B_Y , B_Z REAL ( rp ), DIMENSION ( pchunk ) :: B_R , B_PHI REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_X , E_Y , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: E_R , E_PHI REAL ( rp ), DIMENSION ( pchunk ) :: cP , sP !  INTEGER(ip) :: ezerr INTEGER :: cc !! Particle chunk iterator. INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % A , pchunk , Y_R , Y_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) call calculate_magnetic_field_p ( pchunk , F , Y_R , Y_Z , B_R , B_PHI , B_Z ) call EZspline_interp ( efield_2d % R , efield_2d % PHI , efield_2d % Z , pchunk , Y_R , Y_Z , & E_R , E_PHI , E_Z , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD !  !$OMP& aligned (cP,sP,B_X,B_Y,E_X,E_Y,Y_PHI,B_R,B_PHI,E_R,E_PHI) do cc = 1_idef , pchunk cP ( cc ) = cos ( Y_PHI ( cc )) sP ( cc ) = sin ( Y_PHI ( cc )) B_X ( cc ) = B_R ( cc ) * cP ( cc ) - B_PHI ( cc ) * sP ( cc ) B_Y ( cc ) = B_R ( cc ) * sP ( cc ) + B_PHI ( cc ) * cP ( cc ) E_X ( cc ) = E_R ( cc ) * cP ( cc ) - E_PHI ( cc ) * sP ( cc ) E_Y ( cc ) = E_R ( cc ) * sP ( cc ) + E_PHI ( cc ) * cP ( cc ) end do !$OMP END SIMD end subroutine interp_FOfields1_p","tags":"","loc":"proc/interp_fofields1_p.html"},{"title":"interp_FOcollision_p – KORC-Full Orbit","text":"public subroutine interp_FOcollision_p(pchunk, Y_R, Y_PHI, Y_Z, ne, Te, Zeff, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: ne real(kind=rp), intent(out), DIMENSION(pchunk) :: Te real(kind=rp), intent(out), DIMENSION(pchunk) :: Zeff integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code interp_FOcollision_p Source Code subroutine interp_FOcollision_p ( pchunk , Y_R , Y_PHI , Y_Z , ne , Te , Zeff , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_profiles_domain_p ( pchunk , Y_R , Y_PHI , Y_Z , flag_cache ) !  write(output_unit_write,'(\"YR: \",E17.10)') Y_R(1) !  write(output_unit_write,'(\"YPHI: \",E17.10)') Y_PHI(1) !  write(output_unit_write,'(\"YZ: \",E17.10)') Y_Z(1) !  write(output_unit_write,'(\"Te_interp_R\",E17.10)') profiles_2d%Te%x1 !  write(output_unit_write,'(\"Te_interp_Z\",E17.10)') profiles_2d%Te%x2 call EZspline_interp ( profiles_2d % ne , profiles_2d % Te , & profiles_2d % Zeff , pchunk , Y_R , Y_Z , ne , Te , Zeff , ezerr ) ! this will call PSPLINE routine EZspline_interp2_bmag_cloud_r8 as there ! is the same number of entries call EZspline_error ( ezerr ) end subroutine interp_FOcollision_p","tags":"","loc":"proc/interp_focollision_p.html"},{"title":"interp_fields_p – KORC-Full Orbit","text":"public subroutine interp_fields_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlB_R, curlB_PHI, curlB_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code interp_fields_p Source Code subroutine interp_fields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlB_R , curlB_PHI , curlB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache !write(output_unit_write,*) Y_R,Y_Z,flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , efield_2d % R , & efield_2d % PHI , efield_2d % Z , gradB_2d % R , gradB_2d % PHI , gradB_2d % Z , & curlb_2d % R , curlb_2d % PHI , curlb_2d % Z , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , gradB_R , gradB_PHI , gradB_Z , curlb_R , curlb_PHI , curlb_Z , & ezerr ) call EZspline_error ( ezerr ) end subroutine interp_fields_p","tags":"","loc":"proc/interp_fields_p.html"},{"title":"interp_fields_3D_p – KORC-Full Orbit","text":"public subroutine interp_fields_3D_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlB_R, curlB_PHI, curlB_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code interp_fields_3D_p Source Code subroutine interp_fields_3D_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlB_R , curlB_PHI , curlB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache REAL ( rp ), DIMENSION ( pchunk ) :: Y_PHI_mod Y_PHI_mod = modulo ( Y_PHI , 2._rp * C_PI ) !  write(output_unit_write,*) Y_PHI(1) !  write(output_unit_write,*) Y_PHI_mod(1) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI_mod , Y_Z , flag_cache ) call EZspline_interp ( bfield_3d % R , bfield_3d % PHI , bfield_3d % Z , efield_3d % R , & efield_3d % PHI , efield_3d % Z , gradB_3d % R , gradB_3d % PHI , gradB_3d % Z , & curlb_3d % R , curlb_3d % PHI , curlb_3d % Z , pchunk , Y_R , Y_PHI_mod , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , gradB_R , gradB_PHI , gradB_Z , curlb_R , curlb_PHI , curlb_Z , & ezerr ) call EZspline_error ( ezerr ) end subroutine interp_fields_3D_p","tags":"","loc":"proc/interp_fields_3d_p.html"},{"title":"interp_collision_p – KORC-Full Orbit","text":"public subroutine interp_collision_p(pchunk, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, ne, Te, Zeff, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: ne real(kind=rp), intent(out), DIMENSION(pchunk) :: Te real(kind=rp), intent(out), DIMENSION(pchunk) :: Zeff integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code interp_collision_p Source Code subroutine interp_collision_p ( pchunk , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & ne , Te , Zeff , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: ne , Te , Zeff INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache !  INTEGER(ip) :: ezerr call check_if_in_profiles_domain_p ( pchunk , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , efield_2d % R , & efield_2d % PHI , efield_2d % Z , profiles_2d % ne , profiles_2d % Te , & profiles_2d % Zeff , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , ne , Te , Zeff , ezerr ) call EZspline_error ( ezerr ) end subroutine interp_collision_p","tags":"","loc":"proc/interp_collision_p.html"},{"title":"interp_bmag_p – KORC-Full Orbit","text":"public subroutine interp_bmag_p(pchunk, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z Contents Source Code interp_bmag_p Source Code subroutine interp_bmag_p ( pchunk , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z !  INTEGER(ip) :: ezerr call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , & pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , ezerr ) call EZspline_error ( ezerr ) end subroutine interp_bmag_p","tags":"","loc":"proc/interp_bmag_p.html"},{"title":"interp_3D_bfields – KORC-Full Orbit","text":"private subroutine interp_3D_bfields(params, Y, B, flag) @brief Subroutine for interpolating the pre-computed, 3-D magnetic field to the particles' position. @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = , Y(2,:) = , and Y(3,:) = .\n @param[in,out] B Cartesian components of interpolated magnetic field components. B(1,:)= , B(2,:)= , and B(3,:)= .\n @param F Cylindrical components of interpolated magnetic field components. F(1,:)= , F(2,:)= , and F(3,:)= .\n @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0).\n @param pp Particle iterator.\n @param ss Species iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Contents Source Code interp_3D_bfields Source Code subroutine interp_3D_bfields ( params , Y , B , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag INTEGER :: pp INTEGER :: ss ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,B,flag,bfield_3d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( bfield_3d % R , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( bfield_3d % PHI , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( bfield_3d % Z , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then B ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = F ( pp , 3 ) else B ( pp , 1 ) = F ( pp , 1 ) B ( pp , 2 ) = F ( pp , 2 ) B ( pp , 3 ) = F ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_3D_bfields","tags":"","loc":"proc/interp_3d_bfields.html"},{"title":"calculate_magnetic_field – KORC-Full Orbit","text":"public subroutine calculate_magnetic_field(params, Y, F, B, E, PSI_P, flag) @brief Subroutine that calculates the axisymmetric magnetic field to the particles' position using the poloidal magnetic flux.\n @details When the poloidal magnetic flux is used in a KORC simulation, the magnetic field components are calculated as it follows: where and are the radial position of the magnetic axis and the magnetic field as measured at the magnetic axis, respectively.\n First, the derivatives of the poloidal magnetic flux are calculated at the particles' position using the PSPLINE interpolant of\n the poloidal magnetic flux. Then, we calculate the cylindrical components of the magnetic field, and finally we calculate its Cartesian\n components that will be used in the particle pusher. @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = , Y(2,:) = , and Y(3,:) = .\n @param[in] F An instance of KORC's derived type FIELDS containing all the information about the fields used in the simulation.\n See korc_types.f90 and korc_fields.f90.\n @param[in,out] B Cartesian components of interpolated magnetic field components. B(1,:)= , B(2,:)= , and B(3,:)= .\n @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0).\n @param A Variable containing the partial derivatives of the poloidal magnetic flux and the cylindrical components\n of the magnetic field (its value changes through the subroutine).\n @param pp Particle iterator.\n @param ss Species iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y type(FIELDS), intent(in) :: F real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: PSI_P integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Contents Source Code calculate_magnetic_field Source Code subroutine calculate_magnetic_field ( params , Y , F , B , E , PSI_P , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: PSI_P INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: A INTEGER :: pp INTEGER :: ss if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if ALLOCATE ( A ( ss , 3 )) A = 0._rp if ( F % Dim2x1t . and .(. not . F % ReInterp_2x1t )) then !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,A,B,flag,bfield_2X1T,PSI_P) do pp = 1_idef , ss !        write(output_unit_write,'(\"pp: \",I16)') pp !        write(output_unit_write,'(\"Y_R: \",E17.10)') Y(:,1) !      write(output_unit_write,'(\"Y_PHI: \",E17.10)') Y(:,2) !      write(output_unit_write,'(\"Y_Z: \",E17.10)') Y(:,3) call EZspline_interp ( bfield_2X1T % A , Y ( pp , 1 ), F % t0_2x1t , Y ( pp , 3 ), & PSI_P ( pp ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"PSI_P: \",E17.10)') PSI_P(1) ! FR = (dA/dZ)/R call EZspline_derivative ( bfield_2X1T % A , 0 , 0 , 1 , Y ( pp , 1 ), F % t0_2x1t , & Y ( pp , 3 ), A ( pp , 1 ), ezerr ) !\t\t\tcall EZspline_error(ezerr) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is else !           write(output_unit_write,'(\"R*B_R: \",E17.10)') A(pp,1) !if(params%SC_E) A(pp,1)=A(pp,1)/(2*C_PI) A ( pp , 1 ) = A ( pp , 1 ) / Y ( pp , 1 ) ! FPHI = Fo*Ro/R A ( pp , 2 ) = - F % Bo * F % Ro / Y ( pp , 1 ) ! FR = -(dA/dR)/R call EZspline_derivative ( bfield_2X1T % A , 1 , 0 , 0 , Y ( pp , 1 ), & F % t0_2x1t , Y ( pp , 3 ), A ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) !           write(output_unit_write,'(\"R*B_Z: \",E17.10)') A(pp,3) !if(params%SC_E) A(pp,3)=A(pp,3)/(2*C_PI) call EZspline_derivative ( bfield_2X1T % A , 0 , 1 , 0 , Y ( pp , 1 ), & F % t0_2x1t , Y ( pp , 3 ), E ( pp , 2 ), ezerr ) E ( pp , 2 ) = E ( pp , 2 ) / ( 2 * C_PI * Y ( pp , 1 )) A ( pp , 3 ) = - A ( pp , 3 ) / Y ( pp , 1 ) if (. not . params % GC_coords ) then B ( pp , 1 ) = A ( pp , 1 ) * COS ( Y ( pp , 2 )) - A ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = A ( pp , 1 ) * SIN ( Y ( pp , 2 )) + A ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = A ( pp , 3 ) E ( pp , 1 ) = - E ( pp , 2 ) * sin ( Y ( pp , 2 )) E ( pp , 2 ) = E ( pp , 2 ) * cos ( Y ( pp , 2 )) else B ( pp , 1 ) = A ( pp , 1 ) B ( pp , 2 ) = A ( pp , 2 ) B ( pp , 3 ) = A ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,A,B,flag,bfield_2d,PSI_P) do pp = 1_idef , ss !        write(output_unit_write,'(\"pp: \",I16)') pp !        write(output_unit_write,'(\"Y_R: \",E17.10)') Y(:,1) !      write(output_unit_write,'(\"Y_PHI: \",E17.10)') Y(:,2) !      write(output_unit_write,'(\"Y_Z: \",E17.10)') Y(:,3) call EZspline_interp ( bfield_2d % A , Y ( pp , 1 ), Y ( pp , 3 ), & PSI_P ( pp ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"PSI_P: \",E17.10)') PSI_P(1) ! FR = (dA/dZ)/R call EZspline_derivative ( bfield_2d % A , 0 , 1 , Y ( pp , 1 ), Y ( pp , 3 ), & A ( pp , 1 ), ezerr ) !\t\t\tcall EZspline_error(ezerr) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is else !           write(output_unit_write,'(\"R*B_R: \",E17.10)') A(pp,1) !if(params%SC_E) A(pp,1)=A(pp,1)/(2*C_PI) A ( pp , 1 ) = A ( pp , 1 ) / Y ( pp , 1 ) ! FPHI = Fo*Ro/R A ( pp , 2 ) = - F % Bo * F % Ro / Y ( pp , 1 ) ! FR = -(dA/dR)/R call EZspline_derivative ( bfield_2d % A , 1 , 0 , Y ( pp , 1 ), Y ( pp , 3 ), & A ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) !           write(output_unit_write,'(\"R*B_Z: \",E17.10)') A(pp,3) !if(params%SC_E) A(pp,3)=A(pp,3)/(2*C_PI) A ( pp , 3 ) = - A ( pp , 3 ) / Y ( pp , 1 ) if (. not . params % GC_coords ) then B ( pp , 1 ) = A ( pp , 1 ) * COS ( Y ( pp , 2 )) - A ( pp , 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = A ( pp , 1 ) * SIN ( Y ( pp , 2 )) + A ( pp , 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = A ( pp , 3 ) else B ( pp , 1 ) = A ( pp , 1 ) B ( pp , 2 ) = A ( pp , 2 ) B ( pp , 3 ) = A ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO end if !  write(output_unit_write,'(\"calculate_fields\")') !  write(output_unit_write,'(\"B_R: \",E17.10)') A(:,1) !  write(output_unit_write,'(\"B_PHI: \",E17.10)') A(:,2) !  write(output_unit_write,'(\"B_Z: \",E17.10)') A(:,3) !  write(output_unit_write,'(\"B_X: \",E17.10)') B(:,1) !  write(output_unit_write,'(\"B_Y: \",E17.10)') B(:,2) !  write(output_unit_write,'(\"B_Z: \",E17.10)') B(:,3) DEALLOCATE ( A ) end subroutine calculate_magnetic_field","tags":"","loc":"proc/calculate_magnetic_field.html"},{"title":"calculate_magnetic_field_p – KORC-Full Orbit","text":"public subroutine calculate_magnetic_field_p(pchunk, F, Y_R, Y_Z, B_R, B_PHI, B_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z Contents Source Code calculate_magnetic_field_p Source Code subroutine calculate_magnetic_field_p ( pchunk , F , Y_R , Y_Z , B_R , B_PHI , B_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z INTEGER :: pp REAL ( rp ), DIMENSION ( pchunk ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 2 ) :: A call EZspline_interp ( bfield_2d % A , pchunk , Y_R , Y_Z , & PSIp , ezerr ) call EZspline_error ( ezerr ) ! FR = (dA/dZ)/R call EZspline_gradient ( bfield_2d % A , pchunk , Y_R , Y_Z , & A , ezerr ) call EZspline_error ( ezerr ) !write(output_unit_write,'(\"dPSIp/dR: \",E17.10)') A(:,1) !write(output_unit_write,'(\"dPSIp/dZ: \",E17.10)') A(:,2) !write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R B_R = A (:, 2 ) / Y_R ! FPHI = Fo*Ro/R B_PHI = - F % Bo * F % Ro / Y_R ! FR = -(dA/dR)/R !     write(output_unit_write,'(\"R*B_Z: \",E17.10)') B_Z(1) B_Z = - A (:, 1 ) / Y_R !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R(1) !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z(1) !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHI: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_magnetic_field_p","tags":"","loc":"proc/calculate_magnetic_field_p.html"},{"title":"calculate_2DBdBfields_p – KORC-Full Orbit","text":"public subroutine calculate_2DBdBfields_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp Contents Source Code calculate_2DBdBfields_p Source Code subroutine calculate_2DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk , 3 ) :: BR , BPHI , BZ REAL ( rp ), DIMENSION ( pchunk ) :: dBRdR , dBPHIdR , dBZdR REAL ( rp ), DIMENSION ( pchunk ) :: dBRdPHI , dBPHIdPHI , dBZdPHI REAL ( rp ), DIMENSION ( pchunk ) :: dBRdZ , dBPHIdZ , dBZdZ REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , & efield_2d % R , efield_2d % PHI , efield_2d % Z , bfield_2d % A , & pchunk , Y_R , Y_Z , BR , BPHI , BZ , E_R , E_PHI , E_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) !  call EZspline_interp(bfield_2d%R,bfield_2d%PHI,bfield_2d%Z, & !       dbdR_2d%R,dbdR_2d%PHI,dBdR_2d%Z, & !       dbdPHI_2d%R,dbdPHI_2d%PHI,dbdPHI_2d%Z, & !       dbdZ_2d%R,dbdZ_2d%PHI,dbdZ_2d%Z, & !       efield_2d%R,efield_2d%PHI,efield_2d%Z,8,Y_R,Y_Z,B_R,B_PHI,B_Z, & !       dBRdR,dBPHIdR,dBZdR,dBRdPHI,dBPHIdPHI,dBZdPHI,dBRdZ,dBPHIdZ,dBZdZ, & !       E_R,E_PHI,E_Z,ezerr) !  call EZspline_error(ezerr) !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk B_R ( cc ) = BR ( cc , 1 ) B_PHI ( cc ) = BPHI ( cc , 1 ) B_Z ( cc ) = BZ ( cc , 1 ) dBRdR ( cc ) = BR ( cc , 2 ) dBRdPHI ( cc ) = 0._rp dBRdZ ( cc ) = BR ( cc , 3 ) dBPHIdR ( cc ) = BPHI ( cc , 2 ) dBPHIdPHI ( cc ) = 0._rp dBPHIdZ ( cc ) = BPHI ( cc , 3 ) dBZdR ( cc ) = BZ ( cc , 2 ) dBZdPHI ( cc ) = 0._rp dBZdZ ( cc ) = BZ ( cc , 3 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dBRdR ( cc ) + B_PHI ( cc ) * dBPHIdR ( cc ) + & B_Z ( cc ) * dBZdR ( cc )) / Bmag ( cc ) gradB_PHI ( cc ) = ( B_R ( cc ) * dBRdPHI ( cc ) + B_PHI ( cc ) * dBPHIdPHI ( cc ) + & B_Z ( cc ) * dBZdPHI ( cc )) / ( Y_R ( cc ) * Bmag ( cc )) gradB_Z ( cc ) = ( B_R ( cc ) * dBRdZ ( cc ) + B_PHI ( cc ) * dBPHIdZ ( cc ) + & B_Z ( cc ) * dBZdZ ( cc )) / Bmag ( cc ) curlb_R ( cc ) = ( Bmag ( cc ) * dBZdPHI ( cc ) / Y_R ( cc ) - B_Z ( cc ) * gradB_PHI ( cc ) - & Bmag ( cc ) * dBPHIdZ ( cc ) + B_PHI ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) * dBRdZ ( cc ) - B_R ( cc ) * gradB_Z ( cc ) - & Bmag ( cc ) * dBZdR ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * bmag ( cc )) curlb_Z ( cc ) = ( Bmag ( cc ) * B_PHI ( cc ) / Y_R ( cc ) + Bmag ( cc ) * dBPHIdR ( cc ) - & B_PHI ( cc ) * gradB_R ( cc ) - Bmag ( cc ) * dBRdPHI ( cc ) / Y_R ( cc ) + & B_R ( cc ) * gradB_PHI ( cc )) / ( Bmag ( cc ) * bmag ( cc )) end do !$OMP END SIMD !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHIinterp: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_2DBdBfields_p","tags":"","loc":"proc/calculate_2dbdbfields_p.html"},{"title":"calculate_3DBdBfields_p – KORC-Full Orbit","text":"public subroutine calculate_3DBdBfields_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code calculate_3DBdBfields_p Source Code subroutine calculate_3DBdBfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z real ( rp ), DIMENSION ( pchunk ) :: Y_PHI_mod TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ) :: dBRdR , dBPHIdR , dBZdR REAL ( rp ), DIMENSION ( pchunk ) :: dBRdPHI , dBPHIdPHI , dBZdPHI REAL ( rp ), DIMENSION ( pchunk ) :: dBRdZ , dBPHIdZ , dBZdZ REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache Y_PHI_mod = modulo ( Y_PHI , 2._rp * C_PI ) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI_mod , Y_Z , flag_cache ) call EZspline_interp ( bfield_2d % R , bfield_2d % PHI , bfield_2d % Z , & dbdR_2d % R , dbdR_2d % PHI , dBdR_2d % Z , & dbdPHI_2d % R , dbdPHI_2d % PHI , dbdPHI_2d % Z , & dbdZ_2d % R , dbdZ_2d % PHI , dbdZ_2d % Z , & efield_2d % R , efield_2d % PHI , efield_2d % Z , pchunk , Y_R , Y_Z , B_R , B_PHI , B_Z , & dBRdR , dBPHIdR , dBZdR , dBRdPHI , dBPHIdPHI , dBZdPHI , dBRdZ , dBPHIdZ , dBZdZ , & E_R , E_PHI , E_Z , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dBRdR ( cc ) + B_PHI ( cc ) * dBPHIdR ( cc ) + & B_Z ( cc ) * dBZdR ( cc )) / Bmag ( cc ) gradB_PHI ( cc ) = ( B_R ( cc ) * dBRdPHI ( cc ) + B_PHI ( cc ) * dBPHIdPHI ( cc ) + & B_Z ( cc ) * dBZdPHI ( cc )) / ( Y_R ( cc ) * Bmag ( cc )) gradB_Z ( cc ) = ( B_R ( cc ) * dBRdZ ( cc ) + B_PHI ( cc ) * dBPHIdZ ( cc ) + & B_Z ( cc ) * dBZdZ ( cc )) / Bmag ( cc ) curlb_R ( cc ) = ( Bmag ( cc ) * dBZdPHI ( cc ) / Y_R ( cc ) - B_Z ( cc ) * gradB_PHI ( cc ) - & Bmag ( cc ) * dBPHIdZ ( cc ) + B_PHI ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) * dBRdZ ( cc ) - B_R ( cc ) * gradB_Z ( cc ) - & Bmag ( cc ) * dBZdR ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) = ( Bmag ( cc ) * B_PHI ( cc ) / Y_R ( cc ) + Bmag ( cc ) * dBPHIdR ( cc ) - & B_PHI ( cc ) * gradB_R ( cc ) - Bmag ( cc ) * dBRdPHI ( cc ) / Y_R ( cc ) + & B_R ( cc ) * gradB_PHI ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) end do !$OMP END SIMD !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHIinterp: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_3DBdBfields_p","tags":"","loc":"proc/calculate_3dbdbfields_p.html"},{"title":"calculate_3DBdBfields1_p – KORC-Full Orbit","text":"public subroutine calculate_3DBdBfields1_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp Contents Source Code calculate_3DBdBfields1_p Source Code subroutine calculate_3DBdBfields1_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z real ( rp ), DIMENSION ( pchunk ) :: Y_PHI_mod TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk , 4 ) :: BR , BPHI , BZ REAL ( rp ), DIMENSION ( pchunk ) :: dBRdR , dBPHIdR , dBZdR REAL ( rp ), DIMENSION ( pchunk ) :: dBRdPHI , dBPHIdPHI , dBZdPHI REAL ( rp ), DIMENSION ( pchunk ) :: dBRdZ , dBPHIdZ , dBZdZ REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache Y_PHI_mod = modulo ( Y_PHI , 2._rp * C_PI ) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI_mod , Y_Z , flag_cache ) call EZspline_interp ( bfield_3d % R , bfield_3d % PHI , bfield_3d % Z , & efield_3d % R , efield_3d % PHI , efield_3d % Z , bfield_3d % A , & pchunk , Y_R , Y_PHI_mod , Y_Z , BR , BPHI , BZ , E_R , E_PHI , E_Z , PSIp , ezerr ) call EZspline_error ( ezerr ) !  call EZspline_interp(bfield_2d%R,bfield_2d%PHI,bfield_2d%Z, & !       dbdR_2d%R,dbdR_2d%PHI,dBdR_2d%Z, & !       dbdPHI_2d%R,dbdPHI_2d%PHI,dbdPHI_2d%Z, & !       dbdZ_2d%R,dbdZ_2d%PHI,dbdZ_2d%Z, & !       efield_2d%R,efield_2d%PHI,efield_2d%Z,8,Y_R,Y_Z,B_R,B_PHI,B_Z, & !       dBRdR,dBPHIdR,dBZdR,dBRdPHI,dBPHIdPHI,dBZdPHI,dBRdZ,dBPHIdZ,dBZdZ, & !       E_R,E_PHI,E_Z,ezerr) !  call EZspline_error(ezerr) !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk B_R ( cc ) = BR ( cc , 1 ) B_PHI ( cc ) = BPHI ( cc , 1 ) B_Z ( cc ) = BZ ( cc , 1 ) dBRdR ( cc ) = BR ( cc , 2 ) dBRdPHI ( cc ) = BR ( cc , 3 ) dBRdZ ( cc ) = BR ( cc , 4 ) dBPHIdR ( cc ) = BPHI ( cc , 2 ) dBPHIdPHI ( cc ) = BPHI ( cc , 3 ) dBPHIdZ ( cc ) = BPHI ( cc , 4 ) dBZdR ( cc ) = BZ ( cc , 2 ) dBZdPHI ( cc ) = BZ ( cc , 3 ) dBZdZ ( cc ) = BZ ( cc , 4 ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dBRdR ( cc ) + B_PHI ( cc ) * dBPHIdR ( cc ) + & B_Z ( cc ) * dBZdR ( cc )) / Bmag ( cc ) gradB_PHI ( cc ) = ( B_R ( cc ) * dBRdPHI ( cc ) + B_PHI ( cc ) * dBPHIdPHI ( cc ) + & B_Z ( cc ) * dBZdPHI ( cc )) / ( Y_R ( cc ) * Bmag ( cc )) gradB_Z ( cc ) = ( B_R ( cc ) * dBRdZ ( cc ) + B_PHI ( cc ) * dBPHIdZ ( cc ) + & B_Z ( cc ) * dBZdZ ( cc )) / Bmag ( cc ) curlb_R ( cc ) = ( Bmag ( cc ) * dBZdPHI ( cc ) / Y_R ( cc ) - B_Z ( cc ) * gradB_PHI ( cc ) - & Bmag ( cc ) * dBPHIdZ ( cc ) + B_PHI ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) * dBRdZ ( cc ) - B_R ( cc ) * gradB_Z ( cc ) - & Bmag ( cc ) * dBZdR ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) = ( Bmag ( cc ) * B_PHI ( cc ) / Y_R ( cc ) + Bmag ( cc ) * dBPHIdR ( cc ) - & B_PHI ( cc ) * gradB_R ( cc ) - Bmag ( cc ) * dBRdPHI ( cc ) / Y_R ( cc ) + & B_R ( cc ) * gradB_PHI ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) end do !$OMP END SIMD !  write(output_unit_write,'(\"PSIp: \",E17.10)') PSIp !  write(output_unit_write,'(\"Y_R: \",E17.10)') Y_R !  write(output_unit_write,'(\"Y_Z: \",E17.10)') Y_Z !  write(output_unit_write,'(\"B_R: \",E17.10)') B_R !  write(output_unit_write,'(\"B_PHIinterp: \",E17.10)') B_PHI !  write(output_unit_write,'(\"B_Z: \",E17.10)') B_Z end subroutine calculate_3DBdBfields1_p","tags":"","loc":"proc/calculate_3dbdbfields1_p.html"},{"title":"calculate_GCfieldswE_p – KORC-Full Orbit","text":"public subroutine calculate_GCfieldswE_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp Contents Source Code calculate_GCfieldswE_p Source Code subroutine calculate_GCfieldswE_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag , EPHI INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2d % A , efield_2d % PHI , pchunk , Y_R , Y_Z , A , & EPHI , ezerr ) call EZspline_error ( ezerr ) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dZ !A(:,4) = d&#94;2PSIp/dR&#94;2 !A(:,5) = d&#94;2PSIp/dZ&#94;2 !A(:,6) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) B_R ( cc ) = A ( cc , 3 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 4 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 5 ) - B_Z ( cc ) * A ( cc , 6 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 4 ) + A ( cc , 5 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) if ( F % E_2x1t ) then E_R ( cc ) = 0._rp E_PHI ( cc ) = EPHI ( cc ) E_Z ( cc ) = 0._rp else E_R ( cc ) = 0._rp E_PHI ( cc ) = 0._rp E_Z ( cc ) = 0._rp end if end do end subroutine calculate_GCfieldswE_p","tags":"","loc":"proc/calculate_gcfieldswe_p.html"},{"title":"calculate_GCfields_p – KORC-Full Orbit","text":"public subroutine calculate_GCfields_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp Contents Source Code calculate_GCfields_p Source Code subroutine calculate_GCfields_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , & curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2d % A , pchunk , Y_R , Y_Z , A , ezerr ) call EZspline_error ( ezerr ) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dZ !A(:,4) = d&#94;2PSIp/dR&#94;2 !A(:,5) = d&#94;2PSIp/dZ&#94;2 !A(:,6) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) B_R ( cc ) = A ( cc , 3 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 4 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 5 ) - B_Z ( cc ) * A ( cc , 6 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 4 ) + A ( cc , 5 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) E_R ( cc ) = 0._rp E_PHI ( cc ) = F % Eo * F % Ro / Y_R ( cc ) E_Z ( cc ) = 0._rp end do end subroutine calculate_GCfields_p","tags":"","loc":"proc/calculate_gcfields_p.html"},{"title":"calculate_GCfields_2x1t_p – KORC-Full Orbit","text":"public subroutine calculate_GCfields_2x1t_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp real(kind=rp), intent(in) :: time Contents Source Code calculate_GCfields_2x1t_p Source Code subroutine calculate_GCfields_2x1t_p ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp , time ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 7 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache REAL ( rp ), INTENT ( IN ) :: time REAL ( rp ), DIMENSION ( pchunk ) :: Y_T !$OMP SIMD do cc = 1_idef , pchunk Y_T ( cc ) = F % t0_2x1t + time end do !$OMP END SIMD !write(output_unit_write,*) 't0',F%t0_2x1t,'time',time,'Y_T',Y_T(1) call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_T , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2X1T % A , pchunk , Y_R , Y_T , Y_Z , A , ezerr ) call EZspline_error ( ezerr ) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dT !A(:,4) = dPSIp/dZ !A(:,5) = d&#94;2PSIp/dR&#94;2 !A(:,6) = d&#94;2PSIp/dZ&#94;2 !A(:,7) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) B_R ( cc ) = A ( cc , 4 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 7 ) - B_Z ( cc ) * A ( cc , 5 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 7 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 5 ) + A ( cc , 6 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) if ( F % E_2x1t ) then E_R ( cc ) = 0._rp E_PHI ( cc ) = A ( cc , 3 ) / ( 2._rp * C_PI * Y_R ( cc )) E_Z ( cc ) = 0._rp else E_R ( cc ) = 0._rp E_PHI ( cc ) = 0._rp E_Z ( cc ) = 0._rp end if end do !$OMP END SIMD end subroutine calculate_GCfields_2x1t_p","tags":"","loc":"proc/calculate_gcfields_2x1t_p.html"},{"title":"calculate_GCfields_p_FS – KORC-Full Orbit","text":"public subroutine calculate_GCfields_p_FS(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp Contents Source Code calculate_GCfields_p_FS Source Code subroutine calculate_GCfields_p_FS ( pchunk , F , Y_R , Y_PHI , Y_Z , B_R , B_PHI , B_Z , & E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , gradB_PHI , gradB_Z , & flag_cache , PSIp ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlb_R , curlb_PHI , curlb_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ) :: Bmag INTEGER :: cc REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk , 6 ) :: A INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag_cache call check_if_in_fields_domain_p ( pchunk , F , Y_R , Y_PHI , Y_Z , flag_cache ) call EZspline_derivative ( bfield_2d % A , pchunk , Y_R , Y_Z , A , ezerr ) call EZspline_error ( ezerr ) !write (output_unit_write,*) A(1,1),A(1,2) !A(:,1) = PSIp !A(:,2) = dPSIp/dR !A(:,3) = dPSIp/dZ !A(:,4) = d&#94;2PSIp/dR&#94;2 !A(:,5) = d&#94;2PSIp/dZ&#94;2 !A(:,6) = d&#94;2PSIp/dRdZ !$OMP SIMD !    !$OMP& aligned(PSIp,A,B_R,Y_R,B_PHI,B_Z,Bmag,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlb_R,curlb_PHI,curlb_Z,E_R,E_PHI,E_Z) do cc = 1_idef , pchunk PSIp ( cc ) = A ( cc , 1 ) A ( cc , 2 ) = A ( cc , 2 ) / ( 2 * C_PI ) A ( cc , 3 ) = A ( cc , 3 ) / ( 2 * C_PI ) A ( cc , 4 ) = A ( cc , 4 ) / ( 2 * C_PI ) A ( cc , 5 ) = A ( cc , 5 ) / ( 2 * C_PI ) A ( cc , 6 ) = A ( cc , 6 ) / ( 2 * C_PI ) B_R ( cc ) = A ( cc , 3 ) / Y_R ( cc ) ! BR = (dA/dZ)/R B_PHI ( cc ) = - F % Bo * F % Ro / Y_R ( cc ) ! BPHI = Fo*Ro/R B_Z ( cc ) = - A ( cc , 2 ) / Y_R ( cc ) ! BR = -(dA/dR)/R Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * A ( cc , 6 ) - B_Z ( cc ) * A ( cc , 4 ) - Bmag ( cc ) * Bmag ( cc )) / & ( Y_R ( cc ) * Bmag ( cc )) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * A ( cc , 5 ) - B_Z ( cc ) * A ( cc , 6 )) / & ( Y_R ( cc ) * Bmag ( cc )) curlb_R ( cc ) = B_PHI ( cc ) * gradB_Z ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) curlb_PHI ( cc ) = ( Bmag ( cc ) / Y_R ( cc ) * ( B_Z ( cc ) + A ( cc , 4 ) + A ( cc , 5 )) - & B_R ( cc ) * gradB_Z ( cc ) + B_Z ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_Z ( cc ) =- B_PHI ( cc ) * gradB_R ( cc ) / ( Bmag ( cc ) * Bmag ( cc )) E_R ( cc ) = 0._rp E_PHI ( cc ) = F % Eo * F % Ro / Y_R ( cc ) E_Z ( cc ) = 0._rp end do end subroutine calculate_GCfields_p_FS","tags":"","loc":"proc/calculate_gcfields_p_fs.html"},{"title":"add_interp_SCE_p – KORC-Full Orbit","text":"public subroutine add_interp_SCE_p(params, F, Y_R, Y_PHI, Y_Z, E_PHI) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI Contents Source Code add_interp_SCE_p Source Code subroutine add_interp_SCE_p ( params , F , Y_R , Y_PHI , Y_Z , E_PHI ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: rm , E_SC_PHI REAL ( rp ) :: R0 , Z0 INTEGER :: cc , pchunk pchunk = params % pchunk R0 = F % Ro Z0 = F % Zo !$OMP SIMD do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) * ( Y_R ( cc ) - R0 ) + ( Y_Z ( cc ) - Z0 ) * ( Y_Z ( cc ) - Z0 )) end do !$OMP END SIMD call EZspline_interp ( efield_SC1d % PHI , pchunk , rm , E_SC_PHI , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = E_PHI ( cc ) + E_SC_PHI ( cc ) end do !$OMP END SIMD end subroutine add_interp_SCE_p","tags":"","loc":"proc/add_interp_sce_p.html"},{"title":"add_interp_SCE_p_FS – KORC-Full Orbit","text":"public subroutine add_interp_SCE_p_FS(params, F, PSIp, E_PHI) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI Contents Source Code add_interp_SCE_p_FS Source Code subroutine add_interp_SCE_p_FS ( params , F , PSIp , E_PHI ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: PSIp REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ) :: E_SC_PHI INTEGER :: cc , pchunk pchunk = params % pchunk call EZspline_interp ( efield_SC1d % PHI , pchunk , PSIp , E_SC_PHI , ezerr ) call EZspline_error ( ezerr ) !$OMP SIMD do cc = 1_idef , pchunk E_PHI ( cc ) = E_PHI ( cc ) + E_SC_PHI ( cc ) end do !$OMP END SIMD end subroutine add_interp_SCE_p_FS","tags":"","loc":"proc/add_interp_sce_p_fs.html"},{"title":"calculate_initial_magnetic_field – KORC-Full Orbit","text":"public subroutine calculate_initial_magnetic_field(F) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F Contents Source Code calculate_initial_magnetic_field Source Code subroutine calculate_initial_magnetic_field ( F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F REAL ( rp ), dimension ( F % dims ( 1 ), F % dims ( 3 ), 2 ) :: gradA INTEGER :: ii INTEGER :: jj call EZspline_interp ( bfield_2d % A , F % dims ( 1 ), F % dims ( 3 ), F % X % R , F % X % Z , & F % PSIp , ezerr ) call EZspline_error ( ezerr ) ! FR = (dA/dZ)/R call EZspline_gradient ( bfield_2d % A , F % dims ( 1 ), F % dims ( 3 ), F % X % R , F % X % Z , & gradA , ezerr ) call EZspline_error ( ezerr ) do ii = 1 , F % dims ( 1 ) F % B_2D % R ( ii ,:) = gradA ( ii ,:, 2 ) / F % X % R ( ii ) F % B_2D % PHI ( ii ,:) = - F % Bo * F % Ro / F % X % R ( ii ) F % B_2D % Z ( ii ,:) = - gradA ( ii ,:, 1 ) / F % X % R ( ii ) end do !        write(output_unit_write,'(\"AR\",E17.10)') gradA(1) !        write(output_unit_write,'(\"AZ\",E17.10)') gradA(2) end subroutine calculate_initial_magnetic_field","tags":"","loc":"proc/calculate_initial_magnetic_field.html"},{"title":"sample_poloidal_flux – KORC-Full Orbit","text":"public subroutine sample_poloidal_flux(F) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F Contents Source Code sample_poloidal_flux Source Code subroutine sample_poloidal_flux ( F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F ! FR = (dA/dZ)/R call EZspline_interp ( bfield_2d % A , F % dims ( 1 ), F % dims ( 3 ), F % X % R , F % X % Z , & F % PSIp , ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"AR\",E17.10)') gradA(1) !        write(output_unit_write,'(\"AZ\",E17.10)') gradA(2) end subroutine sample_poloidal_flux","tags":"","loc":"proc/sample_poloidal_flux.html"},{"title":"interp_2D_efields – KORC-Full Orbit","text":"private subroutine interp_2D_efields(params, Y, E, flag) @brief Subroutine for interpolating the pre-computed, axisymmetric electric field to the particles' position. @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = , Y(2,:) = , and Y(3,:) = .\n @param[in,out] E Cartesian components of interpolated electric field components. E(1,:)= , E(2,:)= , and E(3,:)= .\n @param F Cylindrical components of interpolated magnetic field components. F(1,:)= , F(2,:)= , and F(3,:)= .\n @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0).\n @param pp Particle iterator.\n @param ss Species iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Contents Source Code interp_2D_efields Source Code subroutine interp_2D_efields ( params , Y , E , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag INTEGER :: pp INTEGER :: ss !  write(output_unit_write,*) 'interp E fields' if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,E,flag,efield_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( efield_2d % R , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( efield_2d % PHI , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( efield_2d % Z , Y ( pp , 1 ), Y ( pp , 3 ), F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then E ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) E ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) E ( pp , 3 ) = F ( pp , 3 ) else E ( pp , 1 ) = F ( pp , 1 ) E ( pp , 2 ) = F ( pp , 2 ) E ( pp , 3 ) = F ( pp , 3 ) end if !write(output_unit_write,*) 'EPHI',E(pp,2) end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_2D_efields","tags":"","loc":"proc/interp_2d_efields.html"},{"title":"interp_3D_efields – KORC-Full Orbit","text":"private subroutine interp_3D_efields(params, Y, E, flag) @brief Subroutine for interpolating the pre-computed 3-D electric field to the particles' position. @param[in] Y Particles' position in cylindrical coordinates, Y(1,:) = , Y(2,:) = , and Y(3,:) = .\n @param[in,out] E Cartesian components of interpolated electric field components. E(1,:)= , E(2,:)= , and E(3,:)= .\n @param F Cylindrical components of interpolated magnetic field components. F(1,:)= , F(2,:)= , and F(3,:)= .\n @param flag Flag that indicates whether particles are followed in the simulation (flag=1), or not (flag=0).\n @param pp Particle iterator.\n @param ss Species iterator. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Contents Source Code interp_3D_efields Source Code subroutine interp_3D_efields ( params , Y , E , flag ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: F INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag INTEGER :: pp INTEGER :: ss ss = size ( Y , 1 ) ALLOCATE ( F ( ss , 3 )) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(F,Y,E,flag,efield_3d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( efield_3d % R , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 1 ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( efield_3d % PHI , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 2 ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( efield_3d % Z , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & F ( pp , 3 ), ezerr ) call EZspline_error ( ezerr ) if (. not . params % GC_coords ) then E ( pp , 1 ) = F ( pp , 1 ) * COS ( Y ( pp , 2 )) - F ( pp , 2 ) * SIN ( Y ( pp , 2 )) E ( pp , 2 ) = F ( pp , 1 ) * SIN ( Y ( pp , 2 )) + F ( pp , 2 ) * COS ( Y ( pp , 2 )) E ( pp , 3 ) = F ( pp , 3 ) else E ( pp , 1 ) = F ( pp , 1 ) E ( pp , 2 ) = F ( pp , 2 ) E ( pp , 3 ) = F ( pp , 3 ) end if end if end do !$OMP END PARALLEL DO DEALLOCATE ( F ) end subroutine interp_3D_efields","tags":"","loc":"proc/interp_3d_efields.html"},{"title":"interp_fields – KORC-Full Orbit","text":"public subroutine interp_fields(params, prtcls, F) Note Subroutine that works as an interface for calling the \n appropriate subroutines for interpolating or calculating the \n electric and magnetic fields. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: prtcls An instance of PARTICLES containing the variables of a given species. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the \n information about the fields used in the simulation.\n See korc_types and korc_fields . Contents Source Code interp_fields Source Code subroutine interp_fields ( params , prtcls , F ) !! @note Subroutine that works as an interface for calling the !! appropriate subroutines for interpolating or calculating the !! electric and magnetic fields. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls !! An instance of PARTICLES containing the variables of a given species. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the !! information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. if (. not . params % GC_coords ) call cart_to_cyl ( prtcls % X , prtcls % Y ) !  write(output_unit_write,'(\"BR: \",E17.10)') prtcls%BR(:,1) !  write(output_unit_write,'(\"Y: \",E17.10)') prtcls%X(2,1) !  write(output_unit_write,'(\"Z: \",E17.10)') prtcls%X(3,1) call check_if_in_fields_domain ( F , prtcls % Y , prtcls % flagCon ) !write(output_unit_write,*) 'checked domain' #ifdef M3D_C1 if ( TRIM ( params % field_model ) . eq . 'M3D_C1' ) then if ( F % M3D_C1_B . ge . 0 ) then call get_m3d_c1_magnetic_fields ( prtcls , F , params ) end if if ( F % M3D_C1_E . ge . 0 ) then call get_m3d_c1_electric_fields ( prtcls , F , params ) end if if ( F % M3D_C1_A . ge . 0 ) then call get_m3d_c1_vector_potential ( prtcls , F , params ) end if end if #endif if (( ALLOCATED ( F % PSIp ). and . F % Bflux ). or . F % ReInterp_2x1t ) then !     write(output_unit_write,'(\"3 size of PSI_P: \",I16)') size(prtcls%PSI_P) !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) !     write(output_unit_write,'(\"PSI_P: \",E17.10)') prtcls%PSI_P call calculate_magnetic_field ( params , prtcls % Y , F , prtcls % B , prtcls % E , & prtcls % PSI_P , prtcls % flagCon ) !write(output_unit_write,*) 'interp PSIp' !     write(output_unit_write,'(\"interp_fields\")') !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) end if if ( ALLOCATED ( F % PSIp3D ). and . F % Bflux3D ) then !     write(output_unit_write,'(\"3 size of PSI_P: \",I16)') size(prtcls%PSI_P) !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) !     write(output_unit_write,'(\"PSI_P: \",E17.10)') prtcls%PSI_P call calculate_magnetic_field ( params , prtcls % Y , F , prtcls % B , prtcls % E , & prtcls % PSI_P , prtcls % flagCon ) !     write(output_unit_write,'(\"interp_fields\")') !     write(output_unit_write,'(\"B_X: \",E17.10)') prtcls%B(:,1) !     write(output_unit_write,'(\"B_Z: \",E17.10)') prtcls%B(:,3) !     write(output_unit_write,'(\"B_Y: \",E17.10)') prtcls%B(:,2) end if if ( ALLOCATED ( F % B_2D % R ). and . F % Bfield ) then call interp_2D_bfields ( params , prtcls % Y , prtcls % B , prtcls % flagCon ) end if if ( ALLOCATED ( F % B_3D % R ). and . F % Bfield ) then call interp_3D_bfields ( params , prtcls % Y , prtcls % B , prtcls % flagCon ) end if !  if (ALLOCATED(F%E_2D%R).and.F%Efield) then !     call interp_2D_efields(params,prtcls%Y,prtcls%E,prtcls%flagCon) !  end if if ( ALLOCATED ( F % E_3D % R ). and . F % Efield . and .(. not . F % ReInterp_2x1t )) then call interp_3D_efields ( params , prtcls % Y , prtcls % E , prtcls % flagCon ) end if if ( ALLOCATED ( F % E_3D % R ). and . F % Efield . and . F % ReInterp_2x1t ) then call interp_2D_efields ( params , prtcls % Y , prtcls % E , prtcls % flagCon ) !     write(output_unit_write,*) 'interpolated efield' end if if ( params % GC_coords . and . ALLOCATED ( F % gradB_2D % R ). and . F % Bfield ) then call interp_2D_gradBfields ( prtcls % Y , prtcls % gradB , prtcls % flagCon ) end if if ( params % GC_coords . and . ALLOCATED ( F % gradB_2D % R ). and . F % Bfield ) then call interp_2D_curlbfields ( prtcls % Y , prtcls % curlb , prtcls % flagCon ) end if if ( params % GC_coords . and . params % orbit_model ( 3 : 6 ) == 'grad' ) then call gradient_2D_bfields ( prtcls % Y , prtcls % BR , prtcls % BPHI , & prtcls % BZ , prtcls % flagCon ) end if end subroutine interp_fields","tags":"","loc":"proc/interp_fields.html"},{"title":"interp_2D_profiles – KORC-Full Orbit","text":"private subroutine interp_2D_profiles(Y, ne, Te, Zeff, flag) Note Subroutine for interpolating the pre-computed, axisymmetric\n plasma profiles to the particles' position. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: ne Interpolated background electron density !! . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Te Interpolated background electron temperature . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Zeff Interpolated effective charge number . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the\n simulation (flag=1), or not (flag=0). Contents Source Code interp_2D_profiles Source Code subroutine interp_2D_profiles ( Y , ne , Te , Zeff , flag ) !! @note Subroutine for interpolating the pre-computed, axisymmetric !! plasma profiles to the particles' position. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: ne !! Interpolated background electron density !!n_e(R,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Te !! Interpolated background electron temperature T_e(R,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Zeff !! Interpolated effective charge number Z_{eff}(R,Z). INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in the !! simulation (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. if ( Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Y , 1 ) end if !  write(output_unit_write,'(\"Also R_buffer: \",E17.10)') Y(1,ss) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(Y,ne,Te,Zeff,flag,profiles_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( profiles_2d % ne , Y ( pp , 1 ), Y ( pp , 3 ), ne ( pp ), ezerr ) call EZspline_error ( ezerr ) !        write(output_unit_write,'(\"Also R_buffer: \",E17.10)') Y(pp,1) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( profiles_2d % Te , Y ( pp , 1 ), Y ( pp , 3 ), Te ( pp ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( profiles_2d % Zeff , Y ( pp , 1 ), Y ( pp , 3 ), Zeff ( pp ), ezerr ) call EZspline_error ( ezerr ) end if end do !$OMP END PARALLEL DO end subroutine interp_2D_profiles","tags":"","loc":"proc/interp_2d_profiles.html"},{"title":"interp_3D_profiles – KORC-Full Orbit","text":"private subroutine interp_3D_profiles(Y, ne, Te, Zeff, flag) Note Subroutine for interpolating the pre-computed,\n 3-D plasma profiles to the particles' position. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: ne Interpolated background electron density . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Te Interpolated background electron temperature . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Zeff Interpolated effective charge number . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in\n the simulation (flag=1), or not (flag=0). Contents Source Code interp_3D_profiles Source Code subroutine interp_3D_profiles ( Y , ne , Te , Zeff , flag ) !! @note Subroutine for interpolating the pre-computed, !! 3-D plasma profiles to the particles' position. @endnote REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Particles' position in cylindrical coordinates, !! Y(1,:) = R, Y(2,:) = \\phi, and Y(3,:) = Z. REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: ne !! Interpolated background electron density n_e(R,\\phi,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Te !! Interpolated background electron temperature T_e(R,\\phi,Z). REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: Zeff !! Interpolated effective charge number Z_{eff}(R,\\phi,Z). INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag !! Flag that indicates whether particles are followed in !! the simulation (flag=1), or not (flag=0). INTEGER :: pp !! Particle iterator. INTEGER :: ss !! Species iterator. ss = size ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,ezerr) & !$OMP& SHARED(Y,ne,Te,Zeff,flag,profiles_2d) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then call EZspline_interp ( profiles_3d % ne , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & ne ( pp ), ezerr ) call EZspline_error ( ezerr ) if ( ezerr . NE . 0 ) then ! We flag the particle as lost flag ( pp ) = 0_is end if call EZspline_interp ( profiles_3d % Te , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & Te ( pp ), ezerr ) call EZspline_error ( ezerr ) call EZspline_interp ( profiles_3d % Zeff , Y ( pp , 1 ), Y ( pp , 2 ), Y ( pp , 3 ), & Zeff ( pp ), ezerr ) call EZspline_error ( ezerr ) end if end do !$OMP END PARALLEL DO end subroutine interp_3D_profiles","tags":"","loc":"proc/interp_3d_profiles.html"},{"title":"interp_profiles – KORC-Full Orbit","text":"public subroutine interp_profiles(params, prtcls, P) Note Subroutine that calls the appropriate subroutines for\n interpolating the 2-D or 3-D plasma profiles to the particles'\n position. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: prtcls An instance of PARTICLES containing the variables of a\n given species. Call to this subroutine generally passes spp%vars. type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See[[ korc_types]] and korc_profiles . Contents Source Code interp_profiles Source Code subroutine interp_profiles ( params , prtcls , P ) !! @note Subroutine that calls the appropriate subroutines for !! interpolating the 2-D or 3-D plasma profiles to the particles' !! position. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls !! An instance of PARTICLES containing the variables of a !! given species. Call to this subroutine generally passes spp%vars. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of KORC's derived type PROFILES containing all the !! information about the plasma profiles used in the simulation. !! See[[ korc_types]] and [[korc_profiles]]. if (. not . params % GC_coords ) call cart_to_cyl ( prtcls % X , prtcls % X ) !write(output_unit_write,'(\"Also R_buffer: \",E17.10)') prtcls%Y(1,1) call check_if_in_profiles_domain ( prtcls % Y , prtcls % flagCon ) if ( ALLOCATED ( P % ne_2D )) then !     write(output_unit_write,'(\"Also R_buffer: \",E17.10)') prtcls%X(1,1) call interp_2D_profiles ( prtcls % Y , prtcls % ne , prtcls % Te , prtcls % Zeff , & prtcls % flagCon ) else if ( ALLOCATED ( P % ne_3D )) then call interp_3D_profiles ( prtcls % Y , prtcls % ne , prtcls % Te , prtcls % Zeff , & prtcls % flagCon ) #ifdef M3D_C1 else if ( P % M3D_C1_ne . ge . 0 . or . & P % M3D_C1_te . ge . 0 . or . & P % M3D_C1_zeff . ge . 0 ) then call get_m3d_c1_profile ( prtcls , P , params ) #endif else write ( output_unit_write , '(\"Error: NO PROFILES ALLOCATED\")' ) call KORC_ABORT () end if end subroutine interp_profiles","tags":"","loc":"proc/interp_profiles.html"},{"title":"finalize_interpolants – KORC-Full Orbit","text":"public subroutine finalize_interpolants(params) @brief Subroutine that frees memory allocated for PSPLINE interpolants. @param[in] params Core KORC simulation parameters. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code finalize_interpolants Source Code subroutine finalize_interpolants ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params if (( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ). or . & ( params % field_eval . eq . 'interp' )) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * FINALIZING FIELD INTERPOLANT * * * *\")' ) end if if ( EZspline_allocated ( bfield_3d % R )) call Ezspline_free ( bfield_3d % R , ezerr ) if ( EZspline_allocated ( bfield_3d % PHI )) & call Ezspline_free ( bfield_3d % PHI , ezerr ) if ( EZspline_allocated ( bfield_3d % Z )) call Ezspline_free ( bfield_3d % Z , ezerr ) if ( EZspline_allocated ( bfield_2d % A )) call Ezspline_free ( bfield_2d % A , ezerr ) if ( EZspline_allocated ( bfield_2d % R )) call Ezspline_free ( bfield_2d % R , ezerr ) if ( EZspline_allocated ( bfield_2d % PHI )) & call Ezspline_free ( bfield_2d % PHI , ezerr ) if ( EZspline_allocated ( bfield_2d % Z )) call Ezspline_free ( bfield_2d % Z , ezerr ) if ( EZspline_allocated ( gradB_2d % R )) call Ezspline_free ( gradB_2d % R , ezerr ) if ( EZspline_allocated ( gradB_2d % PHI )) & call Ezspline_free ( gradB_2d % PHI , ezerr ) if ( EZspline_allocated ( gradB_2d % Z )) call Ezspline_free ( gradB_2d % Z , ezerr ) if ( EZspline_allocated ( curlb_2d % R )) call Ezspline_free ( curlb_2d % R , ezerr ) if ( EZspline_allocated ( curlb_2d % PHI )) & call Ezspline_free ( curlb_2d % PHI , ezerr ) if ( EZspline_allocated ( gradB_3d % R )) call Ezspline_free ( gradB_3d % R , ezerr ) if ( EZspline_allocated ( gradB_3d % PHI )) & call Ezspline_free ( gradB_3d % PHI , ezerr ) if ( EZspline_allocated ( gradB_3d % Z )) call Ezspline_free ( gradB_3d % Z , ezerr ) if ( EZspline_allocated ( curlb_3d % R )) call Ezspline_free ( curlb_3d % R , ezerr ) if ( EZspline_allocated ( curlb_3d % PHI )) & call Ezspline_free ( curlb_3d % PHI , ezerr ) if ( EZspline_allocated ( curlb_3d % Z )) call Ezspline_free ( curlb_3d % Z , ezerr ) if ( ALLOCATED ( profiles_domain % FLAG2D )) DEALLOCATE ( profiles_domain % FLAG2D ) if ( ALLOCATED ( profiles_domain % FLAG3D )) DEALLOCATE ( profiles_domain % FLAG3D ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * FIELD INTERPOLANT FINALIZED * * * *\")' ) end if end if if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * FINALIZING PROFILE INTERPOLANT * * * *\")' ) end if if ( EZspline_allocated ( profiles_3d % ne )) & call Ezspline_free ( profiles_3d % ne , ezerr ) if ( EZspline_allocated ( profiles_3d % Te )) & call Ezspline_free ( profiles_3d % Te , ezerr ) if ( EZspline_allocated ( profiles_3d % Zeff )) call Ezspline_free ( & profiles_3d % Zeff , ezerr ) if ( EZspline_allocated ( profiles_2d % ne )) & call Ezspline_free ( profiles_2d % ne , ezerr ) if ( EZspline_allocated ( profiles_2d % Te )) & call Ezspline_free ( profiles_2d % Te , ezerr ) if ( EZspline_allocated ( profiles_2d % Zeff )) call Ezspline_free ( & profiles_2d % Zeff , ezerr ) if ( ALLOCATED ( profiles_domain % FLAG2D )) DEALLOCATE ( profiles_domain % FLAG2D ) if ( ALLOCATED ( profiles_domain % FLAG3D )) DEALLOCATE ( profiles_domain % FLAG3D ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * PROFILE INTERPOLANT FINALIZED * * * *\")' ) end if end if end subroutine finalize_interpolants","tags":"","loc":"proc/finalize_interpolants.html"},{"title":"get_m3d_c1_magnetic_fields – KORC-Full Orbit","text":"public subroutine get_m3d_c1_magnetic_fields(prtcls, F, params) Uses omp_lib Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(in) :: params Contents Source Code get_m3d_c1_magnetic_fields Source Code subroutine get_m3d_c1_magnetic_fields ( prtcls , F , params ) USE omp_lib IMPLICIT NONE TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Btmp TYPE ( C_PTR ), DIMENSION ( size ( prtcls % hint )) :: hint INTEGER :: thread_num !    write(output_unit_write,*) 'in m3dc1 B' if ( prtcls % cart ) then !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x = prtcls % X ( pp ,:) * params % cpp % length status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & prtcls % B ( pp , 1 ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % B ( pp ,:) = 0 prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if end if end do !$OMP END PARALLEL DO else !       write(output_unit_write,*) 'in cart false' !hint=prtcls%hint !write(output_unit_write,*) 'hint: ',hint Btmp = 0._rp !$OMP PARALLEL DO DEFAULT(none) & !$OMP& SHARED(prtcls,params,F) & !$OMP& PRIVATE(pp,status,x,thread_num) & !$OMP& FIRSTPRIVATE(Btmp) do pp = 1 , SIZE ( prtcls % hint ) thread_num = OMP_GET_THREAD_NUM () if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( pp , 1 ) * params % cpp % length x ( 2 ) = prtcls % Y ( pp , 2 ) x ( 3 ) = prtcls % Y ( pp , 3 ) * params % cpp % length !prtcls%hint(pp)=c_null_ptr !write(output_unit_write,*) 'thread',thread_num,'X',x !             prtcls%hint(pp)=c_null_ptr !write(output_unit_write,*) 'thread',thread_num,'before interpolating B' status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & Btmp ( 1 ), prtcls % hint ( pp )) !write(output_unit_write,*) 'thread',thread_num,'interpolated B' if ( status . eq . FIO_NO_DATA ) then prtcls % B ( pp ,:) = 0 prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if if (. not . params % GC_coords ) then prtcls % B ( pp , 1 ) = ( Btmp ( 1 ) * cos ( x ( 2 )) - Btmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Bo prtcls % B ( pp , 2 ) = ( Btmp ( 1 ) * sin ( x ( 2 )) + Btmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Bo prtcls % B ( pp , 3 ) = Btmp ( 3 ) / params % cpp % Bo else prtcls % B ( pp , 1 ) = Btmp ( 1 ) / params % cpp % Bo prtcls % B ( pp , 2 ) = Btmp ( 2 ) / params % cpp % Bo prtcls % B ( pp , 3 ) = Btmp ( 3 ) / params % cpp % Bo end if end if end do !$OMP END PARALLEL DO end if end subroutine get_m3d_c1_magnetic_fields","tags":"","loc":"proc/get_m3d_c1_magnetic_fields.html"},{"title":"get_m3d_c1_FOmagnetic_fields_p – KORC-Full Orbit","text":"public subroutine get_m3d_c1_FOmagnetic_fields_p(params, F, Y_R, Y_PHI, Y_Z, B_X, B_Y, B_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code get_m3d_c1_FOmagnetic_fields_p Source Code subroutine get_m3d_c1_FOmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_X , B_Y , B_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: B_X , B_Y , B_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Btmp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & Btmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then B_X ( pp ) = ( Btmp ( 1 ) * cos ( x ( 2 )) - Btmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Bo B_Y ( pp ) = ( Btmp ( 1 ) * sin ( x ( 2 )) + Btmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Bo B_Z ( pp ) = Btmp ( 3 ) / params % cpp % Bo else if ( status . eq . FIO_NO_DATA ) then flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_FOmagnetic_fields_p","tags":"","loc":"proc/get_m3d_c1_fomagnetic_fields_p.html"},{"title":"get_m3d_c1_GCmagnetic_fields_p – KORC-Full Orbit","text":"public subroutine get_m3d_c1_GCmagnetic_fields_p(params, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, gradB_R, gradB_PHI, gradB_Z, curlb_R, curlb_PHI, curlb_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code get_m3d_c1_GCmagnetic_fields_p Source Code subroutine get_m3d_c1_GCmagnetic_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & B_R , B_PHI , B_Z , gradB_R , gradB_PHI , gradB_Z , & curlb_R , curlb_PHI , curlb_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: curlb_R , curlb_PHI , curlb_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Btmp REAL ( rp ), DIMENSION ( 9 ) :: dBtmp REAL ( rp ) :: Bmag , dBRdR , dBPHIdR , dBZdR , dBRdPHI , dBPHIdPHI , dBZdPHI , dBRdZ , dBPHIdZ , dBZdZ pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr !if (pp.eq.1) write(output_unit_write,*) 'Yinterp',x status = fio_eval_field ( F % M3D_C1_B , x ( 1 ), & Btmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then !if (pp.eq.1) write(output_unit_write,*) 'interp success!' B_R ( pp ) = Btmp ( 1 ) / params % cpp % Bo B_PHI ( pp ) = Btmp ( 2 ) / params % cpp % Bo B_Z ( pp ) = Btmp ( 3 ) / params % cpp % Bo Bmag = sqrt ( B_R ( pp ) * B_R ( pp ) + B_PHI ( pp ) * B_PHI ( pp ) + B_Z ( pp ) * B_Z ( pp )) status = fio_eval_field_deriv ( F % M3D_C1_B , x ( 1 ), dBtmp ( 1 ), hint ( pp )) !dBRdR=dBtmp(FIO_DR_R)*(params%cpp%length/params%cpp%Bo) !dBPHIdR=dBtmp(FIO_DR_PHI)*(params%cpp%length/params%cpp%Bo) !dBZdR=dBtmp(FIO_DR_Z)*(params%cpp%length/params%cpp%Bo) !dBRdPHI=dBtmp(FIO_DPHI_R)*(params%cpp%length/params%cpp%Bo) !dBPHIdPHI=dBtmp(FIO_DPHI_PHI)*(params%cpp%length/params%cpp%Bo) !dBZdPHI=dBtmp(FIO_DPHI_Z)*(params%cpp%length/params%cpp%Bo) !dBRdZ=dBtmp(FIO_DZ_R)*(params%cpp%length/params%cpp%Bo) !dBPHIdZ=dBtmp(FIO_DZ_PHI)*(params%cpp%length/params%cpp%Bo) !dBZdZ=dBtmp(FIO_DZ_Z)*(params%cpp%length/params%cpp%Bo) dBRdR = dBtmp ( 1 ) * ( params % cpp % length / params % cpp % Bo ) dBPHIdR = dBtmp ( 2 ) * ( params % cpp % length / params % cpp % Bo ) dBZdR = dBtmp ( 3 ) * ( params % cpp % length / params % cpp % Bo ) dBRdPHI = dBtmp ( 4 ) * ( params % cpp % length / params % cpp % Bo ) dBPHIdPHI = dBtmp ( 5 ) * ( params % cpp % length / params % cpp % Bo ) dBZdPHI = dBtmp ( 6 ) * ( params % cpp % length / params % cpp % Bo ) dBRdZ = dBtmp ( 7 ) * ( params % cpp % length / params % cpp % Bo ) dBPHIdZ = dBtmp ( 8 ) * ( params % cpp % length / params % cpp % Bo ) dBZdZ = dBtmp ( 9 ) * ( params % cpp % length / params % cpp % Bo ) gradB_R ( pp ) = ( B_R ( pp ) * dBRdR + B_PHI ( pp ) * dBPHIdR + B_Z ( pp ) * dBZdR ) / & Bmag gradB_PHI ( pp ) = ( B_R ( pp ) * dBRdPHI + B_PHI ( pp ) * dBPHIdPHI + & B_Z ( pp ) * dBZdPHI ) / ( Y_R ( pp ) * Bmag ) gradB_Z ( pp ) = ( B_R ( pp ) * dBRdZ + B_PHI ( pp ) * dBPHIdZ + B_Z ( pp ) * dBZdZ ) / & Bmag curlb_R ( pp ) = ( Bmag / Y_R ( pp ) * dBZdPHI - B_Z ( pp ) * gradB_PHI ( pp ) - & Bmag * dBPHIdZ + B_PHI ( pp ) * gradB_Z ( pp )) / ( Bmag * Bmag ) curlb_PHI ( pp ) = ( Bmag * dBRdZ - B_R ( pp ) * gradB_Z ( pp ) - & Bmag * dBZdR + B_Z ( pp ) * gradB_R ( pp )) / ( Bmag * Bmag ) curlb_Z ( pp ) = ( Bmag / Y_R ( pp ) * B_PHI ( pp ) + Bmag * dBPHIdR - & B_PHI ( pp ) * gradB_R ( pp ) - & Bmag / Y_R ( pp ) * dBRdPHI + B_R ( pp ) * gradB_PHI ( pp )) / ( Bmag * Bmag ) else if ( status . eq . FIO_NO_DATA ) then flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_GCmagnetic_fields_p","tags":"","loc":"proc/get_m3d_c1_gcmagnetic_fields_p.html"},{"title":"get_m3d_c1_vector_potential – KORC-Full Orbit","text":"public subroutine get_m3d_c1_vector_potential(prtcls, F, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(in) :: params Contents Source Code get_m3d_c1_vector_potential Source Code subroutine get_m3d_c1_vector_potential ( prtcls , F , params ) TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Atmp integer ( ip ) :: ss if ( prtcls % Y ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( prtcls % Y , 1 ) end if Atmp = 0._rp !$OMP PARALLEL DO DEFAULT(SHARED) & !$OMP& PRIVATE(pp,status,x) & !$OMP& FIRSTPRIVATE(Atmp) do pp = 1 , ss if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( pp , 1 ) * params % cpp % length x ( 2 ) = prtcls % Y ( pp , 2 ) x ( 3 ) = prtcls % Y ( pp , 3 ) * params % cpp % length !prtcls%hint(pp)=c_null_ptr !write(output_unit_write,*) F%M3D_C1_A,x,Atmp status = fio_eval_field ( F % M3D_C1_A , x ( 1 ), & Atmp ( 1 ), prtcls % hint ( pp )) if ( status . eq . FIO_SUCCESS ) then prtcls % PSI_P ( pp ) =- Atmp ( 2 ) * x ( 1 ) else if ( status . eq . FIO_NO_DATA ) then prtcls % PSI_P ( pp ) = 10 0._rp prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is prtcls % PSI_P ( pp ) = 10 0._rp end if end if end do !$OMP END PARALLEL DO end subroutine get_m3d_c1_vector_potential","tags":"","loc":"proc/get_m3d_c1_vector_potential.html"},{"title":"get_m3d_c1_vector_potential_p – KORC-Full Orbit","text":"public subroutine get_m3d_c1_vector_potential_p(params, F, Y_R, Y_PHI, Y_Z, PSIp, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code get_m3d_c1_vector_potential_p Source Code subroutine get_m3d_c1_vector_potential_p ( params , F , Y_R , Y_PHI , Y_Z , & PSIp , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: PSIp INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Atmp integer ( ip ) :: ss pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr status = fio_eval_field ( F % M3D_C1_A , x ( 1 ), & Atmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then PSIp ( pp ) =- Atmp ( 2 ) * x ( 1 ) else if ( status . eq . FIO_NO_DATA ) then PSIp ( pp ) = 10 0._rp flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then PSIp ( pp ) = 10 0._rp flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_vector_potential_p","tags":"","loc":"proc/get_m3d_c1_vector_potential_p.html"},{"title":"get_m3d_c1_electric_fields – KORC-Full Orbit","text":"public subroutine get_m3d_c1_electric_fields(prtcls, F, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(in) :: params Contents Source Code get_m3d_c1_electric_fields Source Code subroutine get_m3d_c1_electric_fields ( prtcls , F , params ) TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Etmp if ( prtcls % cart ) then !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x = prtcls % X ( pp ,:) * params % cpp % length status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & prtcls % E ( pp , 1 ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % E ( pp ,:) = 0 else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if end if end do !$OMP END PARALLEL DO else Etmp = 0._rp !$OMP PARALLEL DO DEFAULT(none) & !$OMP& SHARED(prtcls,params,F) & !$OMP& PRIVATE(pp,status,x) & !$OMP& FIRSTPRIVATE(Etmp) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( pp , 1 ) * params % cpp % length x ( 2 ) = prtcls % Y ( pp , 2 ) x ( 3 ) = prtcls % Y ( pp , 3 ) * params % cpp % length status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & Etmp ( 1 ), prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % E ( pp ,:) = 0 prtcls % flagCon ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is end if if (. not . params % GC_coords ) then prtcls % E ( pp , 1 ) = ( Etmp ( 1 ) * cos ( x ( 2 )) - Etmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Eo prtcls % E ( pp , 2 ) = ( Etmp ( 1 ) * sin ( x ( 2 )) + Etmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Eo prtcls % E ( pp , 3 ) = Etmp ( 3 ) / params % cpp % Eo else prtcls % E ( pp , 1 ) = Etmp ( 1 ) / params % cpp % Eo prtcls % E ( pp , 2 ) = Etmp ( 2 ) / params % cpp % Eo prtcls % E ( pp , 3 ) = Etmp ( 3 ) / params % cpp % Eo end if end if end do !$OMP END PARALLEL DO end if end subroutine get_m3d_c1_electric_fields","tags":"","loc":"proc/get_m3d_c1_electric_fields.html"},{"title":"get_m3d_c1_FOelectric_fields_p – KORC-Full Orbit","text":"public subroutine get_m3d_c1_FOelectric_fields_p(params, F, Y_R, Y_PHI, Y_Z, E_X, E_Y, E_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code get_m3d_c1_FOelectric_fields_p Source Code subroutine get_m3d_c1_FOelectric_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & E_X , E_Y , E_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_X , E_Y , E_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Etmp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !             prtcls%hint(pp)=c_null_ptr status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & Etmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then E_X ( pp ) = ( Etmp ( 1 ) * cos ( x ( 2 )) - Etmp ( 2 ) * sin ( x ( 2 ))) / & params % cpp % Eo E_Y ( pp ) = ( Etmp ( 1 ) * sin ( x ( 2 )) + Etmp ( 2 ) * cos ( x ( 2 ))) / & params % cpp % Eo E_Z ( pp ) = Etmp ( 3 ) / params % cpp % Eo else if ( status . eq . FIO_NO_DATA ) then E_X ( pp ) = 0 E_Y ( pp ) = 0 E_Z ( pp ) = 0 flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if end if end do end subroutine get_m3d_c1_FOelectric_fields_p","tags":"","loc":"proc/get_m3d_c1_foelectric_fields_p.html"},{"title":"get_m3d_c1_GCelectric_fields_p – KORC-Full Orbit","text":"public subroutine get_m3d_c1_GCelectric_fields_p(params, F, Y_R, Y_PHI, Y_Z, E_R, E_PHI, E_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code get_m3d_c1_GCelectric_fields_p Source Code subroutine get_m3d_c1_GCelectric_fields_p ( params , F , Y_R , Y_PHI , Y_Z , & E_R , E_PHI , E_Z , flag , hint ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ), DIMENSION ( 3 ) :: Etmp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length status = fio_eval_field ( F % M3D_C1_E , x ( 1 ), & Etmp ( 1 ), hint ( pp )) if ( status . eq . FIO_SUCCESS ) then E_R ( pp ) = Etmp ( 1 ) / params % cpp % Eo E_PHI ( pp ) = Etmp ( 2 ) / params % cpp % Eo E_Z ( pp ) = Etmp ( 3 ) / params % cpp % Eo else if ( status . eq . FIO_NO_DATA ) then E_R ( pp ) = 0 E_PHI ( pp ) = 0 E_Z ( pp ) = 0 flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is end if !          write(6,*) E_R,E_PHI,E_Z end if end do end subroutine get_m3d_c1_GCelectric_fields_p","tags":"","loc":"proc/get_m3d_c1_gcelectric_fields_p.html"},{"title":"get_m3d_c1_profile – KORC-Full Orbit","text":"public subroutine get_m3d_c1_profile(prtcls, P, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(PROFILES), intent(in) :: P type(KORC_PARAMS), intent(in) :: params Contents Source Code get_m3d_c1_profile Source Code subroutine get_m3d_c1_profile ( prtcls , P , params ) TYPE ( PARTICLES ), INTENT ( INOUT ) :: prtcls TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params INTEGER ( C_INT ) :: status INTEGER :: pp REAL ( rp ), DIMENSION ( 3 ) :: x if ( prtcls % cart ) then !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x = prtcls % X ( pp ,:) * params % cpp % length status = fio_eval_field ( P % M3D_C1_ne , x ( 1 ), & prtcls % ne ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % ne ( pp ) = 0 else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is CYCLE end if status = fio_eval_field ( P % M3D_C1_te , x ( 1 ), & prtcls % te ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % te ( pp ) = 0 end if status = fio_eval_field ( P % M3D_C1_zeff , x ( 1 ), & prtcls % Zeff ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % Zeff ( pp ) = 1 end if end if end do !$OMP END PARALLEL DO else !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(pp,status,x) do pp = 1 , SIZE ( prtcls % hint ) if ( prtcls % flagCon ( pp ) . EQ . 1_is ) then x ( 1 ) = prtcls % Y ( 1 , pp ) * params % cpp % length x ( 2 ) = prtcls % Y ( 2 , pp ) x ( 3 ) = prtcls % Y ( 3 , pp ) * params % cpp % length status = fio_eval_field ( P % M3D_C1_ne , x ( 1 ), & prtcls % ne ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % ne ( pp ) = 0 else if ( status . ne . FIO_SUCCESS ) then prtcls % flagCon ( pp ) = 0_is CYCLE end if status = fio_eval_field ( P % M3D_C1_te , x ( 1 ), & prtcls % te ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % te ( pp ) = 0 end if status = fio_eval_field ( P % M3D_C1_zeff , x ( 1 ), & prtcls % Zeff ( pp ), & prtcls % hint ( pp )) if ( status . eq . FIO_NO_DATA ) then prtcls % Zeff ( pp ) = 1 end if end if end do !$OMP END PARALLEL DO end if end subroutine get_m3d_c1_profile","tags":"","loc":"proc/get_m3d_c1_profile.html"},{"title":"get_m3d_c1_profile_p – KORC-Full Orbit","text":"public subroutine get_m3d_c1_profile_p(params, P, Y_R, Y_PHI, Y_Z, n_e, T_e, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(PROFILES), intent(in) :: P real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: n_e real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: T_e integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint Contents Source Code get_m3d_c1_profile_p Source Code subroutine get_m3d_c1_profile_p ( params , P , Y_R , Y_PHI , Y_Z , & n_e , T_e , flag , hint ) TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: n_e , T_e INTEGER ( is ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: flag TYPE ( C_PTR ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: hint INTEGER ( C_INT ) :: status INTEGER :: pp , pchunk REAL ( rp ), DIMENSION ( 3 ) :: x REAL ( rp ) :: netmp =- 1._rp , Tetmp =- 1._rp pchunk = params % pchunk do pp = 1 , pchunk if ( flag ( pp ) . EQ . 1_is ) then x ( 1 ) = Y_R ( pp ) * params % cpp % length x ( 2 ) = Y_PHI ( pp ) x ( 3 ) = Y_Z ( pp ) * params % cpp % length !write(6,*) P%M3D_C1_ne,x status = fio_eval_field ( P % M3D_C1_ne , x ( 1 ), & netmp , hint ( pp )) if ( status . eq . FIO_SUCCESS ) then n_e ( pp ) = netmp / params % cpp % density else if ( status . eq . FIO_NO_DATA ) then flag ( pp ) = 0_is else if ( status . ne . FIO_SUCCESS ) then flag ( pp ) = 0_is CYCLE end if status = fio_eval_field ( P % M3D_C1_te , x ( 1 ), & Tetmp , hint ( pp )) if ( status . eq . FIO_SUCCESS ) then T_e ( pp ) = Tetmp / ( params % cpp % temperature / C_E ) end if !          write(6,*) E_R,E_PHI,E_Z end if end do end subroutine get_m3d_c1_profile_p","tags":"","loc":"proc/get_m3d_c1_profile_p.html"},{"title":"deg2rad – KORC-Full Orbit","text":"public function deg2rad(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code deg2rad Source Code FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad","tags":"","loc":"proc/deg2rad~4.html"},{"title":"fRE – KORC-Full Orbit","text":"private function fRE(x, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: p Return Value real(kind=rp) Contents Source Code fRE Source Code FUNCTION fRE ( x , p ) REAL ( rp ), INTENT ( IN ) :: x ! x = cos(pitch) REAL ( rp ), INTENT ( IN ) :: p ! momentum REAL ( rp ) :: fRE fRE = aval_params % fo * p * EXP ( - p * ( aval_params % C2 * x + aval_params % C1 / x )) / x END FUNCTION fRE","tags":"","loc":"proc/fre~3.html"},{"title":"log10fRE – KORC-Full Orbit","text":"public function log10fRE(x, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: p Return Value real(kind=rp) Contents Source Code log10fRE Source Code FUNCTION log10fRE ( x , p ) REAL ( rp ), INTENT ( IN ) :: x ! x = cos(pitch) REAL ( rp ), INTENT ( IN ) :: p ! momentum REAL ( rp ) :: log10fRE log10fRE = LOG ( fRE ( x , p )) END FUNCTION log10fRE","tags":"","loc":"proc/log10fre.html"},{"title":"PSI_ROT – KORC-Full Orbit","text":"private function PSI_ROT(R, R0, sigR, Z, Z0, sigZ, theta) Calculates value of argument of 2D Gaussian spatial distribution with\n with counter-clockwise rotation. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R R-coordinate of MH sampled location real(kind=rp), intent(in) :: R0 R-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigR Variance of first dimension of 2D Gaussian real(kind=rp), intent(in) :: Z Z-coordinate of MH sampled location real(kind=rp), intent(in) :: Z0 Z-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigZ Variance of second dimension of 2D Gaussian real(kind=rp), intent(in) :: theta Angle of counter-clockwise rotation (in radians), of 2D Gaussian\n distribution relative to R,Z Return Value real(kind=rp) Argument of exponential comprising 2D Gaussian distribution Contents Source Code PSI_ROT Source Code FUNCTION PSI_ROT ( R , R0 , sigR , Z , Z0 , sigZ , theta ) !! Calculates value of argument of 2D Gaussian spatial distribution with !! with counter-clockwise rotation. REAL ( rp ), INTENT ( IN ) :: R !! R-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: R0 !! R-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigR !! Variance of first dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: Z !! Z-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: Z0 !! Z-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigZ !! Variance of second dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: theta !! Angle of counter-clockwise rotation (in radians), of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: PSI_ROT !! Argument of exponential comprising 2D Gaussian distribution PSI_ROT = ( R - R0 ) ** 2 * (( cos ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( sin ( theta )) ** 2 / & ( 2 * sigZ ** 2 )) + 2 * ( R - R0 ) * ( Z - Z0 ) * cos ( theta ) * sin ( theta ) * ( 1 / & ( 2 * sigR ** 2 ) - 1 / ( 2 * sigZ ** 2 )) + ( Z - Z0 ) ** 2 * (( sin ( theta )) ** 2 / & ( 2 * sigR ** 2 ) + ( cos ( theta )) ** 2 / ( 2 * sigZ ** 2 )) END FUNCTION PSI_ROT","tags":"","loc":"proc/psi_rot~2.html"},{"title":"indicator – KORC-Full Orbit","text":"private function indicator(psi, psi_max) Compares argument psi to chosen psi_max, returning step function. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: psi real(kind=rp), intent(in) :: psi_max Return Value real(kind=rp) Contents Source Code indicator Source Code FUNCTION indicator ( psi , psi_max ) !! Compares argument psi to chosen psi_max, returning step function. REAL ( rp ), INTENT ( IN ) :: psi REAL ( rp ), INTENT ( IN ) :: psi_max REAL ( rp ) :: indicator IF ( psi . LT . psi_max ) THEN indicator = 1 ELSE indicator = 0 END IF END FUNCTION indicator","tags":"","loc":"proc/indicator~2.html"},{"title":"random_norm – KORC-Full Orbit","text":"private function random_norm(mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Contents Source Code random_norm Source Code FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = mean + sigma * SQRT ( - 2.0_rp * LOG ( rand1 )) * COS ( 2.0_rp * C_PI * rand2 ); END FUNCTION random_norm","tags":"","loc":"proc/random_norm~5.html"},{"title":"get_avalanche_distribution – KORC-Full Orbit","text":"public subroutine get_avalanche_distribution(params, g, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao Contents Source Code get_avalanche_distribution Source Code SUBROUTINE get_avalanche_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao call initialize_avalanche_params ( params ) call save_avalanche_params ( params ) call sample_distribution ( params , g , eta , go , etao ) END SUBROUTINE get_avalanche_distribution","tags":"","loc":"proc/get_avalanche_distribution.html"},{"title":"get_Avalanche_4D – KORC-Full Orbit","text":"public subroutine get_Avalanche_4D(params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code get_Avalanche_4D Source Code SUBROUTINE get_Avalanche_4D ( params , spp , P , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp TYPE ( PROFILES ), INTENT ( IN ) :: P TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. call initialize_avalanche_params ( params ) call save_avalanche_params ( params ) call Avalanche_4D ( params , spp , P , F ) END SUBROUTINE get_Avalanche_4D","tags":"","loc":"proc/get_avalanche_4d.html"},{"title":"initialize_avalanche_params – KORC-Full Orbit","text":"private subroutine initialize_avalanche_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code initialize_avalanche_params Source Code SUBROUTINE initialize_avalanche_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) :: max_pitch_angle !REAL(rp) :: min_pitch_angle !REAL(rp) :: max_energy !REAL(rp) :: min_energy !REAL(rp) :: ne !REAL(rp) :: Zeff !REAL(rp) :: Epar !REAL(rp) :: Te !REAL(rp) :: dth !REAL(rp) :: dp !REAL(rp) :: dR !REAL(rp) :: dZ !NAMELIST /AvalancheGenerationPDF/ max_pitch_angle,min_pitch_angle, & !     max_energy,min_energy,ne,Zeff,Epar,Te,dth,dp,dR,dZ !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=AvalancheGenerationPDF) !close(default_unit_open) aval_params % dth = dth_aval aval_params % dp = dp_aval aval_params % dR = dR_aval / params % cpp % length aval_params % dZ = dZ_aval / params % cpp % length aval_params % max_pitch_angle = max_pitch_angle_aval aval_params % min_pitch_angle = min_pitch_angle_aval aval_params % max_energy = max_energy_aval * C_E ! In Joules aval_params % ne = ne_aval aval_params % Zeff = Zeff_aval aval_params % Te = Te_aval * C_E ! In Joules aval_params % lD = SQRT ( C_E0 * aval_params % Te / ( aval_params % ne * C_E ** 2 )) aval_params % bmin = aval_params % Zeff / ( 1 2.0_rp * C_PI * aval_params % ne * & aval_params % lD ** 2 ) aval_params % CoulombLog = LOG ( aval_params % lD / aval_params % bmin ) aval_params % Tau = 1.0_rp / ( 4.0_rp * C_PI * C_C * C_RE ** 2 * aval_params % ne * & aval_params % CoulombLog ) aval_params % Ec = C_ME * C_C / ( C_E * aval_params % Tau ) aval_params % Epar = Epar_aval aval_params % Ebar = aval_params % Epar / aval_params % Ec if ( min_energy_aval . EQ . 0.0_rp ) then aval_params % max_p = SQRT (( aval_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 & - 1.0_rp ) ! In units of mec&#94;2 aval_params % min_p = SQRT ( aval_params % Ebar - 1.0_rp ) ! In units of mec&#94;2 aval_params % min_energy = SQRT ( 1.0_rp + aval_params % min_p ** 2 ) * C_ME * C_C ** 2 else aval_params % min_energy = min_energy_aval * C_E ! In Joules aval_params % max_p = SQRT (( aval_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mec&#94;2 aval_params % min_p = SQRT (( aval_params % min_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mec&#94;2 end if aval_params % alpha = ( aval_params % Ebar - 1.0_rp ) / ( 1.0_rp + aval_params % Zeff ) aval_params % cz = SQRT ( 3.0_rp * ( aval_params % Zeff + 5.0_rp ) / C_PI ) * & aval_params % CoulombLog aval_params % fo = aval_params % alpha / aval_params % cz aval_params % C1 = 0.5_rp * aval_params % alpha aval_params % C2 = 1.0_rp / aval_params % cz - aval_params % C1 END SUBROUTINE initialize_avalanche_params","tags":"","loc":"proc/initialize_avalanche_params.html"},{"title":"sample_distribution – KORC-Full Orbit","text":"private subroutine sample_distribution(params, g, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao Contents Source Code sample_distribution Source Code SUBROUTINE sample_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: chi , chi_test REAL ( rp ) :: p_buffer , p_test REAL ( rp ) :: eta_buffer , eta_test REAL ( rp ) :: ratio , rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_tmp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax , min_p , max_p , min_pitch_angle , max_pitch_angle REAL ( 4 ), DIMENSION ( 2 ) :: tarray REAL ( 4 ) :: time_elapsed REAL ( rp ) :: deta REAL ( rp ) :: dp LOGICAL :: lp , leta INTEGER :: num_accepted INTEGER :: ii , jj , ppp , nsamples INTEGER :: mpierr ppp = SIZE ( g ) nsamples = ppp * params % mpi_params % nmpi ALLOCATE ( p ( ppp )) deta = ( aval_params % max_pitch_angle - aval_params % min_pitch_angle ) / 10 0.0_rp dp = ( aval_params % max_p - aval_params % min_p ) / 10 0.0_rp do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_p - REAL ( jj , rp ) * dp if ( minmax . GT . 0.0_rp ) then min_p = minmax end if end do max_p = aval_params % max_p + minmax_buffer_size * dp if ( aval_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = aval_params % min_pitch_angle end if do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax else max_pitch_angle = aval_params % max_pitch_angle EXIT end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( p_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( p_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_buffer = aval_params % min_pitch_angle + ( aval_params % max_pitch_angle & - aval_params % min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) p_buffer = aval_params % min_p + ( aval_params % max_p - aval_params % min_p ) * & rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . aval_params % max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . aval_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) end do chi_test = COS ( deg2rad ( eta_test )) chi = COS ( deg2rad ( eta_buffer )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . aval_params % min_p ). OR .( p_test . GT . aval_params % max_p )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( chi_test , p_test ) / fRE ( chi , p_buffer ) if ( ratio . GE . 1.0_rp ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef end if end if end do ! Transient ! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_tmp ( 1 ) = eta_buffer p_tmp ( 1 ) = p_buffer num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR .( ABS ( eta_test ) & . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) end do chi_test = COS ( deg2rad ( eta_test )) chi = COS ( deg2rad ( eta_tmp ( ii - 1 ))) p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . min_p ). OR .( p_test . GT . max_p )) p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( chi_test , p_test ) / fRE ( chi , p_tmp ( ii - 1 )) if ( ratio . GE . 1.0_rp ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) lp = ( p_tmp ( ii ). LE . aval_params % max_p ). AND .( p_tmp ( ii ). GE . & aval_params % min_p ) leta = ( eta_tmp ( ii ). LE . aval_params % max_pitch_angle ). AND . & ( eta_tmp ( ii ). GE . aval_params % min_pitch_angle ) if ( lp . AND . leta ) then num_accepted = num_accepted + 1_idef p_samples ( num_accepted ) = p_tmp ( ii ) eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do eta_tmp ( 1 ) = eta_tmp ( ii ) p_tmp ( 1 ) = p_tmp ( ii ) end do go = SUM ( SQRT ( 1.0_rp + p_samples ** 2 )) / nsamples etao = SUM ( eta_samples ) / nsamples end if CALL MPI_SCATTER ( p_samples , ppp , MPI_REAL8 , p , ppp , MPI_REAL8 , 0 , & MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , ppp , MPI_REAL8 , eta , ppp , MPI_REAL8 , & 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( go , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( etao , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) g = SQRT ( 1.0_rp + p ** 2 ) DEALLOCATE ( p ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( p_samples ) DEALLOCATE ( eta_samples ) end if END SUBROUTINE sample_distribution","tags":"","loc":"proc/sample_distribution~3.html"},{"title":"update_avalanche_params – KORC-Full Orbit","text":"private subroutine update_avalanche_params(params, prtcls) Updates the avalanche parameters aval_params% at each step\n in the MCMC after the profiles are interpolated at the sampled\n R,Z location. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(in) :: prtcls An instance of PARTICLES containing the variables of a\n given species. Call to this subroutine generally passes spp%vars. Contents Source Code update_avalanche_params Source Code SUBROUTINE update_avalanche_params ( params , prtcls ) !! Updates the avalanche parameters aval_params% at each step !! in the MCMC after the profiles are interpolated at the sampled !! R,Z location. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( IN ) :: prtcls !! An instance of PARTICLES containing the variables of a !! given species. Call to this subroutine generally passes spp%vars. aval_params % ne = prtcls % ne ( 1 ) * params % cpp % density aval_params % Zeff = prtcls % Zeff ( 1 ) aval_params % Te = prtcls % Te ( 1 ) * params % cpp % temperature ! In Joules aval_params % lD = SQRT ( C_E0 * aval_params % Te / ( aval_params % ne * C_E ** 2 )) aval_params % bmin = aval_params % Zeff / ( 1 2.0_rp * C_PI * aval_params % ne * & aval_params % lD ** 2 ) aval_params % CoulombLog = LOG ( aval_params % lD / aval_params % bmin ) aval_params % Tau = 1.0_rp / ( 4.0_rp * C_PI * C_C * C_RE ** 2 * aval_params % ne * & aval_params % CoulombLog ) aval_params % Ec = C_ME * C_C / ( C_E * aval_params % Tau ) aval_params % Ebar = aval_params % Epar / aval_params % Ec aval_params % alpha = ( aval_params % Ebar - 1.0_rp ) / ( 1.0_rp + & aval_params % Zeff ) aval_params % cz = SQRT ( 3.0_rp * ( aval_params % Zeff + 5.0_rp ) / C_PI ) * & aval_params % CoulombLog aval_params % fo = aval_params % alpha / aval_params % cz aval_params % C1 = 0.5_rp * aval_params % alpha aval_params % C2 = 1.0_rp / aval_params % cz - aval_params % C1 END SUBROUTINE update_avalanche_params","tags":"","loc":"proc/update_avalanche_params.html"},{"title":"Avalanche_4D – KORC-Full Orbit","text":"private subroutine Avalanche_4D(params, spp, P, F) Note Subroutine that generates a 2D Gaussian distribution in an \n elliptic torus as the initial spatial condition of a given particle \n species in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code Avalanche_4D Source Code subroutine Avalanche_4D ( params , spp , P , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: P_samples !! Magnitude of momentum of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: T_samples !! Pitch angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: mom !! Magnitude of momentum of samples on individual mpi process REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers REAL ( rp ) :: max_p !! Maximum domain for momentum sampling including buffer REAL ( rp ) :: min_p !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: P_buffer !! Previous sample of momentum REAL ( rp ) :: T_buffer !! Previous sample of pitch angle REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: P_test !! Present sample of momentum REAL ( rp ) :: T_test !! Present sample of pitch angle REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: fRE0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: fRE1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator ALLOCATE ( mom ( spp % ppp )) nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.1_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp ! buffer at minimum p boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_p - REAL ( ii , rp ) * ( aval_params % max_p - & aval_params % min_p ) / 100_rp if ( minmax . GT . 0.0_rp ) then min_p = minmax end if end do ! buffer at maximum p boundary max_p = aval_params % max_p + minmax_buffer_size * ( aval_params % max_p - & aval_params % min_p ) / 100_rp ! buffer at minimum pitch angle boundary if ( aval_params % min_pitch_angle . GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % min_pitch_angle - REAL ( ii , rp ) * & ( aval_params % max_pitch_angle - aval_params % min_pitch_angle ) / 100_rp if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = aval_params % min_pitch_angle end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = aval_params % max_pitch_angle + REAL ( ii , rp ) * & ( aval_params % max_pitch_angle - aval_params % min_pitch_angle ) / 100_rp if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( P_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( T_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo call RANDOM_NUMBER ( rand_unif ) T_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) P_buffer = min_p + ( max_p - min_p ) * rand_unif !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length ii = 1_idef do while ( ii . LE . 1000_idef ) !        write(output_unit_write,'(\"burn:\",I15)') ii R_test = R_buffer + random_norm ( 0.0_rp , aval_params % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , aval_params % dZ ) P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) ! Test that pitch angle and momentum are within chosen boundary do while (( T_test . GT . aval_params % max_pitch_angle ). OR . & ( T_test . LT . aval_params % min_pitch_angle )) T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) end do do while (( P_test . LT . aval_params % min_p ). OR . & ( P_test . GT . aval_params % max_p )) P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then psi0 = PSI_ROT ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) ! Repetedly put location of sample into first entry of spp%vars%Y, ! beacause spp%vas%X isn't filled until the end of this subrouting. ! This allows us to use the machinery for calling PSPLINES ! interpolation routines here also. spp % vars % Y ( 1 , 1 ) = R_buffer spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_buffer call get_profiles ( params , spp % vars , P , F ) !           write(output_unit_write,'(\"ne\",E17.10)') spp%vars%ne(1) !           write(output_unit_write,'(\"Te\",E17.10)') spp%vars%Te(1) !           write(output_unit_write,'(\"Zeff\",E17.10)') spp%vars%Zeff(1) ! Update avalanche parameters with interpolated fields to be used ! in call to avalanche distribution function call update_avalanche_params ( params , spp % vars ) fRE0 = fRE ( cos ( deg2rad ( T_buffer )), P_buffer ) else psi0 = psi1 fRE0 = fRE1 end if psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test call get_profiles ( params , spp % vars , P , F ) call update_avalanche_params ( params , spp % vars ) fRE1 = fRE ( COS ( deg2rad ( T_test )), P_test ) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator ( psi1 , spp % psi_max ) * R_test * EXP ( - psi1 ) * & sin ( deg2rad ( T_test )) * fRE1 / ( R_buffer * EXP ( - psi0 ) * & sin ( deg2rad ( T_buffer )) * fRE0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , 10000 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if R_test = R_buffer + random_norm ( 0.0_rp , aval_params % dR ) Z_test = Z_buffer + random_norm ( 0.0_rp , aval_params % dZ ) P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) ! Selection boundary is set with buffer region do while (( T_test . GT . max_pitch_angle ). OR . & ( T_test . LT . min_pitch_angle )) if ( T_test . lt . 0 ) then T_test = abs ( T_test ) exit end if T_test = T_buffer + random_norm ( 0.0_rp , aval_params % dth ) end do do while (( P_test . LT . min_p ). OR .( P_test . GT . max_p )) if ( P_test . lt . 0 ) then P_test = abs ( P_test ) exit end if P_test = P_buffer + random_norm ( 0.0_rp , aval_params % dp ) end do psi0 = psi1 fRE0 = fRE1 psi1 = PSI_ROT ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test call get_profiles ( params , spp % vars , P , F ) call update_avalanche_params ( params , spp % vars ) fRE1 = fRE ( COS ( deg2rad ( T_test )), P_test ) ratio = indicator ( psi1 , psi_max_buff ) * R_test * EXP ( - psi1 ) * & sin ( deg2rad ( T_test )) * fRE1 / ( R_buffer * EXP ( - psi0 ) * & sin ( deg2rad ( T_buffer )) * fRE0 ) if ( ratio . GE . 1.0_rp ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then R_buffer = R_test Z_buffer = Z_test P_buffer = P_test T_buffer = T_test end if end if ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator ( psi1 , spp % psi_max )). EQ . 1 ). AND . & ( P_buffer . LE . aval_params % max_p ). AND . & ( P_buffer . GE . aval_params % min_p ). AND . & ( T_buffer . LE . aval_params % max_pitch_angle ). AND . & ( T_buffer . GE . aval_params % min_pitch_angle )) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer P_samples ( ii ) = P_buffer T_samples ( ii ) = T_buffer ! Sample phi location uniformly call RANDOM_NUMBER ( rand_unif ) PHI_samples ( ii ) = 2.0_rp * C_PI * rand_unif ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length end if CALL MPI_SCATTER ( R_samples * cos ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( R_samples * sin ( PHI_samples ), spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( P_samples , spp % ppp , MPI_REAL8 , & mom , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( T_samples , spp % ppp , MPI_REAL8 , & spp % vars % eta , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum spp % vars % g = SQRT ( 1.0_rp + mom ** 2 ) if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' DEALLOCATE ( mom ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( P_samples ) DEALLOCATE ( T_samples ) end if end subroutine Avalanche_4D","tags":"","loc":"proc/avalanche_4d.html"},{"title":"save_avalanche_params – KORC-Full Orbit","text":"private subroutine save_avalanche_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_avalanche_params Source Code SUBROUTINE save_avalanche_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"avalanche_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , aval_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in avalanche PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , aval_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * aval_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in avalanche PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * aval_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , aval_params % max_p , attr ) dset = TRIM ( gname ) // \"/min_p\" attr = \"Maximum momentum in avalanche PDF (me*c&#94;2)\" call save_to_hdf5 ( h5file_id , dset , aval_params % min_p , attr ) dset = TRIM ( gname ) // \"/ne\" attr = \"Background electron density (m&#94;-3)\" call save_to_hdf5 ( h5file_id , dset , aval_params % ne , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , aval_params % Zeff , attr ) dset = TRIM ( gname ) // \"/Ec\" attr = \"Critical electric field in (V/m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % Ec , attr ) dset = TRIM ( gname ) // \"/Epar\" attr = \"Parallel electric field in (V/m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % Epar , attr ) dset = TRIM ( gname ) // \"/Te\" attr = \"Background electron temperature (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * aval_params % Te , attr ) dset = TRIM ( gname ) // \"/lambda_D\" attr = \"Debye length (m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % lD , attr ) dset = TRIM ( gname ) // \"/bmin\" attr = \"Maximum approach radius (m)\" call save_to_hdf5 ( h5file_id , dset , aval_params % bmin , attr ) dset = TRIM ( gname ) // \"/Clog\" attr = \"Coulomb logarithm\" call save_to_hdf5 ( h5file_id , dset , aval_params % CoulombLog , attr ) dset = TRIM ( gname ) // \"/Tau\" attr = \"Collision time (s)\" call save_to_hdf5 ( h5file_id , dset , aval_params % Tau , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_avalanche_params","tags":"","loc":"proc/save_avalanche_params.html"},{"title":"compute_charcs_plasma_params – KORC-Full Orbit","text":"public subroutine compute_charcs_plasma_params(params, spp, F) Note Subroutine that calculates characteristic scales of \n the current KORC simulation. Normalization and non-dimensionalization of the variables and equations \n of motion allows us to solve them more accurately by reducing truncation \n erros when performing operations that combine small and large numbers. For normalizing and obtaining the non-dimensional form of the variables \n and equations solved in KORC we use characteristic scales calculated with \n the input data of each KORC simulation. Characteristic scales in KORC Characteristic scale Symbol Value Description Velocity Speed of light Time Inverse of electron cyclotron frequency Relativistic time Inverse of relativistic electron cyclotron frequency Length -- Mass Electron mass Charge Absolute value of electron charge Momentum -- Magnetic field Magnetic field at the magnetic axis Electric field -- Energy -- Temperature Temperature given in Joules. Density -- Magnetic moment -- Pressure -- -- With these characteristic scales we can write the dimensionless \n form of all the equations. For example, the Lorentz force for a \n charged particle , mass , and momentum can be written as: where , , , , , \n and . Todo Characteristic pressure needs to be defined. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the \n information of different electron species. See korc_types . type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the \n information about the fields used in the simulation. \n See korc_types and korc_fields . Contents Source Code compute_charcs_plasma_params Source Code subroutine compute_charcs_plasma_params ( params , spp , F ) !! @note Subroutine that calculates characteristic scales of !! the current KORC simulation. @endnote !! Normalization and non-dimensionalization of the variables and equations !! of motion allows us to solve them more accurately by reducing truncation !! erros when performing operations that combine small and large numbers. !! !! For normalizing and obtaining the non-dimensional form of the variables !! and equations solved in KORC we use characteristic scales calculated with !! the input data of each KORC simulation. !! <table cellspacing=\"10\"> !! <caption id=\"multi_row\">Characteristic scales in KORC</caption> !! <tr><th>Characteristic scale</th>\t<th>Symbol</th>\t        <th>Value</th>\t\t\t<th>Description</th></tr> !! <tr><td rowspan=\"1\">Velocity \t<td>v_{ch}\t\t<td>c\t\t\t<td> Speed of light !! <tr><td rowspan=\"1\">Time \t\t<td>t_{ch}\t\t<td>\\Omega&#94;{-1} = m_{ch}/q_{ch}B_{ch} \t<td> Inverse of electron cyclotron frequency !! <tr><td rowspan=\"1\">Relativistic time <td>t_{r,ch}\t<td>\\Omega_r&#94;{-1} = \\gamma m_{ch}/q_{ch}B_{ch} \t<td> Inverse of relativistic electron cyclotron frequency !! <tr><td rowspan=\"1\">Length \t<td>l_{ch}\t\t<td>v_{ch}t_{ch}\t\t<td>-- !! <tr><td rowspan=\"1\">Mass \t\t<td>m_{ch}\t\t<td>m_e\t\t\t<td> Electron mass !! <tr><td rowspan=\"1\">Charge \t<td>q_{ch}\t\t<td>e\t\t\t<td> Absolute value of electron charge !! <tr><td rowspan=\"1\">Momentum       <td>p_{ch}\t        <td>m_{ch}v_{ch} \t        <td> -- !! <tr><td rowspan=\"1\">Magnetic field <td>B_{ch}\t\t<td>B_0\t\t        <td> Magnetic field at the magnetic axis !! <tr><td rowspan=\"1\">Electric field <td>E_{ch}\t\t<td>v_{ch}B_{ch}\t\t<td> -- !! <tr><td rowspan=\"1\">Energy \t<td>\\mathcal{E}_{ch}<td>m_{ch}v_{ch}&#94;2\t\t<td>-- !! <tr><td rowspan=\"1\">Temperature \t<td>T_{ch}\t\t<td>m_{ch}v_{ch}&#94;2\t\t<td> Temperature given in Joules. !! <tr><td rowspan=\"1\">Density \t<td>n_{ch}\t\t<td>l_{ch}&#94;{-3}\t\t<td>-- !! <tr><td rowspan=\"1\">Magnetic moment \t<td>\\mu_{ch}<td>m_{ch}v_{ch}&#94;2/B_{ch}\t<td>-- !! <tr><td rowspan=\"1\">Pressure \t<td>P_{ch}\t\t<td>--\t\t                <td>-- !! </table> !! With these characteristic scales we can write the dimensionless !! form of all the equations. For example, the Lorentz force for a !! charged particle q, mass m, and momentum !! \\mathbf{p}=\\gamma m \\mathbf{v} can be written as: !! !! \\frac{d \\mathbf{p}'}{dt'} = q'\\left[ \\mathbf{E}' + !! \\frac{\\mathbf{p}'}{\\gamma m'}\\times \\mathbf{B}' \\right], !! !! where \\mathbf{p}' = \\mathbf{p}/p_{ch}, t' = t/t_{ch}, !! q' = q/q_{ch}, m' = m/m_{ch}, \\mathbf{E}' = \\mathbf{E}/E_{ch}, !! and \\mathbf{B}'=\\mathbf{B}/B_{ch}. !! @todo Characteristic pressure needs to be defined. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the !! information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the !! information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. INTEGER :: ii !! Index of the spp array containing the mass, electric charge !! and corresponding cyclotron frequency used to derived some characteristic scales. params % cpp % velocity = C_C params % cpp % Bo = ABS ( F % Bo ) params % cpp % Eo = ABS ( params % cpp % velocity * params % cpp % Bo ) ! Non-relativistic cyclotron frequency spp (:)% wc = ( ABS ( spp (:)% q ) / spp (:)% m ) * params % cpp % Bo ! Relativistic cyclotron frequency spp (:)% wc_r = ABS ( spp (:)% q ) * params % cpp % Bo / ( spp (:)% go * spp (:)% m ) ii = MAXLOC ( spp (:)% wc , 1 ) ! Index to maximum cyclotron frequency params % cpp % time = 1.0_rp / spp ( ii )% wc ii = MAXLOC ( spp (:)% wc_r , 1 ) ! Index to maximum relativistic cyclotron frequency params % cpp % time_r = 1.0_rp / spp ( ii )% wc_r params % cpp % mass = C_ME params % cpp % charge = C_E params % cpp % length = params % cpp % velocity * params % cpp % time params % cpp % energy = params % cpp % mass * params % cpp % velocity ** 2 params % cpp % density = 1.0_rp / params % cpp % length ** 3 params % cpp % pressure = 0.0_rp params % cpp % temperature = params % cpp % energy end subroutine compute_charcs_plasma_params","tags":"","loc":"proc/compute_charcs_plasma_params.html"},{"title":"normalize_variables – KORC-Full Orbit","text":"public subroutine normalize_variables(params, spp, F, P) Note Subroutine that normalizes the simulation variables with \n the previously computed characteristic scales. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all \n the information of different electron species. See korc_types . type(FIELDS), intent(inout) :: F @param[in,out] F An instance of KORC's derived type FIELDS \n containing all the information about the fields used in the simulation.\n See korc_types and korc_fields . type(PROFILES), intent(inout) :: P @param[in,out] P An instance of KORC's derived type PROFILES containing all the information about the plasma profiles used in\n the simulation. See korc_types.f90 and korc_profiles.f90. Contents Source Code normalize_variables Source Code subroutine normalize_variables ( params , spp , F , P ) !! @note Subroutine that normalizes the simulation variables with !! the previously computed characteristic scales. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information of different electron species. See [[korc_types]]. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! @param[in,out] F An instance of KORC's derived type FIELDS !! containing all the information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. TYPE ( PROFILES ), INTENT ( INOUT ) :: P !! @param[in,out] P An instance of KORC's derived type PROFILES containing all the information about the plasma profiles used in !! the simulation. See korc_types.f90 and korc_profiles.f90. INTEGER :: ii !! @param ii Interator of spp array. !\tNormalize params variables params % dt = params % dt / params % cpp % time params % simulation_time = params % simulation_time / params % cpp % time params % snapshot_frequency = params % snapshot_frequency / params % cpp % time params % minimum_particle_energy = params % minimum_particle_energy / params % cpp % energy params % init_time = params % init_time / params % cpp % time !\tNormalize particle variables do ii = 1_idef , size ( spp ) spp ( ii )% q = spp ( ii )% q / params % cpp % charge spp ( ii )% m = spp ( ii )% m / params % cpp % mass spp ( ii )% Eo = spp ( ii )% Eo / params % cpp % energy spp ( ii )% Eo_lims = spp ( ii )% Eo_lims / params % cpp % energy spp ( ii )% wc = spp ( ii )% wc * params % cpp % time spp ( ii )% wc_r = spp ( ii )% wc_r * params % cpp % time spp ( ii )% vars % X = spp ( ii )% vars % X / params % cpp % length spp ( ii )% vars % V = spp ( ii )% vars % V / params % cpp % velocity spp ( ii )% vars % Rgc = spp ( ii )% vars % Rgc / params % cpp % length spp ( ii )% Ro = spp ( ii )% Ro / params % cpp % length spp ( ii )% Zo = spp ( ii )% Zo / params % cpp % length spp ( ii )% r_inner = spp ( ii )% r_inner / params % cpp % length spp ( ii )% r_outter = spp ( ii )% r_outter / params % cpp % length spp ( ii )% sigmaR = spp ( ii )% sigmaR / params % cpp % length spp ( ii )% sigmaZ = spp ( ii )% sigmaZ / params % cpp % length spp ( ii )% falloff_rate = spp ( ii )% falloff_rate * params % cpp % length spp ( ii )% Xtrace = spp ( ii )% Xtrace / params % cpp % length spp ( ii )% Spong_b = spp ( ii )% Spong_b / params % cpp % length spp ( ii )% Spong_w = spp ( ii )% Spong_w / params % cpp % length spp ( ii )% dR = spp ( ii )% dR / params % cpp % length spp ( ii )% dZ = spp ( ii )% dZ / params % cpp % length end do !\tNormalize electromagnetic fields and profiles F % Bo = F % Bo / params % cpp % Bo F % Eo = F % Eo / params % cpp % Eo F % Ro = F % Ro / params % cpp % length F % Zo = F % Zo / params % cpp % length F % E_dyn = F % E_dyn / params % cpp % Eo F % E_pulse = F % E_pulse / params % cpp % time F % E_width = F % E_width / params % cpp % time F % t0_2x1t = F % t0_2x1t / params % cpp % time P % a = P % a / params % cpp % length P % R0 = P % R0 / params % cpp % length P % Z0 = P % Z0 / params % cpp % length P % R0_RE = P % R0_RE / params % cpp % length P % Z0_RE = P % Z0_RE / params % cpp % length P % neo = P % neo / params % cpp % density P % n_ne = P % n_ne / params % cpp % density P % n_shelf = P % n_shelf / params % cpp % density P % Teo = P % Teo / params % cpp % temperature P % n_REr0 = P % n_REr0 / params % cpp % length P % n_tauion = P % n_tauion / params % cpp % time P % n_tauin = P % n_tauin / params % cpp % time P % n_tauout = P % n_tauout / params % cpp % time P % n_shelfdelay = P % n_shelfdelay / params % cpp % time P % n_lamfront = P % n_lamfront / params % cpp % length P % n_lamback = P % n_lamback / params % cpp % length P % n_lamshelf = P % n_lamshelf / params % cpp % length if ( params % profile_model . EQ . 'ANALYTICAL' ) then if ( params % field_eval . eq . 'interp' ) then if ( ALLOCATED ( P % X % R )) P % X % R = P % X % R / params % cpp % length if ( ALLOCATED ( P % X % Z )) P % X % Z = P % X % Z / params % cpp % length if ( ALLOCATED ( P % ne_2D )) P % ne_2D = P % ne_2D / params % cpp % density if ( ALLOCATED ( P % Te_2D )) P % Te_2D = P % Te_2D / params % cpp % temperature end if else if ( params % profile_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( ALLOCATED ( P % X % R )) P % X % R = P % X % R / params % cpp % length if ( ALLOCATED ( P % X % Z )) P % X % Z = P % X % Z / params % cpp % length if ( ALLOCATED ( P % ne_2D )) P % ne_2D = P % ne_2D / params % cpp % density if ( ALLOCATED ( P % Te_2D )) P % Te_2D = P % Te_2D / params % cpp % temperature if ( ALLOCATED ( P % ne_3D )) P % ne_3D = P % ne_3D / params % cpp % density if ( ALLOCATED ( P % Te_3D )) P % Te_3D = P % Te_3D / params % cpp % temperature end if if ( params % field_model ( 1 : 10 ) . EQ . 'ANALYTICAL' ) then F % AB % Bo = F % AB % Bo / params % cpp % Bo F % AB % a = F % AB % a / params % cpp % length F % AB % Ro = F % AB % Ro / params % cpp % length F % AB % lambda = F % AB % lambda / params % cpp % length F % AB % Bpo = F % AB % Bpo / params % cpp % Bo if ( params % field_eval . eq . 'interp' ) then if ( ALLOCATED ( F % B_2D % R )) F % B_2D % R = F % B_2D % R / params % cpp % Bo if ( ALLOCATED ( F % B_2D % PHI )) F % B_2D % PHI = F % B_2D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_2D % Z )) F % B_2D % Z = F % B_2D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_2D % R )) F % E_2D % R = F % E_2D % R / params % cpp % Eo if ( ALLOCATED ( F % E_2D % PHI )) F % E_2D % PHI = F % E_2D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_2D % Z )) F % E_2D % Z = F % E_2D % Z / params % cpp % Eo if ( ALLOCATED ( F % B_3D % R )) F % B_3D % R = F % B_3D % R / params % cpp % Bo if ( ALLOCATED ( F % B_3D % PHI )) F % B_3D % PHI = F % B_3D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_3D % Z )) F % B_3D % Z = F % B_3D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_3D % R )) F % E_3D % R = F % E_3D % R / params % cpp % Eo if ( ALLOCATED ( F % E_3D % PHI )) F % E_3D % PHI = F % E_3D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_3D % Z )) F % E_3D % Z = F % E_3D % Z / params % cpp % Eo if ( ALLOCATED ( F % PSIp )) F % PSIp = F % PSIp / & ( params % cpp % Bo * params % cpp % length ** 2 ) F % PSIP_min = F % PSIP_min / & ( params % cpp % Bo * params % cpp % length ** 2 ) if (. not . params % field_model . eq . 'M3D_C1' ) then F % PSIp_lim = F % PSIp_lim / & ( params % cpp % Bo * params % cpp % length ** 2 ) end if F % X % R = F % X % R / params % cpp % length ! Nothing to do for the PHI component F % X % Z = F % X % Z / params % cpp % length if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then if ( ALLOCATED ( F % gradB_2D % R )) F % gradB_2D % R = F % gradB_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % PHI )) F % gradB_2D % PHI = F % gradB_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % Z )) F % gradB_2D % Z = F % gradB_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % R )) F % curlb_2D % R = F % curlb_2D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % PHI )) F % curlb_2D % PHI = F % curlb_2D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % Z )) F % curlb_2D % Z = F % curlb_2D % Z / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % R )) F % gradB_3D % R = F % gradB_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % PHI )) F % gradB_3D % PHI = F % gradB_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % Z )) F % gradB_3D % Z = F % gradB_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % R )) F % curlb_3D % R = F % curlb_3D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % PHI )) F % curlb_3D % PHI = F % curlb_3D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % Z )) F % curlb_3D % Z = F % curlb_3D % Z / & ( 1. / params % cpp % length ) end if end if else if ( params % field_model ( 1 : 8 ) . EQ . 'EXTERNAL' ) then if ( ALLOCATED ( F % B_3D % R )) F % B_3D % R = F % B_3D % R / params % cpp % Bo if ( ALLOCATED ( F % B_3D % PHI )) F % B_3D % PHI = F % B_3D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_3D % Z )) F % B_3D % Z = F % B_3D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_3D % R )) F % E_3D % R = F % E_3D % R / params % cpp % Eo if ( ALLOCATED ( F % E_3D % PHI )) F % E_3D % PHI = F % E_3D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_3D % Z )) F % E_3D % Z = F % E_3D % Z / params % cpp % Eo if ( ALLOCATED ( F % PSIp )) F % PSIp = F % PSIp / ( params % cpp % Bo * params % cpp % length ** 2 ) if ( ALLOCATED ( F % PSIp3D )) F % PSIp3D = F % PSIp3D / & ( params % cpp % Bo * params % cpp % length ** 2 ) F % PSIP_min = F % PSIP_min / ( params % cpp % Bo * params % cpp % length ** 2 ) F % PSIp_lim = F % PSIp_lim / ( params % cpp % Bo * params % cpp % length ** 2 ) if ( ALLOCATED ( F % B_2D % R )) F % B_2D % R = F % B_2D % R / params % cpp % Bo if ( ALLOCATED ( F % B_2D % PHI )) F % B_2D % PHI = F % B_2D % PHI / params % cpp % Bo if ( ALLOCATED ( F % B_2D % Z )) F % B_2D % Z = F % B_2D % Z / params % cpp % Bo if ( ALLOCATED ( F % E_2D % R )) F % E_2D % R = F % E_2D % R / params % cpp % Eo if ( ALLOCATED ( F % E_2D % PHI )) F % E_2D % PHI = F % E_2D % PHI / params % cpp % Eo if ( ALLOCATED ( F % E_2D % Z )) F % E_2D % Z = F % E_2D % Z / params % cpp % Eo if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then if ( ALLOCATED ( F % gradB_2D % R )) F % gradB_2D % R = F % gradB_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % PHI )) F % gradB_2D % PHI = F % gradB_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_2D % Z )) F % gradB_2D % Z = F % gradB_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % R )) F % curlb_2D % R = F % curlb_2D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % PHI )) F % curlb_2D % PHI = F % curlb_2D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_2D % Z )) F % curlb_2D % Z = F % curlb_2D % Z / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % R )) F % gradB_3D % R = F % gradB_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % PHI )) F % gradB_3D % PHI = F % gradB_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % gradB_3D % Z )) F % gradB_3D % Z = F % gradB_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % R )) F % curlb_3D % R = F % curlb_3D % R / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % PHI )) F % curlb_3D % PHI = F % curlb_3D % PHI / & ( 1. / params % cpp % length ) if ( ALLOCATED ( F % curlb_3D % Z )) F % curlb_3D % Z = F % curlb_3D % Z / & ( 1. / params % cpp % length ) end if if ( F % dBfield ) then if ( ALLOCATED ( F % dBdR_2D % R )) F % dBdR_2D % R = F % dBdR_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_2D % PHI )) F % dBdR_2D % PHI = F % dBdR_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_2D % Z )) F % dBdR_2D % Z = F % dBdR_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_2D % R )) F % dBdPHI_2D % R = F % dBdPHI_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_2D % PHI )) F % dBdPHI_2D % PHI = F % dBdPHI_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_2D % Z )) F % dBdPHI_2D % Z = F % dBdPHI_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_2D % R )) F % dBdZ_2D % R = F % dBdZ_2D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_2D % PHI )) F % dBdZ_2D % PHI = F % dBdZ_2D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_2D % Z )) F % dBdZ_2D % Z = F % dBdZ_2D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_3D % R )) F % dBdR_3D % R = F % dBdR_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_3D % PHI )) F % dBdR_3D % PHI = F % dBdR_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdR_3D % Z )) F % dBdR_3D % Z = F % dBdR_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_3D % R )) F % dBdPHI_3D % R = F % dBdPHI_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_3D % PHI )) F % dBdPHI_3D % PHI = F % dBdPHI_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdPHI_3D % Z )) F % dBdPHI_3D % Z = F % dBdPHI_3D % Z / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_3D % R )) F % dBdZ_3D % R = F % dBdZ_3D % R / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_3D % PHI )) F % dBdZ_3D % PHI = F % dBdZ_3D % PHI / & ( params % cpp % Bo / params % cpp % length ) if ( ALLOCATED ( F % dBdZ_3D % Z )) F % dBdZ_3D % Z = F % dBdZ_3D % Z / & ( params % cpp % Bo / params % cpp % length ) end if F % X % R = F % X % R / params % cpp % length ! Nothing to do for the PHI component F % X % Z = F % X % Z / params % cpp % length if ( F % Dim2x1t ) then F % X % PHI = F % X % PHI / params % cpp % time end if !     end if end if end subroutine normalize_variables","tags":"","loc":"proc/normalize_variables.html"},{"title":"load_korc_params – KORC-Full Orbit","text":"private subroutine load_korc_params(params) Note Subroutine that loads the simulation parameters from the \n file specified in params\\%path_to_inputs Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Flag to indicate if the simulations restarts (restart=T) or not\n (restart=F). Restart simulation that exited before simulation_time\n reached. Flag to indicate if the simulations proceeds (proceed=T) or not\n (proceed=F). Append simulation results after previous simulation_time\n reached. Flag to begin a new simulation, reinitializing from restart file state Total simulation time in seconds. Time between snapshots in time of the simulation. Time between overwrites of restart file in time of the simulation. Time step in the simulation as a fraction of the relativistic \n electron gyro-period @f$\\tau_e = 2\\pi\\gamma m_e/eB_0@f$ Minimum allowed relativistic factor @f$\\gamma@f$ of simulated electrons. Flag to indicate if synchrotron radiation losses are included\n (radiation=T) or not (radiation=F). Flag to indicate if collisionsare included (collisions=T) or not\n (collisions=F). String with the name of the collisions model to be used in the simulation. String with the name of the model for the plasma profiles. String with the name of the model for the field profiles. String with the name of the model for the fields and plasma profiles. List of electron variables to include in the outputs. Number of different populations of simulated relativistic electrons\n in KORC. Contents Source Code load_korc_params Source Code subroutine load_korc_params ( params ) !! @note Subroutine that loads the simulation parameters from the !! file specified in params\\%path_to_inputs @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. !LOGICAL \t\t\t\t:: restart !! Flag to indicate if the simulations restarts (restart=T) or not !! (restart=F). Restart simulation that exited before simulation_time !! reached. !LOGICAL \t\t\t\t:: proceed !! Flag to indicate if the simulations proceeds (proceed=T) or not !! (proceed=F). Append simulation results after previous simulation_time !! reached. !LOGICAL  :: reinit !! Flag to begin a new simulation, reinitializing from restart file state !REAL(rp) \t\t\t\t:: simulation_time !! Total simulation time in seconds. !REAL(rp) \t\t\t\t:: snapshot_frequency !! Time between snapshots in time of the simulation. !REAL(rp) \t\t\t\t:: restart_overwrite_frequency !! Time between overwrites of restart file in time of the simulation. !REAL(rp) \t\t\t\t:: dt !! Time step in the simulation as a fraction of the relativistic !! electron gyro-period @f$\\tau_e = 2\\pi\\gamma m_e/eB_0@f$ !REAL(rp) \t\t\t\t:: minimum_particle_energy !! Minimum allowed relativistic factor @f$\\gamma@f$ of simulated electrons. !LOGICAL \t\t\t\t:: radiation !! Flag to indicate if synchrotron radiation losses are included !! (radiation=T) or not (radiation=F). !LOGICAL \t\t\t\t:: collisions !! Flag to indicate if collisionsare included (collisions=T) or not !! (collisions=F). !CHARACTER(MAX_STRING_LENGTH) \t\t:: GC_rad_model !CHARACTER(MAX_STRING_LENGTH) \t\t:: collisions_model !! String with the name of the collisions model to be used in the simulation. !CHARACTER(MAX_STRING_LENGTH) \t\t:: bound_electron_model !CHARACTER(MAX_STRING_LENGTH) \t\t:: profile_model !! String with the name of the model for the plasma profiles. !CHARACTER(MAX_STRING_LENGTH) \t\t:: field_model !! String with the name of the model for the field profiles. !CHARACTER(MAX_STRING_LENGTH) \t\t:: magnetic_field_filename !! String with the name of the model for the fields and plasma profiles. !CHARACTER(MAX_STRING_LENGTH) \t\t:: outputs_list !! List of electron variables to include in the outputs. !INTEGER \t\t\t\t:: num_species !! Number of different populations of simulated relativistic electrons !! in KORC. INTEGER :: imax !! Auxiliary variable used to parse the output_list INTEGER :: imin !! Auxiliary variable used to parse the output_list INTEGER :: ii !! Iterator used to parse the output_list INTEGER :: jj !! Iterator used to parse the output_list INTEGER :: num_outputs !! Auxiliary variable used to parse the output_list INTEGER , DIMENSION ( 2 ) :: indices !! Auxiliary variable used to parse the output_list !LOGICAL \t\t\t\t:: HDF5_error_handling !! Flag for HDF5 error handling !LOGICAL \t\t:: FO_GC_compare !CHARACTER(MAX_STRING_LENGTH) \t\t:: orbit_model !! String with the name of the orbit model ('FO' or 'GC'). !CHARACTER(MAX_STRING_LENGTH) :: field_eval !! String with the name of the field evaluation method for !! analytical fields ('interp' or 'eqn') !LOGICAL \t\t\t\t:: FokPlan !! Flag to decouple spatial-dependence of evolution !LOGICAL :: SameRandSeed !LOGICAL :: SC_E !LOGICAL :: SC_E_add !INTEGER                           :: time_slice !REAL(rp)                          :: rmax,rmin,zmax,zmin !INTEGER                           :: pchunk !NAMELIST /input_parameters/ restart,field_model,magnetic_field_filename, & !     simulation_time,snapshot_frequency,dt,num_species,radiation, & !     collisions,collisions_model,outputs_list,minimum_particle_energy, & !     HDF5_error_handling,orbit_model,field_eval,proceed,profile_model, & !     restart_overwrite_frequency,FokPlan,GC_rad_model, & !     bound_electron_model,FO_GC_compare,SameRandSeed,SC_E,reinit, & !     SC_E_add,time_slice,rmax,rmin,zmax,zmin,pchunk !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=input_parameters) !close(default_unit_open) params % restart = restart params % proceed = proceed params % reinit = reinit params % simulation_time = simulation_time params % snapshot_frequency = snapshot_frequency params % restart_overwrite_frequency = restart_overwrite_frequency params % dt = dt params % num_species = num_species params % profile_model = TRIM ( profile_model ) params % field_model = TRIM ( field_model ) params % magnetic_field_filename = TRIM ( magnetic_field_filename ) params % time_slice = time_slice params % rmax = rmax params % rmin = rmin params % zmax = zmax params % zmin = zmin params % minimum_particle_energy = minimum_particle_energy * C_E params % minimum_particle_g = 1.0_rp + params % minimum_particle_energy / & ( C_ME * C_C ** 2 ) ! Minimum value of relativistic gamma factor params % radiation = radiation params % collisions = collisions params % collisions_model = TRIM ( collisions_model ) params % bound_electron_model = TRIM ( bound_electron_model ) params % GC_rad_model = TRIM ( GC_rad_model ) if ( HDF5_error_handling ) then params % HDF5_error_handling = 1_idef else params % HDF5_error_handling = 0_idef end if params % orbit_model = orbit_model params % FO_GC_compare = FO_GC_compare params % field_eval = field_eval params % GC_coords = . FALSE . params % FokPlan = FokPlan params % SameRandSeed = SameRandSeed params % SC_E = SC_E params % SC_E_add = SC_E_add params % pchunk = pchunk ! Loading list of output parameters (parsing) imin = SCAN ( outputs_list , '{' ) imax = SCAN ( outputs_list , '}' ) ii = 1_idef jj = 1_idef num_outputs = 1_idef do while ( ii . NE . 0 ) ii = SCAN ( outputs_list ( jj :), \",\" ) if ( ii . NE . 0 ) then jj = jj + ii num_outputs = num_outputs + 1_idef end if end do ALLOCATE ( params % outputs_list ( num_outputs )) if ( num_outputs . GT . 1_idef ) then indices = 0_idef indices ( 2 ) = SCAN ( outputs_list , \",\" ) params % outputs_list ( 1 ) = TRIM ( outputs_list ( imin + 1_idef : indices ( 2 ) - 1_idef )) indices ( 1 ) = indices ( 1 ) + indices ( 2 ) + 1_idef do ii = 2_idef , num_outputs indices ( 2 ) = SCAN ( outputs_list ( indices ( 1 ):), \",\" ) if ( indices ( 2 ). EQ . 0_idef ) then params % outputs_list ( ii ) = TRIM ( outputs_list ( indices ( 1 ): imax - 1_idef )) else params % outputs_list ( ii ) = TRIM ( outputs_list ( indices ( 1 ): indices ( 1 ) + indices ( 2 ) - 2_idef )) indices ( 1 ) = indices ( 1 ) + indices ( 2 ) end if end do else params % outputs_list ( 1 ) = TRIM ( outputs_list ( imin + 1_idef : imax - 1_idef )) end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * SIMULATION PARAMETERS * * * * *\")' ) write ( output_unit_write , '(\"Restarting simulation: \",L1)' ) params % restart write ( output_unit_write , '(\"Continuing simulation: \",L1)' ) params % proceed write ( output_unit_write , '(\"Number of electron populations: \",I16)' ) params % num_species write ( output_unit_write , * ) 'Orbit model: ' , TRIM ( params % orbit_model ) write ( output_unit_write , * ) 'Magnetic field model: ' , TRIM ( params % field_model ) write ( output_unit_write , * ) 'Magnetic field evaluation: ' , TRIM ( params % field_eval ) if ( TRIM ( params % field_model ). EQ . 'EXTERNAL' ) then write ( output_unit_write , * ) 'Magnetic field file: ' , TRIM ( params % magnetic_field_filename ) end if write ( output_unit_write , '(\"Radiation losses included: \",L1)' ) params % radiation if ( params % radiation . and .( params % orbit_model ( 1 : 2 ). eq . 'GC' )) then write ( output_unit_write , * ) 'Radiation model: ' , TRIM ( params % GC_rad_model ) end if write ( output_unit_write , '(\"Collisions losses included: \",L1)' ) params % collisions if ( params % collisions ) then write ( output_unit_write , * ) 'Collision model: ' , TRIM ( params % collisions_model ) write ( output_unit_write , * ) & 'Bound electron model: ' , TRIM ( params % bound_electron_model ) end if write ( output_unit_write , '(\"Self-consistent E included: \",L1)' ) params % SC_E write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine load_korc_params","tags":"","loc":"proc/load_korc_params.html"},{"title":"initialize_korc_parameters – KORC-Full Orbit","text":"public subroutine initialize_korc_parameters(params) Note Interface for calling initialization subroutines Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code initialize_korc_parameters Source Code subroutine initialize_korc_parameters ( params ) !! @note Interface for calling initialization subroutines @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: mpierr !! MPI error status. call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call read_namelist ( params , params % path_to_inputs ,. true ., params % path_to_outputs ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call load_korc_params ( params ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) end subroutine initialize_korc_parameters","tags":"","loc":"proc/initialize_korc_parameters.html"},{"title":"define_time_step – KORC-Full Orbit","text":"public subroutine define_time_step(params) Note Subroutine that defines or loads from restart file the time\n stepping parameters. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code define_time_step Source Code subroutine define_time_step ( params ) !! @note Subroutine that defines or loads from restart file the time !! stepping parameters. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. if ( params % restart ) then call load_time_stepping_params ( params ) else if ( params % proceed ) then call load_prev_time ( params ) params % ito = 1_ip params % dt = params % dt * ( 2.0_rp * C_PI * params % cpp % time_r ) params % t_steps = CEILING (( params % simulation_time - params % init_time ) / & params % dt , ip ) params % output_cadence = FLOOR ( params % snapshot_frequency / params % dt , ip ) if ( params % output_cadence . EQ . 0_ip ) params % output_cadence = 1_ip params % num_snapshots = params % t_steps / params % output_cadence params % restart_output_cadence = FLOOR ( params % restart_overwrite_frequency / & params % dt , ip ) params % t_skip = min ( params % t_steps , params % output_cadence ) params % t_skip = max ( 1_ip , params % t_skip ) else params % ito = 1_ip params % dt = params % dt * ( 2.0_rp * C_PI * params % cpp % time_r ) params % t_steps = CEILING ( params % simulation_time / params % dt , ip ) params % output_cadence = FLOOR ( params % snapshot_frequency / params % dt , ip ) if ( params % output_cadence . EQ . 0_ip ) params % output_cadence = 1_ip params % num_snapshots = params % t_steps / params % output_cadence params % restart_output_cadence = FLOOR ( params % restart_overwrite_frequency / & params % dt , ip ) params % t_skip = min ( params % t_steps , params % output_cadence ) params % t_skip = max ( 1_ip , params % t_skip ) end if !    write(output_unit_write,*) 'dt',params%dt,'t_skip',params%t_skip if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * TIME STEPPING PARAMETERS * * * * *\")' ) write ( output_unit_write , '(\"Simulation time: \",E17.10,\" s\")' ) params % simulation_time write ( output_unit_write , '(\"Initial time: \",E17.10,\" s\")' ) params % init_time write ( output_unit_write , '(\"Output frequency: \",E17.10,\" s\")' ) params % snapshot_frequency write ( output_unit_write , '(\"Relativistic gyro-period: \",E17.10)' ) 2.0_rp * C_PI * & params % cpp % time_r write ( output_unit_write , '(\"Time step: \",E17.10)' ) params % dt write ( output_unit_write , '(\"Number of time steps: \",I16)' ) params % t_steps write ( output_unit_write , '(\"Starting simulation at time step: \",I16)' ) params % ito write ( output_unit_write , '(\"Output cadence: \",I16)' ) params % output_cadence write ( output_unit_write , '(\"Restart cadence: \",I16)' ) params % restart_output_cadence write ( output_unit_write , '(\"Number of outputs: \",I16)' ) params % num_snapshots write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine define_time_step","tags":"","loc":"proc/define_time_step.html"},{"title":"initialize_particles – KORC-Full Orbit","text":"public subroutine initialize_particles(params, F, P, spp) Note Subroutine that loads the information of the initial condition \n of the different particle species. This subroutine calls\n the subroutine that generates the initial energy and pitch angle \n distribution functions. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information \n about the fields used in the simulation. See korc_types and korc_fields . type(PROFILES), intent(inout) :: P type(SPECIES), intent(out), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the information \n of different electron species. See korc_types . Number of computational particles per MPI process \n used to simulate each electron species. Charge of each species. Mass of each species. Initial energy of each electron species in case of \n using an initial mono-energetic distribution. Initial pitch-angle of each electron species in case of \n using an initial mono-pitch-angle distribution. Minimum and maximum energy limits of a given initial\n non-mono-energetic distribution. Minimum and maximum pitch-angle limits of a given initial\n non-mono-pitch-angle distribution. Flag to decide whether a given electron is a runaway (runaway=T)\n or not (runaway=F). String describing the type of initial spatial distribution for\n each electron species. String describing the type of initial energy distribution for each\n electron species. String describing the type of initial pitch-angle distribution\n for each electron species. Radial position of the center of the electrons' initial\n spatial distribution. Azimuthal position of the electrons' initial spatial distribution, \n in case of using a disk at a certain poloidal section. Height of the center of the electrons' initial spatial distribution. Minimum minor radius of the electrons' initial spatial distribution. Maximum minor radius of the electrons' initial spatial distribution. Exponential falloff or standard deviation of a non-uniform radial\n distribution of electrons. Shear factor used to generate an initial spatial \n distribution with an elliptic poloidal cross section.\n See Carbajal and del-Castillo-Negrete, Nuclear Fusion,\n submitted (2018) . Variance of the first dimension of a 2D Gaussian, spatial\n distribution function Variance of the second dimension of a 2D Gaussian, spatial\n distribution function Angle of counter-clockwise rotation (in degrees) of 2D Gaussian\n distribution relative to R,Z Maximum value of the argument of the 2D gaussian exponential, used for an\n indicator function that limits the region of MH sampling Contents Source Code initialize_particles Source Code subroutine initialize_particles ( params , F , P , spp ) !! @note Subroutine that loads the information of the initial condition !! of the different particle species. This subroutine calls !! the subroutine that generates the initial energy and pitch angle !! distribution functions. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of KORC's derived type FIELDS containing all the information !! about the fields used in the simulation. See [[korc_types]] !!and [[korc_fields]]. TYPE ( PROFILES ), INTENT ( INOUT ) :: P TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the information !! of different electron species. See [[korc_types]]. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: ppp !! Number of computational particles per MPI process !! used to simulate each electron species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: q !! Charge of each species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: m !! Mass of each species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Eo !! Initial energy of each electron species in case of !! using an initial mono-energetic distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: etao !! Initial pitch-angle of each electron species in case of !! using an initial mono-pitch-angle distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Eo_lims !! Minimum and maximum energy limits of a given initial !! non-mono-energetic distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: etao_lims !! Minimum and maximum pitch-angle limits of a given initial !! non-mono-pitch-angle distribution. !LOGICAL, DIMENSION(:), ALLOCATABLE \t\t\t\t:: runaway !! Flag to decide whether a given electron is a runaway (runaway=T) !! or not (runaway=F). !CHARACTER(MAX_STRING_LENGTH),DIMENSION(:),ALLOCATABLE  :: spatial_distribution !! String describing the type of initial spatial distribution for !! each electron species. !CHARACTER(MAX_STRING_LENGTH), DIMENSION(:), ALLOCATABLE :: energy_distribution !! String describing the type of initial energy distribution for each !! electron species. !CHARACTER(MAX_STRING_LENGTH), DIMENSION(:), ALLOCATABLE :: pitch_distribution !! String describing the type of initial pitch-angle distribution !! for each electron species. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Ro !! Radial position of the center of the electrons' initial !! spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: PHIo !! Azimuthal position of the electrons' initial spatial distribution, !! in case of using a disk at a certain poloidal section. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: Zo !! Height of the center of the electrons' initial spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: r_inner !! Minimum minor radius of the electrons' initial spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: r_outter !! Maximum minor radius of the electrons' initial spatial distribution. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: falloff_rate !! Exponential falloff or standard deviation of a non-uniform radial !! distribution of electrons. !REAL(rp), DIMENSION(:), ALLOCATABLE \t\t\t\t:: shear_factor !! Shear factor used to generate an initial spatial !! distribution with an elliptic poloidal cross section. !! See <em>Carbajal and del-Castillo-Negrete, Nuclear Fusion, !! submitted (2018)</em>. !REAL(rp), DIMENSION(:), ALLOCATABLE                           :: sigmaR !! Variance of the first dimension of a 2D Gaussian, spatial !! distribution function !REAL(rp), DIMENSION(:), ALLOCATABLE                           :: sigmaZ !! Variance of the second dimension of a 2D Gaussian, spatial !! distribution function !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: theta_gauss !! Angle of counter-clockwise rotation (in degrees) of 2D Gaussian !! distribution relative to R,Z !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: psi_max !! Maximum value of the argument of the 2D gaussian exponential, used for an !! indicator function that limits the region of MH sampling !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: Spong_b !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: Spong_w !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: Spong_dlam !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: dth,dgam !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: dR !REAL(rp), DIMENSION(:), ALLOCATABLE                          :: dZ INTEGER :: ii !! Iterator of spp structure. INTEGER :: mpierr !! MPI error status. !REAL(rp), DIMENSION(:), ALLOCATABLE :: Xtrace !NAMELIST /plasma_species/ ppp,q,m,Eo,etao,Eo_lims,etao_lims,runaway, & !     spatial_distribution,energy_distribution,pitch_distribution,Ro, & !     PHIo,Zo,r_inner,r_outter,falloff_rate,shear_factor,sigmaR,sigmaZ, & !     theta_gauss,psi_max,Xtrace,Spong_b,Spong_w,Spong_dlam,dth,dR,dZ,dgam ! Allocate array containing variables of particles for each species ALLOCATE ( spp ( params % num_species )) !ALLOCATE(ppp(params%num_species)) !ALLOCATE(q(params%num_species)) !ALLOCATE(m(params%num_species)) !ALLOCATE(Eo(params%num_species)) !ALLOCATE(etao(params%num_species)) !ALLOCATE(Eo_lims(2_idef*params%num_species)) !ALLOCATE(etao_lims(2_idef*params%num_species)) !ALLOCATE(runaway(params%num_species)) !ALLOCATE(spatial_distribution(params%num_species)) !ALLOCATE(energy_distribution(params%num_species)) !ALLOCATE(pitch_distribution(params%num_species)) !ALLOCATE(Ro(params%num_species)) !ALLOCATE(PHIo(params%num_species)) !ALLOCATE(Zo(params%num_species)) !ALLOCATE(r_inner(params%num_species)) !ALLOCATE(r_outter(params%num_species)) !ALLOCATE(falloff_rate(params%num_species)) !ALLOCATE(shear_factor(params%num_species)) !ALLOCATE(sigmaR(params%num_species)) !ALLOCATE(sigmaZ(params%num_species)) !ALLOCATE(theta_gauss(params%num_species)) !ALLOCATE(psi_max(params%num_species)) !ALLOCATE(Spong_b(params%num_species)) !ALLOCATE(Spong_w(params%num_species)) !ALLOCATE(Spong_dlam(params%num_species)) !ALLOCATE(dth(params%num_species)) !ALLOCATE(dgam(params%num_species)) !ALLOCATE(dR(params%num_species)) !ALLOCATE(dZ(params%num_species)) !ALLOCATE(Xtrace(3_idef*params%num_species)) !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=plasma_species) !close(default_unit_open) do ii = 1_idef , params % num_species spp ( ii )% runaway = runaway ( ii ) spp ( ii )% spatial_distribution = TRIM ( spatial_distribution ( ii )) spp ( ii )% energy_distribution = TRIM ( energy_distribution ( ii )) spp ( ii )% pitch_distribution = TRIM ( pitch_distribution ( ii )) spp ( ii )% q = q ( ii ) * C_E spp ( ii )% m = m ( ii ) * C_ME spp ( ii )% ppp = ppp ( ii ) spp ( ii )% Ro = Ro ( ii ) spp ( ii )% PHIo = C_PI * PHIo ( ii ) / 18 0.0_rp spp ( ii )% Zo = Zo ( ii ) spp ( ii )% r_inner = r_inner ( ii ) spp ( ii )% r_outter = r_outter ( ii ) spp ( ii )% falloff_rate = falloff_rate ( ii ) spp ( ii )% shear_factor = shear_factor ( ii ) spp ( ii )% sigmaR = sigmaR ( ii ) spp ( ii )% sigmaZ = sigmaZ ( ii ) spp ( ii )% theta_gauss = theta_gauss ( ii ) spp ( ii )% psi_max = psi_max ( ii ) spp ( ii )% Spong_w = Spong_w ( ii ) spp ( ii )% Spong_b = Spong_b ( ii ) spp ( ii )% Spong_dlam = Spong_dlam ( ii ) spp ( ii )% dth = dth ( ii ) spp ( ii )% dgam = dgam ( ii ) spp ( ii )% dR = dR ( ii ) spp ( ii )% dZ = dZ ( ii ) ! * * These values can change in initial_energy_pitch_dist * * ! spp ( ii )% Eo = Eno ( ii ) * C_E spp ( ii )% Eo_lims = Eo_lims (( ii - 1_idef ) * 2_idef + 1_idef : 2_idef * ii ) * C_E spp ( ii )% etao = etao ( ii ) spp ( ii )% etao_lims = etao_lims (( ii - 1_idef ) * 2_idef + 1_idef : 2_idef * ii ) ! * * These values can change in initial_energy_pitch_dist * * ! if ( spp ( ii )% spatial_distribution . eq . 'TRACER' ) & spp ( ii )% Xtrace = Xtrace (( ii - 1_idef ) * 3_idef + 1_idef : 3_idef * ii ) ALLOCATE ( spp ( ii )% vars % X ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % V ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % Rgc ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % Y ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % E ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % B ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % PSI_P ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % ne ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Te ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Zeff ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % g ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % eta ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % mu ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Prad ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % Pin ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % flagCon ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % flagCol ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % wt ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % hint ( spp ( ii )% ppp )) !     write(output_unit_write,'(\"0 size of PSI_P: \",I16)') size(spp(ii)%vars%PSI_P) spp ( ii )% vars % X = 0.0_rp spp ( ii )% vars % V = 0.0_rp spp ( ii )% vars % Rgc = 0.0_rp spp ( ii )% vars % Y = 0.0_rp spp ( ii )% vars % E = 0.0_rp spp ( ii )% vars % B = 0.0_rp spp ( ii )% vars % PSI_P = 0.0_rp spp ( ii )% vars % ne = 0.0_rp spp ( ii )% vars % Te = 0.0_rp spp ( ii )% vars % Zeff = 0.0_rp spp ( ii )% vars % g = 0.0_rp spp ( ii )% vars % eta = 0.0_rp spp ( ii )% vars % mu = 0.0_rp spp ( ii )% vars % Prad = 0.0_rp spp ( ii )% vars % Pin = 0.0_rp spp ( ii )% vars % flagCon = 1_is spp ( ii )% vars % flagCol = 1_is spp ( ii )% vars % wt = 0.0_rp if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then ALLOCATE ( spp ( ii )% vars % Y0 ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % V0 ( spp ( ii )% ppp ) ) ALLOCATE ( spp ( ii )% vars % k1 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k2 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k3 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k4 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k5 ( spp ( ii )% ppp , 4 ) ) ALLOCATE ( spp ( ii )% vars % k6 ( spp ( ii )% ppp , 4 ) ) if ( params % orbit_model ( 3 : 5 ) == 'pre' . or . params % field_model == 'M3D_C1' ) then ALLOCATE ( spp ( ii )% vars % gradB ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % curlb ( spp ( ii )% ppp , 3 ) ) spp ( ii )% vars % gradB = 0.0_rp spp ( ii )% vars % curlb = 0.0_rp else if ( params % orbit_model ( 3 : 6 ) == 'grad' ) then ALLOCATE ( spp ( ii )% vars % BR ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % BPHI ( spp ( ii )% ppp , 3 ) ) ALLOCATE ( spp ( ii )% vars % BZ ( spp ( ii )% ppp , 3 ) ) spp ( ii )% vars % BR = 0.0_rp spp ( ii )% vars % BPHI = 0.0_rp spp ( ii )% vars % BZ = 0.0_rp end if ALLOCATE ( spp ( ii )% vars % RHS ( spp ( ii )% ppp , 5 ) ) spp ( ii )% vars % Y0 = 0.0_rp spp ( ii )% vars % V0 = 0.0_rp spp ( ii )% vars % k1 = 0.0_rp spp ( ii )% vars % k2 = 0.0_rp spp ( ii )% vars % k3 = 0.0_rp spp ( ii )% vars % k4 = 0.0_rp spp ( ii )% vars % k5 = 0.0_rp spp ( ii )% vars % k6 = 0.0_rp spp ( ii )% vars % RHS = 0.0_rp end if end do P % R0_RE = spp ( 1 )% Ro P % Z0_RE = spp ( 1 )% Zo P % n_REr0 = max ( sqrt ( spp ( 1 )% psi_max * 2 * spp ( 1 )% sigmaR ** 2 ), & sqrt ( spp ( 1 )% psi_max * 2 * spp ( 1 )% sigmaZ ** 2 )) call initial_energy_pitch_dist ( params , spp ) DEALLOCATE ( ppp ) DEALLOCATE ( q ) DEALLOCATE ( m ) DEALLOCATE ( Eno ) DEALLOCATE ( etao ) DEALLOCATE ( Eo_lims ) DEALLOCATE ( etao_lims ) DEALLOCATE ( runaway ) DEALLOCATE ( spatial_distribution ) DEALLOCATE ( energy_distribution ) DEALLOCATE ( pitch_distribution ) DEALLOCATE ( Ro ) DEALLOCATE ( PHIo ) DEALLOCATE ( Zo ) DEALLOCATE ( r_inner ) DEALLOCATE ( r_outter ) DEALLOCATE ( falloff_rate ) DEALLOCATE ( shear_factor ) DEALLOCATE ( sigmaR ) DEALLOCATE ( sigmaZ ) DEALLOCATE ( theta_gauss ) DEALLOCATE ( psi_max ) DEALLOCATE ( Spong_b ) DEALLOCATE ( Spong_w ) DEALLOCATE ( Spong_dlam ) DEALLOCATE ( dth ) DEALLOCATE ( dgam ) DEALLOCATE ( dR ) DEALLOCATE ( dZ ) DEALLOCATE ( Xtrace ) end subroutine initialize_particles","tags":"","loc":"proc/initialize_particles.html"},{"title":"set_up_particles_ic – KORC-Full Orbit","text":"public subroutine set_up_particles_ic(params, F, spp, P) Note Subroutine with calls to subroutines to load particles' \n information if it is a restarting simulation, or to initialize the\n spatial and velocity distribution of each species if it is a new simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of KORC's derived type FIELDS containing all \n the information about the fields used in the simulation. \n See korc_types and korc_fields . type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all \n the information of different electron species. See korc_types . type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. Contents Source Code set_up_particles_ic Source Code subroutine set_up_particles_ic ( params , F , spp , P ) !! @note Subroutine with calls to subroutines to load particles' !! information if it is a restarting simulation, or to initialize the !! spatial and velocity distribution of each species if it is a new !! simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of KORC's derived type FIELDS containing all !! the information about the fields used in the simulation. !! See [[korc_types]] and [[korc_fields]]. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all !! the information of different electron species. See [[korc_types]]. TYPE ( PROFILES ), INTENT ( IN ) :: P !! An instance of the KORC derived type PROFILES. INTEGER :: ii !! Species iterator. if ( params % restart . OR . params % proceed . or . params % reinit ) then call load_particles_ic ( params , spp , F ) call init_random_seed () else if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING SPATIAL DISTRIBUTION * * * *\")' ) end if call intitial_spatial_distribution ( params , spp , P , F ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING VELOCITY COMPONENTS * * * *\")' ) end if call initial_gyro_distribution ( params , F , spp ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end if end subroutine set_up_particles_ic","tags":"","loc":"proc/set_up_particles_ic.html"},{"title":"korc_abort – KORC-Full Orbit","text":"public subroutine korc_abort() Note Subroutine that terminates the simulation. Arguments None Contents Source Code korc_abort Source Code subroutine korc_abort () !! @note Subroutine that terminates the simulation. @endnote INTEGER :: mpierr !! MPI error status call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call MPI_ABORT ( MPI_COMM_WORLD , - 2000 , mpierr ) end subroutine korc_abort","tags":"","loc":"proc/korc_abort.html"},{"title":"set_paths – KORC-Full Orbit","text":"public subroutine set_paths(params) Note Subroutine that sets the input/output paths. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code set_paths Source Code subroutine set_paths ( params ) !! @note Subroutine that sets the input/output paths.@endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: argn , read_stat , exei !! Number of command line inputs. The default value is !! two: the input files path and the outputs path. CHARACTER ( MAX_STRING_LENGTH ) :: ctmp argn = command_argument_count () if ( argn . EQ . 2_idef ) then call get_command_argument ( 1 , params % path_to_inputs ) call get_command_argument ( 2 , params % path_to_outputs ) else call korc_abort () end if !write(6,*) TRIM(params%path_to_outputs) !write(6,*) TRIM(params%path_to_inputs) if ( params % mpi_params % rank . EQ . 0 ) then OPEN ( UNIT = output_unit_write , & FILE = TRIM ( params % path_to_outputs ) // \"output.korc\" , & STATUS = 'UNKNOWN' , FORM = 'FORMATTED' , POSITION = 'REWIND' ) write ( output_unit_write , '(/,\"* * * * * PATHS * * * * *\")' ) write ( output_unit_write , * ) 'The input file is: ' ,& TRIM ( params % path_to_inputs ) write ( output_unit_write , '(/)' ) write ( output_unit_write , * ) 'The output folder is: ' ,& TRIM ( params % path_to_outputs ) write ( output_unit_write , '(\"* * * * * * * * * * * * *\",/)' ) write ( output_unit_write , '(/,\"* * * * * * * GIT INFO * * * * * * *\")' ) #ifdef MAC call execute_command_line ( \"/Users/21b/Desktop/KORC/src/get_git_details.sh\" , & exitstat = exei ) #elif CORI call execute_command_line ( \"/global/u1/m/mbeidler/KORC/src/get_git_details.sh\" , & exitstat = exei ) #endif IF ( exei /= 0 ) then write ( 6 , * ) 'Error executing get_git_details.sh' call korc_abort end if OPEN ( UNIT = default_unit_open , FILE = 'git_hash.txt' , & STATUS = 'OLD' , POSITION = 'REWIND' ) READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = read_stat ) ctmp IF ( read_stat /= 0 ) then write ( 6 , * ) 'Error reading git_hash.txt' call korc_abort end if write ( output_unit_write , * ) 'Git hash of most recent commit is: ' , & TRIM ( ctmp ) write ( output_unit_write , '(/)' ) CLOSE ( default_unit_open ) OPEN ( UNIT = default_unit_open , FILE = 'git_diff.txt' , & STATUS = 'OLD' , POSITION = 'REWIND' ) write ( output_unit_write , * ) 'Git diff of HEAD and most recent commit is:' DO READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = read_stat ) ctmp IF ( read_stat . gt . 0 ) then write ( 6 , * ) 'Error reading git_diff.txt' call korc_abort else if ( read_stat . lt . 0 ) then CLOSE ( default_unit_open ) write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * *\",/)' ) RETURN end if write ( output_unit_write , * ) TRIM ( ctmp ) END DO end if end subroutine set_paths","tags":"","loc":"proc/set_paths.html"},{"title":"initialize_mpi – KORC-Full Orbit","text":"public subroutine initialize_mpi(params) Note Subroutine that initialize MPI communications. Through this subroutine the default MPI communicator MPI_COMM_WORLD \n is initialized. Also, a Cartesian Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Contents Source Code initialize_mpi Source Code subroutine initialize_mpi ( params ) !! @note Subroutine that initialize MPI communications.@endnote !! Through this subroutine the default MPI communicator MPI_COMM_WORLD !! is initialized. Also, a Cartesian TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. INTEGER :: mpierr !! MPI error status. INTEGER , PARAMETER :: NDIMS = 1 !! Number of dimensions of non-standard topology. !! NDIMS=1 for a 1-D MPI topology, NDIMS=2 for a 2-D MPI topology, !! and NDIMS=3 for a 3-D MPI topology. INTEGER , DIMENSION (:), ALLOCATABLE :: DIMS !! Dimension of the non-standard MPI topology params::mpi_params::mpi_topo. !! This is equal to the number of MPI processes in KORC. LOGICAL :: all_mpis_initialized = . FALSE . !! Flag to determine if all the MPI processes were initialized correctly. LOGICAL :: mpi_process_initialized = . FALSE . !! Flag to determine if a given MPI process was initialized correctly. LOGICAL , PARAMETER :: REORDER = . FALSE . !! Flag to determine if the new MPI topology params::mpi_params::mpi_topo !! needs to be re-ordered. LOGICAL , DIMENSION (:), ALLOCATABLE :: PERIODS !< Something here !! Array of logicals determining what dimensions of the new MPI !! topology params::mpi_params::mpi_topo are periodic (T) or not (F). INTEGER :: ii !! Variable to iterate over different MPI processes. call MPI_INIT ( mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Initializing MPI. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if call MPI_INITIALIZED ( mpi_process_initialized , mpierr ) call MPI_REDUCE ( mpi_process_initialized , all_mpis_initialized , 1 , & MPI_LOGICAL , MPI_LAND , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BCAST ( all_mpis_initialized , 1 , & MPI_LOGICAL , 0 , MPI_COMM_WORLD , mpierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , params % mpi_params % nmpi , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Obtaining size of communicator. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if ! * * * Getting the rank of the MPI process in the WORLD COMMON communicator * * * ! call MPI_COMM_RANK ( MPI_COMM_WORLD , params % mpi_params % rank , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Obtaining MPI rank. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if ! * * * Here a Cartesian topology for MPI is created * * * ! ALLOCATE ( DIMS ( NDIMS )) ALLOCATE ( PERIODS ( NDIMS )) ! This loop isn't necessary but helps to do things more general in the future do ii = 1_idef , NDIMS DIMS ( ii ) = params % mpi_params % nmpi PERIODS ( ii ) = . TRUE . end do ! * * * Here a periodic topology for MPI is created * * * ! call MPI_CART_CREATE ( MPI_COMM_WORLD , NDIMS , DIMS , PERIODS , REORDER , & params % mpi_params % mpi_topo , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Creating new MPI topology. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if ! * * * Getting the rank of the MPI process in the new topology * * * ! call MPI_COMM_RANK ( params % mpi_params % mpi_topo , params % mpi_params % rank_topo , mpierr ) if ( mpierr . NE . MPI_SUCCESS ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: Obtaining new MPI topology ranks. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if DEALLOCATE ( DIMS ) DEALLOCATE ( PERIODS ) if ( all_mpis_initialized ) then call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call set_paths ( params ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * COMMUNICATIONS  * * * * *\")' ) write ( output_unit_write , '(/,\"  MPI communications initialized!  \")' ) write ( output_unit_write , '(/,\"  Number of MPI processes: \",I5)' ) params % mpi_params % nmpi write ( output_unit_write , '(/,\"* * * * * * * * * * * * * * * * * *\")' ) end if else if ( params % mpi_params % rank . EQ . 0 ) then write ( 6 , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( 6 , '(/,\" ERROR: MPI not initialized. Aborting... \")' ) write ( 6 , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) call MPI_ABORT ( MPI_COMM_WORLD , - 10 , mpierr ) end if end if !... end subroutine initialize_mpi","tags":"","loc":"proc/initialize_mpi.html"},{"title":"timing_KORC – KORC-Full Orbit","text":"public subroutine timing_KORC(params) Note Subroutine for timing the execution of any parallel\n section of KORC. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. Contents Source Code timing_KORC Source Code subroutine timing_KORC ( params ) !! @note Subroutine for timing the execution of any parallel !! section of KORC. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ) :: individual_runtime !! Execution time of each MPI process. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: runtime !! Execution time of KORC defined as the average of the !! execution times of all MPI processes. INTEGER :: mpierr !! MPI error status. if ( timed_already ) then t2 = MPI_WTIME () ALLOCATE ( runtime ( params % mpi_params % nmpi )) individual_runtime = t2 - t1 call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call MPI_GATHER ( individual_runtime , 1 , MPI_DOUBLE_PRECISION , runtime , & 1 , MPI_DOUBLE_PRECISION , 0_idef , MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , '(\"Timing: \",F30.16,\" s\")' ) & SUM ( runtime ) / REAL ( params % mpi_params % nmpi , rp ) end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) DEALLOCATE ( runtime ) timed_already = . FALSE . end if t1 = MPI_WTIME () timed_already = . TRUE . end subroutine timing_KORC","tags":"","loc":"proc/timing_korc.html"},{"title":"finalize_mpi – KORC-Full Orbit","text":"public subroutine finalize_mpi(params) @brief Subroutine for finalizing MPI communications.\n @details This subroutine finalizes all the MPI communications and looks for errors durignt this procces. @param[in] params Core KORC simulation parameters.\n @param mpi_process_finalized Flag indicating whether an individual MPI process was finalized correctly.\n @param mpierr MPI error status. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code finalize_mpi Source Code subroutine finalize_mpi ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params LOGICAL :: mpi_process_finalized = . FALSE . INTEGER :: mpierr call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) call MPI_FINALIZE ( mpierr ) call MPI_FINALIZED ( mpi_process_finalized , mpierr ) if (. NOT . mpi_process_finalized ) then write ( output_unit_write , '(/,\"* * * * * * * COMMUNICATIONS * * * * * * *\")' ) write ( output_unit_write , '(/,\" ERROR: MPI not finalized well. MPI process: \",I5)' ) params % mpi_params % rank write ( output_unit_write , '(/,\"* * * * * * * * * ** * * * * * * * * * * *\")' ) end if end subroutine finalize_mpi","tags":"","loc":"proc/finalize_mpi.html"},{"title":"initialize_communications – KORC-Full Orbit","text":"public subroutine initialize_communications(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Contents Source Code initialize_communications Source Code subroutine initialize_communications ( params ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: string call initialize_mpi ( params ) !$OMP PARALLEL SHARED(params) params % num_omp_threads = OMP_GET_NUM_THREADS () !$OMP END PARALLEL if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * * * OMP SET-UP * * * * * * *\")' ) !$OMP PARALLEL !$OMP MASTER write ( output_unit_write , '(/,\"OMP threads per MPI process: \",I3)' ) OMP_GET_NUM_THREADS () write ( output_unit_write , '(/,\"Cores available per MPI process: \",I3)' ) OMP_GET_NUM_PROCS () !$OMP END MASTER !$OMP END PARALLEL #ifdef GNU call GET_ENVIRONMENT_VARIABLE ( \"OMP_PLACES\" , string ) write ( output_unit_write , '(/,\"OMP places: \",A30)' ) TRIM ( string ) call GET_ENVIRONMENT_VARIABLE ( \"GOMP_CPU_AFFINITY\" , string ) write ( output_unit_write , '(/,\"OMP CPU affinity: \",A30)' ) TRIM ( string ) #endif write ( output_unit_write , '(\"* * * * * * * * * * * *  * * * * * * *\",/)' ) end if end subroutine initialize_communications","tags":"","loc":"proc/initialize_communications.html"},{"title":"finalize_communications – KORC-Full Orbit","text":"public subroutine finalize_communications(params) Note Interface to function that finalizes MPI communications.\n See korc_hpc . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. Contents Source Code finalize_communications Source Code subroutine finalize_communications ( params ) !! @note Interface to function that finalizes MPI communications. !! See [[korc_hpc]]. TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. call finalize_mpi ( params ) end subroutine finalize_communications","tags":"","loc":"proc/finalize_communications.html"},{"title":"deallocate_variables – KORC-Full Orbit","text":"public subroutine deallocate_variables(params, F, spp) Note Subroutine to free allocatable simulation variables. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of KORC's derived type FIELDS containing all the\n information about the fields used in the simulation. See korc_types and korc_fields . type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the\n information of different electron species. See korc_types . Contents Source Code deallocate_variables Source Code subroutine deallocate_variables ( params , F , spp ) !! @note Subroutine to free allocatable simulation variables. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of KORC's derived type FIELDS containing all the !! information about the fields used in the simulation. See !! [[korc_types]] and [[korc_fields]]. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: spp !! An instance of KORC's derived type SPECIES containing all the !! information of different electron species. See [[korc_types]]. INTEGER :: ii !! Iterator of the spp array DEALLOCATE ( params % outputs_list ) do ii = 1_idef , params % num_species DEALLOCATE ( spp ( ii )% vars % X ) DEALLOCATE ( spp ( ii )% vars % V ) DEALLOCATE ( spp ( ii )% vars % Rgc ) DEALLOCATE ( spp ( ii )% vars % Y ) DEALLOCATE ( spp ( ii )% vars % E ) DEALLOCATE ( spp ( ii )% vars % B ) DEALLOCATE ( spp ( ii )% vars % PSI_P ) DEALLOCATE ( spp ( ii )% vars % ne ) DEALLOCATE ( spp ( ii )% vars % Te ) DEALLOCATE ( spp ( ii )% vars % Zeff ) DEALLOCATE ( spp ( ii )% vars % g ) DEALLOCATE ( spp ( ii )% vars % eta ) DEALLOCATE ( spp ( ii )% vars % mu ) DEALLOCATE ( spp ( ii )% vars % Prad ) DEALLOCATE ( spp ( ii )% vars % flagCon ) DEALLOCATE ( spp ( ii )% vars % flagCol ) DEALLOCATE ( spp ( ii )% vars % wt ) if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then DEALLOCATE ( spp ( ii )% vars % Y0 ) DEALLOCATE ( spp ( ii )% vars % V0 ) DEALLOCATE ( spp ( ii )% vars % k1 ) DEALLOCATE ( spp ( ii )% vars % k2 ) DEALLOCATE ( spp ( ii )% vars % k3 ) DEALLOCATE ( spp ( ii )% vars % k4 ) DEALLOCATE ( spp ( ii )% vars % RHS ) end if end do DEALLOCATE ( spp ) call DEALLOCATE_FIELDS_ARRAYS ( F ) end subroutine deallocate_variables","tags":"","loc":"proc/deallocate_variables.html"},{"title":"read_namelist – KORC-Full Orbit","text":"public subroutine read_namelist(params, infile, echo_in, outdir) open input file. Remove comments from input file and put into temporary file. ----------------------------------------------------------------------- check namelist file for namelist order and number. ----------------------------------------------------------------------- trim all but the namelist name. ----------------------------------------------------------------------- select and read namelist. ----------------------------------------------------------------------- close input file. Delete it since it is the temporary file ----------------------------------------------------------------------- echo the input parameters to the output file. some tests Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params character(len=*), intent(in) :: infile logical, intent(in) :: echo_in character(len=*), intent(in) :: outdir Contents Source Code read_namelist Source Code subroutine read_namelist ( params , infile , echo_in , outdir ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( * ), INTENT ( IN ) :: infile , outdir LOGICAL , INTENT ( IN ) :: echo_in INTEGER :: read_stat , nc INTEGER :: number_of_namelists = 0 , il , inst INTEGER , DIMENSION ( 20 ) :: namel_order = 0 CHARACTER ( 20 ) :: tempfile CHARACTER ( 128 ) :: ctmp CHARACTER ( 128 ) :: outfile LOGICAL :: reading INTEGER :: mpierr INTEGER :: tmp !! Namelist declarations NAMELIST / input_parameters / restart , field_model , magnetic_field_filename , & simulation_time , snapshot_frequency , dt , num_species , radiation , & collisions , collisions_model , outputs_list , minimum_particle_energy , & HDF5_error_handling , orbit_model , field_eval , proceed , profile_model , & restart_overwrite_frequency , FokPlan , GC_rad_model , bound_electron_model ,& FO_GC_compare , SameRandSeed , SC_E , reinit , SC_E_add , time_slice , rmax , & rmin , zmax , zmin , pchunk NAMELIST / plasma_species / ppp , q , m , Eno , etao , Eo_lims , etao_lims , runaway , & spatial_distribution , energy_distribution , pitch_distribution , Ro , & PHIo , Zo , r_inner , r_outter , falloff_rate , shear_factor , sigmaR , sigmaZ , & theta_gauss , psi_max , Xtrace , Spong_b , Spong_w , Spong_dlam , dth , dR , dZ , dgam NAMELIST / analytical_fields_params / Bo , minor_radius , major_radius ,& qa , qo , Eo , current_direction , nR , nZ , nPHI , dim_1D , dt_E_SC , Ip_exp , & E_dyn , E_pulse , E_width NAMELIST / externalPlasmaModel / Efield , Bfield , Bflux , Bflux3D , dBfield , & axisymmetric_fields , Eo , E_dyn , E_pulse , E_width , res_double , & dim_1D , dt_E_SC , Ip_exp , PSIp_lim , Dim2x1t , t0_2x1t , E_2x1t , ReInterp_2x1t , & ind0_2x1t , PSIp_0 NAMELIST / plasmaProfiles / radius_profile , ne_profile , neo , n_ne , a_ne , & Te_profile , Teo , n_Te , a_Te , n_REr0 , n_tauion , n_lamfront , n_lamback , & Zeff_profile , Zeffo , n_Zeff , a_Zeff , filename , axisymmetric , & n_lamshelf , n_shelfdelay , n_tauin , n_tauout , n_shelf , psiN_0 NAMELIST / CollisionParamsSingleSpecies / Te_sing , Ti_sing , ne_sing , & Zeff_sing , dTau_sing NAMELIST / CollisionParamsMultipleSpecies / num_impurity_species , Te_mult , & ne_mult , Zo_mult , Zj_mult , nz_mult , IZj_mult NAMELIST / AvalancheGenerationPDF / max_pitch_angle_aval , & min_pitch_angle_aval , max_energy_aval , min_energy_aval , ne_aval , & Zeff_aval , Epar_aval , Te_aval , dth_aval , dp_aval , dR_aval , dZ_aval NAMELIST / ExperimentalPDF / max_pitch_angle_expt , min_pitch_angle_expt , & max_energy_expt , min_energy_expt , Zeff_expt , E_expt , k_expt , t_expt , & Bo_expt , lambda_expt , A_fact_expt NAMELIST / HollmannPDF / E_Hollmann , Zeff_Hollmann , max_pitch_angle_Hollmann , & min_pitch_angle_Hollmann , max_energy_Hollmann , & min_energy_Hollmann , filename_Hollmann , Bo_Hollmann , lambda_Hollmann , & current_direction_Hollmann , A_fact_Hollmann , sigma_E_Hollmann , & sigma_Z_Hollmann , Eo_Hollmann NAMELIST / SimpleEquilibriumPDF / max_pitch_angle_simple , & min_pitch_angle_simple , Zeff_simple , E_simple , & Bo_simple , lambda_simple NAMELIST / EnergyGammaPDF / max_energy_gamma , min_energy_gamma , k_gamma , t_gamma !!----------------------------------------------------------------------- !!     open input file. !!     Remove comments from input file and put into temporary file. !!----------------------------------------------------------------------- tempfile = 'tempinput.korc' if ( params % mpi_params % rank . eq . 0 ) then CALL rmcoment ( infile , tempfile ) end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) OPEN ( UNIT = default_unit_open , FILE = tempfile , STATUS = 'OLD' , POSITION = 'REWIND' ) !!----------------------------------------------------------------------- !!    check namelist file for namelist order and number. !!----------------------------------------------------------------------- DO READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = read_stat ) ctmp IF ( read_stat /= 0 ) EXIT nc = LEN_TRIM ( ctmp ) IF ( nc < 1 ) CYCLE ctmp = ADJUSTL ( ctmp ) reading = . false . IF ( ctmp ( 1 : 1 ) == '&' ) THEN number_of_namelists = number_of_namelists + 1 !!----------------------------------------------------------------------- !!         trim all but the namelist name. !!----------------------------------------------------------------------- DO il = 2 , nc + 1 IF ( ctmp ( il : il ) /= ' ' ) THEN IF (. NOT . reading ) inst = il reading = . true . CYCLE ENDIF IF ( ctmp ( il : il ) == ' ' . AND . reading ) THEN ctmp = ctmp ( inst : il - 1 ) EXIT ENDIF ENDDO BACKSPACE ( default_unit_open ) !!----------------------------------------------------------------------- !!         select and read namelist. !!----------------------------------------------------------------------- SELECT CASE ( TRIM ( ctmp )) CASE ( 'input_parameters' ) !write(6,*) 'reading input_parameters namelist' READ ( UNIT = default_unit_open , NML = input_parameters , IOSTAT = read_stat ) CASE ( 'plasma_species' ) !write(6,*) 'reading plasma_species namelist' ALLOCATE ( runaway ( num_species )) ALLOCATE ( ppp ( num_species )) ALLOCATE ( q ( num_species )) ALLOCATE ( m ( num_species )) ALLOCATE ( spatial_distribution ( num_species )) ALLOCATE ( Ro ( num_species )) ALLOCATE ( PHIo ( num_species )) ALLOCATE ( Zo ( num_species )) ALLOCATE ( r_inner ( num_species )) ALLOCATE ( r_outter ( num_species )) ALLOCATE ( shear_factor ( num_species )) ALLOCATE ( sigmaR ( num_species )) ALLOCATE ( sigmaZ ( num_species )) ALLOCATE ( theta_gauss ( num_species )) ALLOCATE ( psi_max ( num_species )) ALLOCATE ( falloff_rate ( num_species )) ALLOCATE ( energy_distribution ( num_species )) ALLOCATE ( pitch_distribution ( num_species )) ALLOCATE ( Eno ( num_species )) ALLOCATE ( etao ( num_species )) ALLOCATE ( Eo_lims ( 2_idef * num_species )) ALLOCATE ( etao_lims ( 2_idef * num_species )) ALLOCATE ( Xtrace ( 3_idef * num_species )) ALLOCATE ( Spong_b ( num_species )) ALLOCATE ( Spong_w ( num_species )) ALLOCATE ( Spong_dlam ( num_species )) ALLOCATE ( dth ( num_species )) ALLOCATE ( dgam ( num_species )) ALLOCATE ( dR ( num_species )) ALLOCATE ( dZ ( num_species )) if ( num_species . eq . 1 ) then runaway = . FALSE . ppp = 1E0 q = - 1.0 m = 1.0 spatial_distribution = 'TRACER' Ro = 1.1 PHIo = 0.0 Zo = - 0.05 r_inner = 0.0 r_outter = 0.6 shear_factor = 0.35 sigmaR = 1.e6 sigmaZ = 0.2 theta_gauss = 0.0 psi_max = . 8446 falloff_rate = 0.0 energy_distribution = 'MONOENERGETIC' pitch_distribution = 'MONOPITCH' Eno = 1 0.0E6 etao = 1.0 Eo_lims = ( / 1.0E6 , 5 0.0E6 / ) etao_lims = ( / 0.0 , 2 0.0 / ) Xtrace = ( / 1.1 , 0.0 , 0.0 / ) Spong_b = 0.2 Spong_w = 0.1 Spong_dlam = 0.1 dth = 3. dgam = 3. dR = 0.1 dZ = 0.1 else if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Need to supply all inputs for num_species .gt. 1\")' ) end if end if READ ( UNIT = default_unit_open , NML = plasma_species , IOSTAT = read_stat ) CASE ( 'analytical_fields_params' ) READ ( UNIT = default_unit_open , NML = analytical_fields_params , IOSTAT = read_stat ) CASE ( 'externalPlasmaModel' ) READ ( UNIT = default_unit_open , NML = externalPlasmaModel , IOSTAT = read_stat ) CASE ( 'plasmaProfiles' ) READ ( UNIT = default_unit_open , NML = plasmaProfiles , IOSTAT = read_stat ) CASE ( 'CollisionParamsSingleSpecies' ) READ ( UNIT = default_unit_open , NML = CollisionParamsSingleSpecies , IOSTAT = read_stat ) CASE ( 'CollisionParamsMultipleSpecies' ) READ ( UNIT = default_unit_open , NML = CollisionParamsMultipleSpecies , IOSTAT = read_stat ) CASE ( 'AvalancheGenerationPDF' ) READ ( UNIT = default_unit_open , NML = AvalancheGenerationPDF , IOSTAT = read_stat ) CASE ( 'ExperimentalPDF' ) READ ( UNIT = default_unit_open , NML = ExperimentalPDF , IOSTAT = read_stat ) CASE ( 'HollmannPDF' ) READ ( UNIT = default_unit_open , NML = HollmannPDF , IOSTAT = read_stat ) CASE ( 'EnergyGammaPDF' ) READ ( UNIT = default_unit_open , NML = EnergyGammaPDF , IOSTAT = read_stat ) CASE ( 'SimpleEquilibriumPDF' ) READ ( UNIT = default_unit_open , NML = SimpleEquilibriumPDF , IOSTAT = read_stat ) CASE DEFAULT write ( output_unit_write , * ) ( TRIM ( ctmp ) // ' is an unrecognized namelist.' ) call korc_abort END SELECT IF ( read_stat /= 0 ) then write ( output_unit_write , * ) ( 'Error reading namelist ' // TRIM ( ctmp ) // '.' ) call korc_abort end if ENDIF ENDDO !!----------------------------------------------------------------------- !!     close input file. !!       Delete it since it is the temporary file !!----------------------------------------------------------------------- if ( params % mpi_params % rank . ne . 0 ) then CLOSE ( default_unit_open ) end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . eq . 0 ) then CLOSE ( default_unit_open , STATUS = 'DELETE' ) end if !!----------------------------------------------------------------------- !!     echo the input parameters to the output file. !!----------------------------------------------------------------------- IF ( echo_in ) THEN if ( params % mpi_params % rank . EQ . 0 ) then WRITE ( output_unit_write , '(a,/)' ) 'VALUE OF ALL INPUTS:' WRITE ( UNIT = output_unit_write , NML = input_parameters ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = plasma_species ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = analytical_fields_params ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = externalPlasmaModel ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = plasmaProfiles ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = CollisionParamsSingleSpecies ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = CollisionParamsMultipleSpecies ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = AvalancheGenerationPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = ExperimentalPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = HollmannPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = EnergyGammaPDF ) WRITE ( output_unit_write , '(/)' ) WRITE ( UNIT = output_unit_write , NML = SimpleEquilibriumPDF ) WRITE ( output_unit_write , '(/)' ) end if end if !!--------------------------------------------------------- !!     some tests !!--------------------------------------------------------- !write(6,*) TRIM(outputs_list),len(TRIM(outputs_list)) tmp = len ( TRIM ( outputs_list )) if ( outputs_list ( tmp : tmp ). ne . '}' ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) & 'Check that enough characters are allocated for outputs list!' end if call korc_abort end if end subroutine read_namelist","tags":"","loc":"proc/read_namelist.html"},{"title":"rmcoment – KORC-Full Orbit","text":"public subroutine rmcoment(fileold, filenew) Strip comments.     Note: line lengths limited to 127 characters ----------------------------------------------------------------------- Close files and exit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fileold character(len=*), intent(in) :: filenew Contents Source Code rmcoment Source Code SUBROUTINE rmcoment ( fileold , filenew ) CHARACTER ( * ), INTENT ( IN ) :: fileold , filenew CHARACTER ( 128 ) :: line INTEGER , PARAMETER :: nold = 55 , nnew = 56 INTEGER cmax , ios LOGICAL :: file_exist !!----------------------------------------------------------------------- !!     Open files, but make sure the old one exists first. !!----------------------------------------------------------------------- INQUIRE ( FILE = fileold , EXIST = file_exist ) IF (. NOT . file_exist ) THEN PRINT * , 'The file \"' , fileold , '\" could not be found.' STOP ENDIF OPEN ( UNIT = default_unit_open , FILE = fileold , status = \"OLD\" , form = 'formatted' ) OPEN ( UNIT = default_unit_write , FILE = filenew , status = 'REPLACE' ) !!----------------------------------------------------------------------- !!     Strip comments.     Note: line lengths limited to 127 characters !!----------------------------------------------------------------------- DO READ ( UNIT = default_unit_open , FMT = '(a)' , IOSTAT = ios ) line IF ( ios /= 0 ) EXIT cmax = 1 DO WHILE ( line ( cmax : cmax ). NE . '!' . AND . cmax . LE . 127 ) cmax = cmax + 1 ENDDO IF ( cmax . GT . 1 ) WRITE ( default_unit_write , '(a)' ) line ( 1 : cmax - 1 ) ENDDO !!----------------------------------------------------------------------- !!     Close files and exit !!----------------------------------------------------------------------- CLOSE ( default_unit_open ) CLOSE ( default_unit_write ) END SUBROUTINE rmcoment","tags":"","loc":"proc/rmcoment.html"},{"title":"deg2rad – KORC-Full Orbit","text":"private function deg2rad(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code deg2rad Source Code FUNCTION deg2rad ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: deg2rad deg2rad = C_PI * x / 18 0.0_rp END FUNCTION deg2rad","tags":"","loc":"proc/deg2rad~5.html"},{"title":"rad2deg – KORC-Full Orbit","text":"private function rad2deg(x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code rad2deg Source Code FUNCTION rad2deg ( x ) REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ) :: rad2deg rad2deg = 18 0.0_rp * x / C_PI END FUNCTION rad2deg","tags":"","loc":"proc/rad2deg~3.html"},{"title":"fGamma – KORC-Full Orbit","text":"private function fGamma(x, k, t) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: k real(kind=rp), intent(in) :: t Return Value real(kind=rp) Contents Source Code fGamma Source Code FUNCTION fGamma ( x , k , t ) REAL ( rp ), INTENT ( IN ) :: x ! Independent variable REAL ( rp ), INTENT ( IN ) :: k ! Shape factor REAL ( rp ), INTENT ( IN ) :: t ! Scale factor REAL ( rp ) :: fGamma fGamma = x ** ( k - 1.0_rp ) * EXP ( - x / t ) / ( GAMMA ( k ) * t ** k ) END FUNCTION fGamma","tags":"","loc":"proc/fgamma~2.html"},{"title":"fRE – KORC-Full Orbit","text":"private function fRE(eta, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p Return Value real(kind=rp) Contents Source Code fRE Source Code FUNCTION fRE ( eta , p ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRE REAL ( rp ) :: fE REAL ( rp ) :: feta REAL ( rp ) :: A REAL ( rp ) :: Eo Eo = SQRT ( p ** 2.0_rp + 1.0_rp ) A = ( 2.0_rp * pdf_params % E / ( pdf_params % Zeff + 1.0_rp )) * ( p ** 2 / SQRT ( p ** 2.0_rp + 1.0_rp )) A = A * pdf_params % A_fact feta = 0.5_rp * A * EXP ( A * COS ( deg2rad ( eta ))) / SINH ( A ) fE = fGamma ( Eo , pdf_params % k , pdf_params % t / xo ) / pdf_params % fGo fRE = fE * feta END FUNCTION fRE","tags":"","loc":"proc/fre~4.html"},{"title":"fRExPR – KORC-Full Orbit","text":"private function fRExPR(eta, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p Return Value real(kind=rp) Contents Source Code fRExPR Source Code FUNCTION fRExPR ( eta , p ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: p ! momentum in units of mc REAL ( rp ) :: fRExPR REAL ( rp ) :: A REAL ( rp ) :: Eo fRExPR = fRE ( eta , p ) * PR ( eta , p , pdf_params % Bo , pdf_params % lambda ) END FUNCTION fRExPR","tags":"","loc":"proc/frexpr.html"},{"title":"random_norm – KORC-Full Orbit","text":"private function random_norm(mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Contents Source Code random_norm Source Code FUNCTION random_norm ( mean , sigma ) REAL ( rp ), INTENT ( IN ) :: mean REAL ( rp ), INTENT ( IN ) :: sigma REAL ( rp ) :: random_norm REAL ( rp ) :: rand1 , rand2 call RANDOM_NUMBER ( rand1 ) call RANDOM_NUMBER ( rand2 ) random_norm = mean + sigma * SQRT ( - 2.0_rp * LOG ( rand1 )) * COS ( 2.0_rp * C_PI * rand2 ) END FUNCTION random_norm","tags":"","loc":"proc/random_norm~6.html"},{"title":"IntK – KORC-Full Orbit","text":"private function IntK(v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code IntK Source Code FUNCTION IntK ( v , x ) REAL ( rp ) :: IntK REAL ( rp ), INTENT ( IN ) :: v REAL ( rp ), INTENT ( IN ) :: x IntK = ( C_PI / SQRT ( 2.0_rp )) * ( 1.0_rp - 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp )) * ERFC ( SQRT ( x ))& + 0.25_rp * ( 4.0_rp * v ** 2 - 1.0_rp ) * SQRT ( 0.5_rp * C_PI / x ) * EXP ( - x ) END FUNCTION IntK","tags":"","loc":"proc/intk~2.html"},{"title":"besselk – KORC-Full Orbit","text":"public function besselk(v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) Contents Source Code besselk Source Code FUNCTION besselk ( v , x ) REAL ( rp ) :: besselk REAL ( rp ), INTENT ( IN ) :: x REAL ( rp ), INTENT ( IN ) :: v REAL ( 4 ) :: ri , rk , rip , rkp call bessik ( REAL ( x , 4 ), REAL ( v , 4 ), ri , rk , rip , rkp ) besselk = REAL ( rk , rp ) END FUNCTION besselk","tags":"","loc":"proc/besselk~2.html"},{"title":"IntGamma – KORC-Full Orbit","text":"private function IntGamma(a, b, k, t) @brief Extended trapezoidal rule for integrating the Gamma PDF. See Sec. 4.2 of Numerical Recipies in Fortran 77. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in) :: k real(kind=rp), intent(in) :: t Return Value real(kind=rp) Contents Source Code IntGamma Source Code FUNCTION IntGamma ( a , b , k , t ) REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ), INTENT ( IN ) :: k ! shape factor REAL ( rp ), INTENT ( IN ) :: t ! scale factor REAL ( rp ) :: IntGamma REAL ( rp ) :: Iold REAL ( rp ) :: Inew REAL ( rp ) :: rerr REAL ( rp ) :: sum_f REAL ( rp ) :: h , z INTEGER :: ii , jj , npoints LOGICAL :: flag h = b - a sum_f = 0.5 * ( fGamma ( a , k , t ) + fGamma ( b , k , t )) Iold = 0.0_rp Inew = sum_f * h ii = 1_idef flag = . TRUE . do while ( flag ) Iold = Inew ii = ii + 1_idef npoints = 2_idef ** ( ii - 2_idef ) h = 0.5_rp * ( b - a ) / REAL ( npoints , rp ) sum_f = 0.0_rp do jj = 1_idef , npoints z = a + h + 2.0_rp * ( REAL ( jj , rp ) - 1.0_rp ) * h sum_f = sum_f + fGamma ( z , k , t ) end do Inew = 0.5_rp * Iold + sum_f * h rerr = ABS (( Inew - Iold ) / Iold ) flag = . NOT .( rerr . LT . Tol ) end do IntGamma = Inew END FUNCTION IntGamma","tags":"","loc":"proc/intgamma.html"},{"title":"IntBesselK – KORC-Full Orbit","text":"private function IntBesselK(a, b) @brief Extended trapezoidal rule for integrating the modified Bessel function of second kind. See Sec. 4.2 of Numerical Recipies in Fortran 77. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b Return Value real(kind=rp) Contents Source Code IntBesselK Source Code FUNCTION IntBesselK ( a , b ) REAL ( rp ), INTENT ( IN ) :: a REAL ( rp ), INTENT ( IN ) :: b REAL ( rp ) :: IntBesselK REAL ( rp ) :: Iold REAL ( rp ) :: Inew REAL ( rp ) :: rerr REAL ( rp ) :: sum_f REAL ( rp ) :: v , h , z INTEGER :: ii , jj , npoints LOGICAL :: flag v = 5.0_rp / 3.0_rp h = b - a sum_f = 0.5 * ( besselk ( v , a ) + besselk ( v , b )) Iold = 0.0_rp Inew = sum_f * h ii = 1_idef flag = . TRUE . do while ( flag ) Iold = Inew ii = ii + 1_idef npoints = 2_idef ** ( ii - 2_idef ) h = 0.5_rp * ( b - a ) / REAL ( npoints , rp ) sum_f = 0.0_rp do jj = 1_idef , npoints z = a + h + 2.0_rp * ( REAL ( jj , rp ) - 1.0_rp ) * h sum_f = sum_f + besselk ( v , z ) end do Inew = 0.5_rp * Iold + sum_f * h rerr = ABS (( Inew - Iold ) / Iold ) flag = . NOT .( rerr . LT . Tol ) end do IntBesselK = Inew END FUNCTION IntBesselK","tags":"","loc":"proc/intbesselk~2.html"},{"title":"PR – KORC-Full Orbit","text":"private function PR(eta, p, Bo, l) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p real(kind=rp), intent(in) :: Bo real(kind=rp), intent(in) :: l Return Value real(kind=rp) Contents Source Code PR Source Code FUNCTION PR ( eta , p , Bo , l ) REAL ( rp ), INTENT ( IN ) :: eta ! in radians REAL ( rp ), INTENT ( IN ) :: p ! dimensionless (in units of mc) REAL ( rp ), INTENT ( IN ) :: Bo REAL ( rp ), INTENT ( IN ) :: l REAL ( rp ) :: PR REAL ( rp ) :: g REAL ( rp ) :: v REAL ( rp ) :: k REAL ( rp ) :: lc REAL ( rp ) :: z REAL ( rp ) :: Pi g = SQRT ( p ** 2 + 1.0_rp ) v = C_C * SQRT ( 1.0_rp - 1.0_rp / g ** 2 ) k = C_E * Bo * SIN ( deg2rad ( eta )) / ( g * C_ME * v ) lc = ( 4.0_rp * C_PI / 3.0_rp ) / ( k * g ** 3 ) ! Critical wavelength z = lc / l call P_integral ( z , Pi ) PR = ( C_C * C_E ** 2 ) * Pi / ( SQRT ( 3.0_rp ) * C_E0 * g ** 2 * l ** 3 ) END FUNCTION PR","tags":"","loc":"proc/pr~2.html"},{"title":"fRE_H – KORC-Full Orbit","text":"private function fRE_H(eta, g) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: g Return Value real(kind=rp) Contents Source Code fRE_H Source Code FUNCTION fRE_H ( eta , g ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: g ! Relativistic gamma factor REAL ( rp ) :: fRE_H REAL ( rp ) :: D REAL ( rp ) :: g0 REAL ( rp ) :: g1 REAL ( rp ) :: f0 REAL ( rp ) :: f1 REAL ( rp ) :: m REAL ( rp ) :: feta REAL ( rp ) :: A INTEGER :: index index = MINLOC ( ABS ( h_params % g - g ), 1 ) ! index of gamma supplied to function in Hollmann input gamma range D = h_params % g ( index ) - g ! linear interpolation of Hollmann input gamma range to gamma supplied ! to function if ( D . GT . 0 ) then f0 = h_params % fRE_E ( index - 1 ) g0 = h_params % g ( index - 1 ) f1 = h_params % fRE_E ( index ) g1 = h_params % g ( index ) else f0 = h_params % fRE_E ( index ) g0 = h_params % g ( index ) f1 = h_params % fRE_E ( index + 1 ) g1 = h_params % g ( index + 1 ) end if m = ( f1 - f0 ) / ( g1 - g0 ) fRE_H = f0 + m * ( g - g0 ) ! end of linear interpolation, fRE_H is evaluation of input Hollmann energy ! distribution PDF at gamma supplied to function A = ( 2.0_rp * h_params % E / ( h_params % Zeff + 1.0_rp )) * ( g ** 2 - 1.0_rp ) / g A = A * h_params % A_fact feta = A * EXP ( - A * ( 1.0_rp - COS ( deg2rad ( eta )))) / ( 1.0_rp - EXP ( - 2.0_rp * A )) ! MRC !\tfeta = 0.5_rp*A*EXP(A*COS(deg2rad(eta)))/SINH(A)                            ! MRC fRE_H = fRE_H * feta END FUNCTION fRE_H","tags":"","loc":"proc/fre_h.html"},{"title":"fRE_H_3D – KORC-Full Orbit","text":"public function fRE_H_3D(F, eta, g, R, Z, R0, Z0) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: g real(kind=rp), intent(in) :: R real(kind=rp), intent(in) :: Z real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: Z0 Return Value real(kind=rp) Contents Source Code fRE_H_3D Source Code FUNCTION fRE_H_3D ( F , eta , g , R , Z , R0 , Z0 ) TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: g ! Relativistic gamma factor REAL ( rp ), INTENT ( IN ) :: R , Z , R0 , Z0 REAL ( rp ) :: fRE_H_3D REAL ( rp ) :: D REAL ( rp ) :: g0 REAL ( rp ) :: g1 REAL ( rp ) :: f0 REAL ( rp ) :: f1 REAL ( rp ) :: m REAL ( rp ) :: feta REAL ( rp ) :: A REAL ( rp ) :: rm , E_G , Z_G INTEGER :: index index = MINLOC ( ABS ( h_params % g - g ), 1 ) ! index of gamma supplied to function in Hollmann input gamma range D = h_params % g ( index ) - g ! linear interpolation of Hollmann input gamma range to gamma supplied ! to function if ( D . GT . 0 ) then f0 = h_params % fRE_E ( index - 1 ) g0 = h_params % g ( index - 1 ) f1 = h_params % fRE_E ( index ) g1 = h_params % g ( index ) else f0 = h_params % fRE_E ( index ) g0 = h_params % g ( index ) f1 = h_params % fRE_E ( index + 1 ) g1 = h_params % g ( index + 1 ) end if m = ( f1 - f0 ) / ( g1 - g0 ) fRE_H_3D = f0 + m * ( g - g0 ) ! end of linear interpolation, fRE_H is evaluation of input Hollman energy ! distribution PDF at gamma supplied to function rm = sqrt (( R - R0 ) ** 2 + ( Z - Z0 ) ** 2 ) E_G = F % Ro * h_params % Eo / R !    E_G=h_params%E*exp(-(rm/h_params%sigma_E)**2/2) Z_G = h_params % Zeff * exp ( - ( rm / h_params % sigma_Z ) ** 2 / 2 ) !    write(output_unit_write,'(\"rm: \",E17.10)') rm A = ( 2.0_rp * E_G / ( Z_G + 1.0_rp )) * ( g ** 2 - 1.0_rp ) / g A = A * h_params % A_fact feta = A * EXP ( - A * ( 1.0_rp - COS ( deg2rad ( eta )))) / ( 1.0_rp - EXP ( - 2.0_rp * A )) ! MRC !\tfeta = 0.5_rp*A*EXP(A*COS(deg2rad(eta)))/SINH(A)                            ! MRC fRE_H_3D = fRE_H_3D * feta END FUNCTION fRE_H_3D","tags":"","loc":"proc/fre_h_3d.html"},{"title":"fRE_HxPR – KORC-Full Orbit","text":"public function fRE_HxPR(eta, g) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: g Return Value real(kind=rp) Contents Source Code fRE_HxPR Source Code FUNCTION fRE_HxPR ( eta , g ) REAL ( rp ), INTENT ( IN ) :: eta ! pitch angle in degrees REAL ( rp ), INTENT ( IN ) :: g ! gamma factor REAL ( rp ) :: fRE_HxPR fRE_HxPR = fRE_H ( eta , g ) * PR ( eta , SQRT ( g ** 2 - 1.0_rp ), h_params % Bo , h_params % lambda ) END FUNCTION fRE_HxPR","tags":"","loc":"proc/fre_hxpr.html"},{"title":"fRE_pitch – KORC-Full Orbit","text":"private function fRE_pitch(g) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: g Return Value real(kind=rp) Contents Source Code fRE_pitch Source Code FUNCTION fRE_pitch ( g ) REAL ( rp ), INTENT ( IN ) :: g ! Relativistic gamma factor REAL ( rp ) :: fRE_pitch REAL ( rp ) :: D REAL ( rp ) :: g0 , g1 , f0 , f1 , m INTEGER :: index index = MINLOC ( ABS ( h_params % g - g ), 1 ) D = h_params % g ( index ) - g if ( D . GT . 0 ) then f0 = h_params % fRE_pitch ( index - 1 ) g0 = h_params % g ( index - 1 ) f1 = h_params % fRE_pitch ( index ) g1 = h_params % g ( index ) else f0 = h_params % fRE_pitch ( index ) g0 = h_params % g ( index ) f1 = h_params % fRE_pitch ( index + 1 ) g1 = h_params % g ( index + 1 ) end if m = ( f1 - f0 ) / ( g1 - g0 ) fRE_pitch = f0 + m * ( g - g0 ) fRE_pitch = 18 0.0_rp - fRE_pitch END FUNCTION fRE_pitch","tags":"","loc":"proc/fre_pitch.html"},{"title":"PSI_ROT_exp – KORC-Full Orbit","text":"public function PSI_ROT_exp(R, R0, sigR, Z, Z0, sigZ, theta) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R R-coordinate of MH sampled location real(kind=rp), intent(in) :: R0 R-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigR Variance of first dimension of 2D Gaussian real(kind=rp), intent(in) :: Z Z-coordinate of MH sampled location real(kind=rp), intent(in) :: Z0 Z-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigZ Variance of second dimension of 2D Gaussian real(kind=rp), intent(in) :: theta Angle of counter-clockwise rotation (in radians), of 2D Gaussian\n distribution relative to R,Z Return Value real(kind=rp) Argument of exponential comprising 2D Gaussian distribution Contents Source Code PSI_ROT_exp Source Code FUNCTION PSI_ROT_exp ( R , R0 , sigR , Z , Z0 , sigZ , theta ) REAL ( rp ), INTENT ( IN ) :: R !! R-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: R0 !! R-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigR !! Variance of first dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: Z !! Z-coordinate of MH sampled location REAL ( rp ), INTENT ( IN ) :: Z0 !! Z-coordinate of center of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: sigZ !! Variance of second dimension of 2D Gaussian REAL ( rp ), INTENT ( IN ) :: theta !! Angle of counter-clockwise rotation (in radians), of 2D Gaussian !! distribution relative to R,Z REAL ( rp ) :: PSI_ROT_exp !! Argument of exponential comprising 2D Gaussian distribution PSI_ROT_exp = ( R - R0 ) ** 2 * (( cos ( theta )) ** 2 / ( 2 * sigR ** 2 ) + & ( sin ( theta )) ** 2 / ( 2 * sigZ ** 2 )) + & 2 * ( R - R0 ) * ( Z - Z0 ) * cos ( theta ) * sin ( theta ) * ( 1 / ( 2 * sigR ** 2 ) - 1 / ( 2 * sigZ ** 2 )) + & ( Z - Z0 ) ** 2 * (( sin ( theta )) ** 2 / ( 2 * sigR ** 2 ) + ( cos ( theta )) ** 2 / ( 2 * sigZ ** 2 )) END FUNCTION PSI_ROT_exp","tags":"","loc":"proc/psi_rot_exp.html"},{"title":"indicator_exp – KORC-Full Orbit","text":"public function indicator_exp(psi, psi_max) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: psi real(kind=rp), intent(in) :: psi_max Return Value real(kind=rp) Contents Source Code indicator_exp Source Code FUNCTION indicator_exp ( psi , psi_max ) REAL ( rp ), INTENT ( IN ) :: psi REAL ( rp ), INTENT ( IN ) :: psi_max REAL ( rp ) :: indicator_exp IF ( psi . LT . psi_max ) THEN indicator_exp = 1 ELSE indicator_exp = 0 END IF END FUNCTION indicator_exp","tags":"","loc":"proc/indicator_exp.html"},{"title":"get_experimentalG_distribution – KORC-Full Orbit","text":"public subroutine get_experimentalG_distribution(params, g, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao Contents Source Code get_experimentalG_distribution Source Code SUBROUTINE get_experimentalG_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao call initialize_params ( params ) call save_params ( params ) call sample_distribution ( params , g , eta , go , etao ) END SUBROUTINE get_experimentalG_distribution","tags":"","loc":"proc/get_experimentalg_distribution.html"},{"title":"initialize_params – KORC-Full Orbit","text":"private subroutine initialize_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code initialize_params Source Code SUBROUTINE initialize_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !REAL(rp) :: max_pitch_angle !REAL(rp) :: min_pitch_angle !REAL(rp) :: max_energy !REAL(rp) :: min_energy !REAL(rp) :: Zeff !REAL(rp) :: E !REAL(rp) :: k !REAL(rp) :: t !REAL(rp) :: Bo !REAL(rp) :: lambda !REAL(rp) :: A_fact !NAMELIST /ExperimentalPDF/ max_pitch_angle,min_pitch_angle,max_energy, & !     min_energy,Zeff,E,k,t,Bo,lambda,A_fact !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=ExperimentalPDF) !close(default_unit_open) pdf_params % max_pitch_angle = max_pitch_angle_expt pdf_params % min_pitch_angle = min_pitch_angle_expt pdf_params % min_energy = min_energy_expt * C_E ! In Joules pdf_params % max_energy = max_energy_expt * C_E ! In Joules pdf_params % Zeff = Zeff_expt pdf_params % E = E_expt pdf_params % k = k_expt pdf_params % t = t_expt pdf_params % Bo = Bo_expt pdf_params % lambda = lambda_expt pdf_params % max_p = SQRT (( pdf_params % max_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc pdf_params % min_p = SQRT (( pdf_params % min_energy / ( C_ME * C_C ** 2 )) ** 2 - 1.0_rp ) ! In units of mc pdf_params % fGo = & IntGamma ( SQRT ( pdf_params % min_p ** 2.0_rp + 1.0_rp ), SQRT ( pdf_params % max_p ** 2.0_rp + 1.0_rp ), pdf_params % k , pdf_params % t / xo ) pdf_params % A_fact = A_fact_expt END SUBROUTINE initialize_params","tags":"","loc":"proc/initialize_params~2.html"},{"title":"P_integral – KORC-Full Orbit","text":"private subroutine P_integral(z, P) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: z real(kind=rp), intent(out) :: P Contents Source Code P_integral Source Code SUBROUTINE P_integral ( z , P ) REAL ( rp ), INTENT ( OUT ) :: P REAL ( rp ), INTENT ( IN ) :: z REAL ( rp ) :: a P = 0.0_rp IF ( z . LT . 0.5_rp ) THEN a = ( 2.16_rp / 2.0_rp ** ( 2.0_rp / 3.0_rp )) * z ** ( 1.0_rp / 3.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE IF (( z . GE . 0.5_rp ). AND .( z . LT . 2.5_rp )) THEN a = 0.72_rp * ( z + 1.0_rp ) P = IntBesselK ( z , a ) + IntK ( 5.0_rp / 3.0_rp , a ) ELSE P = IntK ( 5.0_rp / 3.0_rp , z ) END IF END SUBROUTINE P_integral","tags":"","loc":"proc/p_integral~2.html"},{"title":"sample_distribution – KORC-Full Orbit","text":"private subroutine sample_distribution(params, g, eta, go, etao) Transient * ! Transient * ! Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao Contents Source Code sample_distribution Source Code SUBROUTINE sample_distribution ( params , g , eta , go , etao ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: g REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: eta REAL ( rp ), INTENT ( OUT ) :: go REAL ( rp ), INTENT ( OUT ) :: etao REAL ( rp ) :: go_root REAL ( rp ) :: etao_root REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: p_buffer REAL ( rp ) :: p_test REAL ( rp ) :: eta_buffer REAL ( rp ) :: eta_test REAL ( rp ) :: ratio REAL ( rp ) :: rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p_tmp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax REAL ( rp ) :: min_p REAL ( rp ) :: max_p REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: deta REAL ( rp ) :: dp LOGICAL :: lp LOGICAL :: leta INTEGER :: num_accepted INTEGER :: ii INTEGER :: jj INTEGER :: ppp INTEGER :: nsamples INTEGER :: mpierr ppp = SIZE ( g ) nsamples = ppp * params % mpi_params % nmpi ALLOCATE ( p ( ppp )) deta = ( pdf_params % max_pitch_angle - & pdf_params % min_pitch_angle ) / 10 0.0_rp dp = ( pdf_params % max_p - pdf_params % min_p ) / 10 0.0_rp do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % min_p - REAL ( jj , rp ) * dp if ( minmax . GT . 0.0_rp ) then min_p = minmax end if end do max_p = pdf_params % max_p + minmax_buffer_size * dp if ( pdf_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = 0.0_rp end if do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = pdf_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax else max_pitch_angle = pdf_params % max_pitch_angle EXIT end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( p_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( p_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes !* * * Transient * * *! call RANDOM_SEED () call RANDOM_NUMBER ( rand_unif ) eta_buffer = pdf_params % min_pitch_angle + & ( pdf_params % max_pitch_angle - pdf_params % min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) p_buffer = pdf_params % min_p + ( pdf_params % max_p - & pdf_params % min_p ) * rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . pdf_params % max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . pdf_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , deta ) end do p_test = p_buffer + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . pdf_params % min_p ). OR .( p_test . GT . & pdf_params % max_p )) p_test = p_buffer + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( eta_test , p_test ) / fRE ( eta_buffer , p_buffer ) if ( ratio . GE . 1.0_rp ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_buffer = p_test eta_buffer = eta_test ii = ii + 1_idef end if end if end do !* * * Transient * * *! eta_tmp ( 1 ) = eta_buffer p_tmp ( 1 ) = p_buffer num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , deta ) end do p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) do while (( p_test . LT . min_p ). OR .( p_test . GT . max_p )) p_test = p_tmp ( ii - 1 ) + random_norm ( 0.0_rp , dp ) end do ratio = fRE ( eta_test , p_test ) / fRE ( eta_tmp ( ii - 1 ), p_tmp ( ii - 1 )) if ( ratio . GE . 1.0_rp ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) if ( rand_unif . LT . ratio ) then p_tmp ( ii ) = p_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) lp = ( p_tmp ( ii ). LE . pdf_params % max_p ). AND .( p_tmp ( ii ). GE . & pdf_params % min_p ) leta = ( eta_tmp ( ii ). LE . pdf_params % max_pitch_angle ). AND . & ( eta_tmp ( ii ). GE . pdf_params % min_pitch_angle ) if ( lp . AND . leta ) then num_accepted = num_accepted + 1_idef p_samples ( num_accepted ) = p_tmp ( ii ) eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do end do go = SUM ( SQRT ( 1.0_rp + p_samples ** 2 )) / nsamples etao = SUM ( eta_samples ) / nsamples end if CALL MPI_SCATTER ( p_samples , ppp , MPI_REAL8 , p , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , ppp , MPI_REAL8 , eta , ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( go , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_BCAST ( etao , 1 , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) g = SQRT ( 1.0_rp + p ** 2 ) DEALLOCATE ( p ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( p_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( p_tmp ) DEALLOCATE ( eta_tmp ) end if END SUBROUTINE sample_distribution","tags":"","loc":"proc/sample_distribution~2.html"},{"title":"get_Hollmann_distribution – KORC-Full Orbit","text":"public subroutine get_Hollmann_distribution(params, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp Contents Source Code get_Hollmann_distribution Source Code SUBROUTINE get_Hollmann_distribution ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: g !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: eta !    REAL(rp), INTENT(OUT) :: go !    REAL(rp), INTENT(OUT) :: etao INTEGER :: mpierr if ( spp % ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) 'num_samples need to be atleast 10 but is only: ' , & spp % ppp * params % mpi_params % nmpi end if call korc_abort end if call initialize_Hollmann_params ( params ) call save_Hollmann_params ( params ) call sample_Hollmann_distribution ( params , spp ) END SUBROUTINE get_Hollmann_distribution","tags":"","loc":"proc/get_hollmann_distribution.html"},{"title":"get_Hollmann_distribution_3D – KORC-Full Orbit","text":"public subroutine get_Hollmann_distribution_3D(params, spp, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp type(FIELDS), intent(in) :: F Contents Source Code get_Hollmann_distribution_3D Source Code SUBROUTINE get_Hollmann_distribution_3D ( params , spp , F ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp INTEGER :: mpierr if ( spp % ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) 'num_samples need to be atleast 10 but is only: ' , & spp % ppp * params % mpi_params % nmpi end if call korc_abort end if call initialize_Hollmann_params ( params ) call save_Hollmann_params ( params ) call normalize_Hollmann_params ( params ) call sample_Hollmann_distribution_3D ( params , spp , F ) END SUBROUTINE get_Hollmann_distribution_3D","tags":"","loc":"proc/get_hollmann_distribution_3d.html"},{"title":"get_Hollmann_distribution_3D_psi – KORC-Full Orbit","text":"public subroutine get_Hollmann_distribution_3D_psi(params, spp, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params type(SPECIES), intent(inout) :: spp type(FIELDS), intent(in) :: F Contents Source Code get_Hollmann_distribution_3D_psi Source Code SUBROUTINE get_Hollmann_distribution_3D_psi ( params , spp , F ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp INTEGER :: mpierr if ( spp % ppp * params % mpi_params % nmpi . lt . 10 ) then if ( params % mpi_params % rank . eq . 0 ) then write ( 6 , * ) 'num_samples need to be atleast 10 but is only: ' , & spp % ppp * params % mpi_params % nmpi end if call korc_abort end if call initialize_Hollmann_params ( params ) call save_Hollmann_params ( params ) call normalize_Hollmann_params ( params ) call sample_Hollmann_distribution_3D_psi ( params , spp , F ) END SUBROUTINE get_Hollmann_distribution_3D_psi","tags":"","loc":"proc/get_hollmann_distribution_3d_psi.html"},{"title":"initialize_Hollmann_params – KORC-Full Orbit","text":"public subroutine initialize_Hollmann_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code initialize_Hollmann_params Source Code SUBROUTINE initialize_Hollmann_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: current_direction REAL ( rp ) :: E , sigma_E , Eo REAL ( rp ) :: Zeff , sigma_Z REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: max_energy REAL ( rp ) :: min_energy REAL ( rp ) :: Bo REAL ( rp ) :: lambda REAL ( rp ) :: A_fact !NAMELIST /HollmannPDF/ E,Zeff,max_pitch_angle,min_pitch_angle,max_energy, & !     min_energy,filename,Bo,lambda,current_direction,A_fact,sigma_E, & !     sigma_Z,Eo !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=HollmannPDF) !close(default_unit_open) h_params % filename = TRIM ( filename_Hollmann ) h_params % E = E_Hollmann h_params % Eo = Eo_Hollmann h_params % sigma_E = sigma_E_Hollmann h_params % Zeff = Zeff_Hollmann h_params % sigma_Z = sigma_Z_Hollmann h_params % max_pitch_angle = max_pitch_angle_Hollmann h_params % min_pitch_angle = min_pitch_angle_Hollmann h_params % min_sampling_energy = min_energy_Hollmann * C_E ! In Joules h_params % min_sampling_g = 1.0_rp + h_params % min_sampling_energy / & ( C_ME * C_C ** 2 ) h_params % max_sampling_energy = max_energy_Hollmann * C_E ! In Joules. h_params % max_sampling_g = 1.0_rp + h_params % max_sampling_energy / & ( C_ME * C_C ** 2 ) call load_data_from_hdf5 () ! loads h_params%E_axis 1D energy range, h_params%fRE_E ! energy distribution as a function of h_params%E_axis, ! and h_params%fRE_pitch pitch angle distribution as a ! function of h_params%E_axis ALLOCATE ( h_params % g ( h_params % N )) h_params % g = 1.0_rp + h_params % E_axis / ( C_ME * C_C ** 2 ) ! 1D range of gamma based on energy range from Hollmann input file h_params % max_g = MAXVAL ( h_params % g ) h_params % min_g = MINVAL ( h_params % g ) h_params % current_direction = TRIM ( current_direction_Hollmann ) h_params % Bo = Bo_Hollmann h_params % lambda = lambda_Hollmann h_params % A_fact = A_fact_Hollmann END SUBROUTINE initialize_Hollmann_params","tags":"","loc":"proc/initialize_hollmann_params.html"},{"title":"normalize_Hollmann_params – KORC-Full Orbit","text":"public subroutine normalize_Hollmann_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code normalize_Hollmann_params Source Code subroutine normalize_Hollmann_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params h_params % sigma_E = h_params % sigma_E / params % cpp % length h_params % sigma_Z = h_params % sigma_Z / params % cpp % length end subroutine normalize_Hollmann_params","tags":"","loc":"proc/normalize_hollmann_params.html"},{"title":"load_data_from_hdf5 – KORC-Full Orbit","text":"public subroutine load_data_from_hdf5() Arguments None Contents Source Code load_data_from_hdf5 Source Code SUBROUTINE load_data_from_hdf5 () CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id REAL ( rp ) :: rdatum INTEGER :: h5error filename = TRIM ( h_params % filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_data_from_hdf5 (korc_experimental) --> h5fopen_f\")' ) end if dset = \"/N\" call load_from_hdf5 ( h5file_id , dset , rdatum ) h_params % N = INT ( rdatum ) ALLOCATE ( h_params % E_axis ( h_params % N )) ALLOCATE ( h_params % fRE_E ( h_params % N )) ALLOCATE ( h_params % fRE_pitch ( h_params % N )) dset = \"/E\" call load_array_from_hdf5 ( h5file_id , dset , h_params % E_axis ) h_params % E_axis = h_params % E_axis * C_E dset = \"/fRE_E\" call load_array_from_hdf5 ( h5file_id , dset , h_params % fRE_E ) dset = \"/fRE_pitch\" call load_array_from_hdf5 ( h5file_id , dset , h_params % fRE_pitch ) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_data_from_hdf5 (korc_experimental) --> h5fclose_f\")' ) end if END SUBROUTINE load_data_from_hdf5","tags":"","loc":"proc/load_data_from_hdf5.html"},{"title":"sample_Hollmann_distribution – KORC-Full Orbit","text":"public subroutine sample_Hollmann_distribution(params, spp) MCMC and MH algorithm perfomred on single MPI process \n to sample distribution function fRE_H Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp Contents Source Code sample_Hollmann_distribution Source Code SUBROUTINE sample_Hollmann_distribution ( params , spp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) \t:: g !    REAL(rp), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) \t:: eta !    REAL(rp), INTENT(OUT) \t\t\t\t:: go !    REAL(rp), INTENT(OUT) \t\t\t\t:: etao REAL ( rp ), DIMENSION (:), ALLOCATABLE :: p REAL ( rp ) :: g_buffer REAL ( rp ) :: g_test REAL ( rp ) :: eta_buffer REAL ( rp ) :: eta_test REAL ( rp ) :: ratio REAL ( rp ) :: rand_unif REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: g_tmp REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_tmp REAL ( rp ) :: minmax REAL ( rp ) :: min_g REAL ( rp ) :: max_g REAL ( rp ) :: min_pitch_angle REAL ( rp ) :: max_pitch_angle REAL ( rp ) :: dg REAL ( rp ) :: deta LOGICAL :: lp INTEGER :: index_i INTEGER :: index_f INTEGER :: num_accepted INTEGER :: ii INTEGER :: jj INTEGER :: ppp INTEGER :: nsamples INTEGER :: mpierr INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) nsamples = spp % ppp * params % mpi_params % nmpi index_i = MINLOC ( ABS ( h_params % g - h_params % min_sampling_g ), 1 ) !index of minimum gamma range desired index_f = MINLOC ( ABS ( h_params % g - h_params % max_sampling_g ), 1 ) !index of maximum gamma range desired deta = ( h_params % max_pitch_angle - h_params % min_pitch_angle ) / 10 0.0_rp dg = ( h_params % max_sampling_g - h_params % min_sampling_g ) / 10 0.0_rp ! buffer at minimum gamma boundary do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_sampling_g - REAL ( jj , rp ) * dg if ( minmax . GT . h_params % min_g ) then min_g = minmax end if ! buffer at maximum gamma boundary minmax = h_params % max_sampling_g + REAL ( jj , rp ) * dg if ( minmax . LT . h_params % max_g ) then max_g = minmax end if end do ! buffer at minimum pitch angle boundary if ( h_params % min_pitch_angle . GE . korc_zero ) then do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_pitch_angle - REAL ( jj , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = 0.0_rp end if ! buffer at maximum pitch angle boundary do jj = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % max_pitch_angle + REAL ( jj , rp ) * deta if ( minmax . LE . 9 0.0_rp ) then max_pitch_angle = minmax else max_pitch_angle = h_params % max_pitch_angle EXIT end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then !! MCMC and MH algorithm perfomred on single MPI process !! to sample distribution function fRE_H ALLOCATE ( g_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( g_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_tmp ( nsamples )) ! Number of samples to distribute among all MPI processes !Transient! if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if call RANDOM_NUMBER ( rand_unif ) !       rand_unif=get_random_U() eta_buffer = h_params % min_pitch_angle + ( h_params % max_pitch_angle & - h_params % min_pitch_angle ) * rand_unif call RANDOM_NUMBER ( rand_unif ) !       rand_unif=get_random_U() g_buffer = h_params % min_sampling_g + ( h_params % max_sampling_g - & h_params % min_sampling_g ) * rand_unif ii = 2_idef do while ( ii . LE . 1000_idef ) eta_test = eta_buffer + random_norm ( 0.0_rp , spp % dth ) !          eta_test = eta_buffer + get_random_N()*spp%dth do while (( ABS ( eta_test ) . GT . h_params % max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . h_params % min_pitch_angle )) eta_test = eta_buffer + random_norm ( 0.0_rp , spp % dth ) !             eta_test = eta_buffer + get_random_N()*spp%dth end do g_test = g_buffer + random_norm ( 0.0_rp , spp % dgam ) !          g_test = g_buffer + get_random_N()*spp%dgam do while (( g_test . LT . h_params % min_sampling_g ). OR . & ( g_test . GT . h_params % max_sampling_g )) g_test = g_buffer + random_norm ( 0.0_rp , spp % dgam ) !             g_test = g_buffer + get_random_N()*spp%dgam end do ratio = fRE_H ( eta_test , g_test ) * sin ( deg2rad ( eta_test )) / & ( fRE_H ( eta_buffer , g_buffer ) * & sin ( deg2rad ( eta_buffer ))) !ratio = fRE_H(eta_test,g_test)/fRE_H(eta_buffer,g_buffer) !ratio = fRE_HxPR(eta_test,g_test)/fRE_HxPR(eta_buffer,g_buffer) if ( ratio . GE . 1.0_rp ) then g_buffer = g_test eta_buffer = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) !             rand_unif=get_random_U() if ( rand_unif . LT . ratio ) then g_buffer = g_test eta_buffer = eta_test ii = ii + 1_idef end if end if end do !Transient! eta_tmp ( 1 ) = eta_buffer g_tmp ( 1 ) = g_buffer num_accepted = 0_idef do while ( num_accepted . LT . nsamples ) ii = 2_idef do while ( ii . LE . nsamples ) if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !             write(output_unit_write,'(\"iisample\",I16)') ii eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dth ) !eta_test = eta_tmp(ii-1) + get_random_N()*spp%dth !             write(output_unit_write,'(\"max_pitch_angle: \",E17.10)') max_pitch_angle !             write(output_unit_write,'(\"min_pitch_angle: \",E17.10)') min_pitch_angle do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) eta_test = eta_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dth ) !                eta_test = eta_tmp(ii-1) + get_random_N()*spp%dth !                write(output_unit_write,'(\"eta_test: \",E17.10)') eta_test end do g_test = g_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dgam ) !g_test = g_tmp(ii-1) + get_random_N()*spp%dgam !             write(output_unit_write,'(\"max_g: \",E17.10)') max_g !             write(output_unit_write,'(\"min_g: \",E17.10)') min_g do while (( g_test . LT . min_g ). OR .( g_test . GT . max_g )) g_test = g_tmp ( ii - 1 ) + random_norm ( 0.0_rp , spp % dgam ) !                g_test = g_tmp(ii-1) + get_random_N()*spp%dgam !                write(output_unit_write,'(\"g_test: \",E17.10)') g_test end do ratio = fRE_H ( eta_test , g_test ) * sin ( deg2rad ( eta_test )) / & ( fRE_H ( eta_tmp ( ii - 1 ), g_tmp ( ii - 1 )) * & sin ( deg2rad ( eta_tmp ( ii - 1 )))) !             ratio = fRE_H(eta_test,g_test)/fRE_H(eta_tmp(ii-1),g_tmp(ii-1)) !ratio = fRE_HxPR(eta_test,g_test)/fRE_HxPR(eta_tmp(ii-1),g_tmp(ii-1)) !             write(output_unit_write,'(\"ratio: \",E17.10)') ratio if ( ratio . GE . 1.0_rp ) then g_tmp ( ii ) = g_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef else call RANDOM_NUMBER ( rand_unif ) !                rand_unif=get_random_U() if ( rand_unif . LT . ratio ) then g_tmp ( ii ) = g_test eta_tmp ( ii ) = eta_test ii = ii + 1_idef end if end if end do eta_tmp = ABS ( eta_tmp ) ii = 1_idef do while ( ( ii . LT . nsamples ). AND .( num_accepted . LT . nsamples ) ) !             write(output_unit_write,'(\"iiaccept\",I16)') ii lp = ( g_tmp ( ii ). LE . h_params % max_sampling_g ). AND . & ( g_tmp ( ii ). GE . h_params % min_sampling_g ). AND . & ( eta_tmp ( ii ). LE . h_params % max_pitch_angle ). AND . & ( eta_tmp ( ii ). GE . h_params % min_pitch_angle ) if ( lp ) then num_accepted = num_accepted + 1_idef g_samples ( num_accepted ) = g_tmp ( ii ) eta_samples ( num_accepted ) = eta_tmp ( ii ) end if ii = ii + 1_idef end do end do !\t\tif (TRIM(h_params%current_direction) .EQ. 'ANTICLOCKWISE') then !\t\t\teta_samples = 180.0_rp - eta_samples !\t\tend if !       go = SUM(g_samples)/nsamples !       etao = SUM(eta_samples)/nsamples end if !MCMC computed on single MPI process CALL MPI_SCATTER ( g_samples , spp % ppp , MPI_REAL8 , spp % vars % g , spp % ppp , MPI_REAL8 , & 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , spp % ppp , MPI_REAL8 , spp % vars % eta , spp % ppp , MPI_REAL8 , & 0 , MPI_COMM_WORLD , mpierr ) !    CALL MPI_BCAST(go,1,MPI_REAL8,0,MPI_COMM_WORLD,mpierr) !    CALL MPI_BCAST(etao,1,MPI_REAL8,0,MPI_COMM_WORLD,mpierr) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( g_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( g_tmp ) DEALLOCATE ( eta_tmp ) end if !   write(output_unit_write,'(\"sampled eta: \",E17.10)') eta END SUBROUTINE sample_Hollmann_distribution","tags":"","loc":"proc/sample_hollmann_distribution.html"},{"title":"sample_Hollmann_distribution_3D – KORC-Full Orbit","text":"public subroutine sample_Hollmann_distribution_3D(params, spp, F) Note Subroutine that generates a 2D Gaussian distribution in an \n elliptic torus as the initial spatial condition of a given particle \n species in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code sample_Hollmann_distribution_3D Source Code subroutine sample_Hollmann_distribution_3D ( params , spp , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples , X_samples , Y_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: G_samples !! Gamma of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples !! Pitch angle of all samples REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: min_g , max_g REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: eta_buffer !! Previous sample of pitch REAL ( rp ) :: G_buffer REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: eta_test !! Present sample of pitch angle REAL ( rp ) :: G_test REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: f0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: f1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator REAL ( rp ) :: dg , deta LOGICAL :: accepted INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 2._rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp deta = ( h_params % max_pitch_angle - h_params % min_pitch_angle ) / 10 0.0_rp dg = ( h_params % max_sampling_g - h_params % min_sampling_g ) / 10 0.0_rp ! buffer at minimum gamma boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_sampling_g - REAL ( ii , rp ) * dg if ( minmax . GT . h_params % min_g ) then min_g = minmax end if ! buffer at maximum gamma boundary minmax = h_params % max_sampling_g + REAL ( ii , rp ) * dg if ( minmax . LT . h_params % max_g ) then max_g = minmax end if end do ! buffer at minimum pitch angle boundary if ( h_params % min_pitch_angle . GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_pitch_angle - REAL ( ii , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = h_params % min_pitch_angle end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % max_pitch_angle + REAL ( ii , rp ) * deta if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ALLOCATE ( X_samples ( nsamples )) ALLOCATE ( Y_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( G_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if !     call RANDOM_NUMBER(rand_unif) !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*rand_unif !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*get_random_mkl_U() eta_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * get_random_U () !     call RANDOM_NUMBER(rand_unif) !     G_buffer = min_g + (max_g - min_g)*rand_unif !     G_buffer = min_g + (max_g - min_g)*get_random_mkl_U() G_buffer = min_g + ( max_g - min_g ) * get_random_U () !     write(output_unit_write,*) 'R_buffer',R_buffer !     write(output_unit_write,*) 'Z_buffer',Z_buffer !     write(output_unit_write,*) 'eta_buffer',eta_buffer !     write(output_unit_write,*) 'G_buffer',G_buffer !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length accepted = . false . ii = 1_idef do while ( ii . LE . 1000_idef ) !        write(output_unit_write,'(\"burn:\",I15)') ii !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then psi0 = PSI_ROT_exp ( R_buffer , spp % Ro , spp % sigmaR , Z_buffer , spp % Zo , & spp % sigmaZ , theta_rad ) f0 = fRE_H_3D ( F , eta_buffer , G_buffer , R_buffer , Z_buffer , spp % Ro , spp % Zo ) !           f0=fRE_H(eta_buffer,G_buffer) end if if ( accepted ) then psi0 = psi1 f0 = f1 end if psi1 = PSI_ROT_exp ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 !        write(output_unit_write,'(\"f0: \",E17.10)') f0 !        write(output_unit_write,'(\"f1: \",E17.10)') f1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. ratio = indicator_exp ( psi1 , spp % psi_max ) * & R_test * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = indicator_exp(psi1,spp%psi_max)* & !             R_test*EXP(-psi1)*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*EXP(-psi0)*f0*sin(deg2rad(eta_buffer))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef else !           call RANDOM_NUMBER(rand_unif) !           if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do if ( accepted ) then psi0 = psi1 f0 = f1 end if psi1 = PSI_ROT_exp ( R_test , spp % Ro , spp % sigmaR , Z_test , spp % Zo , & spp % sigmaZ , theta_rad ) !        write(output_unit_write,'(\"R: \",E17.10)') R_test !        write(output_unit_write,'(\"R0: \",E17.10)') spp%Ro !        write(output_unit_write,'(\"sigma_R: \",E17.10)') spp%sigmaR !        write(output_unit_write,'(\"dR: \",E17.10)') spp%dR !        write(output_unit_write,'(\"N_dR: \",E17.10)') random_norm(0.0_rp,spp%dR) !        write(output_unit_write,'(\"Z: \",E17.10)') Z_test !        write(output_unit_write,'(\"Z0: \",E17.10)') spp%Zo !        write(output_unit_write,'(\"sigma_Z: \",E17.10)') spp%sigmaZ !        write(output_unit_write,'(\"dZ: \",E17.10)') spp%dZ !        write(output_unit_write,'(\"N_dR: \",Z17.10)') random_norm(0.0_rp,spp%dZ) f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) ratio = indicator_exp ( psi1 , psi_max_buff ) * & R_test * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = indicator_exp(psi1,psi_max_buff)* & !             R_test*EXP(-psi1)*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*EXP(-psi0)*f0*sin(deg2rad(eta_buffer))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test else !call RANDOM_NUMBER(rand_unif) !if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test end if end if !        write(output_unit_write,'(\"R: \",E17.10)') R_buffer !        write(output_unit_write,'(\"Z: \",E17.10)') Z_buffer ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator_exp ( psi1 , spp % psi_max )). EQ . 1 ). AND . & ( G_buffer . LE . h_params % max_sampling_g ). AND . & ( G_buffer . GE . h_params % min_sampling_g ). AND . & ( eta_buffer . LE . h_params % max_pitch_angle ). AND . & ( eta_buffer . GE . h_params % min_pitch_angle ). AND . & ACCEPTED ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer eta_samples ( ii ) = eta_buffer G_samples ( ii ) = G_buffer !           write(output_unit_write,*) 'RS',R_buffer ! Sample phi location uniformly !call RANDOM_NUMBER(rand_unif) !PHI_samples(ii) = 2.0_rp*C_PI*rand_unif !PHI_samples(ii) = 2.0_rp*C_PI*get_random_mkl_U() PHI_samples ( ii ) = 2.0_rp * C_PI * get_random_U () ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length X_samples = R_samples * cos ( PHI_samples ) Y_samples = R_samples * sin ( PHI_samples ) !     write(output_unit_write,*) 'R_samples',R_samples !     write(output_unit_write,*) 'PHI_samples',PHI_samples !     write(output_unit_write,*) 'Z_samples',Z_samples !     write(output_unit_write,*) 'G_samples',G_samples !     write(output_unit_write,*) 'eta_samples',eta_samples end if call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( X_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Y_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , spp % ppp , MPI_REAL8 , & spp % vars % eta , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( G_samples , spp % ppp , MPI_REAL8 , & spp % vars % g , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varY',spp%vars%X(:,2) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varR',spp%vars%Y(:,1) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_PHI: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_Z: \",E17.10)') spp%vars%Y(:,3)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( X_samples ) DEALLOCATE ( Y_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( G_samples ) end if end subroutine sample_Hollmann_distribution_3D","tags":"","loc":"proc/sample_hollmann_distribution_3d.html"},{"title":"sample_Hollmann_distribution_3D_psi – KORC-Full Orbit","text":"public subroutine sample_Hollmann_distribution_3D_psi(params, spp, F) Note Subroutine that generates a 2D Gaussian distribution in an \n elliptic torus as the initial spatial condition of a given particle \n species in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code sample_Hollmann_distribution_3D_psi Source Code subroutine sample_Hollmann_distribution_3D_psi ( params , spp , F ) !! @note Subroutine that generates a 2D Gaussian distribution in an !! elliptic torus as the initial spatial condition of a given particle !! species in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( SPECIES ), INTENT ( INOUT ) :: spp !! An instance of the derived type SPECIES containing all the parameters !! and simulation variables of the different species in the simulation. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:), ALLOCATABLE :: R_samples , X_samples , Y_samples !! Major radial location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: PHI_samples !! Azimuithal angle of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: Z_samples !! Vertical location of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: G_samples !! Gamma of all samples REAL ( rp ), DIMENSION (:), ALLOCATABLE :: eta_samples !! Pitch angle of all samples REAL ( rp ) :: psi_max_buff !! Value of buffer above desired maximum argument of 2D Gaussian spatial !! profile REAL ( rp ) :: minmax !! Temporary variable used for setting buffers !! Minimum domain for momentum sampling including buffer REAL ( rp ) :: max_pitch_angle !! Maximum domain for pitch angle sampling including buffer REAL ( rp ) :: min_pitch_angle !! Minimum domain for pitch angle sampling including buffer REAL ( rp ) :: min_g , max_g REAL ( rp ) :: min_R , max_R REAL ( rp ) :: min_Z , max_Z REAL ( rp ) :: theta_rad !! Angle of rotation of 2D Gaussian spatial distribution in radians REAL ( rp ) :: R_buffer !! Previous sample of R location REAL ( rp ) :: Z_buffer !! Previous sample of Z location REAL ( rp ) :: eta_buffer !! Previous sample of pitch REAL ( rp ) :: G_buffer REAL ( rp ) :: R_test !! Present sample of R location REAL ( rp ) :: Z_test !! Present sample of Z location REAL ( rp ) :: eta_test !! Present sample of pitch angle REAL ( rp ) :: G_test REAL ( rp ) :: psi0 !! Previous value of 2D Gaussian argument based on R_buffer, Z_buffer REAL ( rp ) :: psi1 !! Present value of 2D Gaussian argument based on R_test, Z_test REAL ( rp ) :: PSIp_lim , PSIP0 , PSIN , PSIN0 , PSIN1 , sigma REAL ( rp ) :: f0 !! Evaluation of Avalanche distribution with previous sample REAL ( rp ) :: f1 !! Evaluation of Avalanche distribution with present sample REAL ( rp ) :: rand_unif !! Uniform random variable [0,1] REAL ( rp ) :: ratio !! MH selection criteria INTEGER :: nsamples !! Total number of samples to be distributed over all mpi processes INTEGER :: ii !! Sample iterator. INTEGER :: mpierr !! mpi error indicator REAL ( rp ) :: dg , deta LOGICAL :: accepted INTEGER , DIMENSION ( 33 ) :: seed = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) nsamples = spp % ppp * params % mpi_params % nmpi psi_max_buff = spp % psi_max * 1.25_rp theta_rad = C_PI * spp % theta_gauss / 18 0.0_rp params % GC_coords = . TRUE . PSIp_lim = F % PSIp_lim PSIp0 = F % PSIP_min if ( params % field_model . eq . 'M3D_C1' ) then min_R = params % rmin / params % cpp % length max_R = params % rmax / params % cpp % length min_Z = params % zmin / params % cpp % length max_Z = params % zmax / params % cpp % length else min_R = minval ( F % X % R ) max_R = maxval ( F % X % R ) min_Z = minval ( F % X % Z ) max_Z = maxval ( F % X % Z ) end if sigma = spp % sigmaR * params % cpp % length !write(output_unit_write,*) min_R,max_R !write(output_unit_write,*) min_Z,max_Z deta = ( h_params % max_pitch_angle - h_params % min_pitch_angle ) / 10 0.0_rp dg = ( h_params % max_sampling_g - h_params % min_sampling_g ) / 10 0.0_rp ! buffer at minimum gamma boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_sampling_g - REAL ( ii , rp ) * dg if ( minmax . GT . h_params % min_g ) then min_g = minmax end if ! buffer at maximum gamma boundary minmax = h_params % max_sampling_g + REAL ( ii , rp ) * dg if ( minmax . LT . h_params % max_g ) then max_g = minmax end if end do ! buffer at minimum pitch angle boundary if ( h_params % min_pitch_angle . GE . korc_zero ) then do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % min_pitch_angle - REAL ( ii , rp ) * deta if ( minmax . GT . 0.0_rp ) then min_pitch_angle = minmax end if end do else min_pitch_angle = h_params % min_pitch_angle end if ! buffer at maximum pitch angle boundary do ii = 1_idef , INT ( minmax_buffer_size , idef ) minmax = h_params % max_pitch_angle + REAL ( ii , rp ) * deta if ( minmax . LE . 18 0.0_rp ) then max_pitch_angle = minmax end if end do if ( params % mpi_params % rank . EQ . 0_idef ) then ALLOCATE ( R_samples ( nsamples )) ALLOCATE ( X_samples ( nsamples )) ALLOCATE ( Y_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( PHI_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( Z_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( eta_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ALLOCATE ( G_samples ( nsamples )) ! Number of samples to distribute among all MPI processes ! Transient ! R_buffer = spp % Ro Z_buffer = spp % Zo if (. not . params % SameRandSeed ) then call init_random_seed () else call random_seed ( put = seed ) end if !     call RANDOM_NUMBER(rand_unif) !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*rand_unif !     eta_buffer = min_pitch_angle + (max_pitch_angle & !          - min_pitch_angle)*get_random_mkl_U() eta_buffer = min_pitch_angle + ( max_pitch_angle & - min_pitch_angle ) * get_random_U () !     call RANDOM_NUMBER(rand_unif) !     G_buffer = min_g + (max_g - min_g)*rand_unif !     G_buffer = min_g + (max_g - min_g)*get_random_mkl_U() G_buffer = min_g + ( max_g - min_g ) * get_random_U () !     write(output_unit_write,*) 'R_buffer',R_buffer !     write(output_unit_write,*) 'Z_buffer',Z_buffer !     write(output_unit_write,*) 'eta_buffer',eta_buffer !     write(output_unit_write,*) 'G_buffer',G_buffer !     write(output_unit_write,'(\"length norm: \",E17.10)') params%cpp%length accepted = . false . ii = 1_idef do while ( ii . LE . 1000_idef ) if ( modulo ( ii , 100 ). eq . 0 ) then write ( output_unit_write , '(\"Burn: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do ! initialize 2D gaussian argument and distribution function, or ! copy from previous sample if ( ii == 1 ) then !           psi0=PSI_ROT_exp(R_buffer,spp%Ro,spp%sigmaR,Z_buffer,spp%Zo, & !                spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_buffer spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_buffer write ( output_unit_write , * ) 'R' , R_buffer write ( output_unit_write , * ) 'Z' , Z_buffer call get_fields ( params , spp % vars , F ) psi0 = spp % vars % PSI_P ( 1 ) PSIN0 = ( psi0 - PSIP0 ) / ( PSIp_lim - PSIP0 ) f0 = fRE_H_3D ( F , eta_buffer , G_buffer , R_buffer , Z_buffer , spp % Ro , spp % Zo ) !           f0=fRE_H(eta_buffer,G_buffer) end if if ( accepted ) then !psi0=psi1 PSIN0 = PSIN1 f0 = f1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0._rp spp % vars % Y ( 1 , 3 ) = Z_test call get_fields ( params , spp % vars , F ) psi1 = spp % vars % PSI_P ( 1 ) PSIN1 = ( psi1 - PSIP0 ) / ( PSIp_lim - PSIP0 ) write ( output_unit_write , * ) 'R' , R_test write ( output_unit_write , * ) 'Z' , Z_test write ( output_unit_write , * ) 'PSI' , psi1 write ( output_unit_write , * ) 'PSIN' , PSIN f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) !        write(output_unit_write,'(\"psi0: \",E17.10)') psi0 !        write(output_unit_write,'(\"psi1: \",E17.10)') psi1 !        write(output_unit_write,'(\"f0: \",E17.10)') f0 !        write(output_unit_write,'(\"f1: \",E17.10)') f1 ! Calculate acceptance ratio for MH algorithm. fRE function ! incorporates p&#94;2 factor of spherical coordinate Jacobian ! for velocity phase space, factors of sin(pitch angle) for velocity ! phase space and cylindrical coordinate Jacobian R for spatial ! phase space incorporated here. !        ratio = indicator_exp(PSIN,spp%psi_max)* & !             R_test*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*f0*sin(deg2rad(eta_buffer))) ratio = indicator_exp ( PSIN1 , spp % psi_max ) * & R_test * EXP ( - PSIN1 / sigma ) * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * EXP ( - PSIN0 / sigma ) * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef else !           call RANDOM_NUMBER(rand_unif) !           if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test ii = ii + 1_idef end if end if end do ! Transient ! ii = 1_idef do while ( ii . LE . nsamples ) !        write(output_unit_write,'(\"sample:\",I15)') ii if ( modulo ( ii , nsamples / 10 ). eq . 0 ) then write ( output_unit_write , '(\"Sample: \",I10)' ) ii end if !R_test = R_buffer + random_norm(0.0_rp,spp%dR) !R_test = R_buffer + get_random_mkl_N(0.0_rp,spp%dR) R_test = R_buffer + get_random_N () * spp % dR !Z_test = Z_buffer + random_norm(0.0_rp,spp%dZ) !Z_test = Z_buffer + get_random_mkl_N(0.0_rp,spp%dZ) Z_test = Z_buffer + get_random_N () * spp % dZ !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam ! Test that pitch angle and momentum are within chosen boundary do while (( ABS ( eta_test ) . GT . max_pitch_angle ). OR . & ( ABS ( eta_test ) . LT . min_pitch_angle )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) eta_test = eta_buffer + get_random_N () * spp % dth end do do while (( G_test . LT . min_g ). OR .( G_test . GT . max_g )) !G_test = G_buffer + random_norm(0.0_rp,spp%dgam) !G_test = G_buffer + get_random_mkl_N(0.0_rp,spp%dgam) G_test = G_buffer + get_random_N () * spp % dgam end do do while (( R_test . GT . max_R ). OR .( R_test . LT . min_R )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) R_test = R_buffer + get_random_N () * spp % dR end do do while (( Z_test . GT . max_Z ). OR .( Z_test . LT . min_Z )) !eta_test = eta_buffer + random_norm(0.0_rp,spp%dth) !eta_test = eta_buffer + get_random_mkl_N(0.0_rp,spp%dth) Z_test = Z_buffer + get_random_N () * spp % dZ end do if ( accepted ) then PSIN0 = PSIN1 f0 = f1 end if !        psi1=PSI_ROT_exp(R_test,spp%Ro,spp%sigmaR,Z_test,spp%Zo, & !             spp%sigmaZ,theta_rad) spp % vars % Y ( 1 , 1 ) = R_test spp % vars % Y ( 1 , 2 ) = 0 spp % vars % Y ( 1 , 3 ) = Z_test call get_fields ( params , spp % vars , F ) psi1 = spp % vars % PSI_P ( 1 ) PSIN1 = ( psi1 - PSIP0 ) / ( PSIp_lim - PSIP0 ) !        write(output_unit_write,'(\"R: \",E17.10)') R_test !        write(output_unit_write,'(\"R0: \",E17.10)') spp%Ro !        write(output_unit_write,'(\"sigma_R: \",E17.10)') spp%sigmaR !        write(output_unit_write,'(\"dR: \",E17.10)') spp%dR !        write(output_unit_write,'(\"N_dR: \",E17.10)') random_norm(0.0_rp,spp%dR) !        write(output_unit_write,'(\"Z: \",E17.10)') Z_test !        write(output_unit_write,'(\"Z0: \",E17.10)') spp%Zo !        write(output_unit_write,'(\"sigma_Z: \",E17.10)') spp%sigmaZ !        write(output_unit_write,'(\"dZ: \",E17.10)') spp%dZ !        write(output_unit_write,'(\"N_dR: \",Z17.10)') random_norm(0.0_rp,spp%dZ) f1 = fRE_H_3D ( F , eta_test , G_test , R_test , Z_test , spp % Ro , spp % Zo ) !        f1=fRE_H(eta_test,G_test) !        ratio = indicator_exp(PSIN,psi_max_buff)* & !             R_test*f1*sin(deg2rad(eta_test))/ & !             (R_buffer*f0*sin(deg2rad(eta_buffer))) ratio = indicator_exp ( PSIN1 , psi_max_buff ) * & R_test * EXP ( - PSIN1 / sigma ) * f1 * sin ( deg2rad ( eta_test )) / & ( R_buffer * EXP ( - PSIN0 / sigma ) * f0 * sin ( deg2rad ( eta_buffer ))) !        ratio = f1*sin(deg2rad(eta_test))/(f0*sin(deg2rad(eta_buffer))) accepted = . false . if ( ratio . GE . 1.0_rp ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test else !call RANDOM_NUMBER(rand_unif) !if (rand_unif .LT. ratio) then !if (get_random_mkl_U() .LT. ratio) then if ( get_random_U () . LT . ratio ) then accepted = . true . R_buffer = R_test Z_buffer = Z_test eta_buffer = eta_test G_buffer = G_test end if end if !        write(output_unit_write,'(\"R: \",E17.10)') R_buffer !        write(output_unit_write,'(\"Z: \",E17.10)') Z_buffer ! Only accept sample if it is within desired boundary, but ! add to MC above if within buffer. This helps make the boundary ! more defined. IF (( INT ( indicator_exp ( PSIN1 , spp % psi_max )). EQ . 1 ). AND . & ( G_buffer . LE . h_params % max_sampling_g ). AND . & ( G_buffer . GE . h_params % min_sampling_g ). AND . & ( eta_buffer . LE . h_params % max_pitch_angle ). AND . & ( eta_buffer . GE . h_params % min_pitch_angle ). AND . & ACCEPTED ) THEN R_samples ( ii ) = R_buffer Z_samples ( ii ) = Z_buffer eta_samples ( ii ) = eta_buffer G_samples ( ii ) = G_buffer !           write(output_unit_write,*) 'RS',R_buffer ! Sample phi location uniformly !call RANDOM_NUMBER(rand_unif) !PHI_samples(ii) = 2.0_rp*C_PI*rand_unif !PHI_samples(ii) = 2.0_rp*C_PI*get_random_mkl_U() PHI_samples ( ii ) = 2.0_rp * C_PI * get_random_U () ii = ii + 1_idef END IF end do !  if (minval(R_samples(:)).lt.1._rp/params%cpp%length) stop 'error with sample' !  write(output_unit_write,'(\"R_sample: \",E17.10)') R_samples(:)*params%cpp%length X_samples = R_samples * cos ( PHI_samples ) Y_samples = R_samples * sin ( PHI_samples ) !     write(output_unit_write,*) 'R_samples',R_samples !     write(output_unit_write,*) 'PHI_samples',PHI_samples !     write(output_unit_write,*) 'Z_samples',Z_samples !     write(output_unit_write,*) 'G_samples',G_samples !     write(output_unit_write,*) 'eta_samples',eta_samples end if params % GC_coords = . FALSE . call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( X_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 1 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Y_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 2 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( Z_samples , spp % ppp , MPI_REAL8 , & spp % vars % X (:, 3 ), spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( eta_samples , spp % ppp , MPI_REAL8 , & spp % vars % eta , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) CALL MPI_SCATTER ( G_samples , spp % ppp , MPI_REAL8 , & spp % vars % g , spp % ppp , MPI_REAL8 , 0 , MPI_COMM_WORLD , mpierr ) call MPI_BARRIER ( MPI_COMM_WORLD , mpierr ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varY',spp%vars%X(:,2) !  write(output_unit_write,'(\"X_X: \",E17.10)') spp%vars%X(:,1)*params%cpp%length ! gamma is kept for each particle, not the momentum if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) call cart_to_cyl ( spp % vars % X , spp % vars % Y ) !  write(output_unit_write,*) params%mpi_params%rank,'varX',spp%vars%X(:,1) !  write(output_unit_write,*) params%mpi_params%rank,'varR',spp%vars%Y(:,1) !  write(output_unit_write,'(\"Y_R: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_PHI: \",E17.10)') spp%vars%Y(:,1)*params%cpp%length !  write(output_unit_write,'(\"Y_Z: \",E17.10)') spp%vars%Y(:,3)*params%cpp%length !  if (minval(spp%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with avalanche' if ( params % mpi_params % rank . EQ . 0_idef ) then DEALLOCATE ( R_samples ) DEALLOCATE ( X_samples ) DEALLOCATE ( Y_samples ) DEALLOCATE ( Z_samples ) DEALLOCATE ( PHI_samples ) DEALLOCATE ( eta_samples ) DEALLOCATE ( G_samples ) end if end subroutine sample_Hollmann_distribution_3D_psi","tags":"","loc":"proc/sample_hollmann_distribution_3d_psi.html"},{"title":"save_params – KORC-Full Orbit","text":"private subroutine save_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_params Source Code SUBROUTINE save_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"experimental_distribution_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * pdf_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * pdf_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_p\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % max_p , attr ) dset = TRIM ( gname ) // \"/min_p\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % min_p , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Zeff , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , pdf_params % E , attr ) dset = TRIM ( gname ) // \"/k\" attr = \"Shape factor\" call save_to_hdf5 ( h5file_id , dset , pdf_params % k , attr ) dset = TRIM ( gname ) // \"/t\" attr = \"Scale factor\" call save_to_hdf5 ( h5file_id , dset , pdf_params % t , attr ) dset = TRIM ( gname ) // \"/fGo\" attr = \"Normalization of Gamma function\" call save_to_hdf5 ( h5file_id , dset , pdf_params % fGo , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Wavelength used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % lambda , attr ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Magnetic field used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , pdf_params % Bo , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_params","tags":"","loc":"proc/save_params~2.html"},{"title":"save_Hollmann_params – KORC-Full Orbit","text":"public subroutine save_Hollmann_params(params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Contents Source Code save_Hollmann_params Source Code SUBROUTINE save_Hollmann_params ( params ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ), DIMENSION (:), ALLOCATABLE :: attr_array CHARACTER ( MAX_STRING_LENGTH ) :: dset CHARACTER ( MAX_STRING_LENGTH ) :: attr INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER :: h5error REAL ( rp ) :: units if ( params % mpi_params % rank . EQ . 0 ) then filename = TRIM ( params % path_to_outputs ) // \"experimental_distribution_parameters.h5\" call h5fcreate_f ( TRIM ( filename ), H5F_ACC_TRUNC_F , h5file_id , h5error ) gname = \"pdf_params\" call h5gcreate_f ( h5file_id , TRIM ( gname ), group_id , h5error ) dset = TRIM ( gname ) // \"/max_pitch_angle\" attr = \"Maximum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , h_params % max_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_pitch_angle\" attr = \"Minimum pitch angle in PDF (degrees)\" call save_to_hdf5 ( h5file_id , dset , h_params % min_pitch_angle , attr ) dset = TRIM ( gname ) // \"/min_energy\" attr = \"Minimum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * h_params % min_energy , attr ) dset = TRIM ( gname ) // \"/max_energy\" attr = \"Maximum energy in PDF (eV)\" units = 1.0_rp / C_E call save_to_hdf5 ( h5file_id , dset , units * h_params % max_energy , attr ) dset = TRIM ( gname ) // \"/max_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % max_g , attr ) dset = TRIM ( gname ) // \"/min_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % min_g , attr ) dset = TRIM ( gname ) // \"/max_sampling_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % max_sampling_g , attr ) dset = TRIM ( gname ) // \"/min_sampling_g\" attr = \"Maximum momentum in PDF (me*c)\" call save_to_hdf5 ( h5file_id , dset , h_params % min_sampling_g , attr ) dset = TRIM ( gname ) // \"/Zeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , h_params % Zeff , attr ) dset = TRIM ( gname ) // \"/sigmaZeff\" attr = \"Effective atomic number of ions.\" call save_to_hdf5 ( h5file_id , dset , h_params % sigma_Z , attr ) dset = TRIM ( gname ) // \"/E\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , h_params % E , attr ) dset = TRIM ( gname ) // \"/sigmaE\" attr = \"Parallel electric field in (Ec)\" call save_to_hdf5 ( h5file_id , dset , h_params % sigma_E , attr ) dset = TRIM ( gname ) // \"/lambda\" attr = \"Wavelength used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , h_params % lambda , attr ) dset = TRIM ( gname ) // \"/Bo\" attr = \"Magnetic field used when PDF is weighted with the distribution of synchrotron radiation.\" call save_to_hdf5 ( h5file_id , dset , h_params % Bo , attr ) call h5gclose_f ( group_id , h5error ) call h5fclose_f ( h5file_id , h5error ) end if END SUBROUTINE save_Hollmann_params","tags":"","loc":"proc/save_hollmann_params.html"},{"title":"cross – KORC-Full Orbit","text":"private pure function cross(a, b) Note Function that calculates the cross product of the two\n vectors and . Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: a Vector . real(kind=rp), intent(in), DIMENSION(3) :: b Vector . Return Value real(kind=rp),\n  DIMENSION(3) Cross product Contents Source Code cross Source Code pure function cross ( a , b ) !! @note Function that calculates the cross product of the two !! vectors \\mathbf{a} and \\mathbf{b}. @endnote REAL ( rp ), DIMENSION ( 3 ) :: cross !! Cross product \\mathbf{a}\\times \\mathbf{b} REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: a !!  Vector \\mathbf{a}. REAL ( rp ), DIMENSION ( 3 ), INTENT ( IN ) :: b !!  Vector \\mathbf{b}. cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross","tags":"","loc":"proc/cross~2.html"},{"title":"analytical_fields – KORC-Full Orbit","text":"private subroutine analytical_fields(F, Y, E, B, flag) Note Subroutine that calculates and returns the analytic electric and\n magnetic field for each particle in the simulation. The analytical magnetic field is given by: where is the aspect ratio, the constant denotes the magnitude of the toroidal magnetic field,\n and is the poloidal magnetic\n field with \n safety factor .\n The constant is the safety factor at the magnetic axis and\n the constant is obtained from the values of and at the plasma edge . On the other hand,\n the analytical electric fields is given by: where is the electric field as measured at the mangetic axis. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Toroidal coordinates of each particle in the simulation; \n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in Cartesian coordinates; \n E(1,:) = , E(2,:) = , E(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in Cartesian coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). Contents Source Code analytical_fields Source Code subroutine analytical_fields ( F , Y , E , B , flag ) !! @note Subroutine that calculates and returns the analytic electric and !! magnetic field for each particle in the simulation. @endnote !! The analytical magnetic field is given by: !! !! \\mathbf{B}(r,\\vartheta) = \\frac{1}{1 + \\eta \\cos{\\vartheta}} !! \\left[ B_0 \\hat{e}_\\zeta + B_\\vartheta(r) \\hat{e}_\\vartheta \\right], !! !! where \\eta = r/R_0 is the aspect ratio, the constant B_0 !! denotes the magnitude of the toroidal magnetic field, !! and B_\\vartheta(r) = \\eta B_0/q(r) is the poloidal magnetic !! field with !! safety factor q(r) = q_0\\left( 1 + \\frac{r&#94;2}{\\lambda&#94;2} \\right). !! The constant q_0 is the safety factor at the magnetic axis and !! the constant \\lambda is obtained from the values of q_0 !! and q(r) at the plasma edge r=r_{edge}. On the other hand, !! the analytical electric fields is given by: !! !! \\mathbf{E}(r,\\vartheta) = \\frac{1}{1 + \\eta \\cos{\\vartheta}} !! E_0 \\hat{e}_\\zeta, !! !! where E_0 is the electric field as measured at the mangetic axis. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Toroidal coordinates of each particle in the simulation; !! Y(1,:) = r, Y(2,:) = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in Cartesian coordinates; !! B(1,:) = B_x, B(2,:) = B_y, B(3,:) = B_z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in Cartesian coordinates; !! E(1,:) = E_x, E(2,:) = E_y, E(3,:) = E_z INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ) :: eta !! Aspect ratio \\eta. REAL ( rp ) :: q !! Safety profile q(r). INTEGER ( ip ) :: pp ! Iterator(s) !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,Ezeta,Bp,Bzeta,eta,q) & !$OMP& SHARED(F,Y,E,B,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then eta = Y ( pp , 1 ) / F % Ro q = F % AB % qo * ( 1.0_rp + ( Y ( pp , 1 ) / F % AB % lambda ) ** 2 ) Bp = F % AB % Bp_sign * eta * F % AB % Bo / ( q * ( 1.0_rp + eta * COS ( Y ( pp , 2 )))) Bzeta = F % AB % Bo / ( 1.0_rp + eta * COS ( Y ( pp , 2 )) ) B ( pp , 1 ) = Bzeta * COS ( Y ( pp , 3 )) - Bp * SIN ( Y ( pp , 2 )) * SIN ( Y ( pp , 3 )) B ( pp , 2 ) = - Bzeta * SIN ( Y ( pp , 3 )) - Bp * SIN ( Y ( pp , 2 )) * COS ( Y ( pp , 3 )) B ( pp , 3 ) = Bp * COS ( Y ( pp , 2 )) if ( abs ( F % Eo ) > 0 ) then Ezeta = - F % Eo / ( 1.0_rp + eta * COS ( Y ( pp , 2 )) ) E ( pp , 1 ) = Ezeta * COS ( Y ( pp , 3 )) E ( pp , 2 ) = - Ezeta * SIN ( Y ( pp , 3 )) E ( pp , 3 ) = 0.0_rp end if end if end do !$OMP END PARALLEL DO end subroutine analytical_fields","tags":"","loc":"proc/analytical_fields.html"},{"title":"analytical_fields_p – KORC-Full Orbit","text":"public subroutine analytical_fields_p(pchunk, B0, E0, R0, q0, lam, ar, X_X, X_Y, X_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: B0 real(kind=rp), intent(in) :: E0 real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: q0 real(kind=rp), intent(in) :: lam real(kind=rp), intent(in) :: ar real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_X real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code analytical_fields_p Source Code subroutine analytical_fields_p ( pchunk , B0 , E0 , R0 , q0 , lam , ar , X_X , X_Y , X_Z , & B_X , B_Y , B_Z , E_X , E_Y , E_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: R0 , B0 , lam , q0 , E0 , ar REAL ( rp ), INTENT ( IN ), DIMENSION ( pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: B_X , B_Y , B_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: E_X , E_Y , E_Z INTEGER ( is ), INTENT ( INOUT ), DIMENSION ( pchunk ) :: flag_cache REAL ( rp ), DIMENSION ( pchunk ) :: T_R , T_T , T_Z REAL ( rp ), DIMENSION ( pchunk ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ), DIMENSION ( pchunk ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ), DIMENSION ( pchunk ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ), DIMENSION ( pchunk ) :: eta !! Aspect ratio \\eta. REAL ( rp ), DIMENSION ( pchunk ) :: q !! Safety profile q(r). REAL ( rp ), DIMENSION ( pchunk ) :: cT , sT , cZ , sZ INTEGER :: cc !! Particle chunk iterator. call cart_to_tor_check_if_confined_p ( pchunk , ar , R0 , X_X , X_Y , X_Z , & T_R , T_T , T_Z , flag_cache ) !$OMP SIMD !    !$OMP& aligned(cT,sT,cZ,sZ,eta,q,Bp,Bzeta,B_X,B_Y,B_Z, & !    !$OMP& Ezeta,E_X,E_Y,E_Z,T_T,T_Z,T_R) do cc = 1_idef , pchunk cT ( cc ) = cos ( T_T ( cc )) sT ( cc ) = sin ( T_T ( cc )) cZ ( cc ) = cos ( T_Z ( cc )) sZ ( cc ) = sin ( T_Z ( cc )) eta ( cc ) = T_R ( cc ) / R0 q ( cc ) = q0 * ( 1.0_rp + ( T_R ( cc ) * T_R ( cc ) / ( lam * lam ))) Bp ( cc ) = - eta ( cc ) * B0 / ( q ( cc ) * ( 1.0_rp + eta ( cc ) * cT ( cc ))) Bzeta ( cc ) = B0 / ( 1.0_rp + eta ( cc ) * cT ( cc )) B_X ( cc ) = Bzeta ( cc ) * cZ ( cc ) - Bp ( cc ) * sT ( cc ) * sZ ( cc ) B_Y ( cc ) = - Bzeta ( cc ) * sZ ( cc ) - Bp ( cc ) * sT ( cc ) * cZ ( cc ) B_Z ( cc ) = Bp ( cc ) * cT ( cc ) Ezeta ( cc ) = - E0 / ( 1.0_rp + eta ( cc ) * cT ( cc )) E_X ( cc ) = Ezeta ( cc ) * cZ ( cc ) E_Y ( cc ) = - Ezeta ( cc ) * sZ ( cc ) E_Z ( cc ) = 0.0_rp end do !$OMP END SIMD end subroutine analytical_fields_p","tags":"","loc":"proc/analytical_fields_p.html"},{"title":"analytical_fields_GC_init – KORC-Full Orbit","text":"private subroutine analytical_fields_GC_init(params, F, Y, E, B, gradB, curlB, flag, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Cylindrical coordinates of each particle in the simulation; \n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in cylindricalcoordinates; \n E(1,:) = , E(2,:) = , E(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in cylindrical coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: gradB Gradient of magnitude of magnetic field in cylindrical coordinates; \n gradB(1,:) = , B(2,:) = ,\n B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: curlB Curl of magnetic field unit vector in cylindrical coordinates integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: PSIp Contents Source Code analytical_fields_GC_init Source Code subroutine analytical_fields_GC_init ( params , F , Y , E , B , gradB , curlb , flag , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Cylindrical coordinates of each particle in the simulation; !! Y(1,:) = r, Y(2,:) = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION ( 3 ) :: Btmp !! Placeholder for magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: gradB !! Gradient of magnitude of magnetic field in cylindrical coordinates; !! gradB(1,:) = \\nabla_R B, B(2,:) = \\nabla_\\phi B_, !! B(3,:) = \\nabla_Z B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: curlB !! Curl of magnetic field unit vector in cylindrical coordinates REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in cylindricalcoordinates; !! E(1,:) = E_R, E(2,:) = E_\\phi, E(3,:) = E_Z REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: PSIp INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ) :: eta !! Aspect ratio \\eta. REAL ( rp ) :: q !! Safety profile q(r). INTEGER ( ip ) :: pp ! Iterator(s) !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. REAL ( rp ) :: dRBR REAL ( rp ) :: dRBPHI REAL ( rp ) :: dRBZ REAL ( rp ) :: dZBR REAL ( rp ) :: dZBPHI REAL ( rp ) :: dZBZ REAL ( rp ) :: Bmag REAL ( rp ) :: dRbhatPHI REAL ( rp ) :: dRbhatZ REAL ( rp ) :: dZbhatR REAL ( rp ) :: dZbhatPHI REAL ( rp ) :: qprof REAL ( rp ) :: rm , theta !    write(output_unit_write,'(\"Y: \",E17.10)') Y ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,rm,Btmp,qprof,dRBR,dRBPHI, & !$OMP dRBZ,dZBR,dZBPHI,dZBZ,Bmag,dRbhatPHI,dRbhatZ,dZbhatR,dZbhatPHI, & !$OMP theta,PSIp) & !$OMP& SHARED(F,Y,E,B,gradB,curlb,flag) do pp = 1_idef , ss !       if ( flag(pp) .EQ. 1_is ) then rm = sqrt (( Y ( pp , 1 ) - F % AB % Ro ) ** 2 + Y ( pp , 3 ) ** 2 ) theta = atan2 ( Y ( pp , 3 ),( Y ( pp , 1 ) - F % AB % Ro )) qprof = 1.0_rp + ( rm / F % AB % lambda ) ** 2 PSIp ( pp ) = Y ( pp , 1 ) * F % AB % lambda ** 2 * F % Bo / & ( 2 * F % AB % qo * ( F % AB % Ro + rm * cos ( theta ))) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) Btmp ( 1 ) = F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) Btmp ( 2 ) =- F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) Btmp ( 3 ) =- F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * qprof * Y ( pp , 1 )) B ( pp , 1 ) = Btmp ( 1 ) * COS ( Y ( pp , 2 )) - Btmp ( 2 ) * SIN ( Y ( pp , 2 )) B ( pp , 2 ) = Btmp ( 1 ) * SIN ( Y ( pp , 2 )) + Btmp ( 2 ) * COS ( Y ( pp , 2 )) B ( pp , 3 ) = Btmp ( 3 ) dRBR =- F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1. / Y ( pp , 1 ) + & 2 * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % lambda ** 2 * qprof )) dRBPHI = F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) ** 2 dRBZ = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( - F % AB % Ro / Y ( pp , 1 ) + 2 * ( Y ( pp , 1 ) - & F % AB % Ro ) ** 2 / ( F % AB % lambda ** 2 * qprof )) dZBR = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1 - 2 * Y ( pp , 3 ) * Y ( pp , 3 ) / & ( F % AB % lambda ** 2 * qprof )) dZBPHI = 0._rp dZBZ = F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * Y ( pp , 1 )) * 2 * Y ( pp , 3 ) / & (( F % AB % lambda * qprof ) ** 2 ) Bmag = sqrt ( B ( pp , 1 ) * B ( pp , 1 ) + B ( pp , 2 ) * B ( pp , 2 ) + B ( pp , 3 ) * B ( pp , 3 )) gradB ( pp , 1 ) = ( B ( pp , 1 ) * dRBR + B ( pp , 2 ) * dRBPHI + B ( pp , 3 ) * dRBZ ) / Bmag gradB ( pp , 2 ) = 0._rp gradB ( pp , 3 ) = ( B ( pp , 1 ) * dZBR + B ( pp , 2 ) * dZBPHI + B ( pp , 3 ) * dZBZ ) / Bmag dRbhatPHI = ( Bmag * dRBPHI - B ( pp , 2 ) * gradB ( pp , 1 )) / Bmag ** 2 dRbhatZ = ( Bmag * dRBZ - B ( pp , 3 ) * gradB ( pp , 1 )) / Bmag ** 2 dZbhatR = ( Bmag * dZBR - B ( pp , 1 ) * gradB ( pp , 3 )) / Bmag ** 2 dZbhatPHI = ( Bmag * dZBPHI - B ( pp , 2 ) * gradB ( pp , 3 )) / Bmag ** 2 curlb ( pp , 1 ) =- dZbhatPHI curlb ( pp , 2 ) = dZbhatR - dRbhatZ curlb ( pp , 3 ) = B ( pp , 2 ) / ( Bmag * Y ( pp , 1 )) + dRbhatPHI !          if (abs(F%Eo) > 0) then E ( pp , 1 ) = 0.0_rp E ( pp , 2 ) = F % Eo * F % AB % Ro / Y ( pp , 1 ) E ( pp , 3 ) = 0.0_rp !         end if !      end if end do !$OMP END PARALLEL DO end subroutine analytical_fields_GC_init","tags":"","loc":"proc/analytical_fields_gc_init.html"},{"title":"analytical_fields_GC – KORC-Full Orbit","text":"private subroutine analytical_fields_GC(params, F, Y, E, B, gradB, curlB, flag, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Cylindrical coordinates of each particle in the simulation; \n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in cylindricalcoordinates; \n E(1,:) = , E(2,:) = , E(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in cylindrical coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: gradB Gradient of magnitude of magnetic field in cylindrical coordinates; \n gradB(1,:) = , B(2,:) = ,\n B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: curlB Curl of magnetic field unit vector in cylindrical coordinates integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: PSIp Contents Source Code analytical_fields_GC Source Code subroutine analytical_fields_GC ( params , F , Y , E , B , gradB , curlb , flag , PSIp ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Cylindrical coordinates of each particle in the simulation; !! Y(1,:) = r, Y(2,:) = \\theta, Y(3,:) = \\zeta. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION ( 3 ) :: Btmp !! Placeholder for magnetic field components in cylindrical coordinates; !! B(1,:) = B_R, B(2,:) = B_\\phi, B(3,:) = B_Z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: gradB !! Gradient of magnitude of magnetic field in cylindrical coordinates; !! gradB(1,:) = \\nabla_R B, B(2,:) = \\nabla_\\phi B_, !! B(3,:) = \\nabla_Z B REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: curlB !! Curl of magnetic field unit vector in cylindrical coordinates REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in cylindricalcoordinates; !! E(1,:) = E_R, E(2,:) = E_\\phi, E(3,:) = E_Z REAL ( rp ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: PSIp INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ezeta !! Toroidal electric field E_\\zeta. REAL ( rp ) :: Bzeta !! Toroidal magnetic field B_\\zeta. REAL ( rp ) :: Bp !! Poloidal magnetic field B_\\theta(r). REAL ( rp ) :: eta !! Aspect ratio \\eta. REAL ( rp ) :: q !! Safety profile q(r). INTEGER ( ip ) :: pp ! Iterator(s) !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. REAL ( rp ) :: dRBR REAL ( rp ) :: dRBPHI REAL ( rp ) :: dRBZ REAL ( rp ) :: dZBR REAL ( rp ) :: dZBPHI REAL ( rp ) :: dZBZ REAL ( rp ) :: Bmag REAL ( rp ) :: dRbhatPHI REAL ( rp ) :: dRbhatZ REAL ( rp ) :: dZbhatR REAL ( rp ) :: dZbhatPHI REAL ( rp ) :: qprof REAL ( rp ) :: rm , theta ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,rm,Btmp,qprof,dRBR,dRBPHI, & !$OMP dRBZ,dZBR,dZBPHI,dZBZ,Bmag,dRbhatPHI,dRbhatZ,dZbhatR,dZbhatPHI, & !$OMP theta) & !$OMP& SHARED(F,Y,E,B,gradB,curlb,flag,PSIp) do pp = 1_idef , ss !       if ( flag(pp) .EQ. 1_is ) then rm = sqrt (( Y ( pp , 1 ) - F % AB % Ro ) ** 2 + Y ( pp , 3 ) ** 2 ) theta = atan2 ( Y ( pp , 3 ),( Y ( pp , 1 ) - F % AB % Ro )) qprof = 1.0_rp + ( rm / F % AB % lambda ) ** 2 !       write(output_unit_write,*) 'rm: ',rm !       write(output_unit_write,*) 'R0: ',F%AB%Ro !       write(output_unit_write,*) 'Y_R: ',Y(pp,1) !       write(output_unit_write,*) 'theta: ',theta PSIp ( pp ) = Y ( pp , 1 ) * F % AB % lambda ** 2 * F % Bo / & ( 2 * F % AB % qo * ( F % AB % Ro + rm * cos ( theta ))) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) !       write(output_unit_write,*) 'PSIp: ',PSIp(pp) Btmp ( 1 ) = F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) Btmp ( 2 ) =- F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) Btmp ( 3 ) =- F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * qprof * Y ( pp , 1 )) B ( pp , 1 ) = Btmp ( 1 ) B ( pp , 2 ) = Btmp ( 2 ) B ( pp , 3 ) = Btmp ( 3 ) dRBR =- F % AB % Bo * Y ( pp , 3 ) / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1. / Y ( pp , 1 ) + & 2 * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % lambda ** 2 * qprof )) dRBPHI = F % AB % Bo * F % AB % Ro / Y ( pp , 1 ) ** 2 dRBZ = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( - F % AB % Ro / Y ( pp , 1 ) + 2 * ( Y ( pp , 1 ) - & F % AB % Ro ) ** 2 / ( F % AB % lambda ** 2 * qprof )) dZBR = F % AB % Bo / ( F % AB % qo * qprof * Y ( pp , 1 )) * ( 1 - 2 * Y ( pp , 3 ) * Y ( pp , 3 ) / & ( F % AB % lambda ** 2 * qprof )) dZBPHI = 0._rp dZBZ = F % AB % Bo * ( Y ( pp , 1 ) - F % AB % Ro ) / ( F % AB % qo * Y ( pp , 1 )) * 2 * Y ( pp , 3 ) / & (( F % AB % lambda * qprof ) ** 2 ) Bmag = sqrt ( B ( pp , 1 ) * B ( pp , 1 ) + B ( pp , 2 ) * B ( pp , 2 ) + B ( pp , 3 ) * B ( pp , 3 )) gradB ( pp , 1 ) = ( B ( pp , 1 ) * dRBR + B ( pp , 2 ) * dRBPHI + B ( pp , 3 ) * dRBZ ) / Bmag gradB ( pp , 2 ) = 0._rp gradB ( pp , 3 ) = ( B ( pp , 1 ) * dZBR + B ( pp , 2 ) * dZBPHI + B ( pp , 3 ) * dZBZ ) / Bmag dRbhatPHI = ( Bmag * dRBPHI - B ( pp , 2 ) * gradB ( pp , 1 )) / Bmag ** 2 dRbhatZ = ( Bmag * dRBZ - B ( pp , 3 ) * gradB ( pp , 1 )) / Bmag ** 2 dZbhatR = ( Bmag * dZBR - B ( pp , 1 ) * gradB ( pp , 3 )) / Bmag ** 2 dZbhatPHI = ( Bmag * dZBPHI - B ( pp , 2 ) * gradB ( pp , 3 )) / Bmag ** 2 curlb ( pp , 1 ) =- dZbhatPHI curlb ( pp , 2 ) = dZbhatR - dRbhatZ curlb ( pp , 3 ) = B ( pp , 2 ) / ( Bmag * Y ( pp , 1 )) + dRbhatPHI !          if (abs(F%Eo) > 0) then E ( pp , 1 ) = 0.0_rp E ( pp , 2 ) = F % Eo * F % AB % Ro / Y ( pp , 1 ) E ( pp , 3 ) = 0.0_rp !         end if !      end if end do !$OMP END PARALLEL DO !    write(output_unit_write,*) 'PSIp: ',PSIp(:) !    write(output_unit_write,*) 'B_PHI: ',B(:,2) end subroutine analytical_fields_GC","tags":"","loc":"proc/analytical_fields_gc.html"},{"title":"analytical_fields_Bmag_p – KORC-Full Orbit","text":"public subroutine analytical_fields_Bmag_p(pchunk, F, Y_R, Y_PHI, Y_Z, Bmag, E_PHI) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: Bmag real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI Contents Source Code analytical_fields_Bmag_p Source Code subroutine analytical_fields_Bmag_p ( pchunk , F , Y_R , Y_PHI , Y_Z , Bmag , E_PHI ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ) :: R0 , B0 , lam , q0 , EF0 REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ) :: B_R , B_PHI , B_Z , rm , qprof REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Bmag , E_PHI integer ( ip ) :: cc B0 = F % Bo EF0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,rm,qprof,Bmag) do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) * ( Y_R ( cc ) - R0 ) + Y_Z ( cc ) * Y_Z ( cc )) qprof ( cc ) = 1.0_rp + ( rm ( cc ) * rm ( cc ) / ( lam * lam )) B_R ( cc ) = B0 * Y_Z ( cc ) / ( q0 * qprof ( cc ) * Y_R ( cc )) B_PHI ( cc ) =- B0 * R0 / Y_R ( cc ) B_Z ( cc ) =- B0 * ( Y_R ( cc ) - R0 ) / ( q0 * qprof ( cc ) * Y_R ( cc )) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) E_PHI ( cc ) = EF0 * R0 / Y_R ( cc ) end do !$OMP END SIMD end subroutine analytical_fields_Bmag_p","tags":"","loc":"proc/analytical_fields_bmag_p.html"},{"title":"add_analytical_E_p – KORC-Full Orbit","text":"public subroutine add_analytical_E_p(params, tt, F, E_PHI, Y_R) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params integer(kind=ip), intent(in) :: tt type(FIELDS), intent(in) :: F real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R Contents Source Code add_analytical_E_p Source Code subroutine add_analytical_E_p ( params , tt , F , E_PHI , Y_R ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( FIELDS ), INTENT ( IN ) :: F INTEGER ( ip ), INTENT ( IN ) :: tt REAL ( rp ) :: E_dyn , E_pulse , E_width , time , arg , arg1 , R0 REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( INOUT ) :: E_PHI REAL ( rp ), DIMENSION ( params % pchunk ), INTENT ( IN ) :: Y_R integer ( ip ) :: cc , pchunk pchunk = params % pchunk time = params % init_time + ( params % it - 1 + tt ) * params % dt E_dyn = F % E_dyn E_pulse = F % E_pulse E_width = F % E_width R0 = F % Ro !write(output_unit_write,*) E_dyn,E_pulse,E_width,R0 !$OMP SIMD !    !$OMP& aligned(E_PHI) do cc = 1_idef , pchunk arg = ( time - E_pulse ) ** 2 / ( 2._rp * E_width ** 2 ) arg1 = 1 0._rp * ( time - E_pulse ) / ( sqrt ( 2._rp ) * E_width ) E_PHI ( cc ) = E_PHI ( cc ) + R0 * E_dyn / Y_R ( cc ) * exp ( - arg ) * ( 1._rp + erf ( - arg1 )) / 2._rp end do !$OMP END SIMD !write(output_unit_write,*) arg,arg1 end subroutine add_analytical_E_p","tags":"","loc":"proc/add_analytical_e_p.html"},{"title":"analytical_fields_GC_p – KORC-Full Orbit","text":"public subroutine analytical_fields_GC_p(pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlB_R, curlB_PHI, curlB_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp Contents Source Code analytical_fields_GC_p Source Code subroutine analytical_fields_GC_p ( pchunk , F , Y_R , Y_PHI , & Y_Z , B_R , B_PHI , B_Z , E_R , E_PHI , E_Z , curlb_R , curlb_PHI , curlb_Z , gradB_R , & gradB_PHI , gradB_Z , PSIp ) INTEGER , INTENT ( IN ) :: pchunk TYPE ( FIELDS ), INTENT ( IN ) :: F REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Y_R , Y_PHI , Y_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: B_R , B_PHI , B_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: gradB_R , gradB_PHI , gradB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: curlB_R , curlB_PHI , curlB_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: E_R , E_PHI , E_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: PSIp REAL ( rp ), DIMENSION ( pchunk ) :: dRBR , dRBPHI , dRBZ , dZBR , dZBPHI , dZBZ , Bmag , dRbhatPHI REAL ( rp ), DIMENSION ( pchunk ) :: dRbhatZ , dZbhatR , dZbhatPHI , qprof , rm , theta REAL ( rp ) :: B0 , E0 , lam , R0 , q0 integer ( ip ) :: cc B0 = F % Bo E0 = F % Eo lam = F % AB % lambda R0 = F % AB % Ro q0 = F % AB % qo !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,B_R,B_PHI,B_Z,gradB_R,gradB_PHI,gradB_Z, & !    !$OMP& curlB_R,curlB_PHI,curlB_Z,E_R,E_PHI,E_Z,PSIp) do cc = 1_idef , pchunk rm ( cc ) = sqrt (( Y_R ( cc ) - R0 ) * ( Y_R ( cc ) - R0 ) + Y_Z ( cc ) * Y_Z ( cc )) theta ( cc ) = atan2 ( Y_Z ( cc ),( Y_R ( cc ) - R0 )) qprof ( cc ) = 1.0_rp + ( rm ( cc ) * rm ( cc ) / ( lam * lam )) PSIp ( cc ) = Y_R ( cc ) * lam ** 2 * B0 / & ( 2 * q0 * ( R0 + rm ( cc ) * cos ( theta ( cc )))) * & log ( 1 + ( rm ( cc ) / lam ) ** 2 ) B_R ( cc ) = B0 * Y_Z ( cc ) / ( q0 * qprof ( cc ) * Y_R ( cc )) B_PHI ( cc ) =- B0 * R0 / Y_R ( cc ) B_Z ( cc ) =- B0 * ( Y_R ( cc ) - R0 ) / ( q0 * qprof ( cc ) * Y_R ( cc )) dRBR ( cc ) =- B0 * Y_Z ( cc ) / ( q0 * qprof ( cc ) * Y_R ( cc )) * ( 1. / Y_R ( cc ) + & 2 * ( Y_R ( cc ) - R0 ) / ( lam * lam * qprof ( cc ))) dRBPHI ( cc ) = B0 * R0 / ( Y_R ( cc ) * Y_R ( cc )) dRBZ ( cc ) = B0 / ( q0 * qprof ( cc ) * Y_R ( cc )) * ( - R0 / Y_R ( cc ) + 2 * ( Y_R ( cc ) - & R0 ) * ( Y_R ( cc ) - R0 ) / ( lam * lam * qprof ( cc ))) dZBR ( cc ) = B0 / ( q0 * qprof ( cc ) * Y_R ( cc )) * ( 1 - 2 * Y_Z ( cc ) * Y_Z ( cc ) / & ( lam * lam * qprof ( cc ))) dZBPHI ( cc ) = 0._rp dZBZ ( cc ) = B0 * ( Y_R ( cc ) - R0 ) / ( q0 * Y_R ( cc )) * 2 * Y_Z ( cc ) / & ( lam * lam * qprof ( cc ) * qprof ( cc )) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + B_Z ( cc ) * B_Z ( cc )) gradB_R ( cc ) = ( B_R ( cc ) * dRBR ( cc ) + B_PHI ( cc ) * dRBPHI ( cc ) + B_Z ( cc ) * dRBZ ( cc )) / & Bmag ( cc ) gradB_PHI ( cc ) = 0._rp gradB_Z ( cc ) = ( B_R ( cc ) * dZBR ( cc ) + B_PHI ( cc ) * dZBPHI ( cc ) + B_Z ( cc ) * dZBZ ( cc )) / & Bmag ( cc ) dRbhatPHI ( cc ) = ( Bmag ( cc ) * dRBPHI ( cc ) - B_PHI ( cc ) * gradB_R ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) dRbhatZ ( cc ) = ( Bmag ( cc ) * dRBZ ( cc ) - B_Z ( cc ) * gradB_R ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) dZbhatR ( cc ) = ( Bmag ( cc ) * dZBR ( cc ) - B_R ( cc ) * gradB_Z ( cc )) / ( Bmag ( cc ) * Bmag ( cc )) dZbhatPHI ( cc ) = ( Bmag ( cc ) * dZBPHI ( cc ) - B_PHI ( cc ) * gradB_Z ( cc )) / & ( Bmag ( cc ) * Bmag ( cc )) curlb_R ( cc ) =- dZbhatPHI ( cc ) curlb_PHI ( cc ) = dZbhatR ( cc ) - dRbhatZ ( cc ) curlb_Z ( cc ) = B_PHI ( cc ) / ( Bmag ( cc ) * Y_R ( cc )) + dRbhatPHI ( cc ) E_R ( cc ) = 0.0_rp E_PHI ( cc ) = E0 * R0 / Y_R ( cc ) E_Z ( cc ) = 0.0_rp end do !$OMP END SIMD end subroutine analytical_fields_GC_p","tags":"","loc":"proc/analytical_fields_gc_p.html"},{"title":"uniform_magnetic_field – KORC-Full Orbit","text":"private subroutine uniform_magnetic_field(F, B) Note Subroutine that returns the value of a uniform magnetic\n field. This subroutine is used only when the simulation is ran for a\n 'UNIFORM' plasma. As a convention, in a uniform plasma we\n set . Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in Cartesian coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = Contents Source Code uniform_magnetic_field Source Code subroutine uniform_magnetic_field ( F , B ) !! @note Subroutine that returns the value of a uniform magnetic !! field. @endnote !! This subroutine is used only when the simulation is ran for a !! 'UNIFORM' plasma. As a convention, in a uniform plasma we !! set \\mathbf{B} = B_0 \\hat{x}. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: B !! Magnetic field components in Cartesian coordinates; !! B(1,:) = B_x, B(2,:) = B_y, B(3,:) = B_z B (:, 1 ) = F % Bo B (:, 2 : 3 ) = 0.0_rp end subroutine uniform_magnetic_field","tags":"","loc":"proc/uniform_magnetic_field.html"},{"title":"uniform_electric_field – KORC-Full Orbit","text":"private subroutine uniform_electric_field(F, E) Note Subroutine that returns the value of a uniform electric\n field. This subroutie is used only when the simulation is ran for a\n 'UNIFORM' plasma. As a convention, in a uniform plasma we set . Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in Cartesian coordinates; \n E(1,:) = , E(2,:) = , E(3,:) = Contents Source Code uniform_electric_field Source Code subroutine uniform_electric_field ( F , E ) !! @note Subroutine that returns the value of a uniform electric !! field. @endnote !! This subroutie is used only when the simulation is ran for a !! 'UNIFORM' plasma. As a convention, in a uniform plasma we set !! \\mathbf{E} = E_0 \\hat{x}. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in Cartesian coordinates; !! E(1,:) = E_x, E(2,:) = E_y, E(3,:) = E_z E (:, 1 ) = F % Eo E (:, 2 : 3 ) = 0.0_rp end subroutine uniform_electric_field","tags":"","loc":"proc/uniform_electric_field.html"},{"title":"analytical_electric_field_cyl – KORC-Full Orbit","text":"private subroutine analytical_electric_field_cyl(F, Y, E, flag) Note Subrotuine that calculates and returns the electric field using the\n same analytical model of the 'analytical_fields' subroutine. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Cylindrical coordinates of each particle in the simulation;\n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in Cartesian coordinates;\n  E(1,:) = , E(2,:) = , E(3,:) = integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). Contents Source Code analytical_electric_field_cyl Source Code subroutine analytical_electric_field_cyl ( F , Y , E , flag ) !! @note Subrotuine that calculates and returns the electric field using the !! same analytical model of the 'analytical_fields' subroutine. @endnote TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Y !! Cylindrical coordinates of each particle in the simulation; !! Y(1,:) = R, Y(2,:) = \\phi, Y(3,:) = Z. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: E !! Electric field components in Cartesian coordinates; !!  E(1,:) = E_x, E(2,:) = E_y, E(3,:) = E_z INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( IN ) :: flag !! Flag for each particle to decide whether it is being followed (flag=T) !! or not (flag=F). REAL ( rp ) :: Ephi !! Azimuthal electric field. INTEGER ( ip ) :: pp !! Particle iterator. INTEGER ( ip ) :: ss !! Particle species iterator. if ( abs ( F % Eo ) > 0 ) then ss = SIZE ( Y , 1 ) !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp,Ephi) SHARED(F,Y,E,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then Ephi = F % Eo * F % Ro / Y ( pp , 1 ) E ( pp , 1 ) = - Ephi * SIN ( Y ( pp , 2 )) E ( pp , 2 ) = Ephi * COS ( Y ( pp , 2 )) E ( pp , 3 ) = 0.0_rp end if end do !$OMP END PARALLEL DO end if end subroutine analytical_electric_field_cyl","tags":"","loc":"proc/analytical_electric_field_cyl.html"},{"title":"mean_F_field – KORC-Full Orbit","text":"public subroutine mean_F_field(F, Fo, op_field) Note Subroutine that calculates the mean electric or magnetic field in\n case external fields are being used. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(out) :: Fo Mean electric or magnetic field. type(KORC_STRING), intent(in) :: op_field String that specifies what mean field will be calculated.\n Its value can be 'B' or 'E'. Contents Source Code mean_F_field Source Code subroutine mean_F_field ( F , Fo , op_field ) !! @note Subroutine that calculates the mean electric or magnetic field in !! case external fields are being used. @endnote TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), INTENT ( OUT ) :: Fo !! Mean electric or magnetic field. TYPE ( KORC_STRING ), INTENT ( IN ) :: op_field !!String that specifies what mean field will be calculated. !! Its value can be 'B' or 'E'. if ( TRIM ( op_field % str ) . EQ . 'B' ) then if ( ALLOCATED ( F % B_3D % R )) then ! 3D field Fo = SUM ( SQRT ( F % B_3D % R ** 2 + F % B_3D % PHI ** 2 + F % B_3D % Z ** 2 ) ) / & SIZE ( F % B_3D % R ) else if ( ALLOCATED ( F % B_2D % R )) then ! Axisymmetric 2D field Fo = SUM ( SQRT ( F % B_2D % R ** 2 + F % B_2D % PHI ** 2 + F % B_2D % Z ** 2 ) ) / & SIZE ( F % B_2D % R ) end if else if ( TRIM ( op_field % str ) . EQ . 'E' ) then if ( ALLOCATED ( F % E_3D % R )) then ! 3D field Fo = SUM ( SQRT ( F % E_3D % R ** 2 + F % E_3D % PHI ** 2 + F % E_3D % Z ** 2 ) ) / & SIZE ( F % E_3D % R ) else if ( ALLOCATED ( F % E_2D % R )) then ! Axisymmetric 2D field Fo = SUM ( SQRT ( F % E_2D % R ** 2 + F % E_2D % PHI ** 2 + F % E_2D % Z ** 2 ) ) / & SIZE ( F % E_2D % R ) end if else write ( output_unit_write , '(\"KORC ERROR: Please enter a valid field: mean_F_field\")' ) call korc_abort () end if end subroutine mean_F_field","tags":"","loc":"proc/mean_f_field.html"},{"title":"get_analytical_fields – KORC-Full Orbit","text":"private subroutine get_analytical_fields(params, vars, F) Note Interface for calculating the analytical electric and magnetic\n fields for each particle in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: vars An instance of the KORC derived type PARTICLES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code get_analytical_fields Source Code subroutine get_analytical_fields ( params , vars , F ) !! @note Interface for calculating the analytical electric and magnetic !! fields for each particle in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of the KORC derived type PARTICLES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. if ( params % orbit_model ( 1 : 2 ). eq . 'FO' ) then call cart_to_tor_check_if_confined ( vars % X , F , vars % Y , vars % flagCon ) call analytical_fields ( F , vars % Y , vars % E , vars % B , vars % flagCon ) !       call cart_to_cyl(vars%X,vars%Y) elseif ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then if (. not . params % GC_coords ) then call cart_to_cyl ( vars % X , vars % Y ) call cyl_check_if_confined ( F , vars % Y , vars % flagCon ) call analytical_fields_GC_init ( params , F , vars % Y , vars % E , vars % B , & vars % gradB , vars % curlb , vars % flagCon , vars % PSI_P ) else call cyl_check_if_confined ( F , vars % Y , vars % flagCon ) call analytical_fields_GC ( params , F , vars % Y , vars % E , vars % B , & vars % gradB , vars % curlb , vars % flagCon , vars % PSI_P ) end if endif end subroutine get_analytical_fields","tags":"","loc":"proc/get_analytical_fields.html"},{"title":"uniform_fields – KORC-Full Orbit","text":"private subroutine uniform_fields(vars, F) Note Interface for calculating the uniform electric and magnetic\n fields for each particle in the simulation. Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars An instance of the KORC derived type PARTICLES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code uniform_fields Source Code subroutine uniform_fields ( vars , F ) !! @note Interface for calculating the uniform electric and magnetic !! fields for each particle in the simulation. @endnote TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !! An instance of the KORC derived type PARTICLES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. call uniform_magnetic_field ( F , vars % B ) call uniform_electric_field ( F , vars % E ) end subroutine uniform_fields","tags":"","loc":"proc/uniform_fields.html"},{"title":"unitVectors – KORC-Full Orbit","text":"public subroutine unitVectors(params, Xo, F, b1, b2, b3, flag, cart, hint) Note Subrotuine that calculates an orthonormal basis using information \n of the (local) magnetic field at position . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Xo Array with the position of the simulated particles. type(FIELDS), intent(in) :: F F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: b1 Basis vector pointing along the local magnetic field, \n that is, along . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: b2 Basis vector perpendicular to b1 real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: b3 Basis vector perpendicular to b1 and b2. integer(kind=is), intent(inout), optional DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being \n followed (flag=T) or not (flag=F). logical :: cart type(C_PTR), intent(inout), DIMENSION(:), ALLOCATABLE :: hint Flag for each particle to decide whether it is being \n followed (flag=T) or not (flag=F). Contents Source Code unitVectors Source Code subroutine unitVectors ( params , Xo , F , b1 , b2 , b3 , flag , cart , hint ) !! @note Subrotuine that calculates an orthonormal basis using information !! of the (local) magnetic field at position \\mathbf{X}_0. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Xo !! Array with the position of the simulated particles. TYPE ( FIELDS ), INTENT ( IN ) :: F !! F An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: b1 !! Basis vector pointing along the local magnetic field, !! that is, along \\mathbf{b} = \\mathbf{B}/B. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: b2 !!  Basis vector perpendicular to b1 REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: b3 !! Basis vector perpendicular to b1 and b2. INTEGER ( is ), DIMENSION (:), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: flag !! Flag for each particle to decide whether it is being !! followed (flag=T) or not (flag=F). TYPE ( C_PTR ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: hint !! Flag for each particle to decide whether it is being !! followed (flag=T) or not (flag=F). TYPE ( PARTICLES ) :: vars !! A temporary instance of the KORC derived type PARTICLES. INTEGER :: ii !! Iterator. INTEGER :: ppp !! Number of particles. LOGICAL :: cart !    write(output_unit_write,*) 'in unitVector' ppp = SIZE ( Xo , 1 ) ! Number of particles ALLOCATE ( vars % X ( ppp , 3 ) ) ALLOCATE ( vars % Y ( ppp , 3 ) ) ALLOCATE ( vars % B ( ppp , 3 ) ) ALLOCATE ( vars % gradB ( ppp , 3 ) ) ALLOCATE ( vars % curlb ( ppp , 3 ) ) ALLOCATE ( vars % PSI_P ( ppp ) ) ALLOCATE ( vars % E ( ppp , 3 ) ) ALLOCATE ( vars % flagCon ( ppp ) ) ALLOCATE ( vars % hint ( ppp ) ) vars % X = Xo vars % hint = hint vars % flagCon = 1_idef vars % B = 0._rp vars % PSI_P = 0._rp vars % cart = . false . !write(output_unit_write,*) 'before init_random_seed' call init_random_seed () ! write(output_unit_write,*) 'before get_fields' call get_fields ( params , vars , F ) !    write(output_unit_write,'(\"Bx: \",E17.10)') vars%B(:,1) !    write(output_unit_write,'(\"By: \",E17.10)') vars%B(:,2) !    write(output_unit_write,'(\"Bz: \",E17.10)') vars%B(:,3) !write(output_unit_write,*) 'before b1,b2,b3 calculation' do ii = 1_idef , ppp if ( vars % flagCon ( ii ) . EQ . 1_idef ) then b1 ( ii ,:) = vars % B ( ii ,:) / sqrt ( vars % B ( ii , 1 ) * vars % B ( ii , 1 ) + & vars % B ( ii , 2 ) * vars % B ( ii , 2 ) + vars % B ( ii , 3 ) * vars % B ( ii , 3 )) b2 ( ii ,:) = cross ( b1 ( ii ,:),( / 0.0_rp , 0.0_rp , 1.0_rp / )) b2 ( ii ,:) = b2 ( ii ,:) / sqrt ( b2 ( ii , 1 ) * b2 ( ii , 1 ) + b2 ( ii , 2 ) * b2 ( ii , 2 ) + & b2 ( ii , 3 ) * b2 ( ii , 3 )) b3 ( ii ,:) = cross ( b1 ( ii ,:), b2 ( ii ,:)) b3 ( ii ,:) = b3 ( ii ,:) / sqrt ( b3 ( ii , 1 ) * b3 ( ii , 1 ) + b3 ( ii , 2 ) * b3 ( ii , 2 ) + & b3 ( ii , 3 ) * b3 ( ii , 3 )) end if end do !write(output_unit_write,*) 'before copying hint and flag' hint = vars % hint if ( PRESENT ( flag )) then flag = vars % flagCon end if DEALLOCATE ( vars % X ) DEALLOCATE ( vars % Y ) DEALLOCATE ( vars % B ) DEALLOCATE ( vars % PSI_P ) DEALLOCATE ( vars % gradB ) DEALLOCATE ( vars % curlb ) DEALLOCATE ( vars % E ) DEALLOCATE ( vars % flagCon ) DEALLOCATE ( vars % hint ) !write(output_unit_write,*) 'out unitVectors' end subroutine unitVectors","tags":"","loc":"proc/unitvectors.html"},{"title":"get_fields – KORC-Full Orbit","text":"public subroutine get_fields(params, vars, F) Note Inferface with calls to subroutines for calculating the electric \n and magnetic field for each particle in the simulation. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: vars An instance of the KORC derived type PARTICLES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. Contents Source Code get_fields Source Code subroutine get_fields ( params , vars , F ) !! @note Inferface with calls to subroutines for calculating the electric !! and magnetic field for each particle in the simulation. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( PARTICLES ), INTENT ( INOUT ) :: vars !!  An instance of the KORC derived type PARTICLES. TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then !SELECT CASE (TRIM(params%field_model)) !CASE('ANALYTICAL') if ( params % field_eval . eq . 'eqn' ) then call get_analytical_fields ( params , vars , F ) else call interp_fields ( params , vars , F ) end if else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then !       write(output_unit_write,'(\"2 size of PSI_P: \",I16)') size(vars%PSI_P) call interp_fields ( params , vars , F ) !       write(output_unit_write,'(\"get_fields\")') !       write(output_unit_write,'(\"B_X: \",E17.10)') vars%B(:,1) !       write(output_unit_write,'(\"B_Z: \",E17.10)') vars%B(:,2) !       write(output_unit_write,'(\"B_Y: \",E17.10)') vars%B(:,3) !if (F%Efield.AND..NOT.F%Efield_in_file) then !   call analytical_electric_field_cyl(F,vars%Y,vars%E,vars%flagCon) !end if else if ( params % field_model . eq . 'M3D_C1' ) then call interp_fields ( params , vars , F ) else if ( params % field_model . eq . 'UNIFORM' ) then call uniform_fields ( vars , F ) end if end subroutine get_fields","tags":"","loc":"proc/get_fields.html"},{"title":"calculate_SC_E1D – KORC-Full Orbit","text":"public subroutine calculate_SC_E1D(params, F, Vden) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F real(kind=rp), intent(in), dimension(F%dim_1D) :: Vden Contents Source Code calculate_SC_E1D Source Code subroutine calculate_SC_E1D ( params , F , Vden ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ), intent ( in ) :: Vden real ( rp ), dimension ( F % dim_1D ) :: Jsamone , Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r real ( rp ) :: dr , bet integer :: ii INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) Jsamone = C_E * Vden ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( Jsamone , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !write(output_unit_write,*) 'Jsam: ',Jsamall(1:5) Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = F % J2_SC_1D % PHI F % J2_SC_1D % PHI = F % J1_SC_1D % PHI F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3 * F % J1_SC_1D % PHI - 4 * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2 * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve a = 0._rp b =- 2._rp c = 0._rp u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = 2 * dr ** 2 * C_MU * dJdt do ii = 2_idef , F % dim_1D a ( ii ) = ( REAL ( ii ) - 2._rp ) / ( REAL ( ii ) - 1._rp ) c ( ii ) = REAL ( ii ) / ( REAL ( ii ) - 1._rp ) end do bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = ( 4 * u ( 2 ) - u ( 3 )) / 3._rp ! Writing over F%A* data !    F%A3_SC_1D%PHI=F%A2_SC_1D%PHI !    F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    F%A1_SC_1D%PHI=u !    if (init) then !       F%A3_SC_1D%PHI=F%A1_SC_1D%PHI !       F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    end if !    write(output_unit_write,*) params%mpi_params%rank,'A1(1)',F%A1_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A2(1)',F%A2_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A3(1)',F%A3_SC_1D%PHI(1) ! Calculating inductive E_phi !    F%E_SC_1D%PHI=-(3*F%A1_SC_1D%PHI-4*F%A2_SC_1D%PHI+F%A3_SC_1D%PHI)/ & !         (2*F%dt_E_SC) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(2)' , F % J1_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J2(2)' , F % J2_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J3(2)' , F % J3_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant ( params , F ) end subroutine calculate_SC_E1D","tags":"","loc":"proc/calculate_sc_e1d.html"},{"title":"calculate_SC_E1D_FS – KORC-Full Orbit","text":"public subroutine calculate_SC_E1D_FS(params, F, dintJphidPSIP) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F real(kind=rp), intent(in), dimension(F%dim_1D) :: dintJphidPSIP Contents Source Code calculate_SC_E1D_FS Source Code subroutine calculate_SC_E1D_FS ( params , F , dintJphidPSIP ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ), intent ( in ) :: dintJphidPSIP real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , alpha , beta , gamma real ( rp ) :: dPSIP , bet integer :: ii INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if !write(output_unit_write,*) 'dintJphidPSIP',dintJphidPSIP(F%dim_1D) dPSIP = F % PSIP_1D ( 2 ) - F % PSIP_1D ( 1 ) ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( dintJphidPSIP , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !write(output_unit_write,*) 'JSamAll',Jsamall(F%dim_1D) !write(output_unit_write,*) 'Jsam: ',Jsamall(1:5) Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = F % J2_SC_1D % PHI F % J2_SC_1D % PHI = F % J1_SC_1D % PHI F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3 * F % J1_SC_1D % PHI - 4 * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2 * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve alpha = F % ddMagPsiSqdPsiPSq beta = F % dMagPsiSqdPsiP gamma = C_MU * dJdt a =- alpha * dPSIP / 2._rp + beta b =- 2._rp * beta c = alpha * dPSIP / 2._rp + beta u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = dPSIP ** 2 * gamma c ( 2 ) = c ( 2 ) - a ( 2 ) * a ( 1 ) / c ( 1 ) b ( 2 ) = b ( 2 ) - a ( 2 ) * b ( 1 ) / c ( 1 ) r ( 2 ) = r ( 2 ) - a ( 2 ) * r ( 1 ) / c ( 1 ) bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = 2 * u ( 2 ) - u ( 3 ) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(1)' , F % J1_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J2(1)' , F % J2_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J3(1)' , F % J3_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant_FS ( params , F ) end subroutine calculate_SC_E1D_FS","tags":"","loc":"proc/calculate_sc_e1d_fs.html"},{"title":"calculate_SC_p – KORC-Full Orbit","text":"public subroutine calculate_SC_p(params, F, B_R, B_PHI, B_Z, Y_R, Y_Z, V_PLL, V_MU, m_cache, flagCon, flagCol, Vden) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), dimension(params%pchunk) :: B_R real(kind=rp), intent(in), dimension(params%pchunk) :: B_PHI real(kind=rp), intent(in), dimension(params%pchunk) :: B_Z real(kind=rp), intent(in), dimension(params%pchunk) :: Y_R real(kind=rp), intent(in), dimension(params%pchunk) :: Y_Z real(kind=rp), intent(in), dimension(params%pchunk) :: V_PLL real(kind=rp), intent(in), dimension(params%pchunk) :: V_MU real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(in), dimension(params%pchunk) :: flagCon integer(kind=is), intent(in), dimension(params%pchunk) :: flagCol real(kind=rp), intent(out), dimension(F%dim_1D) :: Vden Contents Source Code calculate_SC_p Source Code subroutine calculate_SC_p ( params , F , B_R , B_PHI , B_Z , Y_R , Y_Z , & V_PLL , V_MU , m_cache , flagCon , flagCol , Vden ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( params % pchunk ), intent ( in ) :: Y_R , Y_Z real ( rp ), dimension ( params % pchunk ), intent ( in ) :: B_R , B_PHI , B_Z real ( rp ), dimension ( params % pchunk ), intent ( in ) :: V_PLL , V_MU real ( rp ), intent ( in ) :: m_cache integer ( is ), dimension ( params % pchunk ), intent ( in ) :: flagCon , flagCol real ( rp ), dimension ( params % pchunk ) :: rm , Bmag , gam , vpll real ( rp ), dimension ( F % dim_1D ), intent ( out ) :: Vden real ( rp ), dimension ( F % dim_1D ) :: Vpart , Ai real ( rp ), dimension ( F % dim_1D ) :: r_1D real ( rp ) :: dr , sigr , ar , arg , arg1 , arg2 , arg3 integer :: cc , ii , rind , pchunk pchunk = params % pchunk dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) r_1D = F % r_1D sigr = dr Vpart = 0._rp do cc = 1_idef , pchunk ! 1D nearest grid point weighting in minor radius !    RR=spp%vars%Y(:,1) !    ZZ=spp%vars%Y(:,3) rm ( cc ) = sqrt (( Y_R ( cc ) - F % Ro ) ** 2 + ( Y_Z ( cc ) - F % Zo ) ** 2 ) * & params % cpp % length !    write (output_unit_write,*) params%mpi_params%rank,'RR',RR !    write (output_unit_write,*) params%mpi_params%rank,'ZZ',spp%vars%Y(:,3) write ( output_unit_write , * ) 'rm' , rm ( cc ) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) gam ( cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc ) * m_cache ) vpll ( cc ) = V_PLL ( cc ) / gam ( cc ) ! Weighting parallel velocity !    write (output_unit_write,*) params%mpi_params%rank,'vpll',vpll !   do pp=1_idef,spp%ppp ! NGP weighting rind = FLOOR (( rm ( cc ) - dr / 2 ) / dr ) + 2_ip Vpart ( rind ) = Vpart ( rind ) + real ( flagCon ( cc )) * real ( flagCol ( cc )) * vpll ( cc ) ! First-order weighting !       rind=FLOOR(rm(cc)/dr)+1_ip !       Vpart(rind)=Vpart(rind)+ & !            vpll(cc)*(r_1D(rind+1)-rm(cc))/dr !       Vpart(rind+1)=Vpart(rind+1)+ & !            vpll(cc)*(rm(cc)-r_1D(rind))/dr ! Gaussian weighting !       do ii=1_idef,F%dim_1D !          arg=MIN((r_1D(ii)-rm(cc))**2._rp/(2._rp*sigr**2._rp),100._rp) !          Vpart(ii)=Vpart(ii)+1/sqrt(2._rp*C_PI*sigr**2._rp)* & !               exp(-arg)*vpll(cc) !       end do end do ar = F % AB % a ! Calculating density of minor radial annulus do ii = 1_idef , F % dim_1D ! NGP weighting if ( ii . eq . 1 ) then Vden ( ii ) = Vpart ( ii ) / ( C_PI * dr ** 2 / 4 ) else Vden ( ii ) = Vpart ( ii ) / ( 2 * C_PI * dr ** 2 * ( ii - 1 )) end if ! First-order weighting !       if(ii.eq.1) then !          Vden(ii)=Vpart(ii)/(C_PI*dr**2/3) !       else !          Vden(ii)=Vpart(ii)/(2*C_PI*dr**2*(ii-1)) !       end if ! Gaussian weighting !       arg=MIN(r_1D(ii)**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg1=MIN((ar-r_1D(ii))**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg2=MIN((ar-r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       arg3=MIN((r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       Ai(ii)=sqrt(C_PI*sigr)*(sqrt(2._rp)*sigr*(exp(-arg)- & !            exp(-arg1))+r_1D(ii)*sqrt(C_PI)* & !            (erf(arg2)-erf(-arg3))) !       Vden(ii)=Vpart(ii)/Ai(ii) end do end subroutine calculate_SC_p","tags":"","loc":"proc/calculate_sc_p.html"},{"title":"calculate_SC_p_FS – KORC-Full Orbit","text":"public subroutine calculate_SC_p_FS(params, F, B_R, B_PHI, B_Z, PSIp, V_PLL, V_MU, m_cache, flagCon, flagCol, dintJphidPSIP) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), dimension(params%pchunk) :: B_R real(kind=rp), intent(in), dimension(params%pchunk) :: B_PHI real(kind=rp), intent(in), dimension(params%pchunk) :: B_Z real(kind=rp), intent(in), dimension(params%pchunk) :: PSIp real(kind=rp), intent(in), dimension(params%pchunk) :: V_PLL real(kind=rp), intent(in), dimension(params%pchunk) :: V_MU real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(in), dimension(params%pchunk) :: flagCon integer(kind=is), intent(in), dimension(params%pchunk) :: flagCol real(kind=rp), intent(out), dimension(F%dim_1D) :: dintJphidPSIP Contents Source Code calculate_SC_p_FS Source Code subroutine calculate_SC_p_FS ( params , F , B_R , B_PHI , B_Z , PSIp , & V_PLL , V_MU , m_cache , flagCon , flagCol , dintJphidPSIP ) TYPE ( FIELDS ), INTENT ( IN ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( params % pchunk ), intent ( in ) :: PSIp real ( rp ), dimension ( params % pchunk ), intent ( in ) :: B_R , B_PHI , B_Z real ( rp ), dimension ( params % pchunk ), intent ( in ) :: V_PLL , V_MU real ( rp ), intent ( in ) :: m_cache integer ( is ), dimension ( params % pchunk ), intent ( in ) :: flagCon , flagCol real ( rp ), dimension ( params % pchunk ) :: Bmag , gam , vpll , PSIp_cache real ( rp ), dimension ( F % dim_1D ), intent ( out ) :: dintJphidPSIP real ( rp ), dimension ( F % dim_1D ) :: PSIP_1D real ( rp ) :: dPSIP , ar , arg , arg1 , arg2 , arg3 , PSIP_lim , sigPSIP integer :: cc , ii , PSIPind , pchunk pchunk = params % pchunk PSIP_1D = F % PSIP_1D dPSIP = PSIP_1D ( 2 ) - PSIP_1D ( 1 ) PSIp_cache = PSIp * ( params % cpp % Bo * params % cpp % length ** 2 ) sigPSIP = dPSIP dintJphidPSIP = 0._rp do cc = 1_idef , pchunk ! 1D Riemann sum !write (output_unit_write,*) 'rm',rm(cc) Bmag ( cc ) = sqrt ( B_R ( cc ) * B_R ( cc ) + B_PHI ( cc ) * B_PHI ( cc ) + & B_Z ( cc ) * B_Z ( cc )) gam ( cc ) = sqrt ( 1 + V_PLL ( cc ) ** 2 + & 2 * V_MU ( cc ) * Bmag ( cc ) * m_cache ) vpll ( cc ) = V_PLL ( cc ) / gam ( cc ) !       write(output_unit_write,*) PSIp_cache(cc) if ( PSIp_cache ( cc ). lt . 0._rp ) PSIp_cache ( cc ) = 0._rp PSIPind = FLOOR ( PSIp_cache ( cc ) / dPSIP ) + 1_ip ! NGP weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+vpll(cc) ! First-order weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+ & !            vpll(cc)*(PSIP_1D(PSIPind+1)-PSIP_cache(cc))/dPSIP !       dintJphidPSIP(PSIPind+1)=dintJphidPSIP(PSIPind+1)+ & !            vpll(cc)*(PSIP_cache(cc)-PSIP_1D(PSIPind))/dPSIP ! Gaussian weighting do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_1D ( ii ) - PSIP_cache ( cc )) ** 2._rp / & ( 2._rp * sigPSIP ** 2._rp ), 10 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) + & exp ( - arg ) * vpll ( cc ) * real ( flagCon ( cc )) * real ( flagCol ( cc )) end do end do ! First-order weighting !    dintJphidPSIP(1)=2*dintJphidPSIP(1) ! Gaussian weighting PSIP_lim = PSIP_1D ( F % dim_1D ) do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_lim - PSIP_1D ( ii )) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) arg1 = MIN ( PSIP_1D ( ii ) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) / & ( erf ( arg ) - erf ( - arg1 )) end do end subroutine calculate_SC_p_FS","tags":"","loc":"proc/calculate_sc_p_fs.html"},{"title":"init_SC_E1D – KORC-Full Orbit","text":"public subroutine init_SC_E1D(params, F, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F type(SPECIES), intent(in) :: spp Contents Source Code init_SC_E1D Source Code subroutine init_SC_E1D ( params , F , spp ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( IN ) :: spp real ( rp ), dimension ( F % dim_1D ) :: Vpart real ( rp ), dimension ( spp % ppp ) :: RR , ZZ , rm , vpll real ( rp ), dimension ( F % dim_1D ) :: Vden , Jsamone , Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , r_1D , Ai real ( rp ) :: dr , Isam , bet , sigr , ar , arg , arg1 , arg2 , arg3 integer :: pp , ii , rind INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if ! 1D nearest grid point weighting in minor radius RR = spp % vars % Y (:, 1 ) ZZ = spp % vars % Y (:, 3 ) rm = sqrt (( RR - F % Ro ) ** 2._rp + ( ZZ - F % Zo ) ** 2._rp ) * params % cpp % length !    write (output_unit_write,*) params%mpi_params%rank,'RR',RR !    write (output_unit_write,*) params%mpi_params%rank,'ZZ',spp%vars%Y(:,3) write ( output_unit_write , * ) 'rm' , rm dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) vpll = spp % vars % V (:, 1 ) / spp % vars % g ! Weighting parallel velocity !    write (output_unit_write,*) 'vpll',vpll Vpart = 0._rp r_1D = F % r_1D sigr = dr do pp = 1_idef , spp % ppp ! NGP weighting rind = FLOOR (( rm ( pp ) - dr / 2 ) / dr ) + 2_ip Vpart ( rind ) = Vpart ( rind ) + vpll ( pp ) ! First-order weighting !       rind=FLOOR(rm(pp)/dr)+1_ip !       Vpart(rind)=Vpart(rind)+vpll(pp)*(F%r_1D(rind+1)-rm(pp))/dr !       Vpart(rind+1)=Vpart(rind+1)+vpll(pp)*(rm(pp)-F%r_1D(rind))/dr ! Gaussian weighting !       do ii=1_idef,F%dim_1D !          arg=MIN((r_1D(ii)-rm(pp))**2._rp/(2._rp*sigr**2._rp),100._rp) !          Vpart(ii)=Vpart(ii)+1/sqrt(2._rp*C_PI*sigr**2._rp)* & !               exp(-arg) !       end do end do ! Calculating density of minor radial annulus ar = F % AB % a do ii = 1_idef , F % dim_1D ! NGP weighting if ( ii . eq . 1 ) then Vden ( ii ) = Vpart ( ii ) / ( C_PI * dr ** 2 / 4 ) else Vden ( ii ) = Vpart ( ii ) / ( 2 * C_PI * dr ** 2 * ( ii - 1 )) end if ! First-order weighting !       if(ii.eq.1) then !          Vden(ii)=Vpart(ii)/(C_PI*dr**2/3) !       else !          Vden(ii)=Vpart(ii)/(2*C_PI*dr**2*(ii-1)) !       end if ! Gaussian weighting !       arg=MIN(r_1D(ii)**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg1=MIN((ar-r_1D(ii))**2._rp/(2._rp*sigr**2._rp),100._rp) !       arg2=MIN((ar-r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       arg3=MIN((r_1D(ii))/(sqrt(2._rp)*sigr),10._rp) !       Ai(ii)=sqrt(C_PI*sigr)*(sqrt(2._rp)*sigr*(exp(-arg)- & !            exp(-arg1))+r_1D(ii)*sqrt(C_PI)* & !            (erf(arg2)-erf(-arg3))) !       Vden(ii)=Vpart(ii)/Ai(ii) end do Jsamone = C_E * Vden ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( Jsamone , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !    write(output_unit_write,*) 'Jsam: ',Jsamall(1:10) ! Integrating current density to scale total current to ! experimentally determined total current Isam = 0._rp do ii = 1_idef , F % dim_1D if (( ii . eq . 1 ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) end if end do Isam = 2._rp * C_PI * Isam * dr !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve a = 0._rp b =- 2._rp c = 0._rp u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = 2 * dr ** 2 * C_MU * dJdt do ii = 2_idef , F % dim_1D a ( ii ) = ( REAL ( ii ) - 2._rp ) / ( REAL ( ii ) - 1._rp ) c ( ii ) = REAL ( ii ) / ( REAL ( ii ) - 1._rp ) end do bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = ( 4._rp * u ( 2 ) - u ( 3 )) / 3._rp ! Writing over F%A* data !    F%A3_SC_1D%PHI=F%A2_SC_1D%PHI !    F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    F%A1_SC_1D%PHI=u !    if (init) then !       F%A3_SC_1D%PHI=F%A1_SC_1D%PHI !       F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    end if !    write(output_unit_write,*) params%mpi_params%rank,'A1(1)',F%A1_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A2(1)',F%A2_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A3(1)',F%A3_SC_1D%PHI(1) ! Calculating inductive E_phi !    F%E_SC_1D%PHI=-(3*F%A1_SC_1D%PHI-4*F%A2_SC_1D%PHI+F%A3_SC_1D%PHI)/ & !         (2*F%dt_E_SC) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(2)' , F % J1_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J2(2)' , F % J2_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'J3(2)' , F % J3_SC_1D % PHI ( 2 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant ( params , F ) end subroutine init_SC_E1D","tags":"","loc":"proc/init_sc_e1d.html"},{"title":"init_SC_E1D_FS – KORC-Full Orbit","text":"public subroutine init_SC_E1D_FS(params, F, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F type(SPECIES), intent(in) :: spp Contents Source Code init_SC_E1D_FS Source Code subroutine init_SC_E1D_FS ( params , F , spp ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( SPECIES ), INTENT ( IN ) :: spp real ( rp ), dimension ( F % dim_1D ) :: dintJphidPSIP , PSIP_1D real ( rp ), dimension ( spp % ppp ) :: PSIP , vpll real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , alpha , beta , gamma real ( rp ) :: dPSIP , Isam , bet , arg , arg1 , PSIP_lim , sigPSIP integer :: pp , ii , PSIPind INTEGER :: mpierr PSIP_1D = F % PSIP_1D dPSIP = PSIP_1D ( 2 ) - PSIP_1D ( 1 ) PSIP = spp % vars % PSI_P * ( params % cpp % Bo * params % cpp % length ** 2 ) sigPSIP = dPSIP vpll = spp % vars % V (:, 1 ) / spp % vars % g dintJphidPSIP = 0._rp do pp = 1_idef , spp % ppp if ( PSIP ( pp ). lt . 0._rp ) PSIP ( pp ) = 0._rp PSIPind = FLOOR ( PSIP ( pp ) / dPSIP ) + 1_ip ! NGP weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+vpll(pp) ! First-order weighting !       dintJphidPSIP(PSIPind)=dintJphidPSIP(PSIPind)+ & !            vpll(pp)*(PSIP_1D(PSIPind+1)-PSIP(pp))/dPSIP !       dintJphidPSIP(PSIPind+1)=dintJphidPSIP(PSIPind+1)+ & !            vpll(pp)*(PSIP(pp)-PSIP_1D(PSIPind))/dPSIP !       write(output_unit_write,*) PSIP(pp),PSIP_1D(PSIPind),dPSIP ! Gaussian weighting do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_1D ( ii ) - PSIP ( pp )) ** 2._rp / & ( 2._rp * sigPSIP ** 2._rp ), 10 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) + & vpll ( pp ) * exp ( - arg ) end do end do ! First-order weighting !    dintJphidPSIP(1)=2*dintJphidPSIP(1) ! Gaussian weighting PSIP_lim = PSIP_1D ( F % dim_1D ) do ii = 1_idef , F % dim_1D arg = MIN (( PSIP_lim - PSIP_1D ( ii )) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) arg1 = MIN ( PSIP_1D ( ii ) / ( sqrt ( 2._rp ) * sigPSIP ), 1 0._rp ) dintJphidPSIP ( ii ) = dintJphidPSIP ( ii ) / & ( erf ( arg ) - erf ( - arg1 )) end do ! Add sampled current densities from all MPI processes Jsamone, ! and output of total sampled current density Jsamall to each ! MPI process. call MPI_ALLREDUCE ( dintJphidPSIP , Jsamall , F % dim_1D , MPI_REAL8 , MPI_SUM , & MPI_COMM_WORLD , mpierr ) !    write(output_unit_write,*) 'Jsam: ',Jsamall(1:10) ! Integrating current density to scale total current to ! experimentally determined total current Isam = 0._rp do ii = 1_idef , F % dim_1D if (( ii . eq . 1 ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) end if end do Isam = Isam * dPSIP !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve alpha = F % ddMagPsiSqdPsiPSq beta = F % dMagPsiSqdPsiP gamma = C_MU * dJdt a =- alpha * dPSIP / 2._rp + beta b =- 2._rp * beta c = alpha * dPSIP / 2._rp + beta u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = dPSIP ** 2 * gamma c ( 2 ) = c ( 2 ) - a ( 2 ) * a ( 1 ) / c ( 1 ) b ( 2 ) = b ( 2 ) - a ( 2 ) * b ( 1 ) / c ( 1 ) r ( 2 ) = r ( 2 ) - a ( 2 ) * r ( 1 ) / c ( 1 ) bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = 2 * u ( 2 ) - u ( 3 ) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(1)' , F % J1_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J2(1)' , F % J2_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J3(1)' , F % J3_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant_FS ( params , F ) end subroutine init_SC_E1D_FS","tags":"","loc":"proc/init_sc_e1d_fs.html"},{"title":"reinit_SC_E1D – KORC-Full Orbit","text":"public subroutine reinit_SC_E1D(params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F Contents Source Code reinit_SC_E1D Source Code subroutine reinit_SC_E1D ( params , F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , r_1D , Ai real ( rp ) :: dr , Isam , bet , sigr , ar , arg , arg1 , arg2 , arg3 integer :: pp , ii , rind INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if dr = F % r_1D ( 2 ) - F % r_1D ( 1 ) r_1D = F % r_1D Jsamall = F % J0_SC_1D % PHI !    write(output_unit_write,*) Jsamall Isam = 0._rp do ii = 1_idef , F % dim_1D !       write(output_unit_write,*) Isam !       write(output_unit_write,*) ii !       write(output_unit_write,*) Jsamall(ii) !       write(output_unit_write,*) (ii) if (( ii . eq . 1_idef ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) * r_1D ( ii ) end if end do Isam = 2._rp * C_PI * Isam * dr !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve a = 0._rp b =- 2._rp c = 0._rp u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = 2 * dr ** 2 * C_MU * dJdt do ii = 2_idef , F % dim_1D a ( ii ) = ( REAL ( ii ) - 2._rp ) / ( REAL ( ii ) - 1._rp ) c ( ii ) = REAL ( ii ) / ( REAL ( ii ) - 1._rp ) end do bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = ( 4._rp * u ( 2 ) - u ( 3 )) / 3._rp ! Writing over F%A* data !    F%A3_SC_1D%PHI=F%A2_SC_1D%PHI !    F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    F%A1_SC_1D%PHI=u !    if (init) then !       F%A3_SC_1D%PHI=F%A1_SC_1D%PHI !       F%A2_SC_1D%PHI=F%A1_SC_1D%PHI !    end if !    write(output_unit_write,*) params%mpi_params%rank,'A1(1)',F%A1_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A2(1)',F%A2_SC_1D%PHI(1) !    write(output_unit_write,*) params%mpi_params%rank,'A3(1)',F%A3_SC_1D%PHI(1) ! Calculating inductive E_phi !    F%E_SC_1D%PHI=-(3*F%A1_SC_1D%PHI-4*F%A2_SC_1D%PHI+F%A3_SC_1D%PHI)/ & !         (2*F%dt_E_SC) F % E_SC_1D % PHI = u !    if (params%mpi_params%rank.eq.0) then !       write(output_unit_write,*) 'J1(1)',F%J1_SC_1D%PHI(1) !       write(output_unit_write,*) 'J2(1)',F%J2_SC_1D%PHI(1) !       write(output_unit_write,*) 'J3(1)',F%J3_SC_1D%PHI(1) !       write(output_unit_write,*) 'E(1)',F%E_SC_1D%PHI(1) !    end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant ( params , F ) end subroutine reinit_SC_E1D","tags":"","loc":"proc/reinit_sc_e1d.html"},{"title":"reinit_SC_E1D_FS – KORC-Full Orbit","text":"public subroutine reinit_SC_E1D_FS(params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F Contents Source Code reinit_SC_E1D_FS Source Code subroutine reinit_SC_E1D_FS ( params , F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params real ( rp ), dimension ( F % dim_1D ) :: Jsamall , Jexp , dJdt , PSIP_1D real ( rp ), dimension ( F % dim_1D ) :: a , b , c , u , gam , r , alpha , beta , gamma real ( rp ) :: dPSIP , Isam , bet integer :: pp , ii , PSIPind INTEGER :: mpierr !    if (params%mpi_params%rank .EQ. 0) then !       write(output_unit_write,*) 'Calculating SC_E1D' !    end if PSIP_1D = F % PSIP_1D dPSIP = PSIP_1D ( 2 ) - PSIP_1D ( 1 ) Jsamall = F % J0_SC_1D % PHI Isam = 0._rp do ii = 1_idef , F % dim_1D if (( ii . eq . 1 ). or .( ii . eq . F % dim_1D )) then Isam = Isam + Jsamall ( ii ) / 2._rp else Isam = Isam + Jsamall ( ii ) end if end do Isam = Isam * dPSIP !    write(output_unit_write,*) params%mpi_params%rank,'Isam: ',Isam F % Ip0 = F % Ip_exp / Isam Jexp = Jsamall * F % Ip0 F % J3_SC_1D % PHI = Jexp F % J2_SC_1D % PHI = Jexp F % J1_SC_1D % PHI = Jexp ! Calculating time-derivative of E_phi dJdt = ( 3._rp * F % J1_SC_1D % PHI - 4._rp * F % J2_SC_1D % PHI + F % J3_SC_1D % PHI ) / & ( 2._rp * F % dt_E_SC ) !    write(output_unit_write,*) params%mpi_params%rank,'J(1)',F%J_SC_1D%PHI(1) ! Solving 1D Poisson equation with tridiagonal matrix solve alpha = F % ddMagPsiSqdPsiPSq beta = F % dMagPsiSqdPsiP gamma = C_MU * dJdt a =- alpha * dPSIP / 2._rp + beta b =- 2._rp * beta c = alpha * dPSIP / 2._rp + beta u = 0._rp gam = 0._rp !    r=-2*dr**2*C_MU*Jexp r = dPSIP ** 2 * gamma c ( 2 ) = c ( 2 ) - a ( 2 ) * a ( 1 ) / c ( 1 ) b ( 2 ) = b ( 2 ) - a ( 2 ) * b ( 1 ) / c ( 1 ) r ( 2 ) = r ( 2 ) - a ( 2 ) * r ( 1 ) / c ( 1 ) bet = b ( 2 ) u ( 2 ) = r ( 2 ) / bet do ii = 3_idef , F % dim_1D - 1 gam ( ii ) = c ( ii - 1 ) / bet bet = b ( ii ) - a ( ii ) * gam ( ii ) if ( bet . eq . 0 ) then stop 'tridiag failed' end if u ( ii ) = ( r ( ii ) - a ( ii ) * u ( ii - 1 )) / bet end do do ii = F % dim_1D - 2 , 2 , - 1 u ( ii ) = u ( ii ) - gam ( ii + 1 ) * u ( ii + 1 ) end do u ( 1 ) = 2 * u ( 2 ) - u ( 3 ) F % E_SC_1D % PHI = u if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , * ) 'J1(1)' , F % J1_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J2(1)' , F % J2_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'J3(1)' , F % J3_SC_1D % PHI ( 1 ) write ( output_unit_write , * ) 'E(1)' , F % E_SC_1D % PHI ( 1 ) end if ! Normalizing inductive E_phi F % E_SC_1D % PHI = F % E_SC_1D % PHI / params % cpp % Eo call initialize_SC1D_field_interpolant_FS ( params , F ) end subroutine reinit_SC_E1D_FS","tags":"","loc":"proc/reinit_sc_e1d_fs.html"},{"title":"initialize_fields – KORC-Full Orbit","text":"public subroutine initialize_fields(params, F) Note Subroutine that initializes the analytical or externally\n calculated electric and magnetic fields. In this subroutine we load the parameters of the electric and\n magnetic fields from the namelists 'analytical_fields_params' and\n 'externalPlasmaModel' in the input file.\n Sign convention in analytical fields corresponds to\n DIII-D fields with and .\n Sign convention in analytical fields corresponds to\n DIII-D fields with and . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(out) :: F An instance of the KORC derived type FIELDS. Magnetic field at magnetic axis for an 'ANALYTICAL' magnetic field,\n or the magnitude of the magnetic field for a 'UNFIROM' plasma. Plasma edge as measured from the magnetic axis. Radial position of the magnetic axis Safety factor at the plasma edge. Safety factor at the magnetic axis . String with information about the direction of the plasma current, \n 'PARALLEL'  or 'ANTI-PARALLEL' to the toroidal magnetic field. Electric field at the magnetic axis. Logical variable that specifies if the electric field is \n going to be used on in a given simulation. Logical variable that specifies if the magnetic field is \n going to be used on in a given simulation. Logical variable that specifies if the poloidal magnetic \n flux is going to be used on in a given simulation. Logical variable that specifies if the plasma is axisymmetric. Contents Source Code initialize_fields Source Code subroutine initialize_fields ( params , F ) !! @note Subroutine that initializes the analytical or externally !! calculated electric and magnetic fields. @endnote !! In this subroutine we load the parameters of the electric and !! magnetic fields from the namelists 'analytical_fields_params' and !! 'externalPlasmaModel' in the input file. TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( OUT ) :: F !! An instance of the KORC derived type FIELDS. !REAL(rp)                       :: Bo !! Magnetic field at magnetic axis for an 'ANALYTICAL' magnetic field, !! or the magnitude of the magnetic field for a 'UNFIROM' plasma. !REAL(rp)                       :: minor_radius !! Plasma edge r_{edge} as measured from the magnetic axis. !REAL(rp)                       :: major_radius !! Radial position of the magnetic axis R_0 !REAL(rp)                       :: qa !! Safety factor at the plasma edge. !REAL(rp)                       :: qo !! Safety factor at the magnetic axis q_0. !CHARACTER(MAX_STRING_LENGTH)   :: current_direction !! String with information about the direction of the plasma current, !! 'PARALLEL'  or 'ANTI-PARALLEL' to the toroidal magnetic field. !CHARACTER(MAX_STRING_LENGTH)   :: E_model !REAL(rp)                       :: Eo,E_dyn,E_pulse,E_width !! Electric field at the magnetic axis. !LOGICAL                        :: Efield !! Logical variable that specifies if the electric field is !! going to be used on in a given simulation. !LOGICAL                        :: dBfield !LOGICAL                        :: Bfield !! Logical variable that specifies if the magnetic field is !! going to be used on in a given simulation. !LOGICAL                        :: Bflux !LOGICAL                        :: Bflux3D !LOGICAL                        :: Dim2x1t !LOGICAL                        :: E_2x1t,ReInterp_2x1t !! Logical variable that specifies if the poloidal magnetic !! flux is going to be used on in a given simulation. !LOGICAL                        :: axisymmetric_fields !! Logical variable that specifies if the plasma is axisymmetric. INTEGER :: ii !! Iterators for creating mesh for GC model with analytic fields INTEGER :: kk !! Iterators for creating mesh for GC model with analytic fields !INTEGER                        :: nR !! Number of mesh points in R for grid in GC model of analytical field !INTEGER                        :: nZ,nPHI !! Number of mesh points in Z for grid in GC model of analytical field real ( rp ) :: rm !! Minor radius at each position in the grid for !! GC model of analytical field real ( rp ) :: qr !! Safety factor at each position in the grid for !! GC model of analytical field real ( rp ) :: theta !! Poloidal angle at each position in the grid for !! GC model of analytical field logical :: test !integer :: res_double real ( rp ) :: RMAX , RMIN , ZMAX , ZMIN !integer :: dim_1D,ind0_2x1t !real(rp) :: dt_E_SC,Ip_exp,PSIp_lim,PSIp_0 !real(rp) :: t0_2x1t !NAMELIST /analytical_fields_params/ Bo,minor_radius,major_radius,& !     qa,qo,Eo,current_direction,nR,nZ,nPHI,dim_1D,dt_E_SC,Ip_exp, & !     E_dyn,E_pulse,E_width !NAMELIST /externalPlasmaModel/ Efield, Bfield, Bflux,Bflux3D,dBfield, & !     axisymmetric_fields, Eo,E_dyn,E_pulse,E_width,res_double, & !     dim_1D,dt_E_SC,Ip_exp,PSIp_lim,Dim2x1t,t0_2x1t,E_2x1t,ReInterp_2x1t, & !     ind0_2x1t,PSIp_0 #ifdef M3D_C1 F % M3D_C1_B = - 1 F % M3D_C1_E = - 1 #endif if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * * * * INITIALIZING FIELDS * * * * * * * *\")' ) end if !    SELECT CASE (TRIM(params%field_model)) if ( params % field_model ( 1 : 10 ). eq . 'ANALYTICAL' ) then !    CASE('ANALYTICAL') ! Load the parameters of the analytical magnetic field !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=analytical_fields_params) !close(default_unit_open) F % AB % Bo = Bo F % AB % a = minor_radius F % AB % Ro = major_radius F % Ro = major_radius F % Zo = 0.0_rp F % AB % qa = qa F % AB % qo = qo F % AB % lambda = F % AB % a / SQRT ( qa / qo - 1.0_rp ) F % AB % Bpo = F % AB % lambda * F % AB % Bo / ( F % AB % qo * F % AB % Ro ) F % AB % current_direction = TRIM ( current_direction ) SELECT CASE ( TRIM ( F % AB % current_direction )) CASE ( 'PARALLEL' ) F % AB % Bp_sign = 1.0_rp CASE ( 'ANTI-PARALLEL' ) F % AB % Bp_sign = - 1.0_rp CASE DEFAULT END SELECT F % Eo = Eo F % Bo = F % AB % Bo F % E_dyn = E_dyn F % E_pulse = E_pulse F % E_width = E_width F % PSIp_lim = PSIp_lim !write(output_unit_write,*) E_dyn,E_pulse,E_width F % res_double = res_double if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"ANALYTIC\")' ) write ( output_unit_write , '(\"Magnetic field: \",E17.10)' ) F % Bo write ( output_unit_write , '(\"Electric field: \",E17.10)' ) F % Eo end if if ( params % field_eval . eq . 'interp' ) then F % dims ( 1 ) = nR F % dims ( 2 ) = nPHI F % dims ( 3 ) = nZ if ( params % field_model ( 12 : 14 ). eq . 'PSI' ) then F % axisymmetric_fields = . TRUE . F % Bfield = . TRUE . F % Efield = . TRUE . F % Bflux = . TRUE . call ALLOCATE_2D_FIELDS_ARRAYS ( params , F , F % Bfield , F % Bflux , & . false ., F % Efield ) do ii = 1_idef , F % dims ( 1 ) F % X % R ( ii ) = ( F % Ro - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 1 ) - 1 ) end do do ii = 1_idef , F % dims ( 3 ) F % X % Z ( ii ) = ( F % Zo - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 3 ) - 1 ) end do !write(6,*) F%X%R !write(6,*) F%X%Z do ii = 1_idef , F % dims ( 1 ) do kk = 1_idef , F % dims ( 3 ) rm = sqrt (( F % X % R ( ii ) - F % Ro ) ** 2 + ( F % X % Z ( kk ) - F % Zo ) ** 2 ) qr = F % AB % qo * ( 1 + ( rm / F % AB % lambda ) ** 2 ) theta = atan2 ( F % X % Z ( kk ) - F % Zo , F % X % R ( ii ) - F % Ro ) F % B_2D % R ( ii , kk ) = ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * sin ( theta ) F % B_2D % PHI ( ii , kk ) =- ( F % Ro / F % X % R ( ii )) * F % AB % Bo F % B_2D % Z ( ii , kk ) =- ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * cos ( theta ) F % E_2D % R ( ii , kk ) = 0.0_rp F % E_2D % PHI ( ii , kk ) =- ( F % Ro / F % X % R ( ii )) * F % Eo F % E_2D % Z ( ii , kk ) = 0.0_rp F % PSIp ( ii , kk ) = F % X % R ( ii ) * F % AB % lambda ** 2 * F % Bo / & ( 2 * F % AB % qo * ( F % Ro + rm * cos ( theta ))) * & log ( 1 + ( rm / F % AB % lambda ) ** 2 ) !! Sign convention in analytical fields corresponds to !! DIII-D fields with B_\\phi<0 and B_\\theta<0. F % FLAG2D = 1. end do end do F % FLAG2D ( 1 : 2 ,:) = 0. F % FLAG2D ( F % dims ( 1 ) - 1 : F % dims ( 1 ),:) = 0. F % FLAG2D (:, 1 : 2 ) = 0. F % FLAG2D (:, F % dims ( 3 ) - 1 : F % dims ( 3 )) = 0. if ( F % Bflux ) F % PSIP_min = minval ( F % PSIp ) F % Bfield = . FALSE . else if ( params % field_model ( 12 : 13 ). eq . '3D' ) then F % axisymmetric_fields = . FALSE . F % Bfield = . TRUE . F % Efield = . TRUE . call ALLOCATE_3D_FIELDS_ARRAYS ( params , F , F % Bfield , F % Efield ,. false .) do ii = 1_idef , F % dims ( 1 ) F % X % R ( ii ) = ( F % Ro - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 1 ) - 1 ) end do do ii = 1_idef , F % dims ( 2 ) F % X % PHI ( ii ) = 0._rp + ( ii - 1 ) * 2 * C_PI / ( F % dims ( 1 ) - 1 ) end do do ii = 1_idef , F % dims ( 3 ) F % X % Z ( ii ) = ( F % Zo - F % AB % a ) + ( ii - 1 ) * 2 * F % AB % a / ( F % dims ( 3 ) - 1 ) end do !write(output_unit_write,*) size(F%B_3D%R) do ii = 1_idef , F % dims ( 1 ) do kk = 1_idef , F % dims ( 3 ) !write(output_unit_write,*) ii,kk rm = sqrt (( F % X % R ( ii ) - F % Ro ) ** 2 + ( F % X % Z ( kk ) - F % Zo ) ** 2 ) qr = F % AB % qo * ( 1 + ( rm / F % AB % lambda ) ** 2 ) theta = atan2 ( F % X % Z ( kk ) - F % Zo , F % X % R ( ii ) - F % Ro ) F % B_3D % R ( ii ,:, kk ) = ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * sin ( theta ) F % B_3D % PHI ( ii ,:, kk ) =- ( F % Ro / F % X % R ( ii )) * F % AB % Bo !write(output_unit_write,*) F%B_3D%PHI(ii,1,kk) F % B_3D % Z ( ii ,:, kk ) =- ( rm / F % X % R ( ii )) * & ( F % AB % Bo / qr ) * cos ( theta ) F % E_3D % R ( ii ,:, kk ) = 0.0_rp F % E_3D % PHI ( ii ,:, kk ) =- ( F % Ro / F % X % R ( ii )) * F % Eo F % E_3D % Z ( ii ,:, kk ) = 0.0_rp !! Sign convention in analytical fields corresponds to !! DIII-D fields with B_\\phi<0 and B_\\theta<0. F % FLAG3D = 1. end do end do F % FLAG3D ( 1 : 2 ,:,:) = 0. F % FLAG3D ( F % dims ( 1 ) - 1 : F % dims ( 1 ),:,:) = 0. F % FLAG3D (:,:, 1 : 2 ) = 0. F % FLAG3D (:,:, F % dims ( 3 ) - 1 : F % dims ( 3 )) = 0. end if if ( params % orbit_model ( 3 : 5 ). eq . 'pre' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"Initializing GC fields from analytic EM fields\")' ) end if if ( params % field_model ( 12 : 13 ). eq . '2D' ) then call initialize_GC_fields ( F ) else if ( params % field_model ( 12 : 13 ). eq . '3D' ) then call initialize_GC_fields_3D ( F ) end if end if !F%Bfield= .FALSE. !F%axisymmetric_fields = .TRUE. !F%Bflux=.TRUE. !F%Efield=.FALSE. end if if ( params % SC_E ) then F % dim_1D = dim_1D F % dt_E_SC = dt_E_SC F % Ip_exp = Ip_exp ALLOCATE ( F % E_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % A1_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % A2_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % A3_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % J1_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % J2_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % J3_SC_1D % PHI ( F % dim_1D )) ALLOCATE ( F % r_1D ( F % dim_1D )) F % E_SC_1D % PHI = 0._rp F % A1_SC_1D % PHI = 0._rp F % A2_SC_1D % PHI = 0._rp F % A3_SC_1D % PHI = 0._rp F % J1_SC_1D % PHI = 0._rp F % J2_SC_1D % PHI = 0._rp F % J3_SC_1D % PHI = 0._rp F % r_1D = 0._rp do ii = 1_idef , F % dim_1D F % r_1D ( ii ) = ( ii - 1 ) * F % AB % a / ( F % dim_1D - 1 ) end do end if !    CASE('EXTERNAL') else if ( params % field_model ( 1 : 8 ). eq . 'EXTERNAL' ) then ! Load the magnetic field from an external HDF5 file !open(unit=default_unit_open,file=TRIM(params%path_to_inputs), & !     status='OLD',form='formatted') !read(default_unit_open,nml=externalPlasmaModel) !close(default_unit_open) F % Bfield = Bfield F % dBfield = dBfield F % Bflux = Bflux F % Bflux3D = Bflux3D F % Efield = Efield F % axisymmetric_fields = axisymmetric_fields F % Dim2x1t = Dim2x1t F % ReInterp_2x1t = ReInterp_2x1t F % t0_2x1t = t0_2x1t F % ind0_2x1t = ind0_2x1t if ( params % proceed ) then call load_prev_iter ( params ) F % ind_2x1t = params % prev_iter_2x1t else F % ind_2x1t = F % ind0_2x1t end if F % E_2x1t = E_2x1t F % E_dyn = E_dyn F % E_pulse = E_pulse F % E_width = E_width F % PSIp_lim = PSIp_lim F % res_double = res_double !       write(output_unit_write,'(\"E_dyn: \",E17.10)') E_dyn !       write(output_unit_write,'(\"E_pulse: \",E17.10)') E_pulse !       write(output_unit_write,'(\"E_width: \",E17.10)') E_width call load_dim_data_from_hdf5 ( params , F ) !sets F%dims for 2D or 3D data !write(output_unit_write,*) F%dims call which_fields_in_file ( params , F % Bfield_in_file , F % Efield_in_file , & F % Bflux_in_file , F % dBfield_in_file ) if ( F % Bflux . AND .. NOT . F % Bflux_in_file ) then write ( output_unit_write , '(\"ERROR: Magnetic flux to be used but no data in file!\")' ) call KORC_ABORT () end if if ( F % Bfield . AND .. NOT . F % Bfield_in_file ) then write ( output_unit_write , '(\"ERROR: Magnetic field to be used but no data in file!\")' ) call KORC_ABORT () end if if ( F % dBfield . AND .. NOT . F % dBfield_in_file ) then write ( output_unit_write , '(\"ERROR: differential Magnetic field to be used & but no data in file!\")' ) !          call KORC_ABORT() end if if ( F % Efield . AND .. NOT . F % Efield_in_file ) then if ( params % mpi_params % rank . EQ . 0_idef ) then write ( output_unit_write , '(/,\"* * * * * * * * * *  FIELDS  * * * * * * * * * *\")' ) write ( output_unit_write , '(\"MESSAGE: Analytical electric field will be used.\")' ) write ( output_unit_write , '(\"* * * * * * * * * * * * ** * * * * * * * * * * *\",/)' ) end if end if if ( F % axisymmetric_fields ) then if ( F % Dim2x1t ) then call ALLOCATE_2D_FIELDS_ARRAYS ( params , F , F % Bfield , & F % Bflux , F % dBfield , F % Efield . AND . F % Efield_in_file ) call ALLOCATE_3D_FIELDS_ARRAYS ( params , F , F % Bfield , & F % Efield , F % dBfield ) else F % Efield_in_file = . TRUE . call ALLOCATE_2D_FIELDS_ARRAYS ( params , F , F % Bfield , & F % Bflux , F % dBfield , F % Efield . AND . F % Efield_in_file ) F % Efield_in_file = . FALSE . end if else call ALLOCATE_3D_FIELDS_ARRAYS ( params , F , F % Bfield , F % Efield , F % dBfield ) end if !allocates 2D or 3D data arrays (fields and spatial) call load_field_data_from_hdf5 ( params , F ) !       write(output_unit_write,*) F%PSIp !write(output_unit_write,*) F%E_3D%PHI(:,F%ind0_2x1t,:) !       end if if ( F % Bflux ) then F % PSIP_min = minval ( F % PSIp ) else if ( F % Bflux3D ) then F % PSIP_min = minval ( F % PSIp3D (:, 1 ,:)) end if if ((. not . F % Efield_in_file ). and .(. not . F % Dim2x1t )) then F % Eo = Eo if ( F % axisymmetric_fields ) then F % E_2D % R = 0._rp do ii = 1_idef , F % dims ( 1 ) F % E_2D % PHI ( ii ,:) = F % Eo * F % Ro / F % X % R ( ii ) end do F % E_2D % Z = 0._rp else F % E_3D % R = 0._rp do ii = 1_idef , F % dims ( 1 ) F % E_3D % PHI ( ii ,:,:) = F % Eo * F % Ro / F % X % R ( ii ) end do F % E_3D % Z = 0._rp end if end if if ( F % dBfield . and .. not . F % dBfield_in_file ) then if ( F % axisymmetric_fields ) then F % dBdR_2D % R = 0._rp F % dBdR_2D % PHI = 0._rp F % dBdR_2D % Z = 0._rp F % dBdPHI_2D % R = 0._rp F % dBdPHI_2D % PHI = 0._rp F % dBdPHI_2D % Z = 0._rp F % dBdZ_2D % R = 0._rp F % dBdZ_2D % PHI = 0._rp F % dBdZ_2D % Z = 0._rp else F % dBdR_3D % R = 0._rp F % dBdR_3D % PHI = 0._rp F % dBdR_3D % Z = 0._rp F % dBdPHI_3D % R = 0._rp F % dBdPHI_3D % PHI = 0._rp F % dBdPHI_3D % Z = 0._rp F % dBdZ_3D % R = 0._rp F % dBdZ_3D % PHI = 0._rp F % dBdZ_3D % Z = 0._rp end if end if if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"EXTERNAL\")' ) write ( output_unit_write , '(\"Magnetic field: \",E17.10)' ) F % Bo write ( output_unit_write , '(\"Electric field: \",E17.10)' ) F % Eo end if if ( params % SC_E ) then F % dim_1D = dim_1D F % dt_E_SC = dt_E_SC F % Ip_exp = Ip_exp write ( output_unit_write , * ) 'dt_E_SC' , F % dt_E_SC , 'Ip_exp' , Ip_exp call allocate_1D_FS_arrays ( params , F ) call load_1D_FS_from_hdf5 ( params , F ) !          write(output_unit_write,*) F%PSIP_1D end if !       test=.true. !       if (F%Bflux.and.(.not.test)) then !          call initialize_fields_interpolant(params,F) !          F%Bfield=.TRUE. !          F%Efield=.TRUE. !          F%Efield_in_file=.TRUE. !          RMIN=F%X%R(1) !          RMAX=F%X%R(F%dims(1)) !          ZMIN=F%X%Z(1) !          ZMAX=F%X%Z(F%dims(3)) !          do ii=1_idef,res_double !             F%dims(1)=2*F%dims(1)-1 !             F%dims(3)=2*F%dims(3)-1 !          end do !          if (res_double>0) then !             DEALLOCATE(F%X%R) !             DEALLOCATE(F%X%Z) !             DEALLOCATE(F%PSIp) !          end if !          call ALLOCATE_2D_FIELDS_ARRAYS(params,F,F%Bfield, & !               F%Bflux,F%Efield.AND.F%Efield_in_file) !          do ii=1_idef,F%dims(1) !             F%X%R(ii)=RMIN+REAL(ii-1)/REAL(F%dims(1)-1)*(RMAX-RMIN) !          end do !          do ii=1_idef,F%dims(3) !             F%X%Z(ii)=ZMIN+REAL(ii-1)/REAL(F%dims(3)-1)*(ZMAX-ZMIN) !          end do !          call calculate_initial_magnetic_field(F) !          F%E_2D%R=0._rp !          do ii=1_idef,F%dims(1) !             F%E_2D%PHI(ii,:)=F%Eo*F%Ro/F%X%R(ii) !          end do !          F%E_2D%Z=0._rp !       end if !       if (F%Bflux.and.test) then !          F%Bfield=.TRUE. !          F%Efield=.TRUE. !          F%Efield_in_file=.TRUE. !          call ALLOCATE_2D_FIELDS_ARRAYS(params,F,F%Bfield, & !               F%Bflux,F%Efield.AND.F%Efield_in_file) ! B ! edge nodes at minimum R,Z !          F%B_2D%Z(1,:)=-(F%PSIp(2,:)-F%PSIp(1,:))/(F%X%R(2)-F%X%R(1))/F%X%R(1) !          F%B_2D%R(:,1)=(F%PSIp(:,2)-F%PSIp(:,1))/(F%X%Z(2)-F%X%Z(1))/F%X%R(:) ! edge nodes at maximum R,Z !          F%B_2D%Z(F%dims(1),:)=-(F%PSIp(F%dims(1),:)-F%PSIp(F%dims(1)-1,:))/ & !               (F%X%R(F%dims(1))-F%X%R(F%dims(1)-1))/F%X%R(F%dims(1)) !          F%B_2D%R(:,F%dims(3))=(F%PSIp(:,F%dims(3))-F%PSIp(:,F%dims(3)-1))/ & !               (F%X%Z(F%dims(3))-F%X%Z(F%dims(3)-1))/F%X%R(:) !          do ii=2_idef,F%dims(1)-1 ! central difference over R for interior nodes for BZ !             F%B_2D%Z(ii,:)=-(F%PSIp(ii+1,:)-F%PSIp(ii-1,:))/ & !                  (F%X%R(ii+1)-F%X%R(ii-1))/F%X%R(ii) !          end do !          do ii=2_idef,F%dims(3)-1 ! central difference over Z for interior nodes for BR !             F%B_2D%R(:,ii)=(F%PSIp(:,ii+1)-F%PSIp(:,ii-1))/ & !                  (F%X%Z(ii+1)-F%X%Z(ii-1))/F%X%R(:) !          end do !          do ii=1_idef,F%dims(1) !             F%B_2D%PHI(ii,:)=-F%Bo*F%Ro/F%X%R(ii) !          end do !          F%E_2D%R=0._rp !          do ii=1_idef,F%dims(1) !             F%E_2D%PHI(ii,:)=F%Eo*F%Ro/F%X%R(ii) !          end do !          F%E_2D%Z=0._rp !          F%Bfield=.FALSE. if ( params % mpi_params % rank . EQ . 0 ) then if ( F % axisymmetric_fields ) then if ( F % Bflux ) then write ( output_unit_write , '(\"PSIp(r=0)\",E17.10)' ) F % PSIp ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"BPHI(r=0)\",E17.10)' ) F % Bo write ( output_unit_write , '(\"EPHI(r=0)\",E17.10)' ) F % Eo else if ( F % Bflux3D ) then write ( output_unit_write , '(\"PSIp(r=0)\",E17.10)' ) F % PSIp3D ( F % dims ( 1 ) / 2 , 1 , F % dims ( 3 ) / 2 ) else write ( output_unit_write , '(\"BR(r=0)\",E17.10)' ) F % B_2D % R ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"BPHI(r=0)\",E17.10)' ) & F % B_2D % PHI ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"BZ(r=0)\",E17.10)' ) F % B_2D % Z ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) write ( output_unit_write , '(\"EPHI(r=0)\",E17.10)' ) & F % E_2D % PHI ( F % dims ( 1 ) / 2 , F % dims ( 3 ) / 2 ) end if end if end if if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , '(\"Initializing GC fields from external EM fields\")' ) end if if ( params % field_model ( 10 : 12 ). eq . '2DB' ) then if ( F % axisymmetric_fields ) then call initialize_GC_fields ( F ) else call initialize_GC_fields_3D ( F ) end if end if end if !       write(output_unit_write,'(\"gradBR\",E17.10)') F%gradB_2D%R(F%dims(1)/2,F%dims(3)/2) !       write(output_unit_write,'(\"gradBPHI\",E17.10)') F%gradB_2D%PHI(F%dims(1)/2,F%dims(3)/2) !       write(output_unit_write,'(\"gradBZ\",E17.10)') F%gradB_2D%Z(F%dims(1)/2,F%dims(3)/2) end if if ( params % mpi_params % rank . eq . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine initialize_fields","tags":"","loc":"proc/initialize_fields.html"},{"title":"initialize_GC_fields – KORC-Full Orbit","text":"private subroutine initialize_GC_fields(F) Computes the auxiliary fields and that are used in the RHS of the\n evolution equations for the GC orbit model. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. Contents Source Code initialize_GC_fields Source Code subroutine initialize_GC_fields ( F ) !! Computes the auxiliary fields \\nabla|{\\bf B}| and !! \\nabla\\times\\hat{b} that are used in the RHS of the !! evolution equations for the GC orbit model. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. INTEGER :: ii !! Iterator across F%dim REAL ( rp ), DIMENSION (:,:), ALLOCATABLE :: Bmag !! Magnetic field magnitude REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: bhat !! Magnetic field unit vector Bmag = SQRT ( F % B_2D % R ** 2 + F % B_2D % PHI ** 2 + F % B_2D % Z ** 2 ) ALLOCATE ( bhat ( F % dims ( 1 ), F % dims ( 3 ), 3 )) bhat (:,:, 1 ) = F % B_2D % R / Bmag bhat (:,:, 2 ) = F % B_2D % PHI / Bmag bhat (:,:, 3 ) = F % B_2D % Z / Bmag F % gradB_2D % PHI = 0. ! No variation in phi direction ! Single-sided difference for axiliary fields at edge nodes ! Differential over R on first index, differential over Z ! on second index. ! gradB ! edge nodes at minimum R,Z F % gradB_2D % R ( 1 ,:) = ( Bmag ( 2 ,:) - Bmag ( 1 ,:)) / ( F % X % R ( 2 ) - F % X % R ( 1 )) F % gradB_2D % Z (:, 1 ) = ( Bmag (:, 2 ) - Bmag (:, 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! edge nodes at maximum R,Z F % gradB_2D % R ( F % dims ( 1 ),:) = ( Bmag ( F % dims ( 1 ),:) - Bmag ( F % dims ( 1 ) - 1 ,:)) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) F % gradB_2D % Z (:, F % dims ( 3 )) = ( Bmag (:, F % dims ( 3 )) - Bmag (:, F % dims ( 3 ) - 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! curlb ! edge nodes at minimum R,Z ! R component has differential over Z F % curlb_2D % R (:, 1 ) =- ( bhat (:, 2 , 2 ) - bhat (:, 1 , 2 )) / & ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! PHI component has differentials over R and Z F % curlb_2D % PHI ( 1 ,:) =- ( bhat ( 2 ,:, 3 ) - bhat ( 1 ,:, 3 )) / & ( F % X % R ( 2 ) - F % X % R ( 1 )) F % curlb_2D % PHI (:, 1 ) = F % curlb_2D % PHI (:, 1 ) + & (( bhat (:, 2 , 1 ) - bhat (:, 1 , 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 ))) ! Z component has differentials over R F % curlb_2D % Z ( 1 ,:) = (( bhat ( 2 ,:, 2 ) * F % X % R ( 2 ) - & bhat ( 1 ,:, 2 ) * F % X % R ( 1 )) / ( F % X % R ( 2 ) - F % X % R ( 1 ))) / F % X % R ( 1 ) ! edge nodes at minimum R,Z ! R component has differential over Z F % curlb_2D % R (:, F % dims ( 3 )) =- ( bhat (:, F % dims ( 3 ), 2 ) - & bhat (:, F % dims ( 3 ) - 1 , 2 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! PHI component has differentials over R and Z F % curlb_2D % PHI ( F % dims ( 1 ),:) = F % curlb_2D % PHI ( F % dims ( 1 ),:) - & ( bhat ( F % dims ( 1 ),:, 3 ) - bhat ( F % dims ( 1 ) - 1 ,:, 3 )) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) F % curlb_2D % PHI (:, F % dims ( 3 )) = F % curlb_2D % PHI (:, F % dims ( 3 )) + & (( bhat (:, F % dims ( 3 ), 1 ) - bhat (:, F % dims ( 3 ) - 1 , 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 ))) ! Z component has differentials over R F % curlb_2D % Z ( F % dims ( 1 ),:) = (( bhat ( F % dims ( 1 ),:, 2 ) * F % X % R ( F % dims ( 1 )) - & bhat ( F % dims ( 1 ) - 1 ,:, 2 ) * F % X % R ( F % dims ( 1 ) - 1 )) / ( F % X % R ( F % dims ( 1 )) - & F % X % R ( F % dims ( 1 ) - 1 ))) / F % X % R ( F % dims ( 1 )) do ii = 2_idef , F % dims ( 1 ) - 1 ! central difference over R for interior nodes F % gradB_2D % R ( ii ,:) = ( Bmag ( ii + 1 ,:) - Bmag ( ii - 1 ,:)) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) F % curlb_2D % Z ( ii ,:) = (( bhat ( ii + 1 ,:, 2 ) * F % X % R ( ii + 1 ) - & bhat ( ii - 1 ,:, 2 ) * F % X % R ( ii - 1 )) / ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 ))) / & F % X % R ( ii ) F % curlb_2D % PHI ( ii ,:) = F % curlb_2D % PHI ( ii ,:) - & ( bhat ( ii + 1 ,:, 3 ) - bhat ( ii - 1 ,:, 3 )) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) end do do ii = 2_idef , F % dims ( 3 ) - 1 ! central difference over Z for interior nodes F % gradB_2D % Z (:, ii ) = ( Bmag (:, ii + 1 ) - Bmag (:, ii - 1 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_2D % R (:, ii ) =- ( bhat (:, ii + 1 , 2 ) - bhat (:, ii - 1 , 2 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_2D % PHI (:, ii ) = F % curlb_2D % PHI (:, ii ) + & (( bhat (:, ii + 1 , 1 ) - bhat (:, ii - 1 , 1 )) / ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 ))) end do DEALLOCATE ( Bmag ) DEALLOCATE ( bhat ) end subroutine initialize_GC_fields","tags":"","loc":"proc/initialize_gc_fields.html"},{"title":"initialize_GC_fields_3D – KORC-Full Orbit","text":"private subroutine initialize_GC_fields_3D(F) Computes the auxiliary fields and that are used in the RHS of the\n evolution equations for the GC orbit model. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. Contents Source Code initialize_GC_fields_3D Source Code subroutine initialize_GC_fields_3D ( F ) !! Computes the auxiliary fields \\nabla|{\\bf B}| and !! \\nabla\\times\\hat{b} that are used in the RHS of the !! evolution equations for the GC orbit model. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. INTEGER :: ii , jj !! Iterator across F%dim REAL ( rp ), DIMENSION (:,:,:), ALLOCATABLE :: Bmag !! Magnetic field magnitude REAL ( rp ), DIMENSION (:,:,:,:), ALLOCATABLE :: bhat !! Magnetic field unit vector Bmag = SQRT ( F % B_3D % R ** 2 + F % B_3D % PHI ** 2 + F % B_3D % Z ** 2 ) ALLOCATE ( bhat ( F % dims ( 1 ), F % dims ( 2 ), F % dims ( 3 ), 3 )) bhat (:,:,:, 1 ) = F % B_3D % R / Bmag bhat (:,:,:, 2 ) = F % B_3D % PHI / Bmag bhat (:,:,:, 3 ) = F % B_3D % Z / Bmag ! Single-sided difference for axiliary fields at edge nodes ! Differential over R on first index, differential over Z ! on second index. F % gradB_3D % R = 0._rp F % gradB_3D % PHI = 0._rp F % gradB_3D % Z = 0._rp F % curlb_3D % R = 0._rp F % curlb_3D % PHI = 0._rp F % curlb_3D % Z = 0._rp ! gradB ! edge nodes at minimum R,Z F % gradB_3D % R ( 1 ,:,:) = F % gradB_3D % R ( 1 ,:,:) + & ( Bmag ( 2 ,:,:) - Bmag ( 1 ,:,:)) / ( F % X % R ( 2 ) - F % X % R ( 1 )) do ii = 1_idef , F % dims ( 1 ) F % gradB_3D % PHI ( ii , 1 ,:) = F % gradB_3D % PHI ( ii , 1 ,:) + & ( Bmag ( ii , 2 ,:) - Bmag ( ii , F % dims ( 2 ),:)) / & ( F % X % R ( ii ) * ( F % X % PHI ( 2 ) - F % X % PHI ( F % dims ( 2 )))) end do F % gradB_3D % Z (:,:, 1 ) = F % gradB_3D % Z (:,:, 1 ) + & ( Bmag (:,:, 2 ) - Bmag (:,:, 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! edge nodes at maximum R,Z F % gradB_3D % R ( F % dims ( 1 ),:,:) = F % gradB_3D % R ( F % dims ( 1 ),:,:) + & ( Bmag ( F % dims ( 1 ),:,:) - Bmag ( F % dims ( 1 ) - 1 ,:,:)) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) do ii = 1_idef , F % dims ( 1 ) F % gradB_3D % PHI ( ii , F % dims ( 2 ),:) = F % gradB_3D % PHI ( ii , F % dims ( 2 ),:) + & ( Bmag ( ii , 1 ,:) - Bmag ( ii , F % dims ( 2 ) - 1 ,:)) / & ( F % X % R ( ii ) * ( F % X % PHI ( 1 ) - F % X % PHI ( F % dims ( 2 ) - 1 ))) end do F % gradB_3D % Z (:,:, F % dims ( 3 )) = F % gradB_3D % Z (:,:, F % dims ( 3 )) + & ( Bmag (:,:, F % dims ( 3 )) - Bmag (:,:, F % dims ( 3 ) - 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! curlb ! edge nodes at minimum R,PHI,Z ! R component has differential over PHI and Z do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % R ( ii , 1 ,:) = F % curlb_3D % R ( ii , 1 ,:) + & ( bhat ( ii , 2 ,:, 3 ) - bhat ( ii , F % dims ( 2 ),:, 3 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 2 ) - F % X % PHI ( F % dims ( 2 )))) end do F % curlb_3D % R (:,:, 1 ) = F % curlb_3D % R (:,:, 1 ) - & ( bhat (:,:, 2 , 2 ) - bhat (:,:, 1 , 2 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 )) ! PHI component has differentials over R and Z F % curlb_3D % PHI ( 1 ,:,:) = F % curlb_3D % PHI ( 1 ,:,:) - & ( bhat ( 2 ,:,:, 3 ) - bhat ( 1 ,:,:, 3 )) / & ( F % X % R ( 2 ) - F % X % R ( 1 )) F % curlb_3D % PHI (:,:, 1 ) = F % curlb_3D % PHI (:,:, 1 ) + & (( bhat (:,:, 2 , 1 ) - bhat (:,:, 1 , 1 )) / ( F % X % Z ( 2 ) - F % X % Z ( 1 ))) ! Z component has differentials over R and PHI F % curlb_3D % Z ( 1 ,:,:) = F % curlb_3D % Z ( 1 ,:,:) + & (( bhat ( 2 ,:,:, 2 ) * F % X % R ( 2 ) - & bhat ( 1 ,:,:, 2 ) * F % X % R ( 1 )) / ( F % X % R ( 2 ) - F % X % R ( 1 ))) / F % X % R ( 1 ) do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % Z ( ii , 1 ,:) = F % curlb_3D % Z ( ii , 1 ,:) - & ( bhat ( ii , 2 ,:, 1 ) - bhat ( ii , F % dims ( 2 ),:, 1 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 2 ) - F % X % PHI ( F % dims ( 2 )))) end do ! edge nodes at maximum R,PHI,Z ! R component has differential over PHI and Z do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % R ( ii , F % dims ( 2 ),:) = F % curlb_3D % R ( ii , F % dims ( 2 ),:) + & ( bhat ( ii , 1 ,:, 3 ) - bhat ( ii , F % dims ( 2 ) - 1 ,:, 3 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 1 ) - F % X % PHI ( F % dims ( 2 ) - 1 ))) end do F % curlb_3D % R (:,:, F % dims ( 3 )) = F % curlb_3D % R (:,:, F % dims ( 3 )) & - ( bhat (:,:, F % dims ( 3 ), 2 ) - bhat (:,:, F % dims ( 3 ) - 1 , 2 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 )) ! PHI component has differentials over R and Z F % curlb_3D % PHI ( F % dims ( 1 ),:,:) = F % curlb_3D % PHI ( F % dims ( 1 ),:,:) - & ( bhat ( F % dims ( 1 ),:,:, 3 ) - bhat ( F % dims ( 1 ) - 1 ,:,:, 3 )) / & ( F % X % R ( F % dims ( 1 )) - F % X % R ( F % dims ( 1 ) - 1 )) F % curlb_3D % PHI (:,:, F % dims ( 3 )) = F % curlb_3D % PHI (:,:, F % dims ( 3 )) + & (( bhat (:,:, F % dims ( 3 ), 1 ) - bhat (:,:, F % dims ( 3 ) - 1 , 1 )) / & ( F % X % Z ( F % dims ( 3 )) - F % X % Z ( F % dims ( 3 ) - 1 ))) ! Z component has differentials over R and PHI F % curlb_3D % Z ( F % dims ( 1 ),:,:) = F % curlb_3D % Z ( F % dims ( 1 ),:,:) + & (( bhat ( F % dims ( 1 ),:,:, 2 ) * F % X % R ( F % dims ( 1 )) - & bhat ( F % dims ( 1 ) - 1 ,:,:, 2 ) * F % X % R ( F % dims ( 1 ) - 1 )) / ( F % X % R ( F % dims ( 1 )) - & F % X % R ( F % dims ( 1 ) - 1 ))) / F % X % R ( F % dims ( 1 )) do ii = 1_idef , F % dims ( 1 ) F % curlb_3D % Z ( ii , F % dims ( 2 ),:) = F % curlb_3D % Z ( ii , F % dims ( 2 ),:) - & ( bhat ( ii , 1 ,:, 1 ) - bhat ( ii , F % dims ( 2 ) - 1 ,:, 1 )) / & ( F % X % R ( ii ) * ( F % X % PHI ( 1 ) - F % X % PHI ( F % dims ( 2 ) - 1 ))) end do do ii = 2_idef , F % dims ( 1 ) - 1 ! central difference over R for interior nodes F % gradB_3D % R ( ii ,:,:) = F % gradB_3D % R ( ii ,:,:) + & ( Bmag ( ii + 1 ,:,:) - Bmag ( ii - 1 ,:,:)) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) F % curlb_3D % Z ( ii ,:,:) = F % curlb_3D % Z ( ii ,:,:) + & (( bhat ( ii + 1 ,:,:, 2 ) * F % X % R ( ii + 1 ) - & bhat ( ii - 1 ,:,:, 2 ) * F % X % R ( ii - 1 )) / ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 ))) / & F % X % R ( ii ) F % curlb_3D % PHI ( ii ,:,:) = F % curlb_3D % PHI ( ii ,:,:) - & ( bhat ( ii + 1 ,:,:, 3 ) - bhat ( ii - 1 ,:,:, 3 )) / & ( F % X % R ( ii + 1 ) - F % X % R ( ii - 1 )) end do do ii = 2_idef , F % dims ( 2 ) - 1 ! central difference over PHI for interior nodes do jj = 1_idef , F % dims ( 1 ) F % gradB_3D % PHI ( jj , ii ,:) = F % gradB_3D % PHI ( jj , ii ,:) + & ( Bmag ( jj , ii + 1 ,:) - Bmag ( jj , ii - 1 ,:)) / & ( F % X % R ( jj ) * ( F % X % PHI ( ii + 1 ) - F % X % PHI ( ii - 1 ))) F % curlb_3D % Z ( jj , ii ,:) = F % curlb_3D % Z ( jj , ii ,:) - & ( bhat ( jj , ii + 1 ,:, 1 ) - bhat ( jj , ii - 1 ,:, 1 )) / & ( F % X % R ( jj ) * ( F % X % PHI ( ii + 1 ) - F % X % PHI ( ii - 1 ))) F % curlb_3D % R ( jj , ii ,:) = F % curlb_3D % R ( jj , ii ,:) + & ( bhat ( jj , ii + 1 ,:, 3 ) - bhat ( jj , ii - 1 ,:, 3 )) / & ( F % X % R ( jj ) * ( F % X % PHI ( ii + 1 ) - F % X % PHI ( ii - 1 ))) end do end do do ii = 2_idef , F % dims ( 3 ) - 1 ! central difference over Z for interior nodes F % gradB_3D % Z (:,:, ii ) = F % gradB_3D % Z (:,:, ii ) + & ( Bmag (:,:, ii + 1 ) - Bmag (:,:, ii - 1 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_3D % R (:,:, ii ) = F % curlb_3D % R (:,:, ii ) - & ( bhat (:,:, ii + 1 , 2 ) - bhat (:,:, ii - 1 , 2 )) / & ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 )) F % curlb_3D % PHI (:,:, ii ) = F % curlb_3D % PHI (:,:, ii ) + & (( bhat (:,:, ii + 1 , 1 ) - bhat (:,:, ii - 1 , 1 )) / ( F % X % Z ( ii + 1 ) - F % X % Z ( ii - 1 ))) end do DEALLOCATE ( Bmag ) DEALLOCATE ( bhat ) end subroutine initialize_GC_fields_3D","tags":"","loc":"proc/initialize_gc_fields_3d.html"},{"title":"define_SC_time_step – KORC-Full Orbit","text":"public subroutine define_SC_time_step(params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params type(FIELDS), intent(inout) :: F Contents Source Code define_SC_time_step Source Code subroutine define_SC_time_step ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F integer :: sub_E_SC F % subcycle_E_SC = FLOOR ( F % dt_E_SC / params % dt , ip ) sub_E_SC = F % subcycle_E_SC params % t_it_SC = params % t_skip / F % subcycle_E_SC params % t_skip = F % subcycle_E_SC F % dt_E_SC = params % t_skip * params % dt !    write(output_unit_write,*) 'dt_E_SC',F%dt_E_SC,'dt',params%dt,'subcycle_E_SC', & !         F%subcycle_E_SC,'t_skip',params%t_skip, & !         't_it_SC',params%t_it_SC if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(/,\"* * * * * SC_E1D SUBCYCLING * * * * *\")' ) write ( output_unit_write , * ) \"SC_E1D sybcycling iterations: \" , F % subcycle_E_SC write ( output_unit_write , * ) \"Updated number of outputs: \" , & params % t_steps / ( params % t_skip * params % t_it_SC ) write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * *\",/)' ) end if end subroutine define_SC_time_step","tags":"","loc":"proc/define_sc_time_step.html"},{"title":"load_dim_data_from_hdf5 – KORC-Full Orbit","text":"public subroutine load_dim_data_from_hdf5(params, F) @brief Subroutine that loads the size of the arrays having the electric and magnetic field data.\n @details All the information of externally calculated fields must be given in a rectangular, equally spaced mesh in the space of cylindrical coordinates.\n If the fields are axisymmetric, then the fields must be in a rectangular mesh on the -plane. @param[in] params Core KORC simulation parameters.\n @param[in,out] F An instance of the KORC derived type FIELDS.\n @param filename String containing the name of the HDF5 file.\n @param gname String containing the group name of a parameter in the HDF5 file.\n @param subgname String containing the subgroup name of a parameter in the HDF5 file.\n @param dset Name of data set to read from file.\n @param h5file_id HDF5 file identifier.\n @param group_id HDF5 group identifier.\n @param subgroup_id HDF5 subgroup identifier.\n @dims Array containing the size of the mesh with the data of the electric and magnetic fields. dims(1) = dimension along the coordinate,\n dims(2) = dimension along the coordinate, and dims(3) = dimension along the coordinate.\n @param h5error HDF5 error status.\n @param rdamum Temporary variable keeping the read data. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F Contents Source Code load_dim_data_from_hdf5 Source Code subroutine load_dim_data_from_hdf5 ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER ( HSIZE_T ), DIMENSION (:), ALLOCATABLE :: dims INTEGER :: h5error REAL ( rp ) :: rdatum filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_dim_data_from_hdf5 --> h5fopen_f\")' ) end if if ( F % Bflux . OR . F % axisymmetric_fields ) then dset = \"/NR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 1 ) = INT ( rdatum ) F % dims ( 2 ) = 0 dset = \"/NZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 3 ) = INT ( rdatum ) if ( params % SC_E ) then dset = \"/OSNR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 1 ) = INT ( rdatum ) dset = \"/OSNZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 3 ) = INT ( rdatum ) end if if ( F % Dim2x1t ) then dset = \"/NPHI\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 2 ) = INT ( rdatum ) end if else dset = \"/NR\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 1 ) = INT ( rdatum ) dset = \"/NPHI\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 2 ) = INT ( rdatum ) dset = \"/NZ\" call load_from_hdf5 ( h5file_id , dset , rdatum ) F % dims ( 3 ) = INT ( rdatum ) end if call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_dim_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_dim_data_from_hdf5","tags":"","loc":"proc/load_dim_data_from_hdf5.html"},{"title":"which_fields_in_file – KORC-Full Orbit","text":"public subroutine which_fields_in_file(params, Bfield, Efield, Bflux, dBfield) @brief Subroutine that queries the HDF5 file what data are present in the HDF5 input file (sanity check). @param[in] params Core KORC simulation parameters.\n @param Bfield Logical variable that specifies if the magnetic field is present in the HDF5 file.\n @param Efield Logical variable that specifies if the electric field is present in the HDF5 file.\n @param Bflux Logical variable that specifies if the poloidal magnetic flux is present in the HDF5 file.\n @param filename String containing the name of the HDF5 file.\n @param gname String containing the group name of a parameter in the HDF5 file.\n @param subgname String containing the subgroup name of a parameter in the HDF5 file.\n @param dset Name of data set to read from file.\n @param h5file_id HDF5 file identifier.\n @param group_id HDF5 group identifier.\n @param subgroup_id HDF5 subgroup identifier.\n @param h5error HDF5 error status. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params logical, intent(out) :: Bfield logical, intent(out) :: Efield logical, intent(out) :: Bflux logical, intent(out) :: dBfield Contents Source Code which_fields_in_file Source Code subroutine which_fields_in_file ( params , Bfield , Efield , Bflux , dBfield ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params LOGICAL , INTENT ( OUT ) :: Bfield LOGICAL , INTENT ( OUT ) :: dBfield LOGICAL , INTENT ( OUT ) :: Efield LOGICAL , INTENT ( OUT ) :: Bflux CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER :: h5error filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if gname = \"BR\" call h5lexists_f ( h5file_id , TRIM ( gname ), Bfield , h5error ) gname = \"dBRdR\" call h5lexists_f ( h5file_id , TRIM ( gname ), dBfield , h5error ) gname = \"ER\" call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) gname = \"PSIp\" call h5lexists_f ( h5file_id , TRIM ( gname ), Bflux , h5error ) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine which_fields_in_file","tags":"","loc":"proc/which_fields_in_file.html"},{"title":"load_field_data_from_hdf5 – KORC-Full Orbit","text":"public subroutine load_field_data_from_hdf5(params, F) @brief Subroutine that loads the fields data from the HDF5 input file. @param[in] params Core KORC simulation parameters.\n @param[in,out] F An instance of the KORC derived type FIELDS. In this variable we keep the loaded data.\n @param filename String containing the name of the HDF5 file.\n @param gname String containing the group name of a parameter in the HDF5 file.\n @param subgname String containing the subgroup name of a parameter in the HDF5 file.\n @param dset Name of data set to read from file.\n @param h5file_id HDF5 file identifier.\n @param group_id HDF5 group identifier.\n @param subgroup_id HDF5 subgroup identifier.\n @param h5error HDF5 error status. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F Contents Source Code load_field_data_from_hdf5 Source Code subroutine load_field_data_from_hdf5 ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: gname CHARACTER ( MAX_STRING_LENGTH ) :: subgname CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER ( HID_T ) :: group_id INTEGER ( HID_T ) :: subgroup_id INTEGER :: h5error LOGICAL :: Efield filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if if (((. NOT . F % Bflux ). AND .(. NOT . F % axisymmetric_fields )). OR . & F % Dim2x1t ) then dset = \"/PHI\" call load_array_from_hdf5 ( h5file_id , dset , F % X % PHI ) end if if ( params % SC_E ) then dset = \"/OSR\" call load_array_from_hdf5 ( h5file_id , dset , F % X % R ) dset = \"/OSZ\" call load_array_from_hdf5 ( h5file_id , dset , F % X % Z ) else dset = \"/R\" call load_array_from_hdf5 ( h5file_id , dset , F % X % R ) dset = \"/Z\" call load_array_from_hdf5 ( h5file_id , dset , F % X % Z ) end if dset = '/Bo' call load_from_hdf5 ( h5file_id , dset , F % Bo ) if ( F % Efield ) then dset = '/Eo' gname = 'Eo' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_from_hdf5 ( h5file_id , dset , F % Eo ) else F % Eo = 0.0_rp end if else F % Eo = 0.0_rp end if dset = '/Ro' call load_from_hdf5 ( h5file_id , dset , F % Ro ) dset = '/Zo' call load_from_hdf5 ( h5file_id , dset , F % Zo ) if (( F % Bflux . OR . F % axisymmetric_fields ). AND .(. NOT . F % Dim2x1t )) then if ( params % SC_E ) then dset = \"/OSFLAG\" call load_array_from_hdf5 ( h5file_id , dset , F % FLAG2D ) else dset = \"/FLAG\" call load_array_from_hdf5 ( h5file_id , dset , F % FLAG2D ) end if else dset = \"/FLAG\" call load_array_from_hdf5 ( h5file_id , dset , F % FLAG3D ) end if if ( F % Bflux ) then if ( params % SC_E ) then dset = \"/OSPSIp\" gname = 'OSPSIp' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_array_from_hdf5 ( h5file_id , dset , F % PSIp ) else F % PSIp = 0.0_rp end if else dset = \"/PSIp\" gname = 'PSIp' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_array_from_hdf5 ( h5file_id , dset , F % PSIp ) else F % PSIp = 0.0_rp end if !          F%PSIp=2*C_PI*(F%PSIp-minval(F%PSIp)) end if end if if ( F % Bflux3D ) then dset = \"/PSIp\" gname = 'PSIp' call h5lexists_f ( h5file_id , TRIM ( gname ), Efield , h5error ) if ( Efield ) then call load_array_from_hdf5 ( h5file_id , dset , F % PSIp3D ) else F % PSIp3D = 0.0_rp end if !       F%PSIp3D=2*C_PI*(F%PSIp3D-minval(F%PSIp3D)) end if if ( F % Bfield ) then if ( F % axisymmetric_fields ) then dset = \"/BR\" call load_array_from_hdf5 ( h5file_id , dset , F % B_2D % R ) dset = \"/BPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % B_2D % PHI ) dset = \"/BZ\" call load_array_from_hdf5 ( h5file_id , dset , F % B_2D % Z ) else dset = \"/BR\" call load_array_from_hdf5 ( h5file_id , dset , F % B_3D % R ) dset = \"/BPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % B_3D % PHI ) dset = \"/BZ\" call load_array_from_hdf5 ( h5file_id , dset , F % B_3D % Z ) end if end if if ( F % dBfield . and . F % dBfield_in_file ) then if ( F % axisymmetric_fields ) then dset = \"/dBRdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_2D % R ) dset = \"/dBPHIdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_2D % PHI ) dset = \"/dBZdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_2D % Z ) dset = \"/dBRdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_2D % R ) dset = \"/dBPHIdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_2D % PHI ) dset = \"/dBZdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_2D % Z ) dset = \"/dBRdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_2D % R ) dset = \"/dBPHIdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_2D % PHI ) dset = \"/dBZdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_2D % Z ) else dset = \"/dBRdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_3D % R ) dset = \"/dBPHIdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_3D % PHI ) dset = \"/dBZdR\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdR_3D % Z ) dset = \"/dBRdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_3D % R ) dset = \"/dBPHIdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_3D % PHI ) dset = \"/dBZdPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdPHI_3D % Z ) dset = \"/dBRdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_3D % R ) dset = \"/dBPHIdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_3D % PHI ) dset = \"/dBZdZ\" call load_array_from_hdf5 ( h5file_id , dset , F % dBdZ_3D % Z ) end if end if if ( F % Efield . AND . F % Efield_in_file ) then if ( F % axisymmetric_fields . and .(. not . F % ReInterp_2x1t )) then dset = \"/ER\" call load_array_from_hdf5 ( h5file_id , dset , F % E_2D % R ) dset = \"/EPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % E_2D % PHI ) dset = \"/EZ\" call load_array_from_hdf5 ( h5file_id , dset , F % E_2D % Z ) else dset = \"/ER\" call load_array_from_hdf5 ( h5file_id , dset , F % E_3D % R ) dset = \"/EPHI\" call load_array_from_hdf5 ( h5file_id , dset , F % E_3D % PHI ) dset = \"/EZ\" call load_array_from_hdf5 ( h5file_id , dset , F % E_3D % Z ) end if end if call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_field_data_from_hdf5","tags":"","loc":"proc/load_field_data_from_hdf5.html"},{"title":"load_1D_FS_from_hdf5 – KORC-Full Orbit","text":"public subroutine load_1D_FS_from_hdf5(params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F Contents Source Code load_1D_FS_from_hdf5 Source Code subroutine load_1D_FS_from_hdf5 ( params , F ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F CHARACTER ( MAX_STRING_LENGTH ) :: filename CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER :: h5error filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if dset = \"/PSIP1D\" call load_array_from_hdf5 ( h5file_id , dset , F % PSIP_1D ) dset = \"/dMagPsiSqdPsiP\" call load_array_from_hdf5 ( h5file_id , dset , F % dMagPsiSqdPsiP ) dset = \"/ddMagPsiSqdPsiPSq\" call load_array_from_hdf5 ( h5file_id , dset , F % ddMagPsiSqdPsiPSq ) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine load_1D_FS_from_hdf5","tags":"","loc":"proc/load_1d_fs_from_hdf5.html"},{"title":"allocate_1D_FS_arrays – KORC-Full Orbit","text":"public subroutine allocate_1D_FS_arrays(params, F) Note Subroutine that allocates the variables keeping the axisymmetric\n fields data. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. In this variable we keep\n the loaded data. Contents Source Code allocate_1D_FS_arrays Source Code subroutine allocate_1D_FS_arrays ( params , F ) !! @note Subroutine that allocates the variables keeping the axisymmetric !! fields data. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. In this variable we keep !! the loaded data. CHARACTER ( MAX_STRING_LENGTH ) :: dset INTEGER ( HID_T ) :: h5file_id INTEGER :: h5error CHARACTER ( MAX_STRING_LENGTH ) :: filename filename = TRIM ( params % magnetic_field_filename ) call h5fopen_f ( filename , H5F_ACC_RDONLY_F , h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fopen_f\")' ) end if dset = \"/N1D\" call load_from_hdf5 ( h5file_id , dset , F % dim_1D ) ALLOCATE ( F % PSIP_1D ( F % dim_1D )) ALLOCATE ( F % dMagPsiSqdPsiP ( F % dim_1D )) ALLOCATE ( F % ddMagPsiSqdPsiPSq ( F % dim_1D )) call h5fclose_f ( h5file_id , h5error ) if ( h5error . EQ . - 1 ) then write ( output_unit_write , '(\"KORC ERROR: Something went wrong in: load_field_data_from_hdf5 --> h5fclose_f\")' ) end if end subroutine ALLOCATE_1D_FS_ARRAYS","tags":"","loc":"proc/allocate_1d_fs_arrays.html"},{"title":"ALLOCATE_2D_FIELDS_ARRAYS – KORC-Full Orbit","text":"public subroutine ALLOCATE_2D_FIELDS_ARRAYS(params, F, bfield, bflux, dbfield, efield) Note Subroutine that allocates the variables keeping the axisymmetric\n fields data. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. In this variable we keep\n the loaded data. logical, intent(in) :: bfield logical, intent(in) :: bflux Logical variable that specifies if the variables that keep the poloidal\n magnetic flux data is allocated (bflux=T) or not (bflux=F). logical, intent(in) :: dbfield Logical variable that specifies if the variables that keep the magnetic\n field data is allocated (bfield=T) or not (bfield=F). logical, intent(in) :: efield Logical variable that specifies if the variables that keep the electric\n field data is allocated (efield=T) or not (efield=F). Contents Source Code ALLOCATE_2D_FIELDS_ARRAYS Source Code subroutine ALLOCATE_2D_FIELDS_ARRAYS ( params , F , bfield , bflux , dbfield , efield ) !! @note Subroutine that allocates the variables keeping the axisymmetric !! fields data. @endnote TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params !! Core KORC simulation parameters. TYPE ( FIELDS ), INTENT ( INOUT ) :: F !! An instance of the KORC derived type FIELDS. In this variable we keep !! the loaded data. LOGICAL , INTENT ( IN ) :: bfield LOGICAL , INTENT ( IN ) :: dbfield !! Logical variable that specifies if the variables that keep the magnetic !! field data is allocated (bfield=T) or not (bfield=F). LOGICAL , INTENT ( IN ) :: bflux !! Logical variable that specifies if the variables that keep the poloidal !! magnetic flux data is allocated (bflux=T) or not (bflux=F). LOGICAL , INTENT ( IN ) :: efield !! Logical variable that specifies if the variables that keep the electric !! field data is allocated (efield=T) or not (efield=F). if ( bfield . and .(. not . ALLOCATED ( F % B_2D % R ))) then call ALLOCATE_V_FIELD_2D ( F % B_2D , F % dims ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then call ALLOCATE_V_FIELD_2D ( F % curlb_2D , F % dims ) call ALLOCATE_V_FIELD_2D ( F % gradB_2D , F % dims ) end if end if if ( bflux . and .(. not . ALLOCATED ( F % PSIp ))) then ALLOCATE ( F % PSIp ( F % dims ( 1 ), F % dims ( 3 ))) end if if ( dbfield . and .(. not . ALLOCATED ( F % dBdR_2D % R ))) then call ALLOCATE_V_FIELD_2D ( F % dBdR_2D , F % dims ) call ALLOCATE_V_FIELD_2D ( F % dBdPHI_2D , F % dims ) call ALLOCATE_V_FIELD_2D ( F % dBdZ_2D , F % dims ) end if if ( efield . and .(. not . ALLOCATED ( F % E_2D % R ))) then call ALLOCATE_V_FIELD_2D ( F % E_2D , F % dims ) end if if (. NOT . ALLOCATED ( F % FLAG2D )) ALLOCATE ( F % FLAG2D ( F % dims ( 1 ), F % dims ( 3 ))) if (. NOT . ALLOCATED ( F % X % R )) ALLOCATE ( F % X % R ( F % dims ( 1 ))) if (. NOT . ALLOCATED ( F % X % Z )) ALLOCATE ( F % X % Z ( F % dims ( 3 ))) end subroutine ALLOCATE_2D_FIELDS_ARRAYS","tags":"","loc":"proc/allocate_2d_fields_arrays.html"},{"title":"ALLOCATE_3D_FIELDS_ARRAYS – KORC-Full Orbit","text":"public subroutine ALLOCATE_3D_FIELDS_ARRAYS(params, F, bfield, efield, dbfield) @brief Subroutine that allocates the variables keeping the 3-D fields data. @param[in,out] F An instance of the KORC derived type FIELDS. In this variable we keep the loaded data.\n @param[in] bfield Logical variable that specifies if the variables that keep the magnetic field data is allocated (bfield=T) or not (bfield=F).\n @param[in] efield Logical variable that specifies if the variables that keep the electric field data is allocated (efield=T) or not (efield=F). Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F logical, intent(in) :: bfield logical, intent(in) :: efield logical, intent(in) :: dbfield Contents Source Code ALLOCATE_3D_FIELDS_ARRAYS Source Code subroutine ALLOCATE_3D_FIELDS_ARRAYS ( params , F , bfield , efield , dbfield ) TYPE ( KORC_PARAMS ), INTENT ( IN ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F LOGICAL , INTENT ( IN ) :: bfield LOGICAL , INTENT ( IN ) :: dbfield LOGICAL , INTENT ( IN ) :: efield if ( bfield ) then call ALLOCATE_V_FIELD_3D ( F % B_3D , F % dims ) if ( params % orbit_model ( 3 : 5 ). EQ . 'pre' ) then call ALLOCATE_V_FIELD_3D ( F % curlb_3D , F % dims ) call ALLOCATE_V_FIELD_3D ( F % gradB_3D , F % dims ) end if end if if ( F % Bflux3D . and .(. not . ALLOCATED ( F % PSIp3D ))) then ALLOCATE ( F % PSIp3D ( F % dims ( 1 ), F % dims ( 2 ), F % dims ( 3 ))) end if if ( dbfield . and .(. not . ALLOCATED ( F % dBdR_3D % R ))) then call ALLOCATE_V_FIELD_3D ( F % dBdR_3D , F % dims ) call ALLOCATE_V_FIELD_3D ( F % dBdPHI_3D , F % dims ) call ALLOCATE_V_FIELD_3D ( F % dBdZ_3D , F % dims ) end if if ( efield ) then call ALLOCATE_V_FIELD_3D ( F % E_3D , F % dims ) end if if (. NOT . ALLOCATED ( F % FLAG3D )) ALLOCATE ( F % FLAG3D ( F % dims ( 1 ), F % dims ( 2 ), F % dims ( 3 ))) if (. NOT . ALLOCATED ( F % X % R )) ALLOCATE ( F % X % R ( F % dims ( 1 ))) if (. NOT . ALLOCATED ( F % X % PHI )) ALLOCATE ( F % X % PHI ( F % dims ( 2 ))) if (. NOT . ALLOCATED ( F % X % Z )) ALLOCATE ( F % X % Z ( F % dims ( 3 ))) end subroutine ALLOCATE_3D_FIELDS_ARRAYS","tags":"","loc":"proc/allocate_3d_fields_arrays.html"},{"title":"ALLOCATE_V_FIELD_2D – KORC-Full Orbit","text":"private subroutine ALLOCATE_V_FIELD_2D(F, dims) @brief Subroutine that allocates the cylindrical components of an axisymmetric field. @param[in,out] F Vector field to be allocated.\n @param[in] dims Dimension of the mesh containing the field data. Arguments Type Intent Optional Attributes Name type(V_FIELD_2D), intent(inout) :: F integer, intent(in), DIMENSION(3) :: dims Contents Source Code ALLOCATE_V_FIELD_2D Source Code subroutine ALLOCATE_V_FIELD_2D ( F , dims ) TYPE ( V_FIELD_2D ), INTENT ( INOUT ) :: F INTEGER , DIMENSION ( 3 ), INTENT ( IN ) :: dims ALLOCATE ( F % R ( dims ( 1 ), dims ( 3 ))) ALLOCATE ( F % PHI ( dims ( 1 ), dims ( 3 ))) ALLOCATE ( F % Z ( dims ( 1 ), dims ( 3 ))) end subroutine ALLOCATE_V_FIELD_2D","tags":"","loc":"proc/allocate_v_field_2d.html"},{"title":"ALLOCATE_V_FIELD_3D – KORC-Full Orbit","text":"private subroutine ALLOCATE_V_FIELD_3D(F, dims) @brief Subroutine that allocates the cylindrical components of a 3-D field. @param[in,out] F Vector field to be allocated.\n @param[in] dims Dimension of the mesh containing the field data. Arguments Type Intent Optional Attributes Name type(V_FIELD_3D), intent(inout) :: F integer, intent(in), DIMENSION(3) :: dims Contents Source Code ALLOCATE_V_FIELD_3D Source Code subroutine ALLOCATE_V_FIELD_3D ( F , dims ) TYPE ( V_FIELD_3D ), INTENT ( INOUT ) :: F INTEGER , DIMENSION ( 3 ), INTENT ( IN ) :: dims ALLOCATE ( F % R ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) ALLOCATE ( F % PHI ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) ALLOCATE ( F % Z ( dims ( 1 ), dims ( 2 ), dims ( 3 ))) end subroutine ALLOCATE_V_FIELD_3D","tags":"","loc":"proc/allocate_v_field_3d.html"},{"title":"DEALLOCATE_FIELDS_ARRAYS – KORC-Full Orbit","text":"public subroutine DEALLOCATE_FIELDS_ARRAYS(F) @brief Subroutine that deallocates all the variables of the electric and magnetic fields. @param[in,out] F An instance of the KORC derived type FIELDS. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F Contents Source Code DEALLOCATE_FIELDS_ARRAYS Source Code subroutine DEALLOCATE_FIELDS_ARRAYS ( F ) TYPE ( FIELDS ), INTENT ( INOUT ) :: F if ( ALLOCATED ( F % PSIp )) DEALLOCATE ( F % PSIp ) if ( ALLOCATED ( F % B_2D % R )) DEALLOCATE ( F % B_2D % R ) if ( ALLOCATED ( F % B_2D % PHI )) DEALLOCATE ( F % B_2D % PHI ) if ( ALLOCATED ( F % B_2D % Z )) DEALLOCATE ( F % B_2D % Z ) if ( ALLOCATED ( F % gradB_2D % R )) DEALLOCATE ( F % gradB_2D % R ) if ( ALLOCATED ( F % gradB_2D % PHI )) DEALLOCATE ( F % gradB_2D % PHI ) if ( ALLOCATED ( F % gradB_2D % Z )) DEALLOCATE ( F % gradB_2D % Z ) if ( ALLOCATED ( F % curlb_2D % R )) DEALLOCATE ( F % curlb_2D % R ) if ( ALLOCATED ( F % curlb_2D % PHI )) DEALLOCATE ( F % curlb_2D % PHI ) if ( ALLOCATED ( F % curlb_2D % Z )) DEALLOCATE ( F % curlb_2D % Z ) if ( ALLOCATED ( F % B_3D % R )) DEALLOCATE ( F % B_3D % R ) if ( ALLOCATED ( F % B_3D % PHI )) DEALLOCATE ( F % B_3D % PHI ) if ( ALLOCATED ( F % B_3D % Z )) DEALLOCATE ( F % B_3D % Z ) if ( ALLOCATED ( F % E_2D % R )) DEALLOCATE ( F % E_2D % R ) if ( ALLOCATED ( F % E_2D % PHI )) DEALLOCATE ( F % E_2D % PHI ) if ( ALLOCATED ( F % E_2D % Z )) DEALLOCATE ( F % E_2D % Z ) if ( ALLOCATED ( F % E_3D % R )) DEALLOCATE ( F % E_3D % R ) if ( ALLOCATED ( F % E_3D % PHI )) DEALLOCATE ( F % E_3D % PHI ) if ( ALLOCATED ( F % E_3D % Z )) DEALLOCATE ( F % E_3D % Z ) if ( ALLOCATED ( F % E_SC_1D % PHI )) DEALLOCATE ( F % E_SC_1D % PHI ) if ( ALLOCATED ( F % J1_SC_1D % PHI )) DEALLOCATE ( F % J1_SC_1D % PHI ) if ( ALLOCATED ( F % J2_SC_1D % PHI )) DEALLOCATE ( F % J2_SC_1D % PHI ) if ( ALLOCATED ( F % J3_SC_1D % PHI )) DEALLOCATE ( F % J3_SC_1D % PHI ) if ( ALLOCATED ( F % A1_SC_1D % PHI )) DEALLOCATE ( F % A1_SC_1D % PHI ) if ( ALLOCATED ( F % A2_SC_1D % PHI )) DEALLOCATE ( F % A2_SC_1D % PHI ) if ( ALLOCATED ( F % A3_SC_1D % PHI )) DEALLOCATE ( F % A3_SC_1D % PHI ) if ( ALLOCATED ( F % X % R )) DEALLOCATE ( F % X % R ) if ( ALLOCATED ( F % X % PHI )) DEALLOCATE ( F % X % PHI ) if ( ALLOCATED ( F % X % Z )) DEALLOCATE ( F % X % Z ) if ( ALLOCATED ( F % FLAG2D )) DEALLOCATE ( F % FLAG2D ) if ( ALLOCATED ( F % FLAG3D )) DEALLOCATE ( F % FLAG3D ) end subroutine DEALLOCATE_FIELDS_ARRAYS","tags":"","loc":"proc/deallocate_fields_arrays.html"},{"title":"cart_to_cyl – KORC-Full Orbit","text":"public subroutine cart_to_cyl(X, Xcyl) Note Subroutine that converts the position of simulated particles\n from Cartesian to cylindrical coordinates. Here, the coordinate transformation is: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: X Particles' position in Cartesian coordinates. X(1,:) = , X(2,:)\n = , X(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: Xcyl Particles' position in cylindrical coordinates. Xcyl(1,:) = ,\n Xcyl(2,:) = , Xcyl(3,:) = Contents Source Code cart_to_cyl Source Code subroutine cart_to_cyl ( X , Xcyl ) !! @note  Subroutine that converts the position of simulated particles !! from Cartesian (x,y,z) to cylindrical (R,\\phi,Z) coordinates. !! @endnote !! Here, the coordinate transformation is: !! !! R = \\sqrt{x&#94;2 + y&#94;2}, !! \\phi = \\arctan{\\left( \\frac{y}{x} \\right)}, !! Z = z. implicit none REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: X !! Particles' position in Cartesian coordinates. X(1,:) = x, X(2,:) !! = y, X(3,:) = z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: Xcyl !! Particles' position in cylindrical coordinates. Xcyl(1,:) = R, !! Xcyl(2,:) = \\phi, Xcyl(3,:) = Z INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. !    write(output_unit_write,'(\"X_X: \",E17.10)') X(1:10,1) !    write(output_unit_write,'(\"X_Y: \",E17.10)') X(1:10,2) !    write(output_unit_write,'(\"X_Z: \",E17.10)') X(1:10,3) if ( X ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( X , 1 ) end if !    write(output_unit_write,*) 'varX',X(:,1) !    write(output_unit_write,*) 'varY',X(:,2) !    write(output_unit_write,*) 'varR',Xcyl(:,1) !    write(output_unit_write,*) 'varPHI',Xcyl(:,2) !    !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp) SHARED(X,Xcyl) do pp = 1_idef , ss !       write(output_unit_write,*) 'pp',pp Xcyl ( pp , 1 ) = SQRT ( X ( pp , 1 ) ** 2 + X ( pp , 2 ) ** 2 ) Xcyl ( pp , 2 ) = ATAN2 ( X ( pp , 2 ), X ( pp , 1 )) Xcyl ( pp , 2 ) = MODULO ( Xcyl ( pp , 2 ), 2.0_rp * C_PI ) Xcyl ( pp , 3 ) = X ( pp , 3 ) end do !    !$OMP END PARALLEL DO !    write(output_unit_write,*) 'varX',X(:,1) !    write(output_unit_write,*) 'varY',X(:,2) !    write(output_unit_write,*) 'varR',Xcyl(:,1) !    write(output_unit_write,*) 'varPHI',Xcyl(:,2) end subroutine cart_to_cyl","tags":"","loc":"proc/cart_to_cyl.html"},{"title":"cart_to_cyl_p – KORC-Full Orbit","text":"public subroutine cart_to_cyl_p(pchunk, X_X, X_Y, X_Z, Y_R, Y_PHI, Y_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(out), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: Y_Z Contents Source Code cart_to_cyl_p Source Code subroutine cart_to_cyl_p ( pchunk , X_X , X_Y , X_Z , Y_R , Y_PHI , Y_Z ) implicit none INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: X_X REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: X_Y REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: X_Z REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Y_R REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Y_PHI REAL ( rp ), DIMENSION ( pchunk ), INTENT ( OUT ) :: Y_Z INTEGER :: pp !! Iterator. !$OMP SIMD !    !$OMP& aligned(Y_R,Y_PHI,Y_Z,X_X,X_Y,X_Z) do pp = 1_idef , pchunk Y_R ( pp ) = SQRT ( X_X ( pp ) * X_X ( pp ) + X_Y ( pp ) * X_Y ( pp )) Y_PHI ( pp ) = ATAN2 ( X_Y ( pp ), X_X ( pp )) Y_PHI ( pp ) = MODULO ( Y_PHI ( pp ), 2.0_rp * C_PI ) Y_Z ( pp ) = X_Z ( pp ) end do !$OMP END SIMD end subroutine cart_to_cyl_p","tags":"","loc":"proc/cart_to_cyl_p.html"},{"title":"cyl_to_cart – KORC-Full Orbit","text":"public subroutine cyl_to_cart(Xcyl, X) Note Subroutine that converts the position of simulated particles\n from cylindrical to Cartesian ((x,y,z)\\ coordinates. Here, the coordinate transformation is: Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Xcyl Particles' position in cylindrical coordinates. Xcyl(1,:) = ,\n Xcyl(2,:) = , Xcyl(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: X Particles' position in Cartesian coordinates. X(1,:) = , X(2,:)\n = , X(3,:) = Contents Source Code cyl_to_cart Source Code subroutine cyl_to_cart ( Xcyl , X ) !! @note  Subroutine that converts the position of simulated particles !! from cylindrical (R,\\phi,Z) to Cartesian (x,y,z)\\ coordinates. !! @endnote !! Here, the coordinate transformation is: !! !! x=R\\cos(\\phi), !! y=R\\sin(\\phi),, !! Z = z. implicit none REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: X !! Particles' position in Cartesian coordinates. X(1,:) = x, X(2,:) !! = y, X(3,:) = z REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Xcyl !! Particles' position in cylindrical coordinates. Xcyl(1,:) = R, !! Xcyl(2,:) = \\phi, Xcyl(3,:) = Z INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. if ( Xcyl ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Xcyl , 1 ) end if !$OMP PARALLEL DO FIRSTPRIVATE(ss) PRIVATE(pp) SHARED(X,Xcyl) do pp = 1_idef , ss X ( pp , 1 ) = Xcyl ( pp , 1 ) * cos ( Xcyl ( pp , 2 )) X ( pp , 2 ) = Xcyl ( pp , 1 ) * sin ( Xcyl ( pp , 2 )) X ( pp , 3 ) = Xcyl ( pp , 3 ) end do !$OMP END PARALLEL DO end subroutine cyl_to_cart","tags":"","loc":"proc/cyl_to_cart.html"},{"title":"cyl_check_if_confined – KORC-Full Orbit","text":"public subroutine cyl_check_if_confined(F, Xcyl, flag) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Xcyl Particles' position in cylindrical coordinates. Xcyl(1,:) = ,\n Xcyl(2,:) = , Xcyl(3,:) = integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Contents Source Code cyl_check_if_confined Source Code subroutine cyl_check_if_confined ( F , Xcyl , flag ) implicit none TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: Xcyl !! Particles' position in cylindrical coordinates. Xcyl(1,:) = R, !! Xcyl(2,:) = \\phi, Xcyl(3,:) = Z INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag REAL ( rp ) :: a !! Distance to plasma edge as measured from the magnetic axis. REAL ( rp ) :: Ro !! Radial position of the magnetic axis. INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. if ( Xcyl ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( Xcyl , 1 ) end if a = F % AB % a Ro = F % AB % Ro !$OMP PARALLEL DO FIRSTPRIVATE(ss,a,Ro) PRIVATE(pp) SHARED(Xcyl,flag) do pp = 1_idef , ss if ( sqrt (( Xcyl ( pp , 1 ) - Ro ) ** 2 + Xcyl ( pp , 3 ) ** 2 ) . gt . a ) then flag ( pp ) = 0_is endif end do !$OMP END PARALLEL DO end subroutine cyl_check_if_confined","tags":"","loc":"proc/cyl_check_if_confined.html"},{"title":"cyl_check_if_confined_p – KORC-Full Orbit","text":"public subroutine cyl_check_if_confined_p(pchunk, a, R0, Xcyl_R, Xcyl_Z, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: a Distance to plasma edge as measured from the magnetic axis. real(kind=rp), intent(in) :: R0 Distance to plasma edge as measured from the magnetic axis. real(kind=rp), intent(in), DIMENSION(pchunk) :: Xcyl_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Xcyl_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag Contents Source Code cyl_check_if_confined_p Source Code subroutine cyl_check_if_confined_p ( pchunk , a , R0 , Xcyl_R , Xcyl_Z , flag ) implicit none INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Xcyl_R REAL ( rp ), DIMENSION ( pchunk ), INTENT ( IN ) :: Xcyl_Z INTEGER ( is ), DIMENSION ( pchunk ), INTENT ( INOUT ) :: flag REAL ( rp ), INTENT ( IN ) :: a , R0 !! Distance to plasma edge as measured from the magnetic axis. INTEGER :: cc !$OMP SIMD !    !$OMP& aligned(Xcyl_R,Xcyl_Z,flag) do cc = 1_idef , pchunk if ( sqrt (( Xcyl_R ( cc ) - R0 ) ** 2 + Xcyl_Z ( cc ) ** 2 ) . gt . a ) flag ( cc ) = 0_is end do !$OMP END SIMD end subroutine cyl_check_if_confined_p","tags":"","loc":"proc/cyl_check_if_confined_p.html"},{"title":"cart_to_tor_check_if_confined – KORC-Full Orbit","text":"public subroutine cart_to_tor_check_if_confined(X, F, Xtor, flag) Note Subroutine that converts the position of simulated particles\n from Cartesian to toroidal coordinates.\n In addition to performing the coordinate transformation, this\n subroutine checks whether a given particle is within the plasma or not.\n A particle is not longer considered to be within the plasma if its\n minor radius , where is the radial\n distance to the plasma edge as measured from the magnetic axis. For\n more details see the analytical model of the magnetic field in korc_types and korc_fields . The coordinate transformation is given by: where is the radial position of the magnetic axis. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: X Particles' position in Cartesian coordinates. X(1,:) = , X(2,:)\n = , X(3,:) = type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: Xtor Particles' position in cylindrical coordinates. Xtor(1,:) = , Xtor(2,:) = , Xtor(3,:) = integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Contents Source Code cart_to_tor_check_if_confined Source Code subroutine cart_to_tor_check_if_confined ( X , F , Xtor , flag ) !! @note Subroutine that converts the position of simulated particles !! from Cartesian (x,y,z) to toroidal (r,\\theta, \\zeta) coordinates. !! In addition to performing the coordinate transformation, this !! subroutine checks whether a given particle is within the plasma or not. !! A particle is not longer considered to be within the plasma if its !! minor radius r > r_{edge}, where r_{edge} is the radial !! distance to the plasma edge as measured from the magnetic axis. For !! more details see the analytical model of the magnetic field in !! [[korc_types]] and [[korc_fields]]. !! !! The coordinate transformation is given by: !! !! r = \\sqrt{ \\left[\\sqrt{x&#94;2 + y&#94;2}-R_0\\right]&#94;2 + z&#94;2 }, !! \\theta = \\arctan{\\left( \\frac{z}{\\sqrt{x&#94;2 + y&#94;2}-Ro} \\right)}. !! \\zeta = \\arctan{\\left( \\frac{x}{y} \\right)}, !! !! where R_0 is the radial position of the magnetic axis. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( IN ) :: X !! Particles' position in Cartesian coordinates. X(1,:) = x, X(2,:) !! = y, X(3,:) = z TYPE ( FIELDS ), INTENT ( IN ) :: F !! An instance of the KORC derived type FIELDS. REAL ( rp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: Xtor !! Particles' position in cylindrical coordinates. Xtor(1,:) = !! r, Xtor(2,:) = \\theta, Xtor(3,:) = \\zeta INTEGER ( is ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: flag REAL ( rp ) :: a !! Distance to plasma edge as measured from the magnetic axis. REAL ( rp ) :: Ro !! Radial position of the magnetic axis. INTEGER :: pp !! Iterator. INTEGER :: ss !! Iterator. if ( X ( 2 , 1 ). eq . 0 ) then ss = 1_idef else ss = size ( X , 1 ) end if a = F % AB % a Ro = F % AB % Ro !    write(output_unit_write,'(\"X c2tor: \",E17.10)') X(1,:) !$OMP PARALLEL DO FIRSTPRIVATE(ss,a,Ro) PRIVATE(pp) SHARED(X,Xtor,flag) do pp = 1_idef , ss if ( flag ( pp ) . EQ . 1_is ) then Xtor ( pp , 1 ) = SQRT ( ( SQRT ( X ( pp , 1 ) ** 2 + X ( pp , 2 ) ** 2 ) - Ro ) ** 2 + & X ( pp , 3 ) ** 2 ) Xtor ( pp , 2 ) = ATAN2 ( X ( pp , 3 ), SQRT ( X ( pp , 1 ) ** 2 + X ( pp , 2 ) ** 2 ) - Ro ) Xtor ( pp , 2 ) = MODULO ( Xtor ( pp , 2 ), 2.0_rp * C_PI ) Xtor ( pp , 3 ) = ATAN2 ( X ( pp , 1 ), X ( pp , 2 )) Xtor ( pp , 3 ) = MODULO ( Xtor ( pp , 3 ), 2.0_rp * C_PI ) !          write(output_unit_write,'(\"r: \",E17.10)') Xtor(1,1) !          write(output_unit_write,'(\"a: \",E17.10)') a !          write(output_unit_write,'(\"Ro: \",E17.10)') Ro if ( Xtor ( pp , 1 ) . GT . F % AB % a ) then flag ( pp ) = 0_is !             stop 'error in dist init' end if end if end do !$OMP END PARALLEL DO end subroutine cart_to_tor_check_if_confined","tags":"","loc":"proc/cart_to_tor_check_if_confined.html"},{"title":"cart_to_tor_p – KORC-Full Orbit","text":"public subroutine cart_to_tor_p(pchunk, R0, X_X, X_Y, X_Z, T_R, T_T, T_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: T_R real(kind=rp), intent(out), DIMENSION(pchunk) :: T_T real(kind=rp), intent(out), DIMENSION(pchunk) :: T_Z Contents Source Code cart_to_tor_p Source Code subroutine cart_to_tor_p ( pchunk , R0 , X_X , X_Y , X_Z , T_R , T_T , T_Z ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: R0 REAL ( rp ), INTENT ( IN ), DIMENSION ( pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: T_R , T_T , T_Z REAL ( rp ), DIMENSION ( pchunk ) :: RR INTEGER :: cc !! Particle chunk iterator. !$OMP SIMD !    !$OMP& aligned(RR,X_X,X_Y,T_R,T_T,T_Z,X_Z) do cc = 1_idef , pchunk RR ( cc ) = SQRT ( X_X ( cc ) * X_X ( cc ) + X_Y ( cc ) * X_Y ( cc )) - R0 T_R ( cc ) = SQRT ( RR ( cc ) * RR ( cc ) + X_Z ( cc ) * X_Z ( cc ) ) T_T ( cc ) = ATAN2 ( X_Z ( cc ), RR ( cc )) T_T ( cc ) = MODULO ( T_T ( cc ), 2.0_rp * C_PI ) T_Z ( cc ) = ATAN2 ( X_X ( cc ), X_Y ( cc )) T_Z ( cc ) = MODULO ( T_Z ( cc ), 2.0_rp * C_PI ) end do !$OMP END SIMD end subroutine cart_to_tor_p","tags":"","loc":"proc/cart_to_tor_p.html"},{"title":"cart_to_tor_check_if_confined_p – KORC-Full Orbit","text":"public subroutine cart_to_tor_check_if_confined_p(pchunk, ar, R0, X_X, X_Y, X_Z, T_R, T_T, T_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: ar real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: T_R real(kind=rp), intent(out), DIMENSION(pchunk) :: T_T real(kind=rp), intent(out), DIMENSION(pchunk) :: T_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache Contents Source Code cart_to_tor_check_if_confined_p Source Code subroutine cart_to_tor_check_if_confined_p ( pchunk , ar , R0 , X_X , X_Y , X_Z , & T_R , T_T , T_Z , flag_cache ) INTEGER , INTENT ( IN ) :: pchunk REAL ( rp ), INTENT ( IN ) :: R0 , ar REAL ( rp ), INTENT ( IN ), DIMENSION ( pchunk ) :: X_X , X_Y , X_Z REAL ( rp ), INTENT ( OUT ), DIMENSION ( pchunk ) :: T_R , T_T , T_Z INTEGER ( is ), INTENT ( INOUT ), DIMENSION ( pchunk ) :: flag_cache REAL ( rp ), DIMENSION ( pchunk ) :: RR INTEGER :: cc !! Particle chunk iterator. !$OMP SIMD !    !$OMP& aligned(RR,X_X,X_Y,T_R,T_T,T_Z,X_Z) do cc = 1_idef , pchunk RR ( cc ) = SQRT ( X_X ( cc ) * X_X ( cc ) + X_Y ( cc ) * X_Y ( cc )) - R0 T_R ( cc ) = SQRT ( RR ( cc ) * RR ( cc ) + X_Z ( cc ) * X_Z ( cc ) ) T_T ( cc ) = ATAN2 ( X_Z ( cc ), RR ( cc )) T_T ( cc ) = MODULO ( T_T ( cc ), 2.0_rp * C_PI ) T_Z ( cc ) = ATAN2 ( X_X ( cc ), X_Y ( cc )) T_Z ( cc ) = MODULO ( T_Z ( cc ), 2.0_rp * C_PI ) end do !$OMP END SIMD !$OMP SIMD do cc = 1_idef , pchunk if ( T_R ( cc ) . GT . ar ) then flag_cache ( cc ) = 0_is end if end do !$OMP END SIMD end subroutine cart_to_tor_check_if_confined_p","tags":"","loc":"proc/cart_to_tor_check_if_confined_p.html"},{"title":"init_u_random – KORC-Full Orbit","text":"public subroutine init_u_random(seed) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: seed Contents Source Code init_u_random Source Code subroutine init_u_random ( seed ) INTEGER ( 8 ), INTENT ( IN ) :: seed INTEGER ( 8 ) :: dummy_int64 urand_vars % u = seed ** urand_vars % v call rand_int64 () urand_vars % v = urand_vars % u call rand_int64 () urand_vars % w = urand_vars % v call rand_int64 () end subroutine init_u_random","tags":"","loc":"proc/init_u_random.html"},{"title":"rand_int64 – KORC-Full Orbit","text":"private subroutine rand_int64(irand) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out), optional :: irand Contents Source Code rand_int64 Source Code subroutine rand_int64 ( irand ) INTEGER ( 8 ), OPTIONAL , INTENT ( OUT ) :: irand INTEGER ( 8 ) :: x urand_vars % u = urand_vars % u * d + e !u=u* 2862933555777941757LL + 7046029254386353087LL; urand_vars % v = IEOR ( urand_vars % v , ISHFT ( urand_vars % v , - 17 )) ! v&#94;=v>>17; urand_vars % v = IEOR ( urand_vars % v , ISHFT ( urand_vars % v , 31 )) ! v&#94;=v<<31; urand_vars % v = IEOR ( urand_vars % v , ISHFT ( urand_vars % v , - 8 )) ! v&#94;=v>>8; urand_vars % w = a * IAND ( urand_vars % w , b ) + ISHFT ( urand_vars % w , - 32 ) ! w = 4294957665U*(w & 0xffffffff) + (w >> 32); x = IEOR ( urand_vars % u , ISHFT ( urand_vars % u , 21 )) ! Ullong x=u&#94;(u<< 21); x = IEOR ( x , ISHFT ( x , - 35 )) ! x &#94;= x >> 35; x = IEOR ( x , ISHFT ( x , 4 )) ! x &#94;= x << 4; if ( PRESENT ( irand )) then irand = IEOR ( x + urand_vars % v , urand_vars % w ) end if end subroutine rand_int64","tags":"","loc":"proc/rand_int64.html"},{"title":"rand_int32 – KORC-Full Orbit","text":"private subroutine rand_int32(irand32) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: irand32 Contents Source Code rand_int32 Source Code subroutine rand_int32 ( irand32 ) INTEGER ( 4 ), INTENT ( OUT ) :: irand32 INTEGER ( 8 ) :: irand64 call rand_int64 ( irand64 ) irand32 = INT ( irand64 , 4 ) end subroutine rand_int32","tags":"","loc":"proc/rand_int32.html"},{"title":"rand_real_array – KORC-Full Orbit","text":"public subroutine rand_real_array(rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), DIMENSION(:) :: rrand Contents Source Code rand_real_array Source Code subroutine rand_real_array ( rrand ) REAL ( rp ), DIMENSION (:), INTENT ( INOUT ) :: rrand INTEGER ( 8 ) :: irand64 INTEGER :: ii ! Iterator do ii = 1_idef , SIZE ( rrand ) call rand_int64 ( irand64 ) rrand ( ii ) = rcoeff * REAL ( irand64 , rp ) + 0.5_rp end do end subroutine rand_real_array","tags":"","loc":"proc/rand_real_array.html"},{"title":"rand_real – KORC-Full Orbit","text":"private subroutine rand_real(rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out) :: rrand Contents Source Code rand_real Source Code subroutine rand_real ( rrand ) REAL ( rp ), INTENT ( OUT ) :: rrand INTEGER ( 8 ) :: irand64 call rand_int64 ( irand64 ) rrand = rcoeff * REAL ( irand64 , rp ) + 0.5_rp end subroutine rand_real","tags":"","loc":"proc/rand_real.html"},{"title":"init_random_seed – KORC-Full Orbit","text":"public subroutine init_random_seed() Uses korc_random Arguments None Contents Source Code init_random_seed Source Code subroutine init_random_seed () #ifdef PARALLEL_RANDOM use korc_random #endif INTEGER , allocatable :: seed (:) INTEGER ( 8 ), DIMENSION ( 8 ) :: dt INTEGER ( 8 ) :: i INTEGER ( 8 ) :: istat INTEGER ( 8 ) :: pid INTEGER ( 4 ) :: n INTEGER ( 8 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( default_unit_open , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then read ( default_unit_open ) seed close ( default_unit_open ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 _ 8 ) * 365 _ 8 * 24 _ 8 * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 2 ) * 31 _ 8 * 24 _ 8 * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 3 ) * 24 _ 8 * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 5 ) * 60 _ 8 * 60 _ 8 * 1000 _ 8 & + dt ( 6 ) * 60 _ 8 * 1000 _ 8 & + dt ( 7 ) * 1000 _ 8 & + dt ( 8 ) end if pid = getpid () write ( output_unit_write , '(\"PID: \",I15)' ) pid t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if #ifdef PARALLEL_RANDOM call initialize_random ( seed ( 1 )) call initialize_random_U ( seed ( 1 )) call initialize_random_N ( seed ( 1 )) !  call initialize_random_mkl(seed(1)) #else call random_seed ( put = seed ) #endif contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) INTEGER :: lcg INTEGER ( 8 ) :: s if ( s == 0 ) then s = 104729 _ 8 else s = mod ( s , 4294967296 _ 8 ) end if s = mod ( s * 279470273 _ 8 , 4294967291 _ 8 ) lcg = int ( mod ( s , int ( huge ( 0 ), 8 )), kind ( 0 )) end function lcg end subroutine init_random_seed","tags":"","loc":"proc/init_random_seed.html"},{"title":"u_random – KORC-Full Orbit","text":"public interface u_random Contents Module Procedures rand_int64 rand_int32 rand_real rand_real_array Module Procedures private subroutine rand_int64 (irand) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out), optional :: irand private subroutine rand_int32 (irand32) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: irand32 private subroutine rand_real (rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out) :: rrand public subroutine rand_real_array (rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), DIMENSION(:) :: rrand","tags":"","loc":"interface/u_random.html"},{"title":"initialize_m3d_c1 – KORC-Full Orbit","text":"public subroutine initialize_m3d_c1(params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params type(FIELDS), intent(inout) :: F type(PROFILES), intent(inout) :: P type(SPECIES), intent(inout), DIMENSION(:) :: spp Contents Source Code initialize_m3d_c1 Source Code SUBROUTINE initialize_m3d_c1 ( params , F , P , spp ) IMPLICIT NONE TYPE ( KORC_PARAMS ), INTENT ( INOUT ) :: params TYPE ( FIELDS ), INTENT ( INOUT ) :: F TYPE ( PROFILES ), INTENT ( INOUT ) :: P TYPE ( SPECIES ), DIMENSION (:), INTENT ( INOUT ) :: spp INTEGER :: ii INTEGER :: pp INTEGER :: status INTEGER :: isrc !LOGICAL                        :: Efield !LOGICAL                        :: Bfield !LOGICAL                        :: Bflux,Bflux3D,dBfield !LOGICAL                        :: axisymmetric_fields !LOGICAL                        :: Dim2x1t,E_2x1t,ReInterp_2x1t !integer :: res_double !integer :: dim_1D,ind0_2x1t !real(rp) :: dt_E_SC,Ip_exp,PSIp_lim,PSIp_0 !real(rp) :: t0_2x1t,Eo,E_dyn,E_pulse,E_width !NAMELIST /externalPlasmaModel/ Efield, Bfield, Bflux,Bflux3D,dBfield, & !     axisymmetric_fields,Eo,E_dyn,E_pulse,E_width,res_double, & !     dim_1D,dt_E_SC,Ip_exp,PSIp_lim,Dim2x1t,t0_2x1t,E_2x1t,ReInterp_2x1t, & !     ind0_2x1t,PSIp_0 !open(unit=default_unit_open,file=TRIM(params%path_to_inputs),status='OLD',form='formatted') !read(default_unit_open,nml=externalPlasmaModel) !close(default_unit_open) F % Efield = Efield F % PSIp_lim = PSIp_lim F % PSIp_0 = PSIp_0 status = fio_open_source ( FIO_M3DC1_SOURCE , & TRIM ( params % magnetic_field_filename ) & & // C_NULL_CHAR , isrc ) status = fio_get_options ( isrc ) status = fio_set_int_option ( FIO_TIMESLICE , params % time_slice ) status = fio_get_field ( isrc , FIO_MAGNETIC_FIELD , F % M3D_C1_B ) status = fio_get_field ( isrc , FIO_ELECTRIC_FIELD , F % M3D_C1_E ) status = fio_get_field ( isrc , FIO_VECTOR_POTENTIAL , F % M3D_C1_A ) if (. not . F % Efield ) F % M3D_C1_E =- 1 status = fio_set_int_option ( FIO_SPECIES , FIO_ELECTRON ); status = fio_get_field ( isrc , FIO_DENSITY , P % M3D_C1_ne ); status = fio_get_field ( isrc , FIO_TEMPERATURE , P % M3D_C1_te ); !  Hardcode Bo to one for now until a better method of determining the a !  characteristic magnetic field value. F % Bo = 1.0 F % Eo = 1.0 F % Ro = 1.0 F % Zo = 1.0 do ii = 1 , params % num_species do pp = 1 , spp ( ii )% ppp status = fio_allocate_search_hint ( isrc , spp ( ii )% vars % hint ( pp )) !spp(ii)%vars%hint(pp)=c_null_ptr end do spp ( ii )% vars % cart = . false . end do if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) 'Calculate B' , F % M3D_C1_B write ( output_unit_write , * ) 'Calculate E' , F % M3D_C1_E write ( output_unit_write , * ) 'Calculate A' , F % M3D_C1_A write ( output_unit_write , * ) 'Calculate n' , P % M3D_C1_ne write ( output_unit_write , * ) 'Calculate T' , P % M3D_C1_te end if END SUBROUTINE initialize_m3d_c1","tags":"","loc":"proc/initialize_m3d_c1.html"},{"title":"fio_add_field – KORC-Full Orbit","text":"interface public function fio_add_field(icfield, ifield, op, fac) bind(C, NAME='fio_add_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: icfield integer(kind=C_INT), intent(in), VALUE :: ifield integer(kind=C_INT), intent(in), VALUE :: op real(kind=C_DOUBLE), intent(in), VALUE :: fac Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_add_field.html"},{"title":"fio_allocate_search_hint – KORC-Full Orbit","text":"interface public function fio_allocate_search_hint(isrc, hint) bind(C, NAME='fio_allocate_search_hint') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc type(C_PTR), intent(out) :: hint Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_allocate_search_hint.html"},{"title":"fio_close_field – KORC-Full Orbit","text":"interface public function fio_close_field(ifield) bind(C, NAME='fio_close_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: ifield Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_close_field.html"},{"title":"fio_close_series – KORC-Full Orbit","text":"interface public function fio_close_series(iseries) bind(C, NAME='fio_close_series') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: iseries Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_close_series.html"},{"title":"fio_close_source – KORC-Full Orbit","text":"interface public function fio_close_source(isrc) bind(C, NAME='fio_close_source') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_close_source.html"},{"title":"fio_create_compound_field – KORC-Full Orbit","text":"interface public function fio_create_compound_field(ifield) bind(C, NAME='fio_create_compound_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in) :: ifield Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_create_compound_field.html"},{"title":"fio_deallocate_search_hint – KORC-Full Orbit","text":"interface public function fio_deallocate_search_hint(isrc, hint) bind(C, NAME='fio_deallocate_search_hint') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc type(C_PTR), intent(inout) :: hint Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_deallocate_search_hint.html"},{"title":"fio_eval_field – KORC-Full Orbit","text":"interface public function fio_eval_field(ifield, x, v, hint) bind(C, NAME='fio_eval_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: ifield real(kind=C_DOUBLE), intent(in) :: x real(kind=C_DOUBLE), intent(out) :: v type(C_PTR), intent(in), VALUE :: hint Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_eval_field.html"},{"title":"fio_eval_field_deriv – KORC-Full Orbit","text":"interface public function fio_eval_field_deriv(ifield, x, v, hint) bind(C, NAME='fio_eval_field_deriv') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: ifield real(kind=C_DOUBLE), intent(in) :: x real(kind=C_DOUBLE), intent(out) :: v type(C_PTR), intent(in), VALUE :: hint Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_eval_field_deriv.html"},{"title":"fio_eval_series – KORC-Full Orbit","text":"interface public function fio_eval_series(iseries, x, v) bind(C, NAME='fio_eval_series') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: iseries real(kind=C_DOUBLE), intent(in) :: x real(kind=C_DOUBLE), intent(out) :: v Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_eval_series.html"},{"title":"fio_get_options – KORC-Full Orbit","text":"interface public function fio_get_options(isrc) bind(C, NAME='fio_get_options') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_get_options.html"},{"title":"fio_get_available_fields – KORC-Full Orbit","text":"interface public function fio_get_available_fields(isrc, n, f) bind(C, NAME='fio_get_available_fields') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc integer(kind=C_INT), intent(out) :: n integer(kind=C_INT), intent(out), DIMENSION(:) :: f Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_get_available_fields.html"},{"title":"fio_open_source – KORC-Full Orbit","text":"interface public function fio_open_source(itype, filename, handle) bind(C, NAME='fio_open_source') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: itype character(kind=C_CHAR,len=1), intent(in) :: filename integer(kind=C_INT), intent(out) :: handle Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_open_source.html"},{"title":"fio_get_field – KORC-Full Orbit","text":"interface public function fio_get_field(isrc, type, handle) bind(C, NAME='fio_get_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc integer(kind=C_INT), intent(in), VALUE :: type integer(kind=C_INT), intent(inout) :: handle Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_get_field.html"},{"title":"fio_set_int_option – KORC-Full Orbit","text":"interface public function fio_set_int_option(iopt, v) bind(C, NAME='fio_set_int_option') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: iopt integer(kind=C_INT), intent(in), VALUE :: v Return Value integer(kind=C_INT)","tags":"","loc":"interface/fio_set_int_option.html"},{"title":"korc_HDF5 – KORC-Full Orbit","text":"Note Fortran interface to subroutines saving real and integer\n values to HDF5 files.\n @note Fortran interface to subroutines saving 2-D arrays of real values to HDF5 files. Todo To code the corresponding subroutines for saving integer 2-D arrays.\n @note Fortran interface to subroutines saving 3-D arrays of real values to HDF5 files.\n @todo To include the corresponding subroutines for saving arrays of integers.\n @note Fortran interface to subroutines saving 1-D, 2-D or 3-D arrays of real values to HDF5 files.\n @todo To include the corresponding subroutines for saving arrays of integers.\n @note Initialization of HDF5 library. @param h5error HDF5 error status. Note Finalization of HDF5 library. @param h5error HDF5 error status. Note Subroutine to load an integer datum from an HDF5 file. Todo Implement the reading of the attribute of idatum.\n @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[out] idatum Integer datum read from HDF5 file.\n @param[out] attr Attribute of datum read from HDF5 file.\n @param aname Name of idatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param h5error HDF5 error status. Note Subroutine to load a real datum from an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[out] rdatum Real datum read from HDF5 file and casted to\n KORC's real precision type.\n @param[out] attr Attribute of datum read from HDF5 file.\n @param raw_datum Datum read from HDF5 file.\n @param aname Name of rdatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param h5error HDF5 error status. Todo Implement the reading of the attribute of rdatum. Note Subroutine to load a 1-D array of reals from an HDF5 file.\n @details The dimension of the 1-D array rdata is determined by the\n input-output array rdata. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[out] rdata 1-D array of real values read from HDF5 file and\n casted to KORC's real precision type.\n @param[out] attr 1-D array of attributes of rdata.\n @param raw_data 1-D array read from HDF5 file.\n @param aname Name of rdata attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param h5error HDF5 error status. Todo Implement the reading of the attributes of rdata. Note Subroutine to load a 2-D array of reals from an HDF5 file.\n @details The dimensions of the 2-D array rdata is determined by the input-output array rdata. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[out] rdata 2-D array of real values read from HDF5 file and casted to KORC's real precision type.\n @param[out] attr 2-D array of attributes of rdata.\n @param raw_data 2-D array read from HDF5 file.\n @param aname Name of rdata attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param h5error HDF5 error status. Todo Implement the reading of the attributes of rdata. Note Subroutine to load a 3-D array of reals from an HDF5 file.\n @details The dimensions of the 3-D array rdata is determined by the input-output array rdata. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[out] rdata 3-D array of real values read from HDF5 file and casted to KORC's real precision type.\n @param[out] attr 3-D array of attributes of rdata.\n @param raw_data 3-D array read from HDF5 file.\n @param aname Name of rdata attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param h5error HDF5 error status. Todo Implement the reading of the attributes of rdata. Note Subroutine to write a 1 byte (8 bits) integer to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[in] idatum Integer datum read from HDF5 file.\n @param[in] attr Attribute of datum read from HDF5 file.\n @param aname Name of idatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param rank Number of dimensions of idatum's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of idatum attribute's name.\n @param h5error HDF5 error status. Note Subroutine to write a 2 byte (16 bits) integer to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[in] idatum Integer datum read from HDF5 file.\n @param[in] attr Attribute of datum read from HDF5 file.\n @param aname Name of idatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param rank Number of dimensions of idatum's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of idatum attribute's name.\n @param h5error HDF5 error status. Note Subroutine to write a 4 byte (32 bits) integer to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[in] idatum Integer datum read from HDF5 file.\n @param[in] attr Attribute of datum read from HDF5 file.\n @param aname Name of idatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param rank Number of dimensions of idatum's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of idatum attribute's name.\n @param h5error HDF5 error status. Note Subroutine to write a 8 byte (64 bits) integer to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[in] idatum Integer datum read from HDF5 file.\n @param[in] attr Attribute of datum read from HDF5 file.\n @param aname Name of idatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data read from HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param rank Number of dimensions of idatum's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of idatum attribute's name.\n @param h5error HDF5 error status. Note Subroutine to write a 1-D array of integer values to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[in] idata Data written to HDF5 file.\n @param[in] attr Attributes of data written to HDF5 file.\n @param aname Name of idata attributes.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 data space identifier.\n @param aspace_id HDF5 data's attribute space identifier.\n @param attr_id HDF5 data's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data writen to HDF5 file.\n @param adims Dimensions of data's attributes written to HDF5 file.\n @param rank Number of dimensions of idata's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of idata attribute's name.\n @param h5error HDF5 error status.\n @param rr Rank iterator.\n @param dd Dimension iterator. Bug When using a 1-D array of attributes, only the first attribute is saved. Note Subroutine to write a real to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the datum.\n @param[in] rdatum Real datum written to HDF5 file.\n @param[in] attr Attribute of datum written to HDF5 file.\n @param aname Name of rdatum attribute.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 datum space identifier.\n @param aspace_id HDF5 datum's attribute space identifier.\n @param attr_id HDF5 datum's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data written to HDF5 file.\n @param adims Dimensions of data's attributes read from HDF5 file.\n @param rank Number of dimensions of rdatum's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of rdatum attribute's name.\n @param h5error HDF5 error status. Note Subroutine to write a 1-D array of real values to an HDF5 file. Bug When using a 1-D array of attributes, only the first attribute is saved.\n @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[in] rdata Data written to HDF5 file.\n @param[in] attr Attributes of data written to HDF5 file.\n @param aname Name of rdata attributes.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 data space identifier.\n @param aspace_id HDF5 data's attribute space identifier.\n @param attr_id HDF5 data's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data writen to HDF5 file.\n @param adims Dimensions of data's attributes written to HDF5 file.\n @param rank Number of dimensions of rdata's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param tmplen Temporary length of rdata attribute's name.\n @param attrlen Lenght of rdata attribute's name.\n @param h5error HDF5 error status.\n @param rr Rank iterator.\n @param dd Dimension iterator. Note Subroutine to write a 2-D array of real values to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[in] rdata Data written to HDF5 file.\n @param[in] attr Attributes of data written to HDF5 file.\n @param aname Name of rdata attributes.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 data space identifier.\n @param aspace_id HDF5 data's attribute space identifier.\n @param attr_id HDF5 data's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data writen to HDF5 file.\n @param adims Dimensions of data's attributes written to HDF5 file.\n @param rank Number of dimensions of rdata's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of rdata attribute's name.\n @param h5error HDF5 error status.\n @param rr Rank iterator.\n @param dd Dimension iterator. Todo Implement the writting of attributes to HDF5 file. Note Subroutine to write a 3-D array of real values to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the data.\n @param[in] rdata Data written to HDF5 file.\n @param[in] attr Attributes of data written to HDF5 file.\n @param aname Name of rdata attributes.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 data space identifier.\n @param aspace_id HDF5 data's attribute space identifier.\n @param attr_id HDF5 data's attribute identifier.\n @param atype_id Native HDF5 attribute type.\n @param dims Dimensions of data writen to HDF5 file.\n @param adims Dimensions of data's attributes written to HDF5 file.\n @param rank Number of dimensions of rdata's dataspace.\n @param arank Number of dimensions of attr's dataspace.\n @param attrlen Lenght of rdata attribute's name.\n @param h5error HDF5 error status.\n @param rr Rank iterator.\n @param dd Dimension iterator. Todo Implement the writting of attributes to HDF5 file. Note Subroutine to write an array of strings to an HDF5 file. @param[in] h5file_id HDF5 file identifier.\n @param[in] dset String containing the name of the array of strings.\n @param[in] string_array Array of characters containing the strings to be written to HDF5 file.\n @param dset_id HDF5 data set identifier.\n @param dspace_id HDF5 data space identifier.\n @param dims Number of strings to be written to file.\n @param data_dims Dimensions of data written to HDF5 file. This is equal to (Maximum length of KORC string)x(Number of strings).\n @param str_len Size of strings to be written to file without blank spaces.\n @param string_type Native HDF5 string type.\n @param h5error HDF5 error status. Uses korc_hpc korc_types korc_constants HDF5 Contents Variables KORC_HDF5_REAL rp_hdf5 Interfaces load_from_hdf5 load_array_from_hdf5 save_to_hdf5 save_1d_array_to_hdf5 save_2d_array_to_hdf5 save_3d_array_to_hdf5 save_array_to_hdf5 Subroutines initialize_HDF5 finalize_HDF5 iload_from_hdf5 rload_from_hdf5 rload_1d_array_from_hdf5 rload_2d_array_from_hdf5 rload_3d_array_from_hdf5 i1save_to_hdf5 i2save_to_hdf5 i4save_to_hdf5 i8save_to_hdf5 isave_1d_array_to_hdf5 rsave_to_hdf5 rsave_1d_array_to_hdf5 rsave_2d_array_to_hdf5 rsave_3d_array_to_hdf5 save_string_parameter save_simulation_parameters save_simulation_outputs save_restart_variables load_time_stepping_params load_prev_time load_prev_iter load_particles_ic Variables Type Visibility Attributes Name Initial integer(kind=HID_T), private :: KORC_HDF5_REAL HDF5 real precision data type to be used in the simulation. integer(kind=SIZE_T), private :: rp_hdf5 Size of the HDF5 real precision data type used in the simulation. Interfaces public interface load_from_hdf5 Read more… private subroutine iload_from_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(out) :: idatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr private subroutine rload_from_hdf5 (h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(out) :: rdatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr public interface load_array_from_hdf5 Read more… private subroutine rload_1d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(out), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rload_3d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rload_2d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public interface save_to_hdf5 Read more… private subroutine i1save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=1), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i2save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=2), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i4save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=4), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i8save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=8), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine rsave_to_hdf5 (h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in) :: rdatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr public interface save_1d_array_to_hdf5 private subroutine isave_1d_array_to_hdf5 (h5file_id, dset, idata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(in), DIMENSION(:) :: idata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_1d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public interface save_2d_array_to_hdf5 private subroutine rsave_2d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public interface save_3d_array_to_hdf5 public subroutine rsave_3d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public interface save_array_to_hdf5 private subroutine isave_1d_array_to_hdf5 (h5file_id, dset, idata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(in), DIMENSION(:) :: idata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_1d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_2d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public subroutine rsave_3d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr Subroutines public subroutine initialize_HDF5 () Arguments None public subroutine finalize_HDF5 () Arguments None private subroutine iload_from_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(out) :: idatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr private subroutine rload_from_hdf5 (h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(out) :: rdatum character(len=MAX_STRING_LENGTH), intent(out), optional :: attr private subroutine rload_1d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(out), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rload_2d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rload_3d_array_from_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(inout), DIMENSION(:,:,:), ALLOCATABLE :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine i1save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=1), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i2save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=2), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i4save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=4), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine i8save_to_hdf5 (h5file_id, dset, idatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer(kind=8), intent(in) :: idatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine isave_1d_array_to_hdf5 (h5file_id, dset, idata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset integer, intent(in), DIMENSION(:) :: idata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_to_hdf5 (h5file_id, dset, rdatum, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in) :: rdatum character(len=MAX_STRING_LENGTH), intent(in), optional :: attr private subroutine rsave_1d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr private subroutine rsave_2d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public subroutine rsave_3d_array_to_hdf5 (h5file_id, dset, rdata, attr) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset real(kind=rp), intent(in), DIMENSION(:,:,:) :: rdata character(len=MAX_STRING_LENGTH), intent(in), optional DIMENSION(:), ALLOCATABLE :: attr public subroutine save_string_parameter (h5file_id, dset, string_array) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: h5file_id character(len=MAX_STRING_LENGTH), intent(in) :: dset character(len=MAX_STRING_LENGTH), intent(in), DIMENSION(:) :: string_array public subroutine save_simulation_parameters (params, spp, F, P) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(in), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all\n the information of different electron species. See korc_types . type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation. See korc_types and korc_fields . type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . public subroutine save_simulation_outputs (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(in), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all\n the information\n of different electron species. See korc_types . type(FIELDS), intent(in) :: F public subroutine save_restart_variables (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params params Core KORC simulation parameters. type(SPECIES), intent(in), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing\n all the information of different electron species. See korc_types . type(FIELDS), intent(in) :: F public subroutine load_time_stepping_params (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine load_prev_time (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine load_prev_iter (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine load_particles_ic (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the\n information of different electron species. See korc_types.f90. type(FIELDS), intent(inout) :: F","tags":"","loc":"module/korc_hdf5.html"},{"title":"korc_simple_equilibrium_pdf – KORC-Full Orbit","text":"Uses korc_types korc_constants korc_HDF5 korc_hpc special_functions korc_input Contents Variables pdf_params xo Tol minmax_buffer_size Derived Types PARAMS Functions deg2rad rad2deg fRE random_norm IntK besselk IntBesselK PR Subroutines get_equilibrium_distribution initialize_params P_integral sample_distribution save_params Variables Type Visibility Attributes Name Initial type( PARAMS ), private :: pdf_params real(kind=rp), private, parameter :: xo = (C_ME*C_C**2/C_E)/1.0E6 real(kind=rp), private, parameter :: Tol = 1.0E-5_rp real(kind=rp), private, parameter :: minmax_buffer_size = 10.0_rp Derived Types type, private :: PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: E real(kind=rp), public :: Zeff real(kind=rp), public :: max_pitch_angle real(kind=rp), public :: min_pitch_angle real(kind=rp), public :: po real(kind=rp), public :: Bo real(kind=rp), public :: lambda Functions private function deg2rad (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function rad2deg (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function fRE (eta, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p Return Value real(kind=rp) private function random_norm (mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) private function IntK (v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) public function besselk (v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function IntBesselK (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b Return Value real(kind=rp) private function PR (eta, p, Bo, l) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p real(kind=rp), intent(in) :: Bo real(kind=rp), intent(in) :: l Return Value real(kind=rp) Subroutines public subroutine get_equilibrium_distribution (params, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(in) :: go real(kind=rp), intent(out) :: etao private subroutine initialize_params (params, go) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: go private subroutine P_integral (z, P) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: z real(kind=rp), intent(out) :: P private subroutine sample_distribution (params, eta, etao) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: etao private subroutine save_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params","tags":"","loc":"module/korc_simple_equilibrium_pdf.html"},{"title":"korc_collisions – KORC-Full Orbit","text":"Uses korc_types korc_constants korc_HDF5 korc_interp korc_profiles korc_fields korc_input korc_random Contents Variables MODEL1 MODEL2 infinity cparams_ms cparams_ss Derived Types PARAMS_MS PARAMS_SS Functions VTe_wu VTe Gammac_wu Gammacee CLog_wu CLog0_wu CLogee_wu CLogei_wu CLog CLog0 CLogee CLogei delta psi CA CA_SD dCA_SD CF CF_SD CB_ee CB_ei CB_ee_SD CB_ei_SD nu_S h_j g_j nu_D nu_par fun cross Subroutines load_params_ms load_params_ss initialize_collision_params normalize_params_ms normalize_params_ss normalize_collisions_params collision_force define_collisions_time_step unitVectorsC unitVectors_p check_collisions_params include_CoulombCollisions_FO_p include_CoulombCollisions_GC_p include_CoulombCollisions_GCm3dc1_p save_params_ms save_params_ss save_collision_params deallocate_params_ms deallocate_collisions_params Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: MODEL1 = 'SINGLE_SPECIES' character(len=*), private, parameter :: MODEL2 = 'MULTIPLE_SPECIES' real(kind=rp), private, parameter :: infinity = HUGE(1.0_rp) type( PARAMS_MS ), private :: cparams_ms type( PARAMS_SS ), private :: cparams_ss Derived Types type, private :: PARAMS_MS Components Type Visibility Attributes Name Initial integer, public :: num_impurity_species real(kind=rp), public :: Te real(kind=rp), public :: ne real(kind=rp), public :: nH real(kind=rp), public :: nef real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: neb real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zi real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zo real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zj real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: nz real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: IZj real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: aZj real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Ee_IZj real(kind=rp), public :: rD real(kind=rp), public :: re real(kind=rp), public, DIMENSION(11) :: aNe = (/111._rp, 100._rp, 90._rp, 80._rp, 71._rp, 62._rp, 52._rp, 40._rp, 24._rp, 23._rp, 0._rp/) real(kind=rp), public, DIMENSION(19) :: aAr = (/96._rp, 90._rp, 84._rp, 78._rp, 72._rp, 65._rp, 59._rp, 53._rp, 47._rp, 44._rp, 41._rp, 38._rp, 25._rp, 32._rp, 27._rp, 21._rp, 13._rp, 13._rp, 0._rp/) real(kind=rp), public, DIMENSION(11) :: INe = (/137.2_rp, 165.2_rp, 196.9_rp, 235.2_rp, 282.8_rp, 352.6_rp, 475.0_rp, 696.8_rp, 1409.2_rp, 1498.4_rp, huge(1._rp)/) real(kind=rp), public, DIMENSION(19) :: IAr = (/188.5_rp, 219.4_rp, 253.8_rp, 293.4_rp, 339.1_rp, 394.5_rp, 463.4_rp, 568.0_rp, 728.0_rp, 795.9_rp, 879.8_rp, 989.9_rp, 1138.1_rp, 1369.5_rp, 1791.2_rp, 2497.0_rp, 4677.2_rp, 4838.2_rp, huge(1._rp)/) type, private :: PARAMS_SS Components Type Visibility Attributes Name Initial real(kind=rp), public :: Te real(kind=rp), public :: Ti real(kind=rp), public :: ne real(kind=rp), public :: Zeff real(kind=rp), public :: rD real(kind=rp), public :: re real(kind=rp), public :: CoulombLogee real(kind=rp), public :: CoulombLogei real(kind=rp), public :: CLog1 real(kind=rp), public :: CLog2 real(kind=rp), public :: CLog0_1 real(kind=rp), public :: CLog0_2 real(kind=rp), public :: VTe real(kind=rp), public :: VTeo real(kind=rp), public :: delta real(kind=rp), public :: deltao real(kind=rp), public :: Gammac real(kind=rp), public :: Gammaco real(kind=rp), public :: Tau real(kind=rp), public :: Tauc real(kind=rp), public :: taur real(kind=rp), public :: Ec real(kind=rp), public :: ED real(kind=rp), public :: dTau integer(kind=ip), public :: subcycling_iterations real(kind=rp), public, DIMENSION(3) :: x = (/1.0_rp, 0.0_rp, 0.0_rp/) real(kind=rp), public, DIMENSION(3) :: y = (/0.0_rp, 1.0_rp, 0.0_rp/) real(kind=rp), public, DIMENSION(3) :: z = (/0.0_rp, 0.0_rp, 1.0_rp/) type(PROFILES), public :: P real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: rnd_num integer, public :: rnd_num_count integer, public :: rnd_dim = 40000000_idef Functions private function VTe_wu (Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Te In Joules Return Value real(kind=rp) private function VTe (Te) Dimensionless temperature Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function Gammac_wu (params, ne, Te) With units Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function Gammacee (v, ne, Te) Dimensionless ne and Te Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function CLog_wu (ne, Te) With units Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function CLog0_wu (ne, Te) With units Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function CLogee_wu (params, ne, Te) With units Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function CLogei_wu (params, ne, Te) With units Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function CLog (ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function CLog0 (ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function CLogee (v, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function CLogei (v, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne ne is in m&#94;-3 and below is converted to cm&#94;-3 real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function delta (Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function psi (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function CA (v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function CA_SD (v, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) public function dCA_SD (v, me, ne, Te) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: me real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function CF (params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function CF_SD (params, v, ne, Te) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te Return Value real(kind=rp) private function CB_ee (v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function CB_ei (params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function CB_ee_SD (v, ne, Te, Zeff) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te real(kind=rp), intent(in) :: Zeff Return Value real(kind=rp) private function CB_ei_SD (params, v, ne, Te, Zeff) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: ne real(kind=rp), intent(in) :: Te real(kind=rp), intent(in) :: Zeff Return Value real(kind=rp) private function nu_S (params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) public function h_j (i, v) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i real(kind=rp), intent(in) :: v Return Value real(kind=rp) public function g_j (i, v) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function nu_D (params, v) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function nu_par (v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function fun (v) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v Return Value real(kind=rp) private function cross (a, b) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: a real(kind=rp), intent(in), DIMENSION(3) :: b Return Value real(kind=rp),\n  DIMENSION(3) Subroutines private subroutine load_params_ms (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine load_params_ss (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine initialize_collision_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine normalize_params_ms (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine normalize_params_ss (params) Calculate constant quantities used in various functions within\n this module Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine normalize_collisions_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine collision_force (spp, U, Fcoll) For multiple-species collisions\n J. R. Martin-Solis et al. PoP 22, 092512 (2015)\n if (params%collisions .AND. (TRIM(params%collisions_model) .EQ.\n 'MULTIPLE_SPECIES')) then call collision_force(spp(ii),U_os,Fcoll)\n    U_RC = U_RC + a*Fcoll/spp(ii)%q end if Arguments Type Intent Optional Attributes Name type(SPECIES), intent(in) :: spp real(kind=rp), intent(in), DIMENSION(3) :: U real(kind=rp), intent(out), DIMENSION(3) :: Fcoll public subroutine define_collisions_time_step (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine unitVectorsC (B, b1, b2, b3) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: B real(kind=rp), intent(out), DIMENSION(3) :: b1 real(kind=rp), intent(out), DIMENSION(3) :: b2 real(kind=rp), intent(out), DIMENSION(3) :: b3 private subroutine unitVectors_p (pchunk, b_unit_X, b_unit_Y, b_unit_Z, b1_X, b1_Y, b1_Z, b2_X, b2_Y, b2_Z, b3_X, b3_Y, b3_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: b_unit_X real(kind=rp), intent(in), DIMENSION(pchunk) :: b_unit_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: b_unit_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: b1_X real(kind=rp), intent(out), DIMENSION(pchunk) :: b1_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: b1_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: b2_X real(kind=rp), intent(out), DIMENSION(pchunk) :: b2_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: b2_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: b3_X real(kind=rp), intent(out), DIMENSION(pchunk) :: b3_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: b3_Z public subroutine check_collisions_params (spp) Arguments Type Intent Optional Attributes Name type(SPECIES), intent(in) :: spp public subroutine include_CoulombCollisions_FO_p (tt, params, X_X, X_Y, X_Z, U_X, U_Y, U_Z, B_X, B_Y, B_Z, me, P, F, flagCon, flagCol, PSIp) This subroutine performs a Stochastic collision process consistent\n with the Fokker-Planck model for relativitic electron colliding with\n a thermal (Maxwellian) plasma. The collision operator is in spherical\n coordinates of the form found in Papp et al., NF (2011). CA\n corresponds to the parallel (speed diffusion) process, CF corresponds\n to a slowing down (momentum loss) process, and CB corresponds to a\n perpendicular diffusion process. Ordering of the processes are and only the dominant terms are kept. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: U_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: U_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: U_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in) :: me type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp public subroutine include_CoulombCollisions_GC_p (tt, params, Y_R, Y_PHI, Y_Z, Ppll, Pmu, me, flagCon, flagCol, F, P, E_PHI, ne, PSIp) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(KORC_PARAMS), intent(inout) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Ppll real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Pmu real(kind=rp), intent(in) :: me integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp public subroutine include_CoulombCollisions_GCm3dc1_p (tt, params, Y_R, Y_PHI, Y_Z, Ppll, Pmu, me, flagCon, flagCol, F, P, E_PHI, ne, Te, PSIp, hint) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(KORC_PARAMS), intent(inout) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Ppll real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Pmu real(kind=rp), intent(in) :: me integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Te real(kind=rp), DIMENSION(params%pchunk) :: PSIp type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint private subroutine save_params_ms (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine save_params_ss (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine save_collision_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine deallocate_params_ms () Arguments None public subroutine deallocate_collisions_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params","tags":"","loc":"module/korc_collisions.html"},{"title":"nrtype – KORC-Full Orbit","text":"@brief Module containing types used in the modules of the Numerical Recipes book software.\n @details For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". Contents Variables I4B I2B I1B SP DP SPC DPC LGT PI PIO2 TWOPI SQRT2 EULER PI_D PIO2_D TWOPI_D private_dummy Derived Types sprs2_sp sprs2_dp Variables Type Visibility Attributes Name Initial integer, public, parameter :: I4B = SELECTED_INT_KIND(9) integer, public, parameter :: I2B = SELECTED_INT_KIND(4) integer, public, parameter :: I1B = SELECTED_INT_KIND(2) integer, public, parameter :: SP = KIND(1.0) integer, public, parameter :: DP = KIND(1.0D0) integer, public, parameter :: SPC = KIND((1.0, 1.0)) integer, public, parameter :: DPC = KIND((1.0D0, 1.0D0)) integer, public, parameter :: LGT = KIND(.true.) real(kind=SP), public, parameter :: PI = 3.141592653589793238462643383279502884197_sp real(kind=SP), public, parameter :: PIO2 = 1.57079632679489661923132169163975144209858_sp real(kind=SP), public, parameter :: TWOPI = 6.283185307179586476925286766559005768394_sp real(kind=SP), public, parameter :: SQRT2 = 1.41421356237309504880168872420969807856967_sp real(kind=SP), public, parameter :: EULER = 0.5772156649015328606065120900824024310422_sp real(kind=DP), public, parameter :: PI_D = 3.141592653589793238462643383279502884197_dp real(kind=DP), public, parameter :: PIO2_D = 1.57079632679489661923132169163975144209858_dp real(kind=DP), public, parameter :: TWOPI_D = 6.283185307179586476925286766559005768394_dp integer, private :: private_dummy Derived Types type, public :: sprs2_sp Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: n integer(kind=I4B), public :: len real(kind=SP), public, DIMENSION(:), POINTER :: val integer(kind=I4B), public, DIMENSION(:), POINTER :: irow integer(kind=I4B), public, DIMENSION(:), POINTER :: jcol type, public :: sprs2_dp Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: n integer(kind=I4B), public :: len real(kind=DP), public, DIMENSION(:), POINTER :: val integer(kind=I4B), public, DIMENSION(:), POINTER :: irow integer(kind=I4B), public, DIMENSION(:), POINTER :: jcol","tags":"","loc":"module/nrtype.html"},{"title":"nrutil – KORC-Full Orbit","text":"@brief Module containing interfaces used in the modules of the Numerical Recipes book software.\n @details For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". Uses nrtype Contents Variables NPAR_ARTH NPAR2_ARTH NPAR_GEOP NPAR2_GEOP NPAR_CUMSUM NPAR_CUMPROD NPAR_POLY NPAR_POLYTERM Interfaces array_copy swap reallocate imaxloc assert assert_eq arth geop cumsum poly poly_term outerprod outerdiff scatter_add scatter_max diagadd diagmult get_diag put_diag Functions reallocate_rv reallocate_iv reallocate_hv reallocate_rm reallocate_im ifirstloc imaxloc_r imaxloc_i iminloc assert_eq2 assert_eq3 assert_eq4 assert_eqn arth_r arth_d arth_i geop_r geop_d geop_i geop_c geop_dv cumsum_r cumsum_i cumprod poly_rr poly_dd poly_rc poly_cc poly_rrv poly_ddv poly_msk_rrv poly_msk_ddv poly_term_rr poly_term_cc zroots_unity outerprod_r outerprod_d outerdiv outersum outerdiff_r outerdiff_d outerdiff_i outerand get_diag_rv get_diag_dv upper_triangle lower_triangle vabs Subroutines array_copy_r array_copy_d array_copy_i swap_i swap_r swap_rv swap_c swap_cv swap_cm swap_z swap_zv swap_zm masked_swap_rs masked_swap_rv masked_swap_rm assert1 assert2 assert3 assert4 assert_v nrerror scatter_add_r scatter_add_d scatter_max_r scatter_max_d diagadd_rv diagadd_r diagmult_rv diagmult_r put_diag_rv put_diag_r unit_matrix Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: NPAR_ARTH = 16 integer(kind=I4B), public, parameter :: NPAR2_ARTH = 8 integer(kind=I4B), public, parameter :: NPAR_GEOP = 4 integer(kind=I4B), public, parameter :: NPAR2_GEOP = 2 integer(kind=I4B), public, parameter :: NPAR_CUMSUM = 16 integer(kind=I4B), public, parameter :: NPAR_CUMPROD = 8 integer(kind=I4B), public, parameter :: NPAR_POLY = 8 integer(kind=I4B), public, parameter :: NPAR_POLYTERM = 8 Interfaces public interface array_copy public subroutine array_copy_r (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: src real(kind=SP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine array_copy_d (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: src real(kind=DP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine array_copy_i (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: src integer(kind=I4B), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public interface swap public subroutine swap_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b public subroutine swap_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b public subroutine swap_rv (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b public subroutine swap_c (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout) :: a complex(kind=SPC), intent(inout) :: b public subroutine swap_cv (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: a complex(kind=SPC), intent(inout), DIMENSION(:) :: b public subroutine swap_cm (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: a complex(kind=SPC), intent(inout), DIMENSION(:,:) :: b public subroutine swap_z (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout) :: a complex(kind=DPC), intent(inout) :: b public subroutine swap_zv (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:) :: a complex(kind=DPC), intent(inout), DIMENSION(:) :: b public subroutine swap_zm (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DPC), intent(inout), DIMENSION(:,:) :: b public subroutine masked_swap_rs (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask public subroutine masked_swap_rv (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask public subroutine masked_swap_rm (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask public interface reallocate public function reallocate_rv (p, n) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(:), POINTER public function reallocate_rm (p, n, m) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value real(kind=SP),\n  DIMENSION(:,:), POINTER public function reallocate_iv (p, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(:), POINTER public function reallocate_im (p, n, m) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value integer(kind=I4B),\n  DIMENSION(:,:), POINTER public function reallocate_hv (p, n) Arguments Type Intent Optional Attributes Name character(len=1), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value character(len=1),\n  DIMENSION(:), POINTER public interface imaxloc public function imaxloc_r (arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) public function imaxloc_i (iarr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B) public interface assert public subroutine assert1 (n1, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string public subroutine assert2 (n1, n2, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string public subroutine assert3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string public subroutine assert4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string public subroutine assert_v (n, string) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string public interface assert_eq public function assert_eq2 (n1, n2, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer public function assert_eq3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer public function assert_eq4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer public function assert_eqn (nn, string) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string Return Value integer public interface arth public function arth_r (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) public function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public interface geop public function geop_r (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) public function geop_d (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function geop_i (first, factor, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public function geop_c (first, factor, n) Arguments Type Intent Optional Attributes Name complex(kind=SP), intent(in) :: first complex(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value complex(kind=SP),\n  DIMENSION(n) public function geop_dv (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: first real(kind=DP), intent(in), DIMENSION(:) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(size(first),n) public interface cumsum public recursive function cumsum_r (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(in), optional :: seed Return Value real(kind=SP),\n  DIMENSION(size(arr)) public recursive function cumsum_i (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(size(arr)) public interface poly public function poly_rr (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP) public function poly_rrv (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP),\n  DIMENSION(size(x)) public function poly_dd (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP) public function poly_ddv (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP),\n  DIMENSION(size(x)) public function poly_rc (x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) public function poly_cc (x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x complex(kind=SPC), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) public function poly_msk_rrv (x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=SP),\n  DIMENSION(size(x)) public function poly_msk_ddv (x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=DP),\n  DIMENSION(size(x)) public interface poly_term public recursive function poly_term_rr (a, b) result(u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP),\n  DIMENSION(size(a)) public recursive function poly_term_cc (a, b) result(u) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(in) :: b Return Value complex(kind=SPC),\n  DIMENSION(size(a)) public interface outerprod public function outerprod_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerprod_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) public interface outerdiff public function outerdiff_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerdiff_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) public function outerdiff_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) public interface scatter_add public subroutine scatter_add_r (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_add_d (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public interface scatter_max public subroutine scatter_max_r (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_max_d (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public interface diagadd public subroutine diagadd_rv (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag public subroutine diagadd_r (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag public interface diagmult public subroutine diagmult_rv (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag public subroutine diagmult_r (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag public interface get_diag public function get_diag_rv (mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=SP),\n  DIMENSION(size(mat,1)) public function get_diag_dv (mat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=DP),\n  DIMENSION(size(mat,1)) public interface put_diag public subroutine put_diag_rv (diagv, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: diagv real(kind=SP), intent(inout), DIMENSION(:,:) :: mat public subroutine put_diag_r (scal, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: scal real(kind=SP), intent(inout), DIMENSION(:,:) :: mat Functions public function reallocate_rv (p, n) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(:), POINTER public function reallocate_iv (p, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(:), POINTER public function reallocate_hv (p, n) Arguments Type Intent Optional Attributes Name character(len=1), DIMENSION(:), POINTER :: p integer(kind=I4B), intent(in) :: n Return Value character(len=1),\n  DIMENSION(:), POINTER public function reallocate_rm (p, n, m) Arguments Type Intent Optional Attributes Name real(kind=SP), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value real(kind=SP),\n  DIMENSION(:,:), POINTER public function reallocate_im (p, n, m) Arguments Type Intent Optional Attributes Name integer(kind=I4B), DIMENSION(:,:), POINTER :: p integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m Return Value integer(kind=I4B),\n  DIMENSION(:,:), POINTER public function ifirstloc (mask) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value integer(kind=I4B) public function imaxloc_r (arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) public function imaxloc_i (iarr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B) public function iminloc (arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) public function assert_eq2 (n1, n2, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer public function assert_eq3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer public function assert_eq4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n1 integer, intent(in) :: n2 integer, intent(in) :: n3 integer, intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer public function assert_eqn (nn, string) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: nn character(len=*), intent(in) :: string Return Value integer public function arth_r (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) public function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public function geop_r (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) public function geop_d (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) public function geop_i (first, factor, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public function geop_c (first, factor, n) Arguments Type Intent Optional Attributes Name complex(kind=SP), intent(in) :: first complex(kind=SP), intent(in) :: factor integer(kind=I4B), intent(in) :: n Return Value complex(kind=SP),\n  DIMENSION(n) public function geop_dv (first, factor, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: first real(kind=DP), intent(in), DIMENSION(:) :: factor integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(size(first),n) public recursive function cumsum_r (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(in), optional :: seed Return Value real(kind=SP),\n  DIMENSION(size(arr)) public recursive function cumsum_i (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(in), optional :: seed Return Value integer(kind=I4B),\n  DIMENSION(size(arr)) public recursive function cumprod (arr, seed) result(ans) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(in), optional :: seed Return Value real(kind=SP),\n  DIMENSION(size(arr)) public function poly_rr (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP) public function poly_dd (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP) public function poly_rc (x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) public function poly_cc (x, coeffs) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: x complex(kind=SPC), intent(in), DIMENSION(:) :: coeffs Return Value complex(kind=SPC) public function poly_rrv (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=SP),\n  DIMENSION(size(x)) public function poly_ddv (x, coeffs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs Return Value real(kind=DP),\n  DIMENSION(size(x)) public function poly_msk_rrv (x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=SP),\n  DIMENSION(size(x)) public function poly_msk_ddv (x, coeffs, mask) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: coeffs logical(kind=LGT), intent(in), DIMENSION(:) :: mask Return Value real(kind=DP),\n  DIMENSION(size(x)) public recursive function poly_term_rr (a, b) result(u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP),\n  DIMENSION(size(a)) public recursive function poly_term_cc (a, b) result(u) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(in) :: b Return Value complex(kind=SPC),\n  DIMENSION(size(a)) public function zroots_unity (n, nn) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: nn Return Value complex(kind=SPC),\n  DIMENSION(nn) public function outerprod_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerprod_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) public function outerdiv (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outersum (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerdiff_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) public function outerdiff_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) public function outerdiff_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) public function outerand (a, b) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: b Return Value logical(kind=LGT),\n  DIMENSION(size(a),size(b)) public function get_diag_rv (mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=SP),\n  DIMENSION(size(mat,1)) public function get_diag_dv (mat) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: mat Return Value real(kind=DP),\n  DIMENSION(size(mat,1)) public function upper_triangle (j, k, extra) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: j integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in), optional :: extra Return Value logical(kind=LGT),\n  DIMENSION(j,k) public function lower_triangle (j, k, extra) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: j integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in), optional :: extra Return Value logical(kind=LGT),\n  DIMENSION(j,k) public function vabs (v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: v Return Value real(kind=SP) Subroutines public subroutine array_copy_r (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: src real(kind=SP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine array_copy_d (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: src real(kind=DP), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine array_copy_i (src, dest, n_copied, n_not_copied) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: src integer(kind=I4B), intent(out), DIMENSION(:) :: dest integer(kind=I4B), intent(out) :: n_copied integer(kind=I4B), intent(out) :: n_not_copied public subroutine swap_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b public subroutine swap_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b public subroutine swap_rv (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b public subroutine swap_c (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout) :: a complex(kind=SPC), intent(inout) :: b public subroutine swap_cv (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: a complex(kind=SPC), intent(inout), DIMENSION(:) :: b public subroutine swap_cm (a, b) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: a complex(kind=SPC), intent(inout), DIMENSION(:,:) :: b public subroutine swap_z (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout) :: a complex(kind=DPC), intent(inout) :: b public subroutine swap_zv (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:) :: a complex(kind=DPC), intent(inout), DIMENSION(:) :: b public subroutine swap_zm (a, b) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DPC), intent(inout), DIMENSION(:,:) :: b public subroutine masked_swap_rs (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: a real(kind=SP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask public subroutine masked_swap_rv (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask public subroutine masked_swap_rm (a, b, mask) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask public subroutine assert1 (n1, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 character(len=*), intent(in) :: string public subroutine assert2 (n1, n2, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 character(len=*), intent(in) :: string public subroutine assert3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 character(len=*), intent(in) :: string public subroutine assert4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n1 logical, intent(in) :: n2 logical, intent(in) :: n3 logical, intent(in) :: n4 character(len=*), intent(in) :: string public subroutine assert_v (n, string) Arguments Type Intent Optional Attributes Name logical, intent(in), DIMENSION(:) :: n character(len=*), intent(in) :: string public subroutine nrerror (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string public subroutine scatter_add_r (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_add_d (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_max_r (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: dest real(kind=SP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine scatter_max_d (dest, source, dest_index) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(:) :: dest real(kind=DP), intent(in), DIMENSION(:) :: source integer(kind=I4B), intent(in), DIMENSION(:) :: dest_index public subroutine diagadd_rv (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag public subroutine diagadd_r (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag public subroutine diagmult_rv (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in), DIMENSION(:) :: diag public subroutine diagmult_r (mat, diag) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: mat real(kind=SP), intent(in) :: diag public subroutine put_diag_rv (diagv, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: diagv real(kind=SP), intent(inout), DIMENSION(:,:) :: mat public subroutine put_diag_r (scal, mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: scal real(kind=SP), intent(inout), DIMENSION(:,:) :: mat public subroutine unit_matrix (mat) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:,:) :: mat","tags":"","loc":"module/nrutil.html"},{"title":"nr – KORC-Full Orbit","text":"@brief Module containing interfaces used in the modules of the Numerical Recipes book software.\n @details For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". Contents Variables private_dummy Interfaces airy amebsa amoeba anneal asolve atimes avevar balanc banbks bandec banmul bcucof bcuint beschb bessi bessi0 bessi1 bessik bessj bessj0 bessj1 bessjy bessk bessk0 bessk1 bessy bessy0 bessy1 beta betacf betai bico bnldev brent broydn bsstep caldat chder chebev chebft chebpc chint choldc cholsl chsone chstwo cisi cntab1 cntab2 convlv correl cosft1 cosft2 covsrt cyclic daub4 dawson dbrent ddpoly decchk dfpmin dfridr dftcor dftint difeq eclass eclazz ei eigsrt elle ellf ellpi elmhes erf erfc erfcc eulsum evlmem expdev expint factln factrl fasper fdjac fgauss fit fitexy fixrts fleg flmoon four1 four1_alt four1_gather four2 four2_alt four3 four3_alt fourcol fourcol_3d fourn_gather fourrow fourrow_3d fpoly fred2 fredin frenel frprmn ftest gamdev gammln gammp gammq gasdev gaucof gauher gaujac gaulag gauleg gaussj gcf golden gser hqr hunt hypdrv hypgeo hypser icrc igray index_bypack indexx interp rank irbit1 irbit2 jacobi jacobn julday kendl1 kendl2 kermom ks2d1s ks2d2s ksone kstwo laguer lfit linbcg linmin lnsrch locate lop lubksb ludcmp machar medfit memcof mgfas mglin midexp midinf midpnt midsql midsqu miser mmid mnbrak mnewt moment mp2dfr mpdiv mpinv mpmul mppi mprove mpSQRT mrqcof mrqmin newt odeint orthog pade pccheb pcshft pearsn period plgndr poidev polcoe polcof poldiv polin2 polint powell predic probks psdes pwt pwtset pythag pzextr qrdcmp qromb qromo qroot qrsolv qrupdt qsimp qtrap quadct quadmx quadvl ran ran0 ran1 ran2 ran3 ratint ratlsq ratval rc rd realft recur1 recur2 relax relax2 resid rf rj rk4 rkck rkdumb rkqs rlft2 rlft3 rotate rsolv rstrct rtbis rtflsp rtnewt rtsafe rtsec rzextr savgol scrsho select select_bypack select_heap select_inplace simplx simpr sinft slvsm2 slvsml sncndn snrm sobseq solvde sor sort sort2 sort3 sort_bypack sort_byreshape sort_heap sort_pick sort_radix sort_shell spctrm spear sphbes splie2 splin2 spline splint sprsax sprsdiag sprsin sprstp sprstx stifbs stiff stoerm svbksb svdcmp svdfit svdvar toeplz tptest tqli trapzd tred2 tridag tridag_ser ttest tutest twofft vander vegas voltra wt1 wtn wwghts zbrac zbrak zbrent zrhqr zriddr zroots Variables Type Visibility Attributes Name Initial integer, private :: private_dummy Interfaces interface public subroutine airy(x, ai, bi, aip, bip) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: ai real(kind=SP), intent(out) :: bi real(kind=SP), intent(out) :: aip real(kind=SP), intent(out) :: bip interface public subroutine amebsa(p, y, pb, yb, ftol, func, iter, temptr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: p real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(inout), DIMENSION(:) :: pb real(kind=SP), intent(inout) :: yb real(kind=SP), intent(in) :: ftol function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) integer(kind=I4B), intent(inout) :: iter real(kind=SP), intent(in) :: temptr interface public subroutine amoeba(p, y, ftol, func, iter) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: p real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in) :: ftol function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) integer(kind=I4B), intent(out) :: iter interface public subroutine anneal(x, y, iorder) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y integer(kind=I4B), intent(inout), DIMENSION(:) :: iorder interface public subroutine asolve(b, x, itrnsp) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: b real(kind=DP), intent(out), DIMENSION(:) :: x integer(kind=I4B), intent(in) :: itrnsp interface public subroutine atimes(x, r, itrnsp) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(out), DIMENSION(:) :: r integer(kind=I4B), intent(in) :: itrnsp interface public subroutine avevar(data, ave, var) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(out) :: ave real(kind=SP), intent(out) :: var interface public subroutine balanc(a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a interface public subroutine banbks(a, m1, m2, al, indx, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 real(kind=SP), intent(in), DIMENSION(:,:) :: al integer(kind=I4B), intent(in), DIMENSION(:) :: indx real(kind=SP), intent(inout), DIMENSION(:) :: b interface public subroutine bandec(a, m1, m2, al, indx, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 real(kind=SP), intent(out), DIMENSION(:,:) :: al integer(kind=I4B), intent(out), DIMENSION(:) :: indx real(kind=SP), intent(out) :: d interface public subroutine banmul(a, m1, m2, x, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: b interface public subroutine bcucof(y, y1, y2, y12, d1, d2, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(4) :: y real(kind=SP), intent(in), DIMENSION(4) :: y1 real(kind=SP), intent(in), DIMENSION(4) :: y2 real(kind=SP), intent(in), DIMENSION(4) :: y12 real(kind=SP), intent(in) :: d1 real(kind=SP), intent(in) :: d2 real(kind=SP), intent(out), DIMENSION(4,4) :: c interface public subroutine bcuint(y, y1, y2, y12, x1l, x1u, x2l, x2u, x1, x2, ansy, ansy1, ansy2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(4) :: y real(kind=SP), intent(in), DIMENSION(4) :: y1 real(kind=SP), intent(in), DIMENSION(4) :: y2 real(kind=SP), intent(in), DIMENSION(4) :: y12 real(kind=SP), intent(in) :: x1l real(kind=SP), intent(in) :: x1u real(kind=SP), intent(in) :: x2l real(kind=SP), intent(in) :: x2u real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(out) :: ansy real(kind=SP), intent(out) :: ansy1 real(kind=SP), intent(out) :: ansy2 public interface beschb public subroutine beschb_s(x, gam1, gam2, gampl, gammi) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(out) :: gam1 real(kind=DP), intent(out) :: gam2 real(kind=DP), intent(out) :: gampl real(kind=DP), intent(out) :: gammi public subroutine beschb_v(x, gam1, gam2, gampl, gammi) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(out), DIMENSION(:) :: gam1 real(kind=DP), intent(out), DIMENSION(:) :: gam2 real(kind=DP), intent(out), DIMENSION(:) :: gampl real(kind=DP), intent(out), DIMENSION(:) :: gammi public interface bessi public function bessi_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessi_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessi0 public function bessi0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessi0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessi1 public function bessi1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessi1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public subroutine bessik(x, xnu, ri, rk, rip, rkp) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out) :: ri real(kind=SP), intent(out) :: rk real(kind=SP), intent(out) :: rip real(kind=SP), intent(out) :: rkp public interface bessj public function bessj_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessj_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessj0 public function bessj0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessj0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessj1 public function bessj1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessj1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessjy public subroutine bessjy_s(x, xnu, rj, ry, rjp, ryp) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out) :: rj real(kind=SP), intent(out) :: ry real(kind=SP), intent(out) :: rjp real(kind=SP), intent(out) :: ryp public subroutine bessjy_v(x, xnu, rj, ry, rjp, ryp) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out), DIMENSION(:) :: rj real(kind=SP), intent(out), DIMENSION(:) :: ry real(kind=SP), intent(out), DIMENSION(:) :: rjp real(kind=SP), intent(out), DIMENSION(:) :: ryp public interface bessk public function bessk_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessk_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessk0 public function bessk0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessk0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessk1 public function bessk1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessk1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessy public function bessy_s(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessy_v(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessy0 public function bessy0_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessy0_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface bessy1 public function bessy1_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function bessy1_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface beta public function beta_s(z, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: z real(kind=SP), intent(in) :: w Return Value real(kind=SP) public function beta_v(z, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: z real(kind=SP), intent(in), DIMENSION(:) :: w Return Value real(kind=SP),\n  DIMENSION(size(z)) public interface betacf public function betacf_s(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function betacf_v(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface betai public function betai_s(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function betai_v(a, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(a)) public interface bico public function bico_s(n, k) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: k Return Value real(kind=SP) public function bico_v(n, k) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: n integer(kind=I4B), intent(in), DIMENSION(:) :: k Return Value real(kind=SP),\n  DIMENSION(size(n)) interface public function bnldev(pp, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: pp integer(kind=I4B), intent(in) :: n Return Value real(kind=SP) interface public function brent(ax, bx, cx, func, tol, xmin) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: ax real(kind=SP), intent(in) :: bx real(kind=SP), intent(in) :: cx function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: tol real(kind=SP), intent(out) :: xmin Return Value real(kind=SP) interface public subroutine broydn(x, check) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: x logical(kind=LGT), intent(out) :: check interface public subroutine bsstep(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine caldat(julian, mm, id, iyyy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: julian integer(kind=I4B), intent(out) :: mm integer(kind=I4B), intent(out) :: id integer(kind=I4B), intent(out) :: iyyy interface public function chder(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(c)) public interface chebev public function chebev_s(a, b, c, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function chebev_v(a, b, c, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public function chebft(a, b, n, func) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b integer(kind=I4B), intent(in) :: n function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) Return Value real(kind=SP),\n  DIMENSION(n) interface public function chebpc(c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(c)) interface public function chint(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(c)) interface public subroutine choldc(a, p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: p interface public subroutine cholsl(a, p, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:) :: p real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(inout), DIMENSION(:) :: x interface public subroutine chsone(bins, ebins, knstrn, df, chsq, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: bins real(kind=SP), intent(in), DIMENSION(:) :: ebins integer(kind=I4B), intent(in) :: knstrn real(kind=SP), intent(out) :: df real(kind=SP), intent(out) :: chsq real(kind=SP), intent(out) :: prob interface public subroutine chstwo(bins1, bins2, knstrn, df, chsq, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: bins1 real(kind=SP), intent(in), DIMENSION(:) :: bins2 integer(kind=I4B), intent(in) :: knstrn real(kind=SP), intent(out) :: df real(kind=SP), intent(out) :: chsq real(kind=SP), intent(out) :: prob interface public subroutine cisi(x, ci, si) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: ci real(kind=SP), intent(out) :: si interface public subroutine cntab1(nn, chisq, df, prob, cramrv, ccc) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:,:) :: nn real(kind=SP), intent(out) :: chisq real(kind=SP), intent(out) :: df real(kind=SP), intent(out) :: prob real(kind=SP), intent(out) :: cramrv real(kind=SP), intent(out) :: ccc interface public subroutine cntab2(nn, h, hx, hy, hygx, hxgy, uygx, uxgy, uxy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:,:) :: nn real(kind=SP), intent(out) :: h real(kind=SP), intent(out) :: hx real(kind=SP), intent(out) :: hy real(kind=SP), intent(out) :: hygx real(kind=SP), intent(out) :: hxgy real(kind=SP), intent(out) :: uygx real(kind=SP), intent(out) :: uxgy real(kind=SP), intent(out) :: uxy interface public function convlv(data, respns, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(in), DIMENSION(:) :: respns integer(kind=I4B), intent(in) :: isign Return Value real(kind=SP),\n  DIMENSION(size(data)) interface public function correl(data1, data2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 Return Value real(kind=SP),\n  DIMENSION(size(data1)) interface public subroutine cosft1(y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y interface public subroutine cosft2(y, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y integer(kind=I4B), intent(in) :: isign interface public subroutine covsrt(covar, maska) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: covar logical(kind=LGT), intent(in), DIMENSION(:) :: maska interface public subroutine cyclic(a, b, c, alpha, beta, r, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: alpha real(kind=SP), intent(in) :: beta real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(out), DIMENSION(:) :: x interface public subroutine daub4(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign public interface dawson public function dawson_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function dawson_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public function dbrent(ax, bx, cx, func, dbrent_dfunc, tol, xmin) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: ax real(kind=SP), intent(in) :: bx real(kind=SP), intent(in) :: cx function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) function dbrent_dfunc(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: tol real(kind=SP), intent(out) :: xmin Return Value real(kind=SP) interface public subroutine ddpoly(c, x, pd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in) :: x real(kind=SP), intent(out), DIMENSION(:) :: pd interface public function decchk(string, ch) Arguments Type Intent Optional Attributes Name character(len=1), intent(in), DIMENSION(:) :: string character(len=1), intent(out) :: ch Return Value logical(kind=LGT) interface public subroutine dfpmin(p, gtol, iter, fret, func, dfunc) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(in) :: gtol integer(kind=I4B), intent(out) :: iter real(kind=SP), intent(out) :: fret function func(p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: p Return Value real(kind=SP) function dfunc(p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: p Return Value real(kind=SP),\n  DIMENSION(size(p)) interface public function dfridr(func, x, h, err) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: h real(kind=SP), intent(out) :: err Return Value real(kind=SP) interface public subroutine dftcor(w, delta, a, b, endpts, corre, corim, corfac) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: w real(kind=SP), intent(in) :: delta real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: endpts real(kind=SP), intent(out) :: corre real(kind=SP), intent(out) :: corim real(kind=SP), intent(out) :: corfac interface public subroutine dftint(func, a, b, w, cosint, sinint) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in) :: w real(kind=SP), intent(out) :: cosint real(kind=SP), intent(out) :: sinint interface public subroutine difeq(k, k1, k2, jsf, is1, isf, indexv, s, y) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k integer(kind=I4B), intent(in) :: k1 integer(kind=I4B), intent(in) :: k2 integer(kind=I4B), intent(in) :: jsf integer(kind=I4B), intent(in) :: is1 integer(kind=I4B), intent(in) :: isf integer(kind=I4B), intent(in), DIMENSION(:) :: indexv real(kind=SP), intent(out), DIMENSION(:,:) :: s real(kind=SP), intent(in), DIMENSION(:,:) :: y interface public function eclass(lista, listb, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: lista integer(kind=I4B), intent(in), DIMENSION(:) :: listb integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) interface public function eclazz(equiv, n) Arguments Type Intent Optional Attributes Name function equiv(i, j) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: i integer(kind=I4B), intent(in) :: j Return Value logical(kind=LGT) integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) interface public function ei(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) interface public subroutine eigsrt(d, v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:,:) :: v public interface elle public function elle_s(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: phi real(kind=SP), intent(in) :: ak Return Value real(kind=SP) public function elle_v(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: phi real(kind=SP), intent(in), DIMENSION(:) :: ak Return Value real(kind=SP),\n  DIMENSION(size(phi)) public interface ellf public function ellf_s(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: phi real(kind=SP), intent(in) :: ak Return Value real(kind=SP) public function ellf_v(phi, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: phi real(kind=SP), intent(in), DIMENSION(:) :: ak Return Value real(kind=SP),\n  DIMENSION(size(phi)) public interface ellpi public function ellpi_s(phi, en, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: phi real(kind=SP), intent(in) :: en real(kind=SP), intent(in) :: ak Return Value real(kind=SP) public function ellpi_v(phi, en, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: phi real(kind=SP), intent(in), DIMENSION(:) :: en real(kind=SP), intent(in), DIMENSION(:) :: ak Return Value real(kind=SP),\n  DIMENSION(size(phi)) interface public subroutine elmhes(a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a public interface erf public function erf_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function erf_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface erfc public function erfc_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function erfc_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface erfcc public function erfcc_s(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function erfcc_v(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public subroutine eulsum(sum, term, jterm) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: sum real(kind=SP), intent(in) :: term integer(kind=I4B), intent(in) :: jterm interface public function evlmem(fdt, d, xms) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: fdt real(kind=SP), intent(in), DIMENSION(:) :: d real(kind=SP), intent(in) :: xms Return Value real(kind=SP) public interface expdev public subroutine expdev_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine expdev_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest interface public function expint(n, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x Return Value real(kind=SP) public interface factln public function factln_s(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Return Value real(kind=SP) public function factln_v(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: n Return Value real(kind=SP),\n  DIMENSION(size(n)) public interface factrl public function factrl_s(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n Return Value real(kind=SP) public function factrl_v(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: n Return Value real(kind=SP),\n  DIMENSION(size(n)) interface public subroutine fasper(x, y, ofac, hifac, px, py, jmax, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in) :: ofac real(kind=SP), intent(in) :: hifac real(kind=SP), DIMENSION(:), POINTER :: px real(kind=SP), DIMENSION(:), POINTER :: py integer(kind=I4B), intent(out) :: jmax real(kind=SP), intent(out) :: prob interface public subroutine fdjac(x, fvec, df) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: fvec real(kind=SP), intent(out), DIMENSION(:,:) :: df interface public subroutine fgauss(x, a, y, dyda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:,:) :: dyda interface public subroutine fit(x, y, a, b, siga, sigb, chi2, q, sig) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out) :: a real(kind=SP), intent(out) :: b real(kind=SP), intent(out) :: siga real(kind=SP), intent(out) :: sigb real(kind=SP), intent(out) :: chi2 real(kind=SP), intent(out) :: q real(kind=SP), intent(in), optional DIMENSION(:) :: sig interface public subroutine fitexy(x, y, sigx, sigy, a, b, siga, sigb, chi2, q) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sigx real(kind=SP), intent(in), DIMENSION(:) :: sigy real(kind=SP), intent(out) :: a real(kind=SP), intent(out) :: b real(kind=SP), intent(out) :: siga real(kind=SP), intent(out) :: sigb real(kind=SP), intent(out) :: chi2 real(kind=SP), intent(out) :: q interface public subroutine fixrts(d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: d interface public function fleg(x, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) interface public subroutine flmoon(n, nph, jd, frac) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: nph integer(kind=I4B), intent(out) :: jd real(kind=SP), intent(out) :: frac public interface four1 public subroutine four1_dp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign public subroutine four1_sp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine four1_alt(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine four1_gather(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine four2(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine four2_alt(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine four3(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine four3_alt(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine fourcol(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine fourcol_3d(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine fourn_gather(data, nn, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in), DIMENSION(:) :: nn integer(kind=I4B), intent(in) :: isign public interface fourrow public subroutine fourrow_dp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=DPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign public subroutine fourrow_sp(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:) :: data integer(kind=I4B), intent(in) :: isign interface public subroutine fourrow_3d(data, isign) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(inout), DIMENSION(:,:,:) :: data integer(kind=I4B), intent(in) :: isign interface public function fpoly(x, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) interface public subroutine fred2(a, b, t, f, w, g, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(out), DIMENSION(:) :: t real(kind=SP), intent(out), DIMENSION(:) :: f real(kind=SP), intent(out), DIMENSION(:) :: w function g(t) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t Return Value real(kind=SP),\n  DIMENSION(size(t)) function ak(t, s) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t real(kind=SP), intent(in), DIMENSION(:) :: s Return Value real(kind=SP),\n  DIMENSION(size(t),size(s)) interface public function fredin(x, a, b, t, f, w, g, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(in), DIMENSION(:) :: t real(kind=SP), intent(in), DIMENSION(:) :: f real(kind=SP), intent(in), DIMENSION(:) :: w function g(t) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t Return Value real(kind=SP),\n  DIMENSION(size(t)) function ak(t, s) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: t real(kind=SP), intent(in), DIMENSION(:) :: s Return Value real(kind=SP),\n  DIMENSION(size(t),size(s)) Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public subroutine frenel(x, s, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: s real(kind=SP), intent(out) :: c interface public subroutine frprmn(p, ftol, iter, fret) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(in) :: ftol integer(kind=I4B), intent(out) :: iter real(kind=SP), intent(out) :: fret interface public subroutine ftest(data1, data2, f, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: f real(kind=SP), intent(out) :: prob interface public function gamdev(ia) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ia Return Value real(kind=SP) public interface gammln public function gammln_s(xx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: xx Return Value real(kind=SP) public function gammln_v(xx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xx Return Value real(kind=SP),\n  DIMENSION(size(xx)) public interface gammp public function gammp_s(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function gammp_v(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(a)) public interface gammq public function gammq_s(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function gammq_v(a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(a)) public interface gasdev public subroutine gasdev_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine gasdev_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest interface public subroutine gaucof(a, b, amu0, x, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a real(kind=SP), intent(inout), DIMENSION(:) :: b real(kind=SP), intent(in) :: amu0 real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w interface public subroutine gauher(x, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w interface public subroutine gaujac(x, w, alf, bet) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(in) :: alf real(kind=SP), intent(in) :: bet interface public subroutine gaulag(x, w, alf) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(in) :: alf interface public subroutine gauleg(x1, x2, x, w) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: w interface public subroutine gaussj(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(inout), DIMENSION(:,:) :: b public interface gcf public function gcf_s(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x real(kind=SP), intent(out), optional :: gln Return Value real(kind=SP) public function gcf_v(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), optional DIMENSION(:) :: gln Return Value real(kind=SP),\n  DIMENSION(size(a)) interface public function golden(ax, bx, cx, func, tol, xmin) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: ax real(kind=SP), intent(in) :: bx real(kind=SP), intent(in) :: cx function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: tol real(kind=SP), intent(out) :: xmin Return Value real(kind=SP) public interface gser public function gser_s(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: x real(kind=SP), intent(out), optional :: gln Return Value real(kind=SP) public function gser_v(a, x, gln) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), optional DIMENSION(:) :: gln Return Value real(kind=SP),\n  DIMENSION(size(a)) interface public subroutine hqr(a, wr, wi) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: wr real(kind=SP), intent(out), DIMENSION(:) :: wi interface public subroutine hunt(xx, x, jlo) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xx real(kind=SP), intent(in) :: x integer(kind=I4B), intent(inout) :: jlo interface public subroutine hypdrv(s, ry, rdyds) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: s real(kind=SP), intent(in), DIMENSION(:) :: ry real(kind=SP), intent(out), DIMENSION(:) :: rdyds interface public function hypgeo(a, b, c, z) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: a complex(kind=SPC), intent(in) :: b complex(kind=SPC), intent(in) :: c complex(kind=SPC), intent(in) :: z Return Value complex(kind=SPC) interface public subroutine hypser(a, b, c, z, series, deriv) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in) :: a complex(kind=SPC), intent(in) :: b complex(kind=SPC), intent(in) :: c complex(kind=SPC), intent(in) :: z complex(kind=SPC), intent(out) :: series complex(kind=SPC), intent(out) :: deriv interface public function icrc(crc, buf, jinit, jrev) Arguments Type Intent Optional Attributes Name integer(kind=I2B), intent(in) :: crc character(len=1), intent(in), DIMENSION(:) :: buf integer(kind=I2B), intent(in) :: jinit integer(kind=I4B), intent(in) :: jrev Return Value integer(kind=I2B) interface public function igray(n, is) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: is Return Value integer(kind=I4B) interface public subroutine index_bypack(arr, index, partial) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(inout), DIMENSION(:) :: index integer, intent(in), optional :: partial public interface indexx public subroutine indexx_sp(arr, index) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr integer(kind=I4B), intent(out), DIMENSION(:) :: index public subroutine indexx_i4b(iarr, index) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr integer(kind=I4B), intent(out), DIMENSION(:) :: index interface public function interp(uc) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: uc Return Value real(kind=DP),\n  DIMENSION(2*size(uc,1)-1,2*size(uc,1)-1) interface public function rank(indx) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: indx Return Value integer(kind=I4B),\n  DIMENSION(size(indx)) interface public function irbit1(iseed) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: iseed Return Value integer(kind=I4B) interface public function irbit2(iseed) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: iseed Return Value integer(kind=I4B) interface public subroutine jacobi(a, d, v, nrot) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: d real(kind=SP), intent(out), DIMENSION(:,:) :: v integer(kind=I4B), intent(out) :: nrot interface public subroutine jacobn(x, y, dfdx, dfdy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dfdx real(kind=SP), intent(out), DIMENSION(:,:) :: dfdy interface public function julday(mm, id, iyyy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: id integer(kind=I4B), intent(in) :: iyyy Return Value integer(kind=I4B) interface public subroutine kendl1(data1, data2, tau, z, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: tau real(kind=SP), intent(out) :: z real(kind=SP), intent(out) :: prob interface public subroutine kendl2(tab, tau, z, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: tab real(kind=SP), intent(out) :: tau real(kind=SP), intent(out) :: z real(kind=SP), intent(out) :: prob interface public function kermom(y, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: y integer(kind=I4B), intent(in) :: m Return Value real(kind=DP),\n  DIMENSION(m) interface public subroutine ks2d1s(x1, y1, quadvl, d1, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1 real(kind=SP), intent(in), DIMENSION(:) :: y1 subroutine quadvl(x, y, fa, fb, fc, fd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc real(kind=SP), intent(out) :: fd real(kind=SP), intent(out) :: d1 real(kind=SP), intent(out) :: prob interface public subroutine ks2d2s(x1, y1, x2, y2, d, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1 real(kind=SP), intent(in), DIMENSION(:) :: y1 real(kind=SP), intent(in), DIMENSION(:) :: x2 real(kind=SP), intent(in), DIMENSION(:) :: y2 real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: prob interface public subroutine ksone(data, func, d, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: data function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: prob interface public subroutine kstwo(data1, data2, d, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: prob interface public subroutine laguer(a, x, its) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(inout) :: x integer(kind=I4B), intent(out) :: its interface public subroutine lfit(x, y, sig, a, maska, covar, chisq, funcs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(inout), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: maska real(kind=SP), intent(inout), DIMENSION(:,:) :: covar real(kind=SP), intent(out) :: chisq subroutine funcs(x, arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out), DIMENSION(:) :: arr interface public subroutine linbcg(b, x, itol, tol, itmax, iter, err) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: b real(kind=DP), intent(inout), DIMENSION(:) :: x integer(kind=I4B), intent(in) :: itol real(kind=DP), intent(in) :: tol integer(kind=I4B), intent(in) :: itmax integer(kind=I4B), intent(out) :: iter real(kind=DP), intent(out) :: err interface public subroutine linmin(p, xi, fret) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:), TARGET :: p real(kind=SP), intent(inout), DIMENSION(:), TARGET :: xi real(kind=SP), intent(out) :: fret interface public subroutine lnsrch(xold, fold, g, p, x, f, stpmax, check, func) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xold real(kind=SP), intent(in) :: fold real(kind=SP), intent(in), DIMENSION(:) :: g real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(out), DIMENSION(:) :: x real(kind=SP), intent(out) :: f real(kind=SP), intent(in) :: stpmax logical(kind=LGT), intent(out) :: check function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) interface public function locate(xx, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xx real(kind=SP), intent(in) :: x Return Value integer(kind=I4B) interface public function lop(u) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: u Return Value real(kind=DP),\n  DIMENSION(size(u,1),size(u,1)) interface public subroutine lubksb(a, indx, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: indx real(kind=SP), intent(inout), DIMENSION(:) :: b interface public subroutine ludcmp(a, indx, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a integer(kind=I4B), intent(out), DIMENSION(:) :: indx real(kind=SP), intent(out) :: d interface public subroutine machar(ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp, eps, epsneg, xmin, xmax) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(out) :: ibeta integer(kind=I4B), intent(out) :: it integer(kind=I4B), intent(out) :: irnd integer(kind=I4B), intent(out) :: ngrd integer(kind=I4B), intent(out) :: machep integer(kind=I4B), intent(out) :: negep integer(kind=I4B), intent(out) :: iexp integer(kind=I4B), intent(out) :: minexp integer(kind=I4B), intent(out) :: maxexp real(kind=SP), intent(out) :: eps real(kind=SP), intent(out) :: epsneg real(kind=SP), intent(out) :: xmin real(kind=SP), intent(out) :: xmax interface public subroutine medfit(x, y, a, b, abdev) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out) :: a real(kind=SP), intent(out) :: b real(kind=SP), intent(out) :: abdev interface public subroutine memcof(data, xms, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(out) :: xms real(kind=SP), intent(out), DIMENSION(:) :: d interface public subroutine mgfas(u, maxcyc) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u integer(kind=I4B), intent(in) :: maxcyc interface public subroutine mglin(u, ncycle) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u integer(kind=I4B), intent(in) :: ncycle interface public subroutine midexp(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n interface public subroutine midinf(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n interface public subroutine midpnt(func, a, b, s, n) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n interface public subroutine midsql(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n interface public subroutine midsqu(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n interface public subroutine miser(func, regn, ndim, npts, dith, ave, var) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP) real(kind=SP), intent(in), DIMENSION(:) :: regn integer(kind=I4B), intent(in) :: ndim integer(kind=I4B), intent(in) :: npts real(kind=SP), intent(in) :: dith real(kind=SP), intent(out) :: ave real(kind=SP), intent(out) :: var interface public subroutine mmid(y, dydx, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in) :: xs real(kind=SP), intent(in) :: htot integer(kind=I4B), intent(in) :: nstep real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine mnbrak(ax, bx, cx, fa, fb, fc, func) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout) :: ax real(kind=SP), intent(inout) :: bx real(kind=SP), intent(out) :: cx real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) interface public subroutine mnewt(ntrial, x, tolx, tolf, usrfun) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ntrial real(kind=SP), intent(inout), DIMENSION(:) :: x real(kind=SP), intent(in) :: tolx real(kind=SP), intent(in) :: tolf subroutine usrfun(x, fvec, fjac) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: fvec real(kind=SP), intent(out), DIMENSION(:,:) :: fjac interface public subroutine moment(data, ave, adev, sdev, var, skew, curt) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(out) :: ave real(kind=SP), intent(out) :: adev real(kind=SP), intent(out) :: sdev real(kind=SP), intent(out) :: var real(kind=SP), intent(out) :: skew real(kind=SP), intent(out) :: curt interface public subroutine mp2dfr(a, s, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(inout), DIMENSION(:) :: a character(len=1), intent(out), DIMENSION(:) :: s integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(out) :: m interface public subroutine mpdiv(q, r, u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: q character(len=1), intent(out), DIMENSION(:) :: r character(len=1), intent(in), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m interface public subroutine mpinv(u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m interface public subroutine mpmul(w, u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: w character(len=1), intent(in), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m interface public subroutine mppi(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n interface public subroutine mprove(a, alud, indx, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:,:) :: alud integer(kind=I4B), intent(in), DIMENSION(:) :: indx real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(inout), DIMENSION(:) :: x interface public subroutine mpSQRT(w, u, v, n, m) Arguments Type Intent Optional Attributes Name character(len=1), intent(out), DIMENSION(:) :: w character(len=1), intent(out), DIMENSION(:) :: u character(len=1), intent(in), DIMENSION(:) :: v integer(kind=I4B), intent(in) :: n integer(kind=I4B), intent(in) :: m interface public subroutine mrqcof(x, y, sig, a, maska, alpha, beta, chisq, funcs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(in), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: maska real(kind=SP), intent(out), DIMENSION(:,:) :: alpha real(kind=SP), intent(out), DIMENSION(:) :: beta real(kind=SP), intent(out) :: chisq subroutine funcs(x, a, yfit, dyda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: yfit real(kind=SP), intent(out), DIMENSION(:,:) :: dyda interface public subroutine mrqmin(x, y, sig, a, maska, covar, alpha, chisq, funcs, alamda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(inout), DIMENSION(:) :: a logical(kind=LGT), intent(in), DIMENSION(:) :: maska real(kind=SP), intent(out), DIMENSION(:,:) :: covar real(kind=SP), intent(out), DIMENSION(:,:) :: alpha real(kind=SP), intent(out) :: chisq subroutine funcs(x, a, yfit, dyda) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: yfit real(kind=SP), intent(out), DIMENSION(:,:) :: dyda real(kind=SP), intent(inout) :: alamda interface public subroutine newt(x, check) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: x logical(kind=LGT), intent(out) :: check interface public subroutine odeint(ystart, x1, x2, eps, h1, hmin, derivs, rkqs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: ystart real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: eps real(kind=SP), intent(in) :: h1 real(kind=SP), intent(in) :: hmin subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx subroutine rkqs(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine orthog(anu, alpha, beta, a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: anu real(kind=SP), intent(in), DIMENSION(:) :: alpha real(kind=SP), intent(in), DIMENSION(:) :: beta real(kind=SP), intent(out), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: b interface public subroutine pade(cof, resid) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: cof real(kind=SP), intent(out) :: resid interface public function pccheb(d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: d Return Value real(kind=SP),\n  DIMENSION(size(d)) interface public subroutine pcshft(a, b, d) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(inout), DIMENSION(:) :: d interface public subroutine pearsn(x, y, r, prob, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out) :: r real(kind=SP), intent(out) :: prob real(kind=SP), intent(out) :: z interface public subroutine period(x, y, ofac, hifac, px, py, jmax, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in) :: ofac real(kind=SP), intent(in) :: hifac real(kind=SP), DIMENSION(:), POINTER :: px real(kind=SP), DIMENSION(:), POINTER :: py integer(kind=I4B), intent(out) :: jmax real(kind=SP), intent(out) :: prob public interface plgndr public function plgndr_s(l, m, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: l integer(kind=I4B), intent(in) :: m real(kind=SP), intent(in) :: x Return Value real(kind=SP) public function plgndr_v(l, m, x) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: l integer(kind=I4B), intent(in) :: m real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public function poidev(xm) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: xm Return Value real(kind=SP) interface public function polcoe(x, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public function polcof(xa, ya) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya Return Value real(kind=SP),\n  DIMENSION(size(xa)) interface public subroutine poldiv(u, v, q, r) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: u real(kind=SP), intent(in), DIMENSION(:) :: v real(kind=SP), intent(out), DIMENSION(:) :: q real(kind=SP), intent(out), DIMENSION(:) :: r interface public subroutine polin2(x1a, x2a, ya, x1, x2, y, dy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1a real(kind=SP), intent(in), DIMENSION(:) :: x2a real(kind=SP), intent(in), DIMENSION(:,:) :: ya real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(out) :: y real(kind=SP), intent(out) :: dy interface public subroutine polint(xa, ya, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: y real(kind=SP), intent(out) :: dy interface public subroutine powell(p, xi, ftol, iter, fret) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: p real(kind=SP), intent(inout), DIMENSION(:,:) :: xi real(kind=SP), intent(in) :: ftol integer(kind=I4B), intent(out) :: iter real(kind=SP), intent(out) :: fret interface public function predic(data, d, nfut) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data real(kind=SP), intent(in), DIMENSION(:) :: d integer(kind=I4B), intent(in) :: nfut Return Value real(kind=SP),\n  DIMENSION(nfut) interface public function probks(alam) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: alam Return Value real(kind=SP) public interface psdes public subroutine psdes_s(lword, rword) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: lword integer(kind=I4B), intent(inout) :: rword public subroutine psdes_v(lword, rword) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), DIMENSION(:) :: lword integer(kind=I4B), intent(inout), DIMENSION(:) :: rword interface public subroutine pwt(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign interface public subroutine pwtset(n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n public interface pythag public function pythag_dp(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: b Return Value real(kind=DP) public function pythag_sp(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP) interface public subroutine pzextr(iest, xest, yest, yz, dy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iest real(kind=SP), intent(in) :: xest real(kind=SP), intent(in), DIMENSION(:) :: yest real(kind=SP), intent(out), DIMENSION(:) :: yz real(kind=SP), intent(out), DIMENSION(:) :: dy interface public subroutine qrdcmp(a, c, d, sing) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: c real(kind=SP), intent(out), DIMENSION(:) :: d logical(kind=LGT), intent(out) :: sing interface public function qromb(func, a, b) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP) interface public function qromo(func, a, b, choose) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b subroutine choose(funk, aa, bb, s, n) Arguments Type Intent Optional Attributes Name function funk(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: aa real(kind=SP), intent(in) :: bb real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n Return Value real(kind=SP) interface public subroutine qroot(p, b, c, eps) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: p real(kind=SP), intent(inout) :: b real(kind=SP), intent(inout) :: c real(kind=SP), intent(in) :: eps interface public subroutine qrsolv(a, c, d, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:) :: b interface public subroutine qrupdt(r, qt, u, v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: r real(kind=SP), intent(inout), DIMENSION(:,:) :: qt real(kind=SP), intent(inout), DIMENSION(:) :: u real(kind=SP), intent(in), DIMENSION(:) :: v interface public function qsimp(func, a, b) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP) interface public function qtrap(func, a, b) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b Return Value real(kind=SP) interface public subroutine quadct(x, y, xx, yy, fa, fb, fc, fd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in), DIMENSION(:) :: xx real(kind=SP), intent(in), DIMENSION(:) :: yy real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc real(kind=SP), intent(out) :: fd interface public subroutine quadmx(a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:,:) :: a interface public subroutine quadvl(x, y, fa, fb, fc, fd) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(out) :: fa real(kind=SP), intent(out) :: fb real(kind=SP), intent(out) :: fc real(kind=SP), intent(out) :: fd interface public function ran(idum) Arguments Type Intent Optional Attributes Name integer(kind=selected_int_kind(9)), intent(inout) :: idum Return Value real public interface ran0 public subroutine ran0_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran0_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest public interface ran1 public subroutine ran1_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran1_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest public interface ran2 public subroutine ran2_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran2_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest public interface ran3 public subroutine ran3_s(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out) :: harvest public subroutine ran3_v(harvest) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: harvest interface public subroutine ratint(xa, ya, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: y real(kind=SP), intent(out) :: dy interface public subroutine ratlsq(func, a, b, mm, kk, cof, dev) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x Return Value real(kind=DP),\n  DIMENSION(size(x)) real(kind=DP), intent(in) :: a real(kind=DP), intent(in) :: b integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: kk real(kind=DP), intent(out), DIMENSION(:) :: cof real(kind=DP), intent(out) :: dev public interface ratval public function ratval_s(x, cof, mm, kk) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: x real(kind=DP), intent(in), DIMENSION(mm+kk+1) :: cof integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: kk Return Value real(kind=DP) public function ratval_v(x, cof, mm, kk) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(mm+kk+1) :: cof integer(kind=I4B), intent(in) :: mm integer(kind=I4B), intent(in) :: kk Return Value real(kind=DP),\n  DIMENSION(size(x)) public interface rc public function rc_s(x, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y Return Value real(kind=SP) public function rc_v(x, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface rd public function rd_s(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in) :: z Return Value real(kind=SP) public function rd_v(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: z Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface realft public subroutine realft_dp(data, isign, zdata) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign complex(kind=DPC), optional DIMENSION(:), TARGET :: zdata public subroutine realft_sp(data, isign, zdata) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: data integer(kind=I4B), intent(in) :: isign complex(kind=SPC), optional DIMENSION(:), TARGET :: zdata interface public recursive function recur1(a, b) result(u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a)) interface public function recur2(a, b, c) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c Return Value real(kind=SP),\n  DIMENSION(size(a)) interface public subroutine relax(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:,:) :: rhs interface public subroutine relax2(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:,:) :: rhs interface public function resid(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:,:) :: rhs Return Value real(kind=DP),\n  DIMENSION(size(u,1),size(u,1)) public interface rf public function rf_s(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in) :: z Return Value real(kind=SP) public function rf_v(x, y, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: z Return Value real(kind=SP),\n  DIMENSION(size(x)) public interface rj public function rj_s(x, y, z, p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: y real(kind=SP), intent(in) :: z real(kind=SP), intent(in) :: p Return Value real(kind=SP) public function rj_v(x, y, z, p) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: z real(kind=SP), intent(in), DIMENSION(:) :: p Return Value real(kind=SP),\n  DIMENSION(size(x)) interface public subroutine rk4(y, dydx, x, h, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: h real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine rkck(y, dydx, x, h, yout, yerr, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: h real(kind=SP), intent(out), DIMENSION(:) :: yout real(kind=SP), intent(out), DIMENSION(:) :: yerr subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine rkdumb(vstart, x1, x2, nstep, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: vstart real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 integer(kind=I4B), intent(in) :: nstep subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine rkqs(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine rlft2(data, spec, speq, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: data complex(kind=SPC), intent(out), DIMENSION(:,:) :: spec complex(kind=SPC), intent(out), DIMENSION(:) :: speq integer(kind=I4B), intent(in) :: isign interface public subroutine rlft3(data, spec, speq, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:,:) :: data complex(kind=SPC), intent(out), DIMENSION(:,:,:) :: spec complex(kind=SPC), intent(out), DIMENSION(:,:) :: speq integer(kind=I4B), intent(in) :: isign interface public subroutine rotate(r, qt, i, a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:), TARGET :: r real(kind=SP), intent(inout), DIMENSION(:,:), TARGET :: qt integer(kind=I4B), intent(in) :: i real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b interface public subroutine rsolv(a, d, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:) :: b interface public function rstrct(uf) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: uf Return Value real(kind=DP),\n  DIMENSION((size(uf,1)+1)/2,(size(uf,1)+1)/2) interface public function rtbis(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP) interface public function rtflsp(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP) interface public function rtnewt(funcd, x1, x2, xacc) Arguments Type Intent Optional Attributes Name subroutine funcd(x, fval, fderiv) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: fval real(kind=SP), intent(out) :: fderiv real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP) interface public function rtsafe(funcd, x1, x2, xacc) Arguments Type Intent Optional Attributes Name subroutine funcd(x, fval, fderiv) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: fval real(kind=SP), intent(out) :: fderiv real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP) interface public function rtsec(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP) interface public subroutine rzextr(iest, xest, yest, yz, dy) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: iest real(kind=SP), intent(in) :: xest real(kind=SP), intent(in), DIMENSION(:) :: yest real(kind=SP), intent(out), DIMENSION(:) :: yz real(kind=SP), intent(out), DIMENSION(:) :: dy interface public function savgol(nl, nrr, ld, m) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nl integer(kind=I4B), intent(in) :: nrr integer(kind=I4B), intent(in) :: ld integer(kind=I4B), intent(in) :: m Return Value real(kind=SP),\n  DIMENSION(nl+nrr+1) interface public subroutine scrsho(func) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) interface public function select(k, arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k real(kind=SP), intent(inout), DIMENSION(:) :: arr Return Value real(kind=SP) interface public function select_bypack(k, arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k real(kind=SP), intent(inout), DIMENSION(:) :: arr Return Value real(kind=SP) interface public subroutine select_heap(arr, heap) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: arr real(kind=SP), intent(out), DIMENSION(:) :: heap interface public function select_inplace(k, arr) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: k real(kind=SP), intent(in), DIMENSION(:) :: arr Return Value real(kind=SP) interface public subroutine simplx(a, m1, m2, m3, icase, izrov, iposv) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a integer(kind=I4B), intent(in) :: m1 integer(kind=I4B), intent(in) :: m2 integer(kind=I4B), intent(in) :: m3 integer(kind=I4B), intent(out) :: icase integer(kind=I4B), intent(out), DIMENSION(:) :: izrov integer(kind=I4B), intent(out), DIMENSION(:) :: iposv interface public subroutine simpr(y, dydx, dfdx, dfdy, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(in), DIMENSION(:) :: dfdx real(kind=SP), intent(in), DIMENSION(:,:) :: dfdy real(kind=SP), intent(in) :: xs real(kind=SP), intent(in) :: htot integer(kind=I4B), intent(in) :: nstep real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine sinft(y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y interface public subroutine slvsm2(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(3,3) :: u real(kind=DP), intent(in), DIMENSION(3,3) :: rhs interface public subroutine slvsml(u, rhs) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out), DIMENSION(3,3) :: u real(kind=DP), intent(in), DIMENSION(3,3) :: rhs interface public subroutine sncndn(uu, emmc, sn, cn, dn) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: uu real(kind=SP), intent(in) :: emmc real(kind=SP), intent(out) :: sn real(kind=SP), intent(out) :: cn real(kind=SP), intent(out) :: dn interface public function snrm(sx, itol) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: sx integer(kind=I4B), intent(in) :: itol Return Value real(kind=DP) interface public subroutine sobseq(x, init) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: x integer(kind=I4B), intent(in), optional :: init interface public subroutine solvde(itmax, conv, slowc, scalv, indexv, nb, y) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: itmax real(kind=SP), intent(in) :: conv real(kind=SP), intent(in) :: slowc real(kind=SP), intent(in), DIMENSION(:) :: scalv integer(kind=I4B), intent(in), DIMENSION(:) :: indexv integer(kind=I4B), intent(in) :: nb real(kind=SP), intent(inout), DIMENSION(:,:) :: y interface public subroutine sor(a, b, c, d, e, f, u, rjac) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: a real(kind=DP), intent(in), DIMENSION(:,:) :: b real(kind=DP), intent(in), DIMENSION(:,:) :: c real(kind=DP), intent(in), DIMENSION(:,:) :: d real(kind=DP), intent(in), DIMENSION(:,:) :: e real(kind=DP), intent(in), DIMENSION(:,:) :: f real(kind=DP), intent(inout), DIMENSION(:,:) :: u real(kind=DP), intent(in) :: rjac interface public subroutine sort(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine sort2(arr, slave) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr real(kind=SP), intent(inout), DIMENSION(:) :: slave interface public subroutine sort3(arr, slave1, slave2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr real(kind=SP), intent(inout), DIMENSION(:) :: slave1 real(kind=SP), intent(inout), DIMENSION(:) :: slave2 interface public subroutine sort_bypack(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine sort_byreshape(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine sort_heap(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine sort_pick(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine sort_radix(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine sort_shell(arr) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: arr interface public subroutine spctrm(p, k, ovrlap, unit, n_window) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(out), DIMENSION(:) :: p integer(kind=I4B), intent(in) :: k logical(kind=LGT), intent(in) :: ovrlap integer(kind=I4B), intent(in), optional :: unit integer(kind=I4B), intent(in), optional :: n_window interface public subroutine spear(data1, data2, d, zd, probd, rs, probrs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: d real(kind=SP), intent(out) :: zd real(kind=SP), intent(out) :: probd real(kind=SP), intent(out) :: rs real(kind=SP), intent(out) :: probrs public interface sphbes public subroutine sphbes_s(n, x, sj, sy, sjp, syp) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: x real(kind=SP), intent(out) :: sj real(kind=SP), intent(out) :: sy real(kind=SP), intent(out) :: sjp real(kind=SP), intent(out) :: syp public subroutine sphbes_v(n, x, sj, sy, sjp, syp) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(out), DIMENSION(:) :: sj real(kind=SP), intent(out), DIMENSION(:) :: sy real(kind=SP), intent(out), DIMENSION(:) :: sjp real(kind=SP), intent(out), DIMENSION(:) :: syp interface public subroutine splie2(x1a, x2a, ya, y2a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1a real(kind=SP), intent(in), DIMENSION(:) :: x2a real(kind=SP), intent(in), DIMENSION(:,:) :: ya real(kind=SP), intent(out), DIMENSION(:,:) :: y2a interface public function splin2(x1a, x2a, ya, y2a, x1, x2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x1a real(kind=SP), intent(in), DIMENSION(:) :: x2a real(kind=SP), intent(in), DIMENSION(:,:) :: ya real(kind=SP), intent(in), DIMENSION(:,:) :: y2a real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 Return Value real(kind=SP) interface public subroutine spline(x, y, yp1, ypn, y2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in) :: yp1 real(kind=SP), intent(in) :: ypn real(kind=SP), intent(out), DIMENSION(:) :: y2 interface public function splint(xa, ya, y2a, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: xa real(kind=SP), intent(in), DIMENSION(:) :: ya real(kind=SP), intent(in), DIMENSION(:) :: y2a real(kind=SP), intent(in) :: x Return Value real(kind=SP) public interface sprsax public subroutine sprsax_dp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_dp), intent(in) :: sa real(kind=DP), intent(in), DIMENSION (:) :: x real(kind=DP), intent(out), DIMENSION (:) :: b public subroutine sprsax_sp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(in) :: sa real(kind=SP), intent(in), DIMENSION (:) :: x real(kind=SP), intent(out), DIMENSION (:) :: b public interface sprsdiag public subroutine sprsdiag_dp(sa, b) Arguments Type Intent Optional Attributes Name type(sprs2_dp), intent(in) :: sa real(kind=DP), intent(out), DIMENSION(:) :: b public subroutine sprsdiag_sp(sa, b) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(in) :: sa real(kind=SP), intent(out), DIMENSION(:) :: b public interface sprsin public subroutine sprsin_sp(a, thresh, sa) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: a real(kind=SP), intent(in) :: thresh type(sprs2_sp), intent(out) :: sa public subroutine sprsin_dp(a, thresh, sa) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: a real(kind=DP), intent(in) :: thresh type(sprs2_dp), intent(out) :: sa interface public subroutine sprstp(sa) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(inout) :: sa public interface sprstx public subroutine sprstx_dp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_dp), intent(in) :: sa real(kind=DP), intent(in), DIMENSION (:) :: x real(kind=DP), intent(out), DIMENSION (:) :: b public subroutine sprstx_sp(sa, x, b) Arguments Type Intent Optional Attributes Name type(sprs2_sp), intent(in) :: sa real(kind=SP), intent(in), DIMENSION (:) :: x real(kind=SP), intent(out), DIMENSION (:) :: b interface public subroutine stifbs(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine stiff(y, dydx, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: dydx real(kind=SP), intent(inout) :: x real(kind=SP), intent(in) :: htry real(kind=SP), intent(in) :: eps real(kind=SP), intent(in), DIMENSION(:) :: yscal real(kind=SP), intent(out) :: hdid real(kind=SP), intent(out) :: hnext subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx interface public subroutine stoerm(y, d2y, xs, htot, nstep, yout, derivs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: d2y real(kind=SP), intent(in) :: xs real(kind=SP), intent(in) :: htot integer(kind=I4B), intent(in) :: nstep real(kind=SP), intent(out), DIMENSION(:) :: yout subroutine derivs(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(out), DIMENSION(:) :: dydx public interface svbksb public subroutine svbksb_dp(u, w, v, b, x) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:,:) :: u real(kind=DP), intent(in), DIMENSION(:) :: w real(kind=DP), intent(in), DIMENSION(:,:) :: v real(kind=DP), intent(in), DIMENSION(:) :: b real(kind=DP), intent(out), DIMENSION(:) :: x public subroutine svbksb_sp(u, w, v, b, x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: u real(kind=SP), intent(in), DIMENSION(:) :: w real(kind=SP), intent(in), DIMENSION(:,:) :: v real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(out), DIMENSION(:) :: x public interface svdcmp public subroutine svdcmp_dp(a, w, v) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(inout), DIMENSION(:,:) :: a real(kind=DP), intent(out), DIMENSION(:) :: w real(kind=DP), intent(out), DIMENSION(:,:) :: v public subroutine svdcmp_sp(a, w, v) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(out), DIMENSION(:,:) :: v interface public subroutine svdfit(x, y, sig, a, v, w, chisq, funcs) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x real(kind=SP), intent(in), DIMENSION(:) :: y real(kind=SP), intent(in), DIMENSION(:) :: sig real(kind=SP), intent(out), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:,:) :: v real(kind=SP), intent(out), DIMENSION(:) :: w real(kind=SP), intent(out) :: chisq function funcs(x, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) interface public subroutine svdvar(v, w, cvm) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:,:) :: v real(kind=SP), intent(in), DIMENSION(:) :: w real(kind=SP), intent(out), DIMENSION(:,:) :: cvm interface public function toeplz(r, y) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(in), DIMENSION(:) :: y Return Value real(kind=SP),\n  DIMENSION(size(y)) interface public subroutine tptest(data1, data2, t, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: t real(kind=SP), intent(out) :: prob interface public subroutine tqli(d, e, z) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: d real(kind=SP), intent(inout), DIMENSION(:) :: e real(kind=SP), intent(inout), optional DIMENSION(:,:) :: z interface public subroutine trapzd(func, a, b, s, n) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: x Return Value real(kind=SP),\n  DIMENSION(size(x)) real(kind=SP), intent(in) :: a real(kind=SP), intent(in) :: b real(kind=SP), intent(inout) :: s integer(kind=I4B), intent(in) :: n interface public subroutine tred2(a, d, e, novectors) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:,:) :: a real(kind=SP), intent(out), DIMENSION(:) :: d real(kind=SP), intent(out), DIMENSION(:) :: e logical(kind=LGT), intent(in), optional :: novectors public interface tridag public subroutine tridag_par(a, b, c, r, u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(out), DIMENSION(:) :: u interface public subroutine tridag_ser(a, b, c, r, u) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b real(kind=SP), intent(in), DIMENSION(:) :: c real(kind=SP), intent(in), DIMENSION(:) :: r real(kind=SP), intent(out), DIMENSION(:) :: u interface public subroutine ttest(data1, data2, t, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: t real(kind=SP), intent(out) :: prob interface public subroutine tutest(data1, data2, t, prob) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 real(kind=SP), intent(out) :: t real(kind=SP), intent(out) :: prob interface public subroutine twofft(data1, data2, fft1, fft2) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: data1 real(kind=SP), intent(in), DIMENSION(:) :: data2 complex(kind=SPC), intent(out), DIMENSION(:) :: fft1 complex(kind=SPC), intent(out), DIMENSION(:) :: fft2 interface public function vander(x, q) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: x real(kind=DP), intent(in), DIMENSION(:) :: q Return Value real(kind=DP),\n  DIMENSION(size(x)) interface public subroutine vegas(region, func, init, ncall, itmx, nprn, tgral, sd, chi2a) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: region function func(pt, wgt) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: pt real(kind=SP), intent(in) :: wgt Return Value real(kind=SP) integer(kind=I4B), intent(in) :: init integer(kind=I4B), intent(in) :: ncall integer(kind=I4B), intent(in) :: itmx integer(kind=I4B), intent(in) :: nprn real(kind=SP), intent(out) :: tgral real(kind=SP), intent(out) :: sd real(kind=SP), intent(out) :: chi2a interface public subroutine voltra(t0, h, t, f, g, ak) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: t0 real(kind=SP), intent(in) :: h real(kind=SP), intent(out), DIMENSION(:) :: t real(kind=SP), intent(out), DIMENSION(:,:) :: f function g(t) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: t Return Value real(kind=SP),\n  DIMENSION(:), POINTER function ak(t, s) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: t real(kind=SP), intent(in) :: s Return Value real(kind=SP),\n  DIMENSION(:,:), POINTER interface public subroutine wt1(a, isign, wtstep) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign subroutine wtstep(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign interface public subroutine wtn(a, nn, isign, wtstep) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: nn integer(kind=I4B), intent(in) :: isign subroutine wtstep(a, isign) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(inout), DIMENSION(:) :: a integer(kind=I4B), intent(in) :: isign interface public function wwghts(n, h, kermom) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n real(kind=SP), intent(in) :: h function kermom(y, m) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: y integer(kind=I4B), intent(in) :: m Return Value real(kind=DP),\n  DIMENSION(m) Return Value real(kind=SP),\n  DIMENSION(n) interface public subroutine zbrac(func, x1, x2, succes) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(inout) :: x1 real(kind=SP), intent(inout) :: x2 logical(kind=LGT), intent(out) :: succes interface public subroutine zbrak(func, x1, x2, n, xb1, xb2, nb) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 integer(kind=I4B), intent(in) :: n real(kind=SP), DIMENSION(:), POINTER :: xb1 real(kind=SP), DIMENSION(:), POINTER :: xb2 integer(kind=I4B), intent(out) :: nb interface public function zbrent(func, x1, x2, tol) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: tol Return Value real(kind=SP) interface public subroutine zrhqr(a, rtr, rti) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(out), DIMENSION(:) :: rtr real(kind=SP), intent(out), DIMENSION(:) :: rti interface public function zriddr(func, x1, x2, xacc) Arguments Type Intent Optional Attributes Name function func(x) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x Return Value real(kind=SP) real(kind=SP), intent(in) :: x1 real(kind=SP), intent(in) :: x2 real(kind=SP), intent(in) :: xacc Return Value real(kind=SP) interface public subroutine zroots(a, roots, polish) Arguments Type Intent Optional Attributes Name complex(kind=SPC), intent(in), DIMENSION(:) :: a complex(kind=SPC), intent(out), DIMENSION(:) :: roots logical(kind=LGT), intent(in) :: polish","tags":"","loc":"module/nr.html"},{"title":"special_functions – KORC-Full Orbit","text":"@brief Module with calls to subroutines for calculating various special functions.\n @details All the subroutines in this module were taken from the free software available as part of the book Numerical Recipes.\n For details we refer the user to \"FORTRAN Numerical Recipes: Numerical recipes in FORTRAN 90\". Contents Subroutines bessik Subroutines public subroutine bessik (x, xnu, ri, rk, rip, rkp) @brief Subroutine taken from \"Numerical Recipes\" that calculates the modified Bessel function of Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: x real(kind=SP), intent(in) :: xnu real(kind=SP), intent(out) :: ri real(kind=SP), intent(out) :: rk real(kind=SP), intent(out) :: rip real(kind=SP), intent(out) :: rkp","tags":"","loc":"module/special_functions.html"},{"title":"korc_random – KORC-Full Orbit","text":"$OMP PARALLEL PRIVATE(thread_num) $OMP END PARALLEL Uses iso_c_binding korc_types Contents Variables states state Interfaces random_construct_U random_construct_N random_get_number_U random_get_number_N random_destroy_U random_destroy_N Functions get_random get_random_U get_random_N Subroutines initialize_random initialize_random_U initialize_random_N Variables Type Visibility Attributes Name Initial type(C_PTR), private, DIMENSION(:), ALLOCATABLE :: states type(C_PTR), private :: state Interfaces interface public function random_construct_U(seed) bind(C, NAME='random_construct_U') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), VALUE :: seed Return Value type(C_PTR) interface public function random_construct_N(seed) bind(C, NAME='random_construct_N') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), VALUE :: seed Return Value type(C_PTR) interface public function random_get_number_U(r) bind(C, NAME='random_get_number_U') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r Return Value real(kind=C_DOUBLE) interface public function random_get_number_N(r) bind(C, NAME='random_get_number_N') Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r Return Value real(kind=C_DOUBLE) interface public subroutine random_destroy_U(r) bind(C, NAME=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r interface public subroutine random_destroy_N(r) bind(C, NAME=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: r Functions public function get_random () Arguments None Return Value real(kind=rp) public function get_random_U () Arguments None Return Value real(kind=rp) public function get_random_N () Arguments None Return Value real(kind=rp) Subroutines public subroutine initialize_random (seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed public subroutine initialize_random_U (seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed public subroutine initialize_random_N (seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: seed","tags":"","loc":"module/korc_random.html"},{"title":"korc_profiles – KORC-Full Orbit","text":"Note Module that contain subroutines for calculating analytical plasma \n profiles and calls to subroutines for interpolating external plasma \n profiles to the particles positions. Uses korc_types korc_hpc korc_coords korc_interp korc_HDF5 korc_input Contents Subroutines initialize_profiles uniform_profiles analytical_profiles_p get_analytical_profiles get_profiles load_profiles_data_from_hdf5 ALLOCATE_2D_PROFILES_ARRAYS ALLOCATE_3D_PROFILES_ARRAYS Subroutines public subroutine initialize_profiles (params, P, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PROFILES), intent(out) :: P An instance of KORC's derived type PROFILES containing all \n the information about the plasma profiles used in the\n simulation. See korc_types and korc_profiles . type(FIELDS), intent(in) :: F String containing the type of electron density profile \n to be used in the simulation. Read more… private subroutine uniform_profiles (vars, P) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars An instance of PARTICLES containing the variables of a given species. type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the information\n about the plasma profiles used in the simulation. See korc_types and korc_profiles . public subroutine analytical_profiles_p (time, params, Y_R, Y_Z, P, F, ne, Te, Zeff, PSIp) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: time type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . type(FIELDS), intent(in) :: F real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne Background electron density seen by simulated particles. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: Te Backgroun temperature density seen by simulated particles. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: Zeff Effective atomic charge seen by simulated particles. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp private subroutine get_analytical_profiles (P, Y, ne, Te, Zeff, flag) Read more… Arguments Type Intent Optional Attributes Name type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in toroidal coordinates; Y(1,:) = , Y(2,:)\n = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: ne Background electron density seen by simulated particles. real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Te Backgroun temperature density seen by simulated particles. real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Zeff Effective atomic charge seen by simulated particles. integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed\n (flag=T) or not (flag=F). public subroutine get_profiles (params, vars, P, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: vars An instance of PARTICLES containing the variables of a given species. type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all\n the information about the plasma profiles used in the\n simulation. See [[korc_types] and korc_profiles . type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. private subroutine load_profiles_data_from_hdf5 (params, P) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PROFILES), intent(inout) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the\n simulation. See korc_types and korc_profiles . private subroutine ALLOCATE_2D_PROFILES_ARRAYS (P) @brief Subroutine that allocates the mesh information and 2-D arrays for keeping the data of pre-computed plasma profiles. Read more… Arguments Type Intent Optional Attributes Name type(PROFILES), intent(inout) :: P private subroutine ALLOCATE_3D_PROFILES_ARRAYS (P) Read more… Arguments Type Intent Optional Attributes Name type(PROFILES), intent(inout) :: P @param[out] P An instance of KORC's derived type PROFILES containing\n all the information about the plasma profiles used in the\n simulation. See korc_types and korc_profiles .","tags":"","loc":"module/korc_profiles.html"},{"title":"korc_spatial_distribution – KORC-Full Orbit","text":"Note Module with subroutines for generating the initial spatial distribution \n of the different partciles' species in the simulation. Uses korc_types korc_constants korc_HDF5 korc_hpc korc_fields korc_profiles korc_rnd_numbers korc_random korc_hammersley_generator korc_avalanche korc_experimental_pdf Contents Variables minmax_buffer_size Functions fzero PSI_ROT indicator random_norm Spong_2D Subroutines uniform disk torus elliptic_torus exponential_torus exponential_elliptic_torus gaussian_elliptic_torus MH_gaussian_elliptic_torus gaussian_torus Spong_3D MH_psi intitial_spatial_distribution Variables Type Visibility Attributes Name Initial real(kind=rp), private, parameter :: minmax_buffer_size = 10.0_rp Functions private function fzero (r, a, ko, P) result(f) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: r real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: ko real(kind=rp), intent(in) :: P Return Value real(kind=rp) private function PSI_ROT (R, R0, sigR, Z, Z0, sigZ, theta) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R R-coordinate of MH sampled location real(kind=rp), intent(in) :: R0 R-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigR Variance of first dimension of 2D Gaussian real(kind=rp), intent(in) :: Z Z-coordinate of MH sampled location real(kind=rp), intent(in) :: Z0 Z-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigZ Variance of second dimension of 2D Gaussian real(kind=rp), intent(in) :: theta Angle of counter-clockwise rotation (in radians), of 2D Gaussian\n distribution relative to R,Z Return Value real(kind=rp) Argument of exponential comprising 2D Gaussian distribution private function indicator (psi, psi_max) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: psi real(kind=rp), intent(in) :: psi_max Return Value real(kind=rp) public function random_norm (mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) private function Spong_2D (R0, b, w, dlam, R, Z, T) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: b real(kind=rp), intent(in) :: w real(kind=rp), intent(in) :: dlam real(kind=rp), intent(in) :: R real(kind=rp), intent(in) :: Z real(kind=rp), intent(in) :: T Return Value real(kind=rp) Subroutines private subroutine uniform (spp) Read more… Arguments Type Intent Optional Attributes Name type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the \n parameters and simulation variables of the different\nspecies in the simulation. private subroutine disk (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all \n the parameters and simulation variables of the different \n species in the simulation. private subroutine torus (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES \n containing all the parameters and simulation variables of the \n different species in the simulation. private subroutine elliptic_torus (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters \n and simulation variables of the different species in the simulation. private subroutine exponential_torus (params, spp) @brief Subroutine that generates a exponentially decaying radial distribution of particles in a circular cross-section torus of\n major and minor radi and , respectively.\n @details We generate this exponentially decaying radial distribution following the same approach as in\n \\ref korc_spatial_distribution.disk, but this time, the radial distribution is given by: Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp private subroutine exponential_elliptic_torus (params, spp) @brief Subroutine that generates an exponentially decaying radial distribution in an elliptic torus as the initial spatial\n condition of a given particle species in the simulation.\n @details As a first step, we generate an exponentially decaying radial distribution in a circular cross-section torus as in\n \\ref korc_spatial_distribution.exponential_torus. Then we transform this spatial distribution to a one in an torus with an\n elliptic cross section, this following the same approach as in \\ref korc_spatial_distribution.elliptic_torus. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp private subroutine gaussian_elliptic_torus (params, spp) @brief Subroutine that generates a Gaussian radial distribution in an elliptic torus as the initial spatial\n condition of a given particle species in the simulation.\n @details As a first step, we generate an Gaussian radial distribution in a circular cross-section torus as in\n \\ref korc_spatial_distribution.gaussian_torus. Then we transform this spatial distribution to a one in an torus with an\n elliptic cross section, this following the same approach as in \\ref korc_spatial_distribution.elliptic_torus. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp private subroutine MH_gaussian_elliptic_torus (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. private subroutine gaussian_torus (params, spp) @brief Subroutine that generates a Gaussian radial distribution of particles in a circular cross-section torus of\n major and minor radi and , respectively.\n @details We generate this exponentially decaying radial distribution following the same approach as in\n \\ref korc_spatial_distribution.disk, but this time, the radial distribution is given by: Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp private subroutine Spong_3D (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. Read more… private subroutine MH_psi (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. public subroutine intitial_spatial_distribution (params, spp, P, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters and \n simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS.","tags":"","loc":"module/korc_spatial_distribution.html"},{"title":"korc_velocity_distribution – KORC-Full Orbit","text":"Note Module containing subroutines to initialize the velocity \n distribution of the simulated particles. Uses korc_types korc_constants korc_HDF5 korc_hpc korc_fields korc_rnd_numbers korc_hammersley_generator korc_avalanche korc_experimental_pdf korc_energy_pdfs korc_simple_equilibrium_pdf Contents Functions fth_3V random_norm Subroutines thermal_distribution initial_energy_pitch_dist gyro_distribution initial_gyro_distribution Functions private function fth_3V (Vth, V) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: Vth Thermal velocity of the background electrons . real(kind=rp), intent(in), DIMENSION(3) :: V Velocity of the sampled electron . Return Value real(kind=rp) Value of . private function random_norm (mu, sigma) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mu Mean value of the Gaussian distribution. real(kind=rp), intent(in) :: sigma Standard deviation of the Gaussian distribution. Return Value real(kind=rp) Sampled number from the Gaussian distribution . Subroutines public subroutine thermal_distribution (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the\n parameters and simulation variables of the different species\n in the simulation. public subroutine initial_energy_pitch_dist (params, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters and \n simulation variables of the different species in the simulation. private subroutine gyro_distribution (params, F, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. This structure \n has the information of the magnetic field. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the\n parameters and \n simulation variables of the different species in the simulation. public subroutine initial_gyro_distribution (params, F, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. This structure has \n the information of the magnetic field. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters \n and simulation variables of the different species in the simulation.","tags":"","loc":"module/korc_velocity_distribution.html"},{"title":"korc_hammersley_generator – KORC-Full Orbit","text":"@brief Module containing subroutines for generating 1-D and 2-D Hammersley quasi-Monte Carlo sequences.\n @details The algorithm and code for generating the 1-D Hammersley sequence was developed by John Burkardt at the Florida State University.\n Visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\" for more information.\n The algorithm and code for generating the 2-D Hammersley sequence was developed by L. Carbajal at the Oak Ridge National Lab. Uses korc_types Contents Functions prime Subroutines generate_2D_hammersley_sequence hammersley hammersley_inverse hammersley_sequence r8mat_print r8mat_print_some timestamp Functions private function prime (n) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name integer(kind=4) :: n Return Value integer(kind=4) Subroutines public subroutine generate_2D_hammersley_sequence (ID, NMPIS, X, Y) @brief Subroutine for generating a 2-D Hammersley sequence.\n @details This subroutine uses the algorithm for generating a 1-D Hammersley sequence.\n Each MPI process in KORC generates a (different) subset of pairs (X,Y) of a 2-D Hammersley sequence. The total number of pairs (X,Y)\n is NMPIS*N, where NMPIS is the number of MPI processes in the simulation and N is the number of particles followed by each MPI process.\n Each subset of pairs (X,Y) has N elements. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ID integer, intent(in) :: NMPIS real(kind=rp), intent(inout), DIMENSION(:) :: X real(kind=rp), intent(inout), DIMENSION(:) :: Y public subroutine hammersley (i, m, n, r) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name integer(kind=4) :: i integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: r (m) private subroutine hammersley_inverse (r, m, n, i) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". Read more… Arguments Type Intent Optional Attributes Name real(kind=8) :: r (m) integer(kind=4) :: m integer(kind=4) :: n integer(kind=4) :: i private subroutine hammersley_sequence (i1, i2, m, n, r) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name integer(kind=4) :: i1 integer(kind=4) :: i2 integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: r (m,abs(i1-i2)+1) private subroutine r8mat_print (m, n, a, title) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title private subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title private subroutine timestamp () @brief For more info please visit \"https://people.sc.fsu.edu/~jburkardt/f_src/hammersley/hammersley.html\". * * * * * * * * * * * *80 Read more… Arguments None","tags":"","loc":"module/korc_hammersley_generator.html"},{"title":"korc_energy_pdfs – KORC-Full Orbit","text":"@brief Module that contains subroutines and functions to sample various energy distributions. Uses korc_types korc_constants korc_HDF5 korc_hpc korc_input Contents Variables gamma_pdf_params co minmax_buffer_size Derived Types GAMMA_PARAMS Functions deg2rad fGamma fRE random_norm Subroutines get_gamma_distribution initialize_gamma_params sample_gamma_distribution save_gamma_params Variables Type Visibility Attributes Name Initial type( GAMMA_PARAMS ), private :: gamma_pdf_params real(kind=rp), private, parameter :: co = (C_E*1.0E6)/(C_ME*C_C**2) @f$f_\\Gamma(\\mathcal{E},\\kappa,\\theta)@f$ from MeV to Joules. real(kind=rp), private, parameter :: minmax_buffer_size = 10.0_rp using a Metropolis-Hastings method to sample a distribution. Derived Types type, private :: GAMMA_PARAMS @brief KORC derived type that contains information about a given Gamma distribution function @f$f_\\Gamma(x,\\kappa,\\theta)@f$.\n @details We write a given Gamma distribution function in terms of its shape factor @f$\\kappa@f$ and scale factor\n @f$\\theta@f$, so that: Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public :: min_energy real(kind=rp), public :: max_energy real(kind=rp), public :: min_p real(kind=rp), public :: max_p real(kind=rp), public :: k real(kind=rp), public :: t Functions private function deg2rad (x) @brief Function that converts @f$x@f$ from degrees to radians. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function fGamma (x, k, t) @brief Function that calculates the value of the Gamma distribution @f$f_\\Gamma(x,\\kappa,\\theta) =\n \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: k real(kind=rp), intent(in) :: t Return Value real(kind=rp) private function fRE (p) Evaluation of the energy distribution function @f$f_{RE}(\\mathcal{E})@f$ of runaway electrons as function of the normalized momentum\n @f$p' = p/m_ec@f$. Here, @f$p'@f$ is the normalized momentum and @f$m_e@f$ and @f$c@f$ are the electron mass and the speed of light. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: p Return Value real(kind=rp) private function random_norm (mean, sigma) @brief Gaussian random number generator.\n @details This function returns a deviate of a Gaussian distribution @f$f_G(x;\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp{\\left( -(x-\\mu)&#94;2/2\\sigma&#94;2 \\right)}@f$,\n with mean @f$\\mu@f$, and standard deviation @f$\\sigma@f$. Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Subroutines public subroutine get_gamma_distribution (params, g, go) @brief Subroutine that contains calls to subroutine to generate a gamma distribution for the energy distribution of a given\n species in the simulation. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(out) :: go private subroutine initialize_gamma_params (params) @brief Subroutine that reads from the input file the parameters of the Gamma distribution\n @f$f_\\Gamma(x,\\kappa,\\theta) = \\frac{1}{\\Gamma(\\kappa) \\theta&#94;\\kappa}x&#94;{\\kappa-1}\\exp{\\left(-x/\\theta\\right)}@f$. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine sample_gamma_distribution (params, g, go) @brief Subroutine that samples a Gamma distribution representing the runaways' (marginal) energy distribution function.\n @details This subroutine uses the Metropolis-Hastings method for sampling the Gamma distribution representing the runaways'\n (marginal) energy distribution function. Unlike the typical Metropolis-Hasting method, after setting the boundaries of the region\n we want to sample, we perform a sampling in a larger region that contains the original sampling area plus a buffer region.\n After finishing the first sampling, we only keep the particles in the original sampling region, the particles in the p_buffer\n are sampled again until all of them lie within the original sampling region. This method ensures that the boundaries are\n well sampled. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(out) :: go private subroutine save_gamma_params (params) @brief Surboutine that saves the Gamma distribution parameters to the HDF5 file gamma_distribution_parameters.h5 . Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params","tags":"","loc":"module/korc_energy_pdfs.html"},{"title":"korc_ppusher – KORC-Full Orbit","text":"Note Module with subroutines for advancing the particles' position and\n velocity in the simulations. Uses korc_types korc_constants korc_fields korc_profiles korc_interp korc_collisions korc_hpc Contents Variables E0 Functions cross deg2rad rad2deg Subroutines initialize_particle_pusher radiation_force_p FO_init adv_FOeqn_top advance_FOeqn_vars advance_FP3Deqn_vars adv_FOm3dc1_top adv_FOinterp_top advance_FOinterp_vars advance_FOm3dc1_vars advance_FP3Dinterp_vars GC_init adv_GCeqn_top advance_GCeqn_vars advance_FPeqn_vars adv_GCinterp_psi_top_FS adv_GCinterp_psi_top adv_GCinterp_m3dc1_top adv_GCinterp_psiwE_top adv_GCinterp_psi2x1t_top adv_GCinterp_B_top adv_GCinterp_B2D_top adv_GCinterp_2DBdB_top adv_GCinterp_3DBdB1_top adv_GCinterp_3DBdB_top advance_GCinterp_psi_vars_FS advance_GCinterp_psi_vars advance_GCinterp_m3dc1_vars advance_GCinterp_psiwE_vars advance_GCinterp_psi2x1t_vars advance_GCinterp_B2D_vars advance_GCinterp_2DBdB_vars advance_GCinterp_3DBdB_vars advance_GCinterp_3DBdB1_vars advance_GCinterp_B_vars advance_FPinterp_vars GCEoM_p GCEoM1_p GCEoM1_m3dc1_p aux_fields Variables Type Visibility Attributes Name Initial real(kind=rp), private :: E0 Dimensionless vacuum permittivity , see korc_units . Functions private pure function cross (a, b) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: a Vector . real(kind=rp), intent(in), DIMENSION(3) :: b Vector . Return Value real(kind=rp),\n  DIMENSION(3) Value of public function deg2rad (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) public function rad2deg (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) Subroutines public subroutine initialize_particle_pusher (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. private subroutine radiation_force_p (pchunk, q_cache, m_cache, U_X, U_Y, U_Z, E_X, E_Y, E_Z, B_X, B_Y, B_Z, Frad_X, Frad_Y, Frad_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(pchunk) :: U_X , where is the\n particle's velocity. real(kind=rp), intent(in), DIMENSION(pchunk) :: U_Y , where is the\n particle's velocity. real(kind=rp), intent(in), DIMENSION(pchunk) :: U_Z , where is the\n particle's velocity. real(kind=rp), intent(in), DIMENSION(pchunk) :: E_X Electric field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: E_Y Electric field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: E_Z Electric field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: B_X Magnetic field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: B_Y Magnetic field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(in), DIMENSION(pchunk) :: B_Z Magnetic field seen by each particle. This is given\n in Cartesian coordinates. real(kind=rp), intent(out), DIMENSION(pchunk) :: Frad_X The calculated synchrotron radiation reaction force . real(kind=rp), intent(out), DIMENSION(pchunk) :: Frad_Y The calculated synchrotron radiation reaction force . real(kind=rp), intent(out), DIMENSION(pchunk) :: Frad_Z The calculated synchrotron radiation reaction force . public subroutine FO_init (params, F, spp, output, step) Calls get_fields in korc_fields . Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. logical, intent(in) :: output logical, intent(in) :: step public subroutine adv_FOeqn_top (params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. public subroutine advance_FOeqn_vars (tt, a, q_cache, m_cache, params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, P, F, g, flagCon, flagCol, PSIp) Calls radiation_force in korc_ppusher . Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: a This variable is used to simplify notation in the code, and\n is given by , real(kind=rp), intent(in) :: q_cache Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: m_cache Time step used in the leapfrog step ( ). type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp public subroutine advance_FP3Deqn_vars (params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, g, m_cache, B0, lam, R0, q0, EF0, B_X, B_Y, B_Z, E_X, E_Y, E_Z, P, F, flagCon, flagCol, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in) :: B0 real(kind=rp), intent(in) :: lam real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: q0 real(kind=rp), intent(in) :: EF0 real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp public subroutine adv_FOm3dc1_top (params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. public subroutine adv_FOinterp_top (params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. public subroutine advance_FOinterp_vars (tt, a, q_cache, m_cache, params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, g, flagCon, flagCol, P, F, PSIp) Calls radiation_force in korc_ppusher . Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: a This variable is used to simplify notation in the code, and\n is given by , real(kind=rp), intent(in) :: q_cache Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: m_cache Time step used in the leapfrog step ( ). type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp public subroutine advance_FOm3dc1_vars (tt, a, q_cache, m_cache, params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, g, flagCon, flagCol, P, F, PSIp) Calls radiation_force in korc_ppusher . Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: a This variable is used to simplify notation in the code, and\n is given by , real(kind=rp), intent(in) :: q_cache Time step used in the leapfrog step ( ). real(kind=rp), intent(in) :: m_cache Time step used in the leapfrog step ( ). type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp public subroutine advance_FP3Dinterp_vars (params, X_X, X_Y, X_Z, V_X, V_Y, V_Z, g, m_cache, B_X, B_Y, B_Z, E_X, E_Y, E_Z, flagCon, flagCol, P, F, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: X_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: g real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp public subroutine GC_init (params, F, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. public subroutine adv_GCeqn_top (params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. public subroutine advance_GCeqn_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, flagCon, flagCol, q_cache, m_cache, B_R, B_PHI, B_Z, F, P, PSIp, E_PHI) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU integer(kind=is), intent(inout), dimension(params%pchunk) :: flagCon integer(kind=is), intent(inout), dimension(params%pchunk) :: flagCol real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z type(FIELDS), intent(in) :: F An instance of the KORC derived type PROFILES. type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI public subroutine advance_FPeqn_vars (params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, flagCon, flagCol, m_cache, F, P, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol real(kind=rp), intent(in) :: m_cache type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp public subroutine adv_GCinterp_psi_top_FS (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F public subroutine adv_GCinterp_psi_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F public subroutine adv_GCinterp_m3dc1_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F public subroutine adv_GCinterp_psiwE_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F public subroutine adv_GCinterp_psi2x1t_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(inout) :: F public subroutine adv_GCinterp_B_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F public subroutine adv_GCinterp_B2D_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F public subroutine adv_GCinterp_2DBdB_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F public subroutine adv_GCinterp_3DBdB1_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F public subroutine adv_GCinterp_3DBdB_top (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F public subroutine advance_GCinterp_psi_vars_FS (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z public subroutine advance_GCinterp_psi_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne public subroutine advance_GCinterp_m3dc1_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne, Te, hint) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Te type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint public subroutine advance_GCinterp_psiwE_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne public subroutine advance_GCinterp_psi2x1t_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, PSIp, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, ne) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne public subroutine advance_GCinterp_B2D_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp public subroutine advance_GCinterp_2DBdB_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp public subroutine advance_GCinterp_3DBdB_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp public subroutine advance_GCinterp_3DBdB1_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: PSIp public subroutine advance_GCinterp_B_vars (vars, pp, tt, params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, q_cache, m_cache, flagCon, flagCol, F, P, B_R, B_PHI, B_Z, E_PHI, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars integer, intent(in) :: pp integer(kind=ip), intent(in) :: tt time iterator. type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp public subroutine advance_FPinterp_vars (params, Y_R, Y_PHI, Y_Z, V_PLL, V_MU, m_cache, flagCon, flagCol, F, P, E_PHI, ne, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCon integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flagCol type(FIELDS), intent(in) :: F type(PROFILES), intent(in) :: P real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp private subroutine GCEoM_p (params, RHS_R, RHS_PHI, RHS_Z, RHS_PLL, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, V_PLL, V_MU, Y_R, q_cache, m_cache) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache private subroutine GCEoM1_p (tt, P, F, params, RHS_R, RHS_PHI, RHS_Z, RHS_PLL, RHS_MU, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, V_PLL, V_MU, Y_R, Y_Z, q_cache, m_cache, PSIp, ne) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PLL real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne public subroutine GCEoM1_m3dc1_p (tt, P, F, params, RHS_R, RHS_PHI, RHS_Z, RHS_PLL, RHS_MU, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, V_PLL, V_MU, Y_R, Y_PHI, Y_Z, q_cache, m_cache, PSIp, ne, Te, flag, hint) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: tt type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_PLL real(kind=rp), intent(out), DIMENSION(params%pchunk) :: RHS_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: E_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: curlb_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_PLL real(kind=rp), intent(in), DIMENSION(params%pchunk) :: V_MU real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(in) :: q_cache real(kind=rp), intent(in) :: m_cache real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(out), DIMENSION(params%pchunk) :: ne real(kind=rp), intent(out), DIMENSION(params%pchunk) :: Te integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint private subroutine aux_fields (pp, spp, gradB, curlb, Bmag) Arguments Type Intent Optional Attributes Name integer :: pp type(SPECIES), intent(in) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. real(kind=rp), intent(inout), DIMENSION(3) :: gradB real(kind=rp), intent(inout), DIMENSION(3) :: curlb real(kind=rp), intent(in) :: Bmag","tags":"","loc":"module/korc_ppusher.html"},{"title":"korc_interp – KORC-Full Orbit","text":"Note Module containing functions and subroutines for performing \n interpolations using the PSPLINE library. For a detailed documentation of the PSPLINE library we refer the \n user to \"https://w3.pppl.gov/ntcc/PSPLINE/\". Note FIXME Add documentation\n  @note FIXME Add documentation Uses korc_types korc_coords korc_rnd_numbers korc_hpc EZspline_obj EZspline korc_m3d_c1 Contents Variables bfield_2d bfield_3d bfield_2X1T dbdR_2d dbdPHI_2d dbdZ_2d dbdR_3d dbdPHI_3d dbdZ_3d efield_2d efield_3d efield_SC1d gradB_2d curlb_2d gradB_3d curlb_3d fields_domain profiles_2d profiles_3d profiles_domain ezerr Derived Types KORC_3D_FIELDS_INTERPOLANT KORC_2X1T_FIELDS_INTERPOLANT KORC_2D_FIELDS_INTERPOLANT KORC_1D_FIELDS_INTERPOLANT KORC_3D_PROFILES_INTERPOLANT KORC_2D_PROFILES_INTERPOLANT KORC_3D_FIELDS_INTERPOLANT KORC_2X1T_FIELDS_INTERPOLANT KORC_2D_FIELDS_INTERPOLANT KORC_1D_FIELDS_INTERPOLANT KORC_3D_PROFILES_INTERPOLANT KORC_2D_PROFILES_INTERPOLANT KORC_INTERPOLANT_DOMAIN Subroutines initialize_fields_interpolant initialize_SC1D_field_interpolant initialize_SC1D_field_interpolant_FS check_if_in_fields_domain check_if_in_fields_domain_p initialize_profiles_interpolant check_if_in_profiles_domain check_if_in_profiles_domain_p interp_2D_bfields gradient_2D_Bfields interp_2D_gradBfields interp_2D_curlbfields interp_FOfields_p interp_FOfields1_p interp_FOcollision_p interp_fields_p interp_fields_3D_p interp_collision_p interp_bmag_p interp_3D_bfields calculate_magnetic_field calculate_magnetic_field_p calculate_2DBdBfields_p calculate_3DBdBfields_p calculate_3DBdBfields1_p calculate_GCfieldswE_p calculate_GCfields_p calculate_GCfields_2x1t_p calculate_GCfields_p_FS add_interp_SCE_p add_interp_SCE_p_FS calculate_initial_magnetic_field sample_poloidal_flux interp_2D_efields interp_3D_efields interp_fields interp_2D_profiles interp_3D_profiles interp_profiles finalize_interpolants get_m3d_c1_magnetic_fields get_m3d_c1_FOmagnetic_fields_p get_m3d_c1_GCmagnetic_fields_p get_m3d_c1_vector_potential get_m3d_c1_vector_potential_p get_m3d_c1_electric_fields get_m3d_c1_FOelectric_fields_p get_m3d_c1_GCelectric_fields_p get_m3d_c1_profile get_m3d_c1_profile_p Variables Type Visibility Attributes Name Initial type( KORC_2D_FIELDS_INTERPOLANT ), private :: bfield_2d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_3D_FIELDS_INTERPOLANT ), private :: bfield_3d An instance of KORC_3D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_2X1T_FIELDS_INTERPOLANT ), private :: bfield_2X1T type( KORC_2D_FIELDS_INTERPOLANT ), private :: dbdR_2d type( KORC_2D_FIELDS_INTERPOLANT ), private :: dbdPHI_2d type( KORC_2D_FIELDS_INTERPOLANT ), private :: dbdZ_2d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_3D_FIELDS_INTERPOLANT ), private :: dbdR_3d type( KORC_3D_FIELDS_INTERPOLANT ), private :: dbdPHI_3d type( KORC_3D_FIELDS_INTERPOLANT ), private :: dbdZ_3d An instance of KORC_3D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_2D_FIELDS_INTERPOLANT ), private :: efield_2d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the electric field. type( KORC_3D_FIELDS_INTERPOLANT ), private :: efield_3d An instance of KORC_3D_FIELDS_INTERPOLANT for interpolating\n the electric field. type( KORC_1D_FIELDS_INTERPOLANT ), private :: efield_SC1d An instance of KORC_1D_FIELDS_INTERPOLANT for interpolating\n the self-consistent electric field. type( KORC_2D_FIELDS_INTERPOLANT ), private :: gradB_2d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_2D_FIELDS_INTERPOLANT ), private :: curlb_2d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_3D_FIELDS_INTERPOLANT ), private :: gradB_3d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_3D_FIELDS_INTERPOLANT ), private :: curlb_3d An instance of KORC_2D_FIELDS_INTERPOLANT for interpolating\n the magnetic field. type( KORC_INTERPOLANT_DOMAIN ), private :: fields_domain An instance of KORC_INTERPOLANT_DOMAIN used for interpolating fields. type( KORC_2D_PROFILES_INTERPOLANT ), private :: profiles_2d An instance of KORC_2D_PROFILES_INTERPOLANT for interpolating plasma\n profiles. type( KORC_3D_PROFILES_INTERPOLANT ), private :: profiles_3d An instance of KORC_3D_PROFILES_INTERPOLANT for interpolating plasma\n profiles. type( KORC_INTERPOLANT_DOMAIN ), private :: profiles_domain An instance of KORC_INTERPOLANT_DOMAIN used for interpolating plasma\n profiles. integer, public :: ezerr Error status during PSPLINE interpolations. Derived Types type, private :: KORC_3D_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline3_r8), public :: A Interpolant of a scalar field . type(EZspline3_r8), public :: R Interpolant of . type(EZspline3_r8), public :: PHI Interpolant of . type(EZspline3_r8), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. type, private :: KORC_2X1T_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline3_r8), public :: A Interpolant of a scalar field . type(EZspline3_r8), public :: R Interpolant of . type(EZspline3_r8), public :: T Interpolant of . type(EZspline3_r8), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NT Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCST = (/0, 0/) Periodic boundary condition for the interpolants at both \n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both \n ends of the direction. type, private :: KORC_2D_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline2_r8), public :: A Interpolant of a scalar field . type(EZspline2_r8), public :: R Interpolant of . type(EZspline2_r8), public :: PHI Interpolant of . type(EZspline2_r8), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. type, private :: KORC_1D_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline1_r8), public :: A Interpolant of a scalar field . type(EZspline1_r8), public :: R Interpolant of . type(EZspline1_r8), public :: PHI Interpolant of . type(EZspline1_r8), public :: Z Interpolant of . integer, public :: Nrm Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSrm = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. integer, public :: NPSIP Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSPSIP = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. type, private :: KORC_3D_PROFILES_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline3_r8), public :: ne Interpolant of background electron density . type(EZspline3_r8), public :: Te Interpolant of background electron temperature . type(EZspline3_r8), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. type, private :: KORC_2D_PROFILES_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline2_r8), public :: ne Interpolant of background electron density . type(EZspline2_r8), public :: Te Interpolant of background electron temperature . type(EZspline2_r8), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. type, private :: KORC_3D_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline3_r4), public :: R Interpolant of . type(EZspline3_r4), public :: PHI Interpolant of . type(EZspline3_r4), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends of\n the direction. type, private :: KORC_2X1T_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline3_r4), public :: R Interpolant of . type(EZspline3_r4), public :: T Interpolant of . type(EZspline3_r4), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NT Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCST = (/0, 0/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends of\n the direction. type, private :: KORC_2D_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline2_r4), public :: A Interpolant of a scalar field . type(EZspline2_r4), public :: R Interpolant of . type(EZspline2_r4), public :: PHI Interpolant of . type(EZspline2_r4), public :: Z Interpolant of . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. type, private :: KORC_1D_FIELDS_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline1_r4), public :: A Interpolant of a scalar field . type(EZspline1_r4), public :: R Interpolant of . type(EZspline1_r4), public :: PHI Interpolant of . type(EZspline1_r4), public :: Z Interpolant of . integer, public :: Nrm Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSrm = (/0, 0/) Not-a-knot boundary condition for the interpolants at both\n ends of the direction. type, private :: KORC_3D_PROFILES_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline3_r4), public :: ne Interpolant of background electron density . type(EZspline3_r4), public :: Te Interpolant of background electron temperature . type(EZspline3_r4), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NPHI Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSPHI = (/-1, -1/) Periodic boundary condition for the interpolants at both ends of\n the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. type, private :: KORC_2D_PROFILES_INTERPOLANT Read more… Components Type Visibility Attributes Name Initial type(EZspline2_r4), public :: ne Interpolant of background electron density . type(EZspline2_r4), public :: Te Interpolant of background electron temperature . type(EZspline2_r4), public :: Zeff Interpolant of effective charge number . integer, public :: NR Size of mesh containing the field data along the -axis. integer, public :: NZ Size of mesh containing the field data along the -axis. integer, public, DIMENSION(2) :: BCSR = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. integer, public, DIMENSION(2) :: BCSZ = (/0, 0/) Not-a-knot boundary condition for the interpolants at both ends\n of the direction. type, private :: KORC_INTERPOLANT_DOMAIN Read more… Components Type Visibility Attributes Name Initial integer(kind=1), public, DIMENSION(:), ALLOCATABLE :: FLAG1D 2-D array with info of the spatial domain where the axisymmetric fields\n and plasma profiles are known. integer(kind=1), public, DIMENSION(:,:), ALLOCATABLE :: FLAG2D 2-D array with info of the spatial domain where the axisymmetric fields\n and plasma profiles are known. integer(kind=1), public, DIMENSION(:,:,:), ALLOCATABLE :: FLAG3D 3-D array with info of the spatial domain where the 3-D fields and plasma\n profiles are known. real(kind=rp), public :: Ro Smaller radial position of the fields and profiles domain. real(kind=rp), public :: Zo Smaller vertical position of the fields and profiles domain real(kind=rp), public :: To real(kind=rp), public :: Drm real(kind=rp), public :: DPSIP real(kind=rp), public :: DR Separation between grid points along the radial direction. real(kind=rp), public :: DPHI real(kind=rp), public :: DT real(kind=rp), public :: DZ Separation between grid points along the vertical direction. Subroutines public subroutine initialize_fields_interpolant (params, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation.\n See korc_types and korc_fields . public subroutine initialize_SC1D_field_interpolant (params, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation.\n See korc_types and korc_fields . public subroutine initialize_SC1D_field_interpolant_FS (params, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information\n about the fields used in the simulation.\n See korc_types and korc_fields . private subroutine check_if_in_fields_domain (F, Y, flag) Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that determines whether particles are followed in the\n simulation (flag=1), or not (flag=0). private subroutine check_if_in_fields_domain_p (pchunk, F, Y_R, Y_PHI, Y_Z, flag) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag Flag that determines whether particles are followed in the\n simulation (flag=1), or not (flag=0). public subroutine initialize_profiles_interpolant (params, P) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PROFILES), intent(inout) :: P An instance of KORC's derived type PROFILES containing\n all the information about the plasma profiles used in the simulation.\n See korc_types and korc_profiles . private subroutine check_if_in_profiles_domain (Y, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that determines whether particles are followed\n in the simulation (flag=1), or not (flag=0). private subroutine check_if_in_profiles_domain_p (pchunk, Y_R, Y_PHI, Y_Z, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(8) :: Y_R real(kind=rp), intent(in), DIMENSION(8) :: Y_PHI real(kind=rp), intent(in), DIMENSION(8) :: Y_Z integer(kind=is), intent(inout), DIMENSION(8) :: flag Flag that determines whether particles are followed\n in the simulation (flag=1), or not (flag=0). private subroutine interp_2D_bfields (params, Y, B, flag) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Cartesian components of interpolated magnetic field components.\n B(1,:)= , B(2,:)= , and B(3,:)= . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). private subroutine gradient_2D_Bfields (Y, BR, BPHI, BZ, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: BR Cylindrical components of gradient of R-component of magnetic field. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: BPHI Cylindrical components of gradient of R-component of magnetic field. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: BZ Cylindrical components of gradient of R-component of magnetic field. integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). private subroutine interp_2D_gradBfields (Y, gradB, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: gradB Cylindirical components of interpolated gradient of magnitude of\n magnetic field. integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). private subroutine interp_2D_curlbfields (Y, curlb, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates, Y(1,:) = ,\n Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: curlb Cylindirical components of interpolated curl of direction of\n magnetic field. integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the simulation\n (flag=1), or not (flag=0). public subroutine interp_FOfields_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, PSIp, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_X real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine interp_FOfields1_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, PSIp, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_X real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine interp_FOcollision_p (pchunk, Y_R, Y_PHI, Y_Z, ne, Te, Zeff, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: ne real(kind=rp), intent(out), DIMENSION(pchunk) :: Te real(kind=rp), intent(out), DIMENSION(pchunk) :: Zeff integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine interp_fields_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlB_R, curlB_PHI, curlB_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine interp_fields_3D_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlB_R, curlB_PHI, curlB_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine interp_collision_p (pchunk, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, ne, Te, Zeff, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: ne real(kind=rp), intent(out), DIMENSION(pchunk) :: Te real(kind=rp), intent(out), DIMENSION(pchunk) :: Zeff integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine interp_bmag_p (pchunk, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z private subroutine interp_3D_bfields (params, Y, B, flag) @brief Subroutine for interpolating the pre-computed, 3-D magnetic field to the particles' position. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag public subroutine calculate_magnetic_field (params, Y, F, B, E, PSI_P, flag) @brief Subroutine that calculates the axisymmetric magnetic field to the particles' position using the poloidal magnetic flux.\n @details When the poloidal magnetic flux is used in a KORC simulation, the magnetic field components are calculated as it follows: Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y type(FIELDS), intent(in) :: F real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: PSI_P integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag public subroutine calculate_magnetic_field_p (pchunk, F, Y_R, Y_Z, B_R, B_PHI, B_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z public subroutine calculate_2DBdBfields_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp public subroutine calculate_3DBdBfields_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache public subroutine calculate_3DBdBfields1_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp public subroutine calculate_GCfieldswE_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp public subroutine calculate_GCfields_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp public subroutine calculate_GCfields_2x1t_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp, time) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp real(kind=rp), intent(in) :: time public subroutine calculate_GCfields_p_FS (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlb_R, curlb_PHI, curlb_Z, gradB_R, gradB_PHI, gradB_Z, flag_cache, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlb_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp public subroutine add_interp_SCE_p (params, F, Y_R, Y_PHI, Y_Z, E_PHI) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI public subroutine add_interp_SCE_p_FS (params, F, PSIp, E_PHI) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: PSIp real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI public subroutine calculate_initial_magnetic_field (F) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F public subroutine sample_poloidal_flux (F) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F private subroutine interp_2D_efields (params, Y, E, flag) @brief Subroutine for interpolating the pre-computed, axisymmetric electric field to the particles' position. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag private subroutine interp_3D_efields (params, Y, E, flag) @brief Subroutine for interpolating the pre-computed 3-D electric field to the particles' position. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag public subroutine interp_fields (params, prtcls, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: prtcls An instance of PARTICLES containing the variables of a given species. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the \n information about the fields used in the simulation.\n See korc_types and korc_fields . private subroutine interp_2D_profiles (Y, ne, Te, Zeff, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: ne Interpolated background electron density !! . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Te Interpolated background electron temperature . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Zeff Interpolated effective charge number . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in the\n simulation (flag=1), or not (flag=0). private subroutine interp_3D_profiles (Y, ne, Te, Zeff, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Particles' position in cylindrical coordinates,\n Y(1,:) = , Y(2,:) = , and Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: ne Interpolated background electron density . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Te Interpolated background electron temperature . real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: Zeff Interpolated effective charge number . integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag Flag that indicates whether particles are followed in\n the simulation (flag=1), or not (flag=0). public subroutine interp_profiles (params, prtcls, P) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: prtcls An instance of PARTICLES containing the variables of a\n given species. Call to this subroutine generally passes spp%vars. type(PROFILES), intent(in) :: P An instance of KORC's derived type PROFILES containing all the\n information about the plasma profiles used in the simulation.\n See[[ korc_types]] and korc_profiles . public subroutine finalize_interpolants (params) @brief Subroutine that frees memory allocated for PSPLINE interpolants. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine get_m3d_c1_magnetic_fields (prtcls, F, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(in) :: params public subroutine get_m3d_c1_FOmagnetic_fields_p (params, F, Y_R, Y_PHI, Y_Z, B_X, B_Y, B_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_X real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Y real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint public subroutine get_m3d_c1_GCmagnetic_fields_p (params, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, gradB_R, gradB_PHI, gradB_Z, curlb_R, curlb_PHI, curlb_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: B_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: gradB_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_R real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_PHI real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: curlb_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint public subroutine get_m3d_c1_vector_potential (prtcls, F, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(in) :: params public subroutine get_m3d_c1_vector_potential_p (params, F, Y_R, Y_PHI, Y_Z, PSIp, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: PSIp integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint public subroutine get_m3d_c1_electric_fields (prtcls, F, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(FIELDS), intent(in) :: F type(KORC_PARAMS), intent(in) :: params public subroutine get_m3d_c1_FOelectric_fields_p (params, F, Y_R, Y_PHI, Y_Z, E_X, E_Y, E_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint public subroutine get_m3d_c1_GCelectric_fields_p (params, F, Y_R, Y_PHI, Y_Z, E_R, E_PHI, E_Z, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(params%pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint public subroutine get_m3d_c1_profile (prtcls, P, params) Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: prtcls type(PROFILES), intent(in) :: P type(KORC_PARAMS), intent(in) :: params public subroutine get_m3d_c1_profile_p (params, P, Y_R, Y_PHI, Y_Z, n_e, T_e, flag, hint) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(PROFILES), intent(in) :: P real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_Z real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: n_e real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: T_e integer(kind=is), intent(inout), DIMENSION(params%pchunk) :: flag type(C_PTR), intent(inout), DIMENSION(params%pchunk) :: hint","tags":"","loc":"module/korc_interp.html"},{"title":"korc_avalanche – KORC-Full Orbit","text":"Uses korc_types korc_constants korc_HDF5 korc_hpc korc_fields korc_profiles korc_coords korc_input Contents Variables aval_params minmax_buffer_size Derived Types AVALANCHE_PDF_PARAMS Functions deg2rad fRE log10fRE PSI_ROT indicator random_norm Subroutines get_avalanche_distribution get_Avalanche_4D initialize_avalanche_params sample_distribution update_avalanche_params Avalanche_4D save_avalanche_params Variables Type Visibility Attributes Name Initial type( AVALANCHE_PDF_PARAMS ), private :: aval_params real(kind=rp), private, parameter :: minmax_buffer_size = 10.0_rp Derived Types type, private :: AVALANCHE_PDF_PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: max_pitch_angle Maximum pitch angle of sampled PDF in degrees real(kind=rp), public :: min_pitch_angle Minimum pitch angle of sampled PDF in degrees real(kind=rp), public :: min_energy Minimum energy of sampled PDF in MeV real(kind=rp), public :: max_energy Maximum energy of sampled PDF in MeV real(kind=rp), public :: min_p Minimum momentum of sampled PDF real(kind=rp), public :: max_p Maximum momentum of sampled PDF real(kind=rp), public :: ne Background electron density in m&#94;-3 real(kind=rp), public :: Zeff Effective atomic number of ions real(kind=rp), public :: Ec Critical electric field in V/m real(kind=rp), public :: Epar Parallel electric field in V/m real(kind=rp), public :: Ebar Epar/Ec real(kind=rp), public :: Te Background electron temperature in eV real(kind=rp), public :: lD Debye length real(kind=rp), public :: bmin Maximum approach radius real(kind=rp), public :: CoulombLog Coulomb Logarithm real(kind=rp), public :: Tau Collisional time real(kind=rp), public :: dth Variance of sampling normal variate for pitch angle real(kind=rp), public :: dp Variance of sampling normal variate for momentum real(kind=rp), public :: dR Variance of sampling normal variate for R location real(kind=rp), public :: dZ Variance of sampling normal variate for Z location real(kind=rp), public :: fo real(kind=rp), public :: alpha real(kind=rp), public :: cz real(kind=rp), public :: C1 real(kind=rp), public :: C2 Functions public function deg2rad (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function fRE (x, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: p Return Value real(kind=rp) public function log10fRE (x, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: p Return Value real(kind=rp) private function PSI_ROT (R, R0, sigR, Z, Z0, sigZ, theta) Calculates value of argument of 2D Gaussian spatial distribution with\n with counter-clockwise rotation. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R R-coordinate of MH sampled location real(kind=rp), intent(in) :: R0 R-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigR Variance of first dimension of 2D Gaussian real(kind=rp), intent(in) :: Z Z-coordinate of MH sampled location real(kind=rp), intent(in) :: Z0 Z-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigZ Variance of second dimension of 2D Gaussian real(kind=rp), intent(in) :: theta Angle of counter-clockwise rotation (in radians), of 2D Gaussian\n distribution relative to R,Z Return Value real(kind=rp) Argument of exponential comprising 2D Gaussian distribution private function indicator (psi, psi_max) Compares argument psi to chosen psi_max, returning step function. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: psi real(kind=rp), intent(in) :: psi_max Return Value real(kind=rp) private function random_norm (mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) Subroutines public subroutine get_avalanche_distribution (params, g, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao public subroutine get_Avalanche_4D (params, spp, P, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp type(PROFILES), intent(in) :: P type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. private subroutine initialize_avalanche_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine sample_distribution (params, g, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao private subroutine update_avalanche_params (params, prtcls) Updates the avalanche parameters aval_params% at each step\n in the MCMC after the profiles are interpolated at the sampled\n R,Z location. Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(in) :: prtcls An instance of PARTICLES containing the variables of a\n given species. Call to this subroutine generally passes spp%vars. private subroutine Avalanche_4D (params, spp, P, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. private subroutine save_avalanche_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params","tags":"","loc":"module/korc_avalanche.html"},{"title":"korc_units – KORC-Full Orbit","text":"Note Module with subroutines that calculate the characteristic \n scales in the simulation used in the normalization and \n nondimensionalization of the simulation variables. Uses korc_types korc_constants korc_input Contents Subroutines compute_charcs_plasma_params normalize_variables Subroutines public subroutine compute_charcs_plasma_params (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the \n information of different electron species. See korc_types . type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the \n information about the fields used in the simulation. \n See korc_types and korc_fields . public subroutine normalize_variables (params, spp, F, P) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all \n the information of different electron species. See korc_types . type(FIELDS), intent(inout) :: F @param[in,out] F An instance of KORC's derived type FIELDS \n containing all the information about the fields used in the simulation.\n See korc_types and korc_fields . type(PROFILES), intent(inout) :: P @param[in,out] P An instance of KORC's derived type PROFILES containing all the information about the plasma profiles used in\n the simulation. See korc_types.f90 and korc_profiles.f90.","tags":"","loc":"module/korc_units.html"},{"title":"korc_initialize – KORC-Full Orbit","text":"Note Module with subroutines to load simulation parameters \n and to define the time step in the simulation. Uses korc_types korc_constants korc_hpc korc_HDF5 korc_fields korc_rnd_numbers korc_spatial_distribution korc_velocity_distribution korc_coords korc_input Contents Subroutines load_korc_params initialize_korc_parameters define_time_step initialize_particles set_up_particles_ic Subroutines private subroutine load_korc_params (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. Read more… public subroutine initialize_korc_parameters (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine define_time_step (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine initialize_particles (params, F, P, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of KORC's derived type FIELDS containing all the information \n about the fields used in the simulation. See korc_types and korc_fields . type(PROFILES), intent(inout) :: P type(SPECIES), intent(out), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the information \n of different electron species. See korc_types . Read more… public subroutine set_up_particles_ic (params, F, spp, P) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of KORC's derived type FIELDS containing all \n the information about the fields used in the simulation. \n See korc_types and korc_fields . type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all \n the information of different electron species. See korc_types . type(PROFILES), intent(in) :: P An instance of the KORC derived type PROFILES.","tags":"","loc":"module/korc_initialize.html"},{"title":"korc_hpc – KORC-Full Orbit","text":"Note KORC module containing subroutines to initilize, control, \n and to finalize parallel communications. Note Subroutine for initializing MPI and open MP communications. This subroutine initializes MPI and open MP communications and looks for\n errors durignt this procces. The system environment\n variables, which are modified by the user at the moment of\n running/submitting a KORC simulation, are used to determine the\n open MP configuration. Some open MP parameters are displayed on the\n screen/output file. @param[in] params Core KORC simulation parameters.\n @param mpi_process_finalized Flag indicating whether an individual MPI process was finalized correctly.\n @param mpierr MPI error status. Uses korc_types omp_lib mpi Contents Variables timed_already t1 t2 Subroutines korc_abort set_paths initialize_mpi timing_KORC finalize_mpi initialize_communications Variables Type Visibility Attributes Name Initial logical, private :: timed_already = .FALSE. Flag to determine if a first call to WMPI_TIME() was made already. real(kind=rp), private :: t1 Variable to be used in timing a parallel section of KORC. real(kind=rp), private :: t2 Variable to be used in timing a parallel section of KORC. Subroutines public subroutine korc_abort () Read more… Arguments None public subroutine set_paths (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine initialize_mpi (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. public subroutine timing_KORC (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. public subroutine finalize_mpi (params) @brief Subroutine for finalizing MPI communications.\n @details This subroutine finalizes all the MPI communications and looks for errors durignt this procces. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine initialize_communications (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params","tags":"","loc":"module/korc_hpc.html"},{"title":"korc_finalize – KORC-Full Orbit","text":"Note Module containing subroutines to terminate parallel\n communications and free memory. Uses korc_types korc_fields korc_hpc Contents Subroutines finalize_communications deallocate_variables Subroutines public subroutine finalize_communications (params) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. public subroutine deallocate_variables (params, F, spp) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of KORC's derived type FIELDS containing all the\n information about the fields used in the simulation. See korc_types and korc_fields . type(SPECIES), intent(inout), DIMENSION(:), ALLOCATABLE :: spp An instance of KORC's derived type SPECIES containing all the\n information of different electron species. See korc_types .","tags":"","loc":"module/korc_finalize.html"},{"title":"korc_input – KORC-Full Orbit","text":"Note Module with subroutines to read in all namelists in supplied\n input file and broadcast to all mpi processes.\n Default values for all inputs input_parameters Uses korc_types korc_hpc Contents Variables restart proceed reinit simulation_time snapshot_frequency restart_overwrite_frequency dt num_species minimum_particle_energy radiation GC_rad_model collisions collisions_model bound_electron_model field_model profile_model magnetic_field_filename time_slice rmax rmin zmax zmin outputs_list HDF5_error_handling FO_GC_compare orbit_model field_eval FokPlan SameRandSeed SC_E SC_E_add pchunk runaway ppp q m spatial_distribution Ro PHIo Zo r_inner r_outter shear_factor sigmaR sigmaZ theta_gauss psi_max falloff_rate energy_distribution pitch_distribution Eno etao Eo_lims etao_lims Xtrace Spong_b Spong_w Spong_dlam dth dgam dR dZ Eo current_direction Bo minor_radius major_radius qa qo nR nZ nPHI E_dyn E_pulse E_width Bfield dBfield axisymmetric_fields Bflux Bflux3D Efield Dim2x1t E_2x1t t0_2x1t ind0_2x1t ReInterp_2x1t res_double dim_1D dt_E_SC Ip_exp PSIp_lim PSIp_0 axisymmetric filename radius_profile ne_profile neo n_ne n_shelf a_ne n_REr0 n_tauion n_tauin n_tauout n_shelfdelay n_lamfront n_lamback n_lamshelf psiN_0 Te_profile Teo n_Te a_Te Zeff_profile Zeffo n_Zeff a_Zeff Te_sing Ti_sing ne_sing Zeff_sing dTau_sing num_impurity_species Te_mult ne_mult Zo_mult Zj_mult nz_mult IZj_mult max_pitch_angle_aval min_pitch_angle_aval dth_aval dp_aval dR_aval dZ_aval max_energy_aval min_energy_aval ne_aval Zeff_aval Epar_aval Te_aval E_expt Zeff_expt max_pitch_angle_expt min_pitch_angle_expt min_energy_expt max_energy_expt k_expt t_expt Bo_expt lambda_expt A_fact_expt filename_Hollmann Eo_Hollmann E_Hollmann sigma_E_Hollmann Zeff_Hollmann sigma_Z_Hollmann max_pitch_angle_Hollmann min_pitch_angle_Hollmann min_energy_Hollmann max_energy_Hollmann current_direction_Hollmann Bo_Hollmann lambda_Hollmann A_fact_Hollmann min_energy_gamma max_energy_gamma k_gamma t_gamma E_simple Zeff_simple max_pitch_angle_simple min_pitch_angle_simple Bo_simple lambda_simple Subroutines read_namelist rmcoment Variables Type Visibility Attributes Name Initial logical, public :: restart = .FALSE. logical, public :: proceed = .FALSE. logical, public :: reinit = .FALSE. real(kind=rp), public :: simulation_time = 1.E-3 real(kind=rp), public :: snapshot_frequency = 1.E-5 real(kind=rp), public :: restart_overwrite_frequency = 1.E-1 real(kind=rp), public :: dt = 1.E0 integer, public :: num_species = 1 real(kind=rp), public :: minimum_particle_energy = 1.0E5 logical, public :: radiation = .FALSE. character(len=30), public :: GC_rad_model = 'SDE' logical, public :: collisions = .FALSE. character(len=30), public :: collisions_model = 'SINGLE_SPECIES' character(len=30), public :: bound_electron_model = 'HESSLOW' character(len=30), public :: field_model = 'M3D_C1' character(len=30), public :: profile_model = 'M3D_C1' character(len=30), public :: magnetic_field_filename = 'C1.h5' integer, public :: time_slice = 000 real(kind=rp), public :: rmax = 1.60 real(kind=rp), public :: rmin = 0.15 real(kind=rp), public :: zmax = 1.65 real(kind=rp), public :: zmin = -1.65 character(len=50), public :: outputs_list = '{X,Y,V,B,E,g,eta,flagCon,flagCol,PSIp,ne}' logical, public :: HDF5_error_handling = .TRUE. logical, public :: FO_GC_compare = .FALSE. character(len=30), public :: orbit_model = 'GC' character(len=30), public :: field_eval = 'interp' logical, public :: FokPlan = .FALSE. logical, public :: SameRandSeed = .FALSE. logical, public :: SC_E = .FALSE. logical, public :: SC_E_add = .FALSE. integer, public :: pchunk = 1 plasma_species\n As these inputs are vectors with dimension given by the number of species\n indicate default values for num_species=1 below, after the input_parameter\n namelist is read logical, public, DIMENSION(:), ALLOCATABLE :: runaway Flag to decide whether a given electron is a runaway (runaway=T)\n or not (runaway=F). integer, public, DIMENSION(:), ALLOCATABLE :: ppp real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: q real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: m character(len=30), public, DIMENSION(:), ALLOCATABLE :: spatial_distribution String describing the type of initial spatial distribution for\n each electron species. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Ro Radial position of the center of the electrons' initial\n spatial distribution. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PHIo Azimuthal position of the electrons' initial spatial distribution, \n in case of using a disk at a certain poloidal section. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zo Height of the center of the electrons' initial spatial distribution. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: r_inner real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: r_outter real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: shear_factor real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: sigmaR real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: sigmaZ real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: theta_gauss real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: psi_max Maximum value of the argument of the 2D gaussian exponential, used for an\n indicator function that limits the region of MH sampling real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: falloff_rate character(len=30), public, DIMENSION(:), ALLOCATABLE :: energy_distribution character(len=30), public, DIMENSION(:), ALLOCATABLE :: pitch_distribution real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Eno real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: etao real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Eo_lims real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: etao_lims real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Xtrace real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Spong_b real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Spong_w real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Spong_dlam real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: dth real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: dgam real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: dR real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: dZ analytical_fields_params real(kind=rp), public :: Eo = 0. character(len=30), public :: current_direction = 'ANTI-PARALLEL' real(kind=rp), public :: Bo = 2.2 real(kind=rp), public :: minor_radius = 0.7 real(kind=rp), public :: major_radius = 1.7 real(kind=rp), public :: qa = 5 real(kind=rp), public :: qo = 1.5 real(kind=rp), public :: nR = 50 real(kind=rp), public :: nZ = 50 real(kind=rp), public :: nPHI = 50 real(kind=rp), public :: E_dyn = 0. real(kind=rp), public :: E_pulse = 5.E-2 real(kind=rp), public :: E_width = 2.5E-2 externalPlasmaModel logical, public :: Bfield = .FALSE. logical, public :: dBfield = .FALSE. logical, public :: axisymmetric_fields = .FALSE. logical, public :: Bflux = .FALSE. logical, public :: Bflux3D = .FALSE. logical, public :: Efield = .FALSE. logical, public :: Dim2x1t = .FALSE. logical, public :: E_2x1t = .FALSE. real(kind=rp), public :: t0_2x1t = 1.405 integer, public :: ind0_2x1t = 11 logical, public :: ReInterp_2x1t = .FALSE. integer, public :: res_double = 0 integer, public :: dim_1D = 50 real(kind=rp), public :: dt_E_SC = 1.E-7 real(kind=rp), public :: Ip_exp = 2E5 real(kind=rp), public :: PSIp_lim = 0.8446 real(kind=rp), public :: PSIp_0 = 0.6 plasmaProfiles logical, public :: axisymmetric = .TRUE. character(len=30), public :: filename = 'JFIT_D3D_157576_t1580_1.h5' real(kind=rp), public :: radius_profile = 0.6 character(len=30), public :: ne_profile = 'RE-EVO-PSIP-G' real(kind=rp), public :: neo = 4.E20 real(kind=rp), public :: n_ne = 2.5E19 real(kind=rp), public :: n_shelf = 2.5E19 real(kind=rp), public, DIMENSION(4) :: a_ne = (/0.99713, 0.047037, 0.40023, -1.0466/) real(kind=rp), public :: n_REr0 = 0.4 real(kind=rp), public :: n_tauion = 1.5e-2 real(kind=rp), public :: n_tauin = 7.5e-3 real(kind=rp), public :: n_tauout = 1.25e-2 real(kind=rp), public :: n_shelfdelay = 4.e-2 real(kind=rp), public :: n_lamfront = 0.005 real(kind=rp), public :: n_lamback = 0.005 real(kind=rp), public :: n_lamshelf = 0.225 real(kind=rp), public :: psiN_0 = 0.8 character(len=30), public :: Te_profile = 'FLAT' real(kind=rp), public :: Teo = 1.5 real(kind=rp), public :: n_Te = 0.1 real(kind=rp), public, DIMENSION(4) :: a_Te = (/1.0046, -0.076652, -2.6429, 1.7415/) character(len=30), public :: Zeff_profile = 'FLAT' real(kind=rp), public :: Zeffo = 1. real(kind=rp), public :: n_Zeff = 3.0 real(kind=rp), public, DIMENSION(4) :: a_Zeff = (/1.0065, -0.12081, 0.02834, -0.11796/) CollisionParamsSingleSpecies real(kind=rp), public :: Te_sing = 2.0 real(kind=rp), public :: Ti_sing = 2.0 real(kind=rp), public :: ne_sing = 4.E20 real(kind=rp), public :: Zeff_sing = 1. real(kind=rp), public :: dTau_sing = 5.E-2 CollisionParamsMultipleSpecies integer, public :: num_impurity_species = 1 real(kind=rp), public :: Te_mult = 2.0 real(kind=rp), public :: ne_mult = 4.E20 real(kind=rp), public, DIMENSION(10) :: Zo_mult = 10.0 real(kind=rp), public, DIMENSION(10) :: Zj_mult = 1.0 real(kind=rp), public, DIMENSION(10) :: nz_mult = 4.E20 real(kind=rp), public, DIMENSION(10) :: IZj_mult = 15.7596 AvalancheGenerationPDF real(kind=rp), public :: max_pitch_angle_aval = 10.0 real(kind=rp), public :: min_pitch_angle_aval = 0.0 real(kind=rp), public :: dth_aval = 1.0 real(kind=rp), public :: dp_aval = 10.0 real(kind=rp), public :: dR_aval = 0.05 real(kind=rp), public :: dZ_aval = 0.05 real(kind=rp), public :: max_energy_aval = 60E6 real(kind=rp), public :: min_energy_aval = 7.0E6 real(kind=rp), public :: ne_aval = 8.5E18 real(kind=rp), public :: Zeff_aval = 1.0 real(kind=rp), public :: Epar_aval = 0.7427 real(kind=rp), public :: Te_aval = 1.0 ExperimentalPDF real(kind=rp), public :: E_expt = 7.67042 real(kind=rp), public :: Zeff_expt = 1.36632 real(kind=rp), public :: max_pitch_angle_expt = 176.257 real(kind=rp), public :: min_pitch_angle_expt = 158.25 real(kind=rp), public :: min_energy_expt = 9.54997E6 real(kind=rp), public :: max_energy_expt = 44.3241E6 real(kind=rp), public :: k_expt = 11.89 real(kind=rp), public :: t_expt = 0.65 real(kind=rp), public :: Bo_expt = 2.2 real(kind=rp), public :: lambda_expt = 4.0E-6 real(kind=rp), public :: A_fact_expt = 1. HollmannPDF character(len=30), public :: filename_Hollmann = 'Hollmann_PDF_HR.h5' real(kind=rp), public :: Eo_Hollmann = 24.56 real(kind=rp), public :: E_Hollmann = 11. real(kind=rp), public :: sigma_E_Hollmann = .2 real(kind=rp), public :: Zeff_Hollmann = 5. real(kind=rp), public :: sigma_Z_Hollmann = 10. real(kind=rp), public :: max_pitch_angle_Hollmann = 40. real(kind=rp), public :: min_pitch_angle_Hollmann = 0. real(kind=rp), public :: min_energy_Hollmann = 1.E6 real(kind=rp), public :: max_energy_Hollmann = 60.E6 character(len=30), public :: current_direction_Hollmann = 'ANTICLOCKWISE' real(kind=rp), public :: Bo_Hollmann = 2.2 real(kind=rp), public :: lambda_Hollmann = 4.0E-6 real(kind=rp), public :: A_fact_Hollmann = 1. EnergyGammaPDF real(kind=rp), public :: min_energy_gamma = 1.0E6 real(kind=rp), public :: max_energy_gamma = 30.0E6 real(kind=rp), public :: k_gamma = 11.89 real(kind=rp), public :: t_gamma = 0.65 SimpleEquilibriumPDF real(kind=rp), public :: E_simple = 4.5 real(kind=rp), public :: Zeff_simple = 4.0 real(kind=rp), public :: max_pitch_angle_simple = 60.0 real(kind=rp), public :: min_pitch_angle_simple = 0.0 real(kind=rp), public :: Bo_simple = 2.0 real(kind=rp), public :: lambda_simple = 890.0E-9 Subroutines public subroutine read_namelist (params, infile, echo_in, outdir) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params character(len=*), intent(in) :: infile logical, intent(in) :: echo_in character(len=*), intent(in) :: outdir public subroutine rmcoment (fileold, filenew) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fileold character(len=*), intent(in) :: filenew","tags":"","loc":"module/korc_input.html"},{"title":"korc_types – KORC-Full Orbit","text":"Note Module containing the definition of KORC derived types and\n KORC variables, the building blocks of the code. Uses iso_c_binding Contents Variables is ip idef rdef rp rp korc_zero MAX_STRING_LENGTH default_unit_open default_unit_write output_unit_write Derived Types KORC_STRING V_FIELD_3D V_FIELD_2D V_FIELD_1D KORC_MPI CHARCS_PARAMS KORC_PARAMS PARTICLES SPECIES A_FIELD MESH FIELDS PROFILES Variables Type Visibility Attributes Name Initial integer, public, parameter :: is = KIND(INT(1, 1)) Definition of 1 Byte (8 bits) Fortran KORC integer type. integer, public, parameter :: ip = KIND(INT(1, 8)) Definition of 8 Bytes (64 bits) Fortran KORC integer type. integer, public, parameter :: idef = KIND(1) Definition of the default KORC integer type on the system where\n KORC is compiled. integer, public, parameter :: rdef = KIND(1.0) Definition of the default KORC real type on the system where\n KORC is compiled. integer, public, parameter :: rp = KIND(0.d0) Definition of the KORC double precision real type. integer, public, parameter :: rp = KIND(1.0) Definition of the KORC single precision real type. real(kind=rp), public, parameter :: korc_zero = 1.0E-15 Definition of the zero in KORC. integer, public, parameter :: MAX_STRING_LENGTH = 1000 Default length of a KORC_STRING variable. integer, public, parameter :: default_unit_open = 101 Default file unit for opening and reading from an external text file. integer, public, parameter :: default_unit_write = 201 Default file unit for opening and writing to external an external text file. integer, public, parameter :: output_unit_write = 202 Default file unit for opening and writing to external an external text file. Derived Types type, public :: KORC_STRING Read more… Components Type Visibility Attributes Name Initial character(len=MAX_STRING_LENGTH), public :: str type, public :: V_FIELD_3D Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: R component of the vector field variable. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: PHI component of the vector field variable. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: Z component of the vector field variable. type, public :: V_FIELD_2D Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: R component of the vector field variable. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: PHI component of the vector field variable. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Z component of the vector field variable. type, public :: V_FIELD_1D Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: R component of the vector field variable. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PHI component of the vector field variable. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Z component of the vector field variable. type, private :: KORC_MPI Read more… Components Type Visibility Attributes Name Initial integer, public :: nmpi Number of MPI processes. integer, public :: rank Rank in WORLD COMMON communicator. integer, public :: rank_topo Rank in mpi_topo communicator integer, public :: mpi_topo MPI communicator for a certain topology. type, public :: CHARCS_PARAMS Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public :: time Read more… real(kind=rp), public :: time_r Read more… real(kind=rp), public :: velocity Characteristic velocity. This is fixed to the speed of . real(kind=rp), public :: length Characteristic length scale calculated as times the relativistic time scale. real(kind=rp), public :: mass Characteristic particle mass. This is equal to the electron mass . real(kind=rp), public :: charge Characteristic particle charge. This is equal to the electron charge . real(kind=rp), public :: density Characteristic particle density. This is equal to , with the characteristic length. real(kind=rp), public :: Eo Characteristic electric field . Usually at the magnetic axis. real(kind=rp), public :: Bo Characteristic magnetic field . Usually at the magnetic axis. real(kind=rp), public :: energy Characteristic energy. This is equal to . real(kind=rp), public :: pressure Characteristic pressure. Read more… real(kind=rp), public :: temperature Characteristic plasma temperature (Joules). This is equal to . type, public :: KORC_PARAMS Read more… Components Type Visibility Attributes Name Initial character(len=MAX_STRING_LENGTH), public :: path_to_inputs Absolute path to KORC's input file. character(len=MAX_STRING_LENGTH), public :: path_to_outputs Absolute path to the outputs' folder. integer, public :: num_omp_threads Number of open MP threads per MPI process used in the simulation. logical, public :: restart Flag to indicate if the simulations proceeds (restart=T) or not\n (restart=F). Restart simulation that exited before simulation_time\n reached. logical, public :: proceed Flag to indicate if the simulations continues (proceed=T) or not\n (proceed=F). Append simulation results after previous simulation_time\n reached. logical, public :: reinit Flag to begin a new simulation, reinitializing from restart file state real(kind=rp), public :: simulation_time Total simulation time in seconds. real(kind=rp), public :: snapshot_frequency Time between snapshots in time of the simulation. real(kind=rp), public :: restart_overwrite_frequency Time between overwrites of restart file in time of the simulation. real(kind=rp), public :: dt Time step in the simulation as a fraction of the relativistic electron\n gyro-period . real(kind=rp), public :: time = 0.0_rp Current physical time in the simulation. integer(kind=ip), public :: ito = 0_ip Initial time iteration in the simulation, this is different from zero\n in case is a restarting simulation. integer(kind=ip), public :: it = 0_ip Current time iteration in the simulation, this is different from zero\n in case is a restarting simulation. real(kind=rp), public :: init_time = 0.0_rp Time at the beginning of a run with proceed=T integer(kind=ip), public :: t_steps integer(kind=ip), public :: prev_iter_2x1t Number of time steps needed for evolving the electrons up to\n \"simulation_time\". integer(kind=ip), public :: t_skip integer(kind=ip), public :: t_it_SC = 1_ip integer(kind=ip), public :: output_cadence Time iteration offset used to decide when the outputs are generated. integer(kind=ip), public :: restart_output_cadence Time iteration offset used to decide when the restart files are\n generated. integer(kind=ip), public :: num_snapshots Number of snapshots in time for generating the output files. integer, public :: num_species Number of different populations of simulated relativistic electrons\n in KORC. real(kind=rp), public :: minimum_particle_energy Minimum allowed energy of simulated electrons. Read more… real(kind=rp), public :: minimum_particle_g Minimum allowed relativistic factor of simulated electrons. logical, public :: radiation Flag to indicate if synchrotron radiation losses are included\n (radiation=T) or not (radiation=F). logical, public :: collisions Flag to indicate if collisionsare included (collisions=T) or not\n (collisions=F). character(len=MAX_STRING_LENGTH), public :: GC_rad_model character(len=MAX_STRING_LENGTH), public :: collisions_model String with the name of the collisions model to be used in the\n simulation. character(len=MAX_STRING_LENGTH), public :: bound_electron_model character(len=MAX_STRING_LENGTH), public :: field_model character(len=MAX_STRING_LENGTH), public :: profile_model String with the name of the model for the fields and plasma profiles. character(len=MAX_STRING_LENGTH), public :: magnetic_field_filename String with the name of the model for the fields and plasma profiles. character(len=MAX_STRING_LENGTH), public, DIMENSION(:), ALLOCATABLE :: outputs_list List of electron variables to include in the outputs. integer, public :: HDF5_error_handling Flag to indicate whether we allow HDF5 to show warnings \n during runtime (HDF5_error_handling=1) or not (HDF5_error_handling=0) type( KORC_MPI ), public :: mpi_params An instance of the KORC_MPI derived type. type( CHARCS_PARAMS ), public :: cpp An instance of the CHARCS_PARAMS derived type. logical, public :: FO_GC_compare character(len=MAX_STRING_LENGTH), public :: orbit_model String with the name of the orbit model ('FO' or 'GC'). character(len=MAX_STRING_LENGTH), public :: field_eval String with the name of the field evaluation method for\n analytical fields ('interp' or 'eqn') logical, public :: GC_coords Flag to get_fields to control whether cartesian to cylindrical\n coordinate transformation needs to be performed logical, public :: FokPlan Flag to decouple spatial-dependence of evolution logical, public :: SameRandSeed logical, public :: SC_E logical, public :: SC_E_add integer, public :: time_slice real(kind=rp), public :: rmax real(kind=rp), public :: rmin real(kind=rp), public :: zmax real(kind=rp), public :: zmin integer, public :: pchunk number of particles per vectorized chunk type, public :: PARTICLES Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: X Cartesian coordinates of the electrons' position.\n dim(X) = (3,SPECIES::ppp). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: V Cartesian components of the electrons' velocity. dim(V) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Rgc Cartesian coordinates of the electrons' guiding-center position. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Y Coordinates of the electrons' position in cylindrical or toroidal\n coordinates. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Y0 Placeholder coordinates of the electrons' position in cylindrical\n coordinates for GC orbit model. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: V0 Placeholder of the electrons' parallel momentum for the GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: E Cartesian components of the electric field felt by each electron.\n dim(E) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: B Cartesian components of the magnetic field felt by each electron.\n dim(B) = dim(X). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PSI_P real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: BR Cartesian components of the gradient of the R-component of the\n magnetic field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: BPHI Cartesian components of the gradient of the PHI-component of the\n magnetic field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: BZ Cartesian components of the gradient of the Z-component of the\n magnetic field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: gradB Cylindrical components of the gradient of magnitude of magnetic\n field felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: curlb Cylindrical components of the curl of the magnetic field unit\n vector felt by each electron. dim(B) = dim(X). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: RHS RHS of equations of motion for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k1 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k2 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k3 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k4 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k5 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: k6 Cash-Karp Runge-Kutta coefficient for GC orbit model real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: ne Electron density seen by each electron. dim(ne) = (1,SPECIES::ppp). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Te Electron temperature seen by each electron. dim(Te) = (1,SPECIES::ppp). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Zeff Zeff seen by each electron. dim(Zeff) = (1,SPECIES::ppp). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: g Instantaneous relativistic factor\n of each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: eta Instantaneous pitch angle of each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: mu Magnetic moment of each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Prad Instantaneous radiated power by each electron in the simulation. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Pin Instantaneous input power of each electron due to the electric\n field acceleration. integer(kind=is), public, DIMENSION(:), ALLOCATABLE :: flagCon integer(kind=is), public, DIMENSION(:), ALLOCATABLE :: flagCol Flag for each particle to decide whether it is being followed\n (flag=T) or not (flag=F). real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: AUX An auxiliary scalar variable for each electron. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: wt Weight of each electron. This is used when sampling weighted\n PDFs and in the synthetic camera diagnostic. type(C_PTR), public, DIMENSION(:), ALLOCATABLE :: hint Hint for M3D_C1 interpolation. logical, public :: cart type, public :: SPECIES Read more… Components Type Visibility Attributes Name Initial type( PARTICLES ), public :: vars An instance of the PARTICLES derived type. logical, public :: runaway Flag to decide whether a given electron is a runaway (runaway=T)\n or not (runaway=F). character(len=MAX_STRING_LENGTH), public :: spatial_distribution String describing the type of initial spatial distribution for\n each electron species. character(len=MAX_STRING_LENGTH), public :: energy_distribution String describing the type of initial energy distribution for\n each electron species. character(len=MAX_STRING_LENGTH), public :: pitch_distribution String describing the type of initial pitch-angle distribution for\n each electron species. real(kind=rp), public :: Eo Initial energy of each electron species in case of using an initial\n mono-energetic distribution. real(kind=rp), public :: go Corresponding relativisitc factor of each electron species in case\n of using an initial mono-energetic distribution. real(kind=rp), public :: etao Initial pitch-angle of each electron species in case of using an\n initial mono-pitch-angle distribution. real(kind=rp), public, DIMENSION(2) :: Eo_lims Minimum and maximum energy limits of a given initial\n non-mono-energetic distribution. real(kind=rp), public, DIMENSION(2) :: etao_lims Minimum and maximum pitch-angle limits of a given initial\n non-mono-pitch-angle distribution. real(kind=rp), public :: wc The mean electron cyclotron frequency of each electron species. real(kind=rp), public :: wc_r The mean relativistic electron cyclotron frequency of each electron\n species. real(kind=rp), public :: q Charge of each species. Read more… real(kind=rp), public :: m Mass of each species. Read more… integer, public :: ppp Number of computational particles used to simulate each electron\n species. real(kind=rp), public :: Ro Radial position of the center of the electrons' initial spatial\n distribution. real(kind=rp), public :: PHIo Azimuthal position of the electrons' initial spatial \n distribution, in case of using a disk at a certain poloidal section. real(kind=rp), public :: Zo Height of the center of the electrons' initial spatial distribution. real(kind=rp), public :: r_inner Minimum minor radius of the electrons' initial spatial distribution. real(kind=rp), public :: r_outter Maximum minor radius of the electrons' initial spatial distribution. real(kind=rp), public :: falloff_rate Exponential falloff or standard deviation of a non-uniform radial\n distribution of electrons. real(kind=rp), public :: shear_factor Shear factor used to generate an initial spatial distribution with an\n elliptic poloidal cross section. Read more… real(kind=rp), public :: sigmaR Variance of the first dimension of a 2D Gaussian, spatial\n distribution function real(kind=rp), public :: sigmaZ Variance of the second dimension of a 2D Gaussian, spatial\n distribution function real(kind=rp), public :: theta_gauss Angle of counter-clockwise rotation (in degrees) of 2D Gaussian\n distribution relative to R,Z real(kind=rp), public :: psi_max Maximum value of the argument of the 2D gaussian exponential, used\n for an indicator function that limits the region of MH sampling real(kind=rp), public :: Spong_b real(kind=rp), public :: Spong_w real(kind=rp), public :: Spong_dlam real(kind=rp), public :: dth real(kind=rp), public :: dgam real(kind=rp), public :: dR real(kind=rp), public :: dZ real(kind=rp), public, DIMENSION(3) :: Xtrace Initial position in Cartesian coordinates for tracer particle type, private :: A_FIELD Read more… Components Type Visibility Attributes Name Initial real(kind=rp), public :: Bo Magnitude of the toroidal magnetic field . real(kind=rp), public :: a Plasma edge as measured from the magnetic axis. real(kind=rp), public :: Ro Radial position of the magnetic axis real(kind=rp), public :: qa Safety factor at the plasma edge. real(kind=rp), public :: qo Safety factor at the magnetic axis . real(kind=rp), public :: lambda parameter of . real(kind=rp), public :: Bpo @deprecated Parameter not used anymore. Read more… real(kind=rp), public :: Bp_sign Sign of . This depends on current_direction,\n Bp_sign=1 for \n current_direction='PARALLEL', and Bp_sign=-1 for\n current_direction='ANTI-PARALLEL'. character(len=MAX_STRING_LENGTH), public :: current_direction Direction of plasma current: PARALLEL or ANTI-PARALLEL to the\n toroidal magnetic field. type, private :: MESH Derived type with the cylindrical coordinates of the grid nodes \n at which the pre-computed plasma profiles and fields are known. Components Type Visibility Attributes Name Initial real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: R Radial grid. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PHI Azimuthal grid. real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: Z Z grid. type, public :: FIELDS Read more… Components Type Visibility Attributes Name Initial type( A_FIELD ), public :: AB An instance of the KORC derived data type A_FIELD. type( V_FIELD_3D ), public :: E_3D KORC 3-D vector field of the pre-computed electric field. type( V_FIELD_3D ), public :: B_3D type( V_FIELD_3D ), public :: dBdR_3D type( V_FIELD_3D ), public :: dBdPHI_3D type( V_FIELD_3D ), public :: dBdZ_3D KORC 3-D vector field of the pre-computed magnetic field. type( V_FIELD_2D ), public :: E_2D KORC 2-D vector field of the pre-computed electric field. type( V_FIELD_2D ), public :: B_2D type( V_FIELD_2D ), public :: dBdR_2D type( V_FIELD_2D ), public :: dBdPHI_2D type( V_FIELD_2D ), public :: dBdZ_2D KORC 3-D vector field of the pre-computed magnetic field. type( V_FIELD_2D ), public :: gradB_2D type( V_FIELD_3D ), public :: gradB_3D KORC 3-D vector field of the gradient of the magnitude of the\n pre-computed magnetic field. type( V_FIELD_2D ), public :: curlb_2D type( V_FIELD_3D ), public :: curlb_3D KORC 3-D vector field of the curl of the unit vector in the\n direction of the pre-computed magnetic field. type( V_FIELD_1D ), public :: E_SC_1D type( V_FIELD_1D ), public :: J0_SC_1D type( V_FIELD_1D ), public :: J1_SC_1D type( V_FIELD_1D ), public :: J2_SC_1D type( V_FIELD_1D ), public :: J3_SC_1D type( V_FIELD_1D ), public :: A1_SC_1D type( V_FIELD_1D ), public :: A2_SC_1D type( V_FIELD_1D ), public :: A3_SC_1D real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: r_1D real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: PSIP_1D real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: dMagPsiSqdPsiP real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: ddMagPsiSqdPsiPSq type( MESH ), public :: X An instance of the KORC derived type MESH. character(len=MAX_STRING_LENGTH), public :: E_model Name for dynamical, analytic, electric field model to be added to real(kind=rp), public :: E_dyn real(kind=rp), public :: E_pulse real(kind=rp), public :: E_width real(kind=rp), public :: PSIP_min real(kind=rp), public :: PSIp_lim interpolated E field real(kind=rp), public :: PSIp_0 interpolated E field integer, public :: res_double integer, public, DIMENSION(3) :: dims Dimensions of the KORC vector field. dims=(number of grid \n nodes along , number of grid nodes along , \n number of grid nodes along ). integer, public :: dim_1D integer, public :: subcycle_E_SC real(kind=rp), public :: dt_E_SC real(kind=rp), public :: Ip_exp real(kind=rp), public :: Ip0 real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: PSIp real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: PSIp_FS real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: PSIp3D 2-D array for storing the data of the poloidal magnetic flux. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: FLAG2D 2-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: FLAG3D 3-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public :: Eo Characteristic electric field. real(kind=rp), public :: Bo Characteristic magnetic field. real(kind=rp), public :: Ro Radial position of the magnetic axis. real(kind=rp), public :: Zo position of the magnetic axis. logical, public :: Bfield Flag to indicate whether a pre-computed magnetic field will be\n used (Bfield=T) or not (Bfield=F). logical, public :: dBfield Flag to indicate whether a pre-computed magnetic field will be\n used (Bfield=T) or not (Bfield=F). logical, public :: Bflux logical, public :: Bflux3D Flag to indicate whether a pre-computed poloidal magnetic flux will\n be used (Bflux=T) or not (Bflux=F). logical, public :: Efield Flag to indicate whether a pre-computed electric field will be used\n (Efield=T) or not (Efield=F). logical, public :: Bfield_in_file Flag to indicate if a pre-computed magnetic field is in the input file. logical, public :: dBfield_in_file Flag to indicate if a pre-computed magnetic field is in the input file. logical, public :: Bflux_in_file Flag to indicate if a pre-computed poloidal magnetic flux is in the\n input file. logical, public :: Efield_in_file Flag to indicate if a pre-computed electric field is in the input file. logical, public :: axisymmetric_fields Flag to indicate if the pre-computed fields are axisymmetric. logical, public :: Dim2x1t logical, public :: E_2x1t logical, public :: ReInterp_2x1t real(kind=rp), public :: t0_2x1t integer, public :: ind0_2x1t integer, public :: ind_2x1t integer(kind=C_INT), public :: M3D_C1_B An M3D-C1 magnetic field. integer(kind=C_INT), public :: M3D_C1_E An M3D-C1 Electric field. integer(kind=C_INT), public :: M3D_C1_A An M3D-C1 vector potential. type, public :: PROFILES Read more… Components Type Visibility Attributes Name Initial type( MESH ), public :: X An instance of the KORC derived data type MESH. real(kind=rp), public :: a Plasma radius as measured from the magnetic axis real(kind=rp), public :: R0 real(kind=rp), public :: Z0 real(kind=rp), public :: R0_RE real(kind=rp), public :: Z0_RE integer, public, DIMENSION(3) :: dims Dimensions of the arrays containing the pre-computed profiles data. dims=(number of grid nodes along , \n number of grid nodes along , number of grid nodes along ). real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: FLAG2D 2-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: FLAG3D 3-D array defining the simulation domain where pre-computed data exist. real(kind=rp), public :: n_ne used in of the electron density profile. real(kind=rp), public :: n_Te used in of the electron temperature profile. real(kind=rp), public :: n_Zeff used in of the profile. real(kind=rp), public :: n_REr0 = 0._rp real(kind=rp), public :: n_tauion = 0._rp real(kind=rp), public :: n_tauin = 0._rp real(kind=rp), public :: n_tauout = 0._rp real(kind=rp), public :: n_shelfdelay = 0._rp real(kind=rp), public :: n_lamfront = 0._rp real(kind=rp), public :: n_lamback = 0._rp real(kind=rp), public :: n_lamshelf = 0._rp real(kind=rp), public :: n_shelf = 0._rp real(kind=rp), public :: psiN_0 = 1._rp real(kind=rp), public, DIMENSION(4) :: a_ne Coefficients of the polynomial electron density profile. \n See detailed description above, a_ne=( , , , ). real(kind=rp), public, DIMENSION(4) :: a_Te Coefficients of the polynomial electron temperature profile. \n See detailed description above, a_ne=( , , , ). real(kind=rp), public, DIMENSION(4) :: a_Zeff Coefficients of the profile. \n See detailed description above, a_ne=( , , , ). character(len=MAX_STRING_LENGTH), public :: Zeff_profile String containing the type of profile to be used in the simulation. real(kind=rp), public :: Zeffo at the magnetic axis. real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: Zeff_3D 3-D array for keeping the pre-computed data of the profile. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Zeff_2D 2-D array for keeping the pre-computed data of the profile. character(len=MAX_STRING_LENGTH), public :: ne_profile String containing the type of electron density profile to be used in the simulation. real(kind=rp), public :: neo Electron density at the magnetic axis real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: ne_3D 3-D array for keeping the pre-computed data of the electron density profile. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: ne_2D 2-D array for keeping the pre-computed data of the electron density profile. character(len=MAX_STRING_LENGTH), public :: Te_profile String containing the type of electron temperature profile to be used in the simulation. real(kind=rp), public :: Teo Electron temperature at the magnetic axis real(kind=rp), public, DIMENSION(:,:,:), ALLOCATABLE :: Te_3D 3-D array for keeping the pre-computed data of the electron density profile. real(kind=rp), public, DIMENSION(:,:), ALLOCATABLE :: Te_2D 2-D array for keeping the pre-computed data of the electron density profile. character(len=MAX_STRING_LENGTH), public :: filename Full path to the HDF5 file containing the pre-computed plasma profiles. logical, public :: axisymmetric Flag to indicate if the plasma profiles are axisymmetric. integer(kind=C_INT), public :: M3D_C1_ne integer(kind=C_INT), public :: M3D_C1_te integer(kind=C_INT), public :: M3D_C1_zeff","tags":"","loc":"module/korc_types.html"},{"title":"korc_experimental_pdf – KORC-Full Orbit","text":"Uses korc_types korc_constants korc_HDF5 korc_hpc special_functions korc_coords korc_rnd_numbers korc_random korc_fields korc_input Contents Variables pdf_params h_params xo Tol minmax_buffer_size Derived Types PARAMS HOLLMANN_PARAMS Functions deg2rad rad2deg fGamma fRE fRExPR random_norm IntK besselk IntGamma IntBesselK PR fRE_H fRE_H_3D fRE_HxPR fRE_pitch PSI_ROT_exp indicator_exp Subroutines get_experimentalG_distribution initialize_params P_integral sample_distribution get_Hollmann_distribution get_Hollmann_distribution_3D get_Hollmann_distribution_3D_psi initialize_Hollmann_params normalize_Hollmann_params load_data_from_hdf5 sample_Hollmann_distribution sample_Hollmann_distribution_3D sample_Hollmann_distribution_3D_psi save_params save_Hollmann_params Variables Type Visibility Attributes Name Initial type( PARAMS ), private :: pdf_params type( HOLLMANN_PARAMS ), private :: h_params real(kind=rp), private, parameter :: xo = (C_ME*C_C**2/C_E)/1.0E6 real(kind=rp), private, parameter :: Tol = 1.0E-5_rp real(kind=rp), private, parameter :: minmax_buffer_size = 10.0_rp Derived Types type, private :: PARAMS Components Type Visibility Attributes Name Initial real(kind=rp), public :: E real(kind=rp), public :: Zeff real(kind=rp), public :: max_pitch_angle real(kind=rp), public :: min_pitch_angle real(kind=rp), public :: min_energy real(kind=rp), public :: max_energy real(kind=rp), public :: min_p real(kind=rp), public :: max_p real(kind=rp), public :: k real(kind=rp), public :: t real(kind=rp), public :: fGo real(kind=rp), public :: Bo real(kind=rp), public :: lambda real(kind=rp), public :: A_fact type, private :: HOLLMANN_PARAMS Components Type Visibility Attributes Name Initial character(len=MAX_STRING_LENGTH), public :: filename real(kind=rp), public :: E real(kind=rp), public :: Eo real(kind=rp), public :: sigma_E real(kind=rp), public :: Zeff real(kind=rp), public :: sigma_Z real(kind=rp), public :: max_pitch_angle real(kind=rp), public :: min_pitch_angle real(kind=rp), public :: min_sampling_energy real(kind=rp), public :: max_sampling_energy real(kind=rp), public :: min_sampling_g real(kind=rp), public :: max_sampling_g real(kind=rp), public :: min_energy real(kind=rp), public :: max_energy real(kind=rp), public :: min_g real(kind=rp), public :: max_g real(kind=rp), public :: min_pitch real(kind=rp), public :: max_pitch integer, public :: N real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: E_axis real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: g real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: fRE_E real(kind=rp), public, DIMENSION(:), ALLOCATABLE :: fRE_pitch character(len=MAX_STRING_LENGTH), public :: current_direction real(kind=rp), public :: Bo real(kind=rp), public :: lambda real(kind=rp), public :: A_fact Functions private function deg2rad (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function rad2deg (x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function fGamma (x, k, t) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: x real(kind=rp), intent(in) :: k real(kind=rp), intent(in) :: t Return Value real(kind=rp) private function fRE (eta, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p Return Value real(kind=rp) private function fRExPR (eta, p) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p Return Value real(kind=rp) private function random_norm (mean, sigma) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: mean real(kind=rp), intent(in) :: sigma Return Value real(kind=rp) private function IntK (v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) public function besselk (v, x) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: v real(kind=rp), intent(in) :: x Return Value real(kind=rp) private function IntGamma (a, b, k, t) @brief Extended trapezoidal rule for integrating the Gamma PDF. See Sec. 4.2 of Numerical Recipies in Fortran 77. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b real(kind=rp), intent(in) :: k real(kind=rp), intent(in) :: t Return Value real(kind=rp) private function IntBesselK (a, b) @brief Extended trapezoidal rule for integrating the modified Bessel function of second kind. See Sec. 4.2 of Numerical Recipies in Fortran 77. Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: a real(kind=rp), intent(in) :: b Return Value real(kind=rp) private function PR (eta, p, Bo, l) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: p real(kind=rp), intent(in) :: Bo real(kind=rp), intent(in) :: l Return Value real(kind=rp) private function fRE_H (eta, g) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: g Return Value real(kind=rp) public function fRE_H_3D (F, eta, g, R, Z, R0, Z0) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: g real(kind=rp), intent(in) :: R real(kind=rp), intent(in) :: Z real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: Z0 Return Value real(kind=rp) public function fRE_HxPR (eta, g) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: eta real(kind=rp), intent(in) :: g Return Value real(kind=rp) private function fRE_pitch (g) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: g Return Value real(kind=rp) public function PSI_ROT_exp (R, R0, sigR, Z, Z0, sigZ, theta) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: R R-coordinate of MH sampled location real(kind=rp), intent(in) :: R0 R-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigR Variance of first dimension of 2D Gaussian real(kind=rp), intent(in) :: Z Z-coordinate of MH sampled location real(kind=rp), intent(in) :: Z0 Z-coordinate of center of 2D Gaussian real(kind=rp), intent(in) :: sigZ Variance of second dimension of 2D Gaussian real(kind=rp), intent(in) :: theta Angle of counter-clockwise rotation (in radians), of 2D Gaussian\n distribution relative to R,Z Return Value real(kind=rp) Argument of exponential comprising 2D Gaussian distribution public function indicator_exp (psi, psi_max) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: psi real(kind=rp), intent(in) :: psi_max Return Value real(kind=rp) Subroutines public subroutine get_experimentalG_distribution (params, g, eta, go, etao) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao private subroutine initialize_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params private subroutine P_integral (z, P) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in) :: z real(kind=rp), intent(out) :: P private subroutine sample_distribution (params, g, eta, go, etao) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: g real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: eta real(kind=rp), intent(out) :: go real(kind=rp), intent(out) :: etao public subroutine get_Hollmann_distribution (params, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp public subroutine get_Hollmann_distribution_3D (params, spp, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp type(FIELDS), intent(in) :: F public subroutine get_Hollmann_distribution_3D_psi (params, spp, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params type(SPECIES), intent(inout) :: spp type(FIELDS), intent(in) :: F public subroutine initialize_Hollmann_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine normalize_Hollmann_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine load_data_from_hdf5 () Arguments None public subroutine sample_Hollmann_distribution (params, spp) MCMC and MH algorithm perfomred on single MPI process \n to sample distribution function fRE_H Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(SPECIES), intent(inout) :: spp public subroutine sample_Hollmann_distribution_3D (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. public subroutine sample_Hollmann_distribution_3D_psi (params, spp, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(SPECIES), intent(inout) :: spp An instance of the derived type SPECIES containing all the parameters\n and simulation variables of the different species in the simulation. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. private subroutine save_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params public subroutine save_Hollmann_params (params) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params","tags":"","loc":"module/korc_experimental_pdf.html"},{"title":"korc_fields – KORC-Full Orbit","text":"Note Module containing subroutines to initialize externally\n generated fields, and to calculate the electric and magnetic\n fields when using an analytical model. Uses korc_types korc_hpc korc_coords korc_interp korc_HDF5 korc_input Contents Functions cross Subroutines analytical_fields analytical_fields_p analytical_fields_GC_init analytical_fields_GC analytical_fields_Bmag_p add_analytical_E_p analytical_fields_GC_p uniform_magnetic_field uniform_electric_field analytical_electric_field_cyl mean_F_field get_analytical_fields uniform_fields unitVectors get_fields calculate_SC_E1D calculate_SC_E1D_FS calculate_SC_p calculate_SC_p_FS init_SC_E1D init_SC_E1D_FS reinit_SC_E1D reinit_SC_E1D_FS initialize_fields initialize_GC_fields initialize_GC_fields_3D define_SC_time_step load_dim_data_from_hdf5 which_fields_in_file load_field_data_from_hdf5 load_1D_FS_from_hdf5 allocate_1D_FS_arrays ALLOCATE_2D_FIELDS_ARRAYS ALLOCATE_3D_FIELDS_ARRAYS ALLOCATE_V_FIELD_2D ALLOCATE_V_FIELD_3D DEALLOCATE_FIELDS_ARRAYS Functions private pure function cross (a, b) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(3) :: a Vector . real(kind=rp), intent(in), DIMENSION(3) :: b Vector . Return Value real(kind=rp),\n  DIMENSION(3) Cross product Subroutines private subroutine analytical_fields (F, Y, E, B, flag) Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Toroidal coordinates of each particle in the simulation; \n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in Cartesian coordinates; \n E(1,:) = , E(2,:) = , E(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in Cartesian coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). public subroutine analytical_fields_p (pchunk, B0, E0, R0, q0, lam, ar, X_X, X_Y, X_Z, B_X, B_Y, B_Z, E_X, E_Y, E_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: B0 real(kind=rp), intent(in) :: E0 real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in) :: q0 real(kind=rp), intent(in) :: lam real(kind=rp), intent(in) :: ar real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_X real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_X real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Y real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache private subroutine analytical_fields_GC_init (params, F, Y, E, B, gradB, curlB, flag, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Cylindrical coordinates of each particle in the simulation; \n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in cylindricalcoordinates; \n E(1,:) = , E(2,:) = , E(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in cylindrical coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: gradB Gradient of magnitude of magnetic field in cylindrical coordinates; \n gradB(1,:) = , B(2,:) = ,\n B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: curlB Curl of magnetic field unit vector in cylindrical coordinates integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: PSIp private subroutine analytical_fields_GC (params, F, Y, E, B, gradB, curlB, flag, PSIp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Cylindrical coordinates of each particle in the simulation; \n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in cylindricalcoordinates; \n E(1,:) = , E(2,:) = , E(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in cylindrical coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: gradB Gradient of magnitude of magnetic field in cylindrical coordinates; \n gradB(1,:) = , B(2,:) = ,\n B(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: curlB Curl of magnetic field unit vector in cylindrical coordinates integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). real(kind=rp), intent(inout), DIMENSION(:), ALLOCATABLE :: PSIp public subroutine analytical_fields_Bmag_p (pchunk, F, Y_R, Y_PHI, Y_Z, Bmag, E_PHI) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: Bmag real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI public subroutine add_analytical_E_p (params, tt, F, E_PHI, Y_R) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params integer(kind=ip), intent(in) :: tt type(FIELDS), intent(in) :: F real(kind=rp), intent(inout), DIMENSION(params%pchunk) :: E_PHI real(kind=rp), intent(in), DIMENSION(params%pchunk) :: Y_R public subroutine analytical_fields_GC_p (pchunk, F, Y_R, Y_PHI, Y_Z, B_R, B_PHI, B_Z, E_R, E_PHI, E_Z, curlB_R, curlB_PHI, curlB_Z, gradB_R, gradB_PHI, gradB_Z, PSIp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk type(FIELDS), intent(in) :: F real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(in), DIMENSION(pchunk) :: Y_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: B_R real(kind=rp), intent(out), DIMENSION(pchunk) :: B_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: B_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: E_R real(kind=rp), intent(out), DIMENSION(pchunk) :: E_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: E_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: curlB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_R real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: gradB_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: PSIp private subroutine uniform_magnetic_field (F, B) Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: B Magnetic field components in Cartesian coordinates; \n B(1,:) = , B(2,:) = , B(3,:) = private subroutine uniform_electric_field (F, E) Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in Cartesian coordinates; \n E(1,:) = , E(2,:) = , E(3,:) = private subroutine analytical_electric_field_cyl (F, Y, E, flag) Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Y Cylindrical coordinates of each particle in the simulation;\n Y(1,:) = , Y(2,:) = , Y(3,:) = . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: E Electric field components in Cartesian coordinates;\n  E(1,:) = , E(2,:) = , E(3,:) = integer(kind=is), intent(in), DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being followed (flag=T)\n or not (flag=F). public subroutine mean_F_field (F, Fo, op_field) Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(out) :: Fo Mean electric or magnetic field. type(KORC_STRING), intent(in) :: op_field String that specifies what mean field will be calculated.\n Its value can be 'B' or 'E'. private subroutine get_analytical_fields (params, vars, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: vars An instance of the KORC derived type PARTICLES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. private subroutine uniform_fields (vars, F) Read more… Arguments Type Intent Optional Attributes Name type(PARTICLES), intent(inout) :: vars An instance of the KORC derived type PARTICLES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. public subroutine unitVectors (params, Xo, F, b1, b2, b3, flag, cart, hint) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Xo Array with the position of the simulated particles. type(FIELDS), intent(in) :: F F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: b1 Basis vector pointing along the local magnetic field, \n that is, along . real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: b2 Basis vector perpendicular to b1 real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: b3 Basis vector perpendicular to b1 and b2. integer(kind=is), intent(inout), optional DIMENSION(:), ALLOCATABLE :: flag Flag for each particle to decide whether it is being \n followed (flag=T) or not (flag=F). logical :: cart type(C_PTR), intent(inout), DIMENSION(:), ALLOCATABLE :: hint Flag for each particle to decide whether it is being \n followed (flag=T) or not (flag=F). public subroutine get_fields (params, vars, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(PARTICLES), intent(inout) :: vars An instance of the KORC derived type PARTICLES. type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. public subroutine calculate_SC_E1D (params, F, Vden) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F real(kind=rp), intent(in), dimension(F%dim_1D) :: Vden public subroutine calculate_SC_E1D_FS (params, F, dintJphidPSIP) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F real(kind=rp), intent(in), dimension(F%dim_1D) :: dintJphidPSIP public subroutine calculate_SC_p (params, F, B_R, B_PHI, B_Z, Y_R, Y_Z, V_PLL, V_MU, m_cache, flagCon, flagCol, Vden) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), dimension(params%pchunk) :: B_R real(kind=rp), intent(in), dimension(params%pchunk) :: B_PHI real(kind=rp), intent(in), dimension(params%pchunk) :: B_Z real(kind=rp), intent(in), dimension(params%pchunk) :: Y_R real(kind=rp), intent(in), dimension(params%pchunk) :: Y_Z real(kind=rp), intent(in), dimension(params%pchunk) :: V_PLL real(kind=rp), intent(in), dimension(params%pchunk) :: V_MU real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(in), dimension(params%pchunk) :: flagCon integer(kind=is), intent(in), dimension(params%pchunk) :: flagCol real(kind=rp), intent(out), dimension(F%dim_1D) :: Vden public subroutine calculate_SC_p_FS (params, F, B_R, B_PHI, B_Z, PSIp, V_PLL, V_MU, m_cache, flagCon, flagCol, dintJphidPSIP) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(in) :: F real(kind=rp), intent(in), dimension(params%pchunk) :: B_R real(kind=rp), intent(in), dimension(params%pchunk) :: B_PHI real(kind=rp), intent(in), dimension(params%pchunk) :: B_Z real(kind=rp), intent(in), dimension(params%pchunk) :: PSIp real(kind=rp), intent(in), dimension(params%pchunk) :: V_PLL real(kind=rp), intent(in), dimension(params%pchunk) :: V_MU real(kind=rp), intent(in) :: m_cache integer(kind=is), intent(in), dimension(params%pchunk) :: flagCon integer(kind=is), intent(in), dimension(params%pchunk) :: flagCol real(kind=rp), intent(out), dimension(F%dim_1D) :: dintJphidPSIP public subroutine init_SC_E1D (params, F, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F type(SPECIES), intent(in) :: spp public subroutine init_SC_E1D_FS (params, F, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F type(SPECIES), intent(in) :: spp public subroutine reinit_SC_E1D (params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F public subroutine reinit_SC_E1D_FS (params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F public subroutine initialize_fields (params, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params Core KORC simulation parameters. type(FIELDS), intent(out) :: F An instance of the KORC derived type FIELDS. Read more… private subroutine initialize_GC_fields (F) Computes the auxiliary fields and that are used in the RHS of the\n evolution equations for the GC orbit model. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. private subroutine initialize_GC_fields_3D (F) Computes the auxiliary fields and that are used in the RHS of the\n evolution equations for the GC orbit model. Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. public subroutine define_SC_time_step (params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params type(FIELDS), intent(inout) :: F public subroutine load_dim_data_from_hdf5 (params, F) @brief Subroutine that loads the size of the arrays having the electric and magnetic field data.\n @details All the information of externally calculated fields must be given in a rectangular, equally spaced mesh in the space of cylindrical coordinates.\n If the fields are axisymmetric, then the fields must be in a rectangular mesh on the -plane. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F public subroutine which_fields_in_file (params, Bfield, Efield, Bflux, dBfield) @brief Subroutine that queries the HDF5 file what data are present in the HDF5 input file (sanity check). Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params logical, intent(out) :: Bfield logical, intent(out) :: Efield logical, intent(out) :: Bflux logical, intent(out) :: dBfield public subroutine load_field_data_from_hdf5 (params, F) @brief Subroutine that loads the fields data from the HDF5 input file. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F public subroutine load_1D_FS_from_hdf5 (params, F) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F public subroutine allocate_1D_FS_arrays (params, F) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. In this variable we keep\n the loaded data. public subroutine ALLOCATE_2D_FIELDS_ARRAYS (params, F, bfield, bflux, dbfield, efield) Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params Core KORC simulation parameters. type(FIELDS), intent(inout) :: F An instance of the KORC derived type FIELDS. In this variable we keep\n the loaded data. logical, intent(in) :: bfield logical, intent(in) :: bflux Logical variable that specifies if the variables that keep the poloidal\n magnetic flux data is allocated (bflux=T) or not (bflux=F). logical, intent(in) :: dbfield Logical variable that specifies if the variables that keep the magnetic\n field data is allocated (bfield=T) or not (bfield=F). logical, intent(in) :: efield Logical variable that specifies if the variables that keep the electric\n field data is allocated (efield=T) or not (efield=F). public subroutine ALLOCATE_3D_FIELDS_ARRAYS (params, F, bfield, efield, dbfield) @brief Subroutine that allocates the variables keeping the 3-D fields data. Read more… Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(in) :: params type(FIELDS), intent(inout) :: F logical, intent(in) :: bfield logical, intent(in) :: efield logical, intent(in) :: dbfield private subroutine ALLOCATE_V_FIELD_2D (F, dims) @brief Subroutine that allocates the cylindrical components of an axisymmetric field. Read more… Arguments Type Intent Optional Attributes Name type(V_FIELD_2D), intent(inout) :: F integer, intent(in), DIMENSION(3) :: dims private subroutine ALLOCATE_V_FIELD_3D (F, dims) @brief Subroutine that allocates the cylindrical components of a 3-D field. Read more… Arguments Type Intent Optional Attributes Name type(V_FIELD_3D), intent(inout) :: F integer, intent(in), DIMENSION(3) :: dims public subroutine DEALLOCATE_FIELDS_ARRAYS (F) @brief Subroutine that deallocates all the variables of the electric and magnetic fields. Read more… Arguments Type Intent Optional Attributes Name type(FIELDS), intent(inout) :: F","tags":"","loc":"module/korc_fields.html"},{"title":"korc_constants – KORC-Full Orbit","text":"@brief Module containing physical and mathematical constants to be used in KORC.\n @details In this module we define the constant parameters to be used in KORC. Notice that the numerical precision of these quantities is '_rp', see korc_types.f90.\n Any new constant needs to be compliant with the numerical precision used in KORC. Uses korc_types Contents Variables C_PI C_E C_ME C_MP C_U C_KB C_C C_MU C_E0 C_Ke C_RE C_h C_a Variables Type Visibility Attributes Name Initial real(kind=rp), public, parameter :: C_PI = 4.0_rp*ATAN(1.0_rp) real(kind=rp), public, parameter :: C_E = 1.602176E-19_rp real(kind=rp), public, parameter :: C_ME = 9.109382E-31_rp real(kind=rp), public, parameter :: C_MP = 1.672621E-27_rp real(kind=rp), public, parameter :: C_U = 1.660538E-27_rp real(kind=rp), public, parameter :: C_KB = 1.380650E-23_rp real(kind=rp), public, parameter :: C_C = 299792458.0_rp real(kind=rp), public, parameter :: C_MU = 4.0_rp*C_PI*1E-7_rp real(kind=rp), public, parameter :: C_E0 = 1.0_rp/(C_MU*C_C**2) real(kind=rp), public, parameter :: C_Ke = 1.0_rp/(4.0_rp*C_PI*C_E0) real(kind=rp), public, parameter :: C_RE = C_E**2/(4.0_rp*C_PI*C_E0*C_ME*C_C**2) real(kind=rp), public, parameter :: C_h = 6.6261E-34_rp real(kind=rp), public, parameter :: C_a = 1._rp/137._rp","tags":"","loc":"module/korc_constants.html"},{"title":"korc_coords – KORC-Full Orbit","text":"Note Module containing subroutines to calculate the position of\n the simulated particles in toroidal and cylindrical coordinates. Uses korc_types korc_constants Contents Subroutines cart_to_cyl cart_to_cyl_p cyl_to_cart cyl_check_if_confined cyl_check_if_confined_p cart_to_tor_check_if_confined cart_to_tor_p cart_to_tor_check_if_confined_p Subroutines public subroutine cart_to_cyl (X, Xcyl) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: X Particles' position in Cartesian coordinates. X(1,:) = , X(2,:)\n = , X(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: Xcyl Particles' position in cylindrical coordinates. Xcyl(1,:) = ,\n Xcyl(2,:) = , Xcyl(3,:) = public subroutine cart_to_cyl_p (pchunk, X_X, X_Y, X_Z, Y_R, Y_PHI, Y_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: Y_R real(kind=rp), intent(out), DIMENSION(pchunk) :: Y_PHI real(kind=rp), intent(out), DIMENSION(pchunk) :: Y_Z public subroutine cyl_to_cart (Xcyl, X) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Xcyl Particles' position in cylindrical coordinates. Xcyl(1,:) = ,\n Xcyl(2,:) = , Xcyl(3,:) = real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: X Particles' position in Cartesian coordinates. X(1,:) = , X(2,:)\n = , X(3,:) = public subroutine cyl_check_if_confined (F, Xcyl, flag) Arguments Type Intent Optional Attributes Name type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: Xcyl Particles' position in cylindrical coordinates. Xcyl(1,:) = ,\n Xcyl(2,:) = , Xcyl(3,:) = integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag public subroutine cyl_check_if_confined_p (pchunk, a, R0, Xcyl_R, Xcyl_Z, flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: a Distance to plasma edge as measured from the magnetic axis. real(kind=rp), intent(in) :: R0 Distance to plasma edge as measured from the magnetic axis. real(kind=rp), intent(in), DIMENSION(pchunk) :: Xcyl_R real(kind=rp), intent(in), DIMENSION(pchunk) :: Xcyl_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag public subroutine cart_to_tor_check_if_confined (X, F, Xtor, flag) Read more… Arguments Type Intent Optional Attributes Name real(kind=rp), intent(in), DIMENSION(:,:), ALLOCATABLE :: X Particles' position in Cartesian coordinates. X(1,:) = , X(2,:)\n = , X(3,:) = type(FIELDS), intent(in) :: F An instance of the KORC derived type FIELDS. real(kind=rp), intent(inout), DIMENSION(:,:), ALLOCATABLE :: Xtor Particles' position in cylindrical coordinates. Xtor(1,:) = , Xtor(2,:) = , Xtor(3,:) = integer(kind=is), intent(inout), DIMENSION(:), ALLOCATABLE :: flag public subroutine cart_to_tor_p (pchunk, R0, X_X, X_Y, X_Z, T_R, T_T, T_Z) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: T_R real(kind=rp), intent(out), DIMENSION(pchunk) :: T_T real(kind=rp), intent(out), DIMENSION(pchunk) :: T_Z public subroutine cart_to_tor_check_if_confined_p (pchunk, ar, R0, X_X, X_Y, X_Z, T_R, T_T, T_Z, flag_cache) Arguments Type Intent Optional Attributes Name integer, intent(in) :: pchunk real(kind=rp), intent(in) :: ar real(kind=rp), intent(in) :: R0 real(kind=rp), intent(in), DIMENSION(pchunk) :: X_X real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Y real(kind=rp), intent(in), DIMENSION(pchunk) :: X_Z real(kind=rp), intent(out), DIMENSION(pchunk) :: T_R real(kind=rp), intent(out), DIMENSION(pchunk) :: T_T real(kind=rp), intent(out), DIMENSION(pchunk) :: T_Z integer(kind=is), intent(inout), DIMENSION(pchunk) :: flag_cache","tags":"","loc":"module/korc_coords.html"},{"title":"korc_rnd_numbers – KORC-Full Orbit","text":"Note Module with subrotuines for generating integer \n and real random numbers. This subroutines were taken from Numerical Recipes in Fortran 90, \n and provide a way for generating random numbers of 'better quality' \n in a faster way than build-in Fortran random generators (at least better than those of Fortran 77). For more details we refer the user \n to Numerical Recipes in Fortran 90. Uses ifport korc_types Contents Variables iv iw a b d e rcoeff urand_vars Interfaces u_random Derived Types URAND Subroutines init_u_random rand_int64 rand_int32 rand_real_array rand_real init_random_seed Variables Type Visibility Attributes Name Initial integer(kind=8), public, parameter :: iv = 4101842887655102017_8 integer(kind=8), public, parameter :: iw = 1_8 integer(kind=8), public, parameter :: a = 4294957665_8 integer(kind=8), public, parameter :: b = 4294967295_8 integer(kind=8), public, parameter :: d = 2862933555777941757_8 integer(kind=8), public, parameter :: e = 7046029254386353087_8 real(kind=rp), public, parameter :: rcoeff = 5.42101086242752217E-20_rp type( URAND ), private :: urand_vars Interfaces public interface u_random private subroutine rand_int64 (irand) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out), optional :: irand private subroutine rand_int32 (irand32) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: irand32 private subroutine rand_real (rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out) :: rrand public subroutine rand_real_array (rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), DIMENSION(:) :: rrand Derived Types type, private :: URAND Components Type Visibility Attributes Name Initial integer(kind=8), public :: u integer(kind=8), public :: v integer(kind=8), public :: w Subroutines public subroutine init_u_random (seed) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: seed private subroutine rand_int64 (irand) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out), optional :: irand private subroutine rand_int32 (irand32) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: irand32 public subroutine rand_real_array (rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(inout), DIMENSION(:) :: rrand private subroutine rand_real (rrand) Arguments Type Intent Optional Attributes Name real(kind=rp), intent(out) :: rrand public subroutine init_random_seed () Arguments None","tags":"","loc":"module/korc_rnd_numbers.html"},{"title":"korc_m3d_c1 – KORC-Full Orbit","text":"Uses iso_c_binding korc_types korc_input Contents Variables FIO_SUCCESS FIO_OUT_OF_BOUNDS FIO_NO_DATA FIO_M3DC1_SOURCE FIO_TIMESLICE FIO_SPECIES FIO_ELECTRON FIO_DENSITY FIO_TEMPERATURE FIO_ELECTRIC_FIELD FIO_MAGNETIC_FIELD FIO_VECTOR_POTENTIAL Interfaces fio_add_field fio_allocate_search_hint fio_close_field fio_close_series fio_close_source fio_create_compound_field fio_deallocate_search_hint fio_eval_field fio_eval_field_deriv fio_eval_series fio_get_options fio_get_available_fields fio_open_source fio_get_field fio_set_int_option Subroutines initialize_m3d_c1 Variables Type Visibility Attributes Name Initial integer(kind=C_INT), public, parameter :: FIO_SUCCESS = 0 integer(kind=C_INT), public, parameter :: FIO_OUT_OF_BOUNDS = 10002 integer(kind=C_INT), public, parameter :: FIO_NO_DATA = 10006 integer(kind=C_INT), public, parameter :: FIO_M3DC1_SOURCE = 3 integer(kind=C_INT), public, parameter :: FIO_TIMESLICE = 1 integer(kind=C_INT), public, parameter :: FIO_SPECIES = 3 integer(kind=C_INT), public, parameter :: FIO_ELECTRON = 1 integer(kind=C_INT), public, parameter :: FIO_DENSITY = 102 integer(kind=C_INT), public, parameter :: FIO_TEMPERATURE = 103 integer(kind=C_INT), public, parameter :: FIO_ELECTRIC_FIELD = 1001 integer(kind=C_INT), public, parameter :: FIO_MAGNETIC_FIELD = 1003 integer(kind=C_INT), public, parameter :: FIO_VECTOR_POTENTIAL = 1002 Interfaces interface public function fio_add_field(icfield, ifield, op, fac) bind(C, NAME='fio_add_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: icfield integer(kind=C_INT), intent(in), VALUE :: ifield integer(kind=C_INT), intent(in), VALUE :: op real(kind=C_DOUBLE), intent(in), VALUE :: fac Return Value integer(kind=C_INT) interface public function fio_allocate_search_hint(isrc, hint) bind(C, NAME='fio_allocate_search_hint') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc type(C_PTR), intent(out) :: hint Return Value integer(kind=C_INT) interface public function fio_close_field(ifield) bind(C, NAME='fio_close_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: ifield Return Value integer(kind=C_INT) interface public function fio_close_series(iseries) bind(C, NAME='fio_close_series') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: iseries Return Value integer(kind=C_INT) interface public function fio_close_source(isrc) bind(C, NAME='fio_close_source') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc Return Value integer(kind=C_INT) interface public function fio_create_compound_field(ifield) bind(C, NAME='fio_create_compound_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in) :: ifield Return Value integer(kind=C_INT) interface public function fio_deallocate_search_hint(isrc, hint) bind(C, NAME='fio_deallocate_search_hint') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc type(C_PTR), intent(inout) :: hint Return Value integer(kind=C_INT) interface public function fio_eval_field(ifield, x, v, hint) bind(C, NAME='fio_eval_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: ifield real(kind=C_DOUBLE), intent(in) :: x real(kind=C_DOUBLE), intent(out) :: v type(C_PTR), intent(in), VALUE :: hint Return Value integer(kind=C_INT) interface public function fio_eval_field_deriv(ifield, x, v, hint) bind(C, NAME='fio_eval_field_deriv') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: ifield real(kind=C_DOUBLE), intent(in) :: x real(kind=C_DOUBLE), intent(out) :: v type(C_PTR), intent(in), VALUE :: hint Return Value integer(kind=C_INT) interface public function fio_eval_series(iseries, x, v) bind(C, NAME='fio_eval_series') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: iseries real(kind=C_DOUBLE), intent(in) :: x real(kind=C_DOUBLE), intent(out) :: v Return Value integer(kind=C_INT) interface public function fio_get_options(isrc) bind(C, NAME='fio_get_options') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc Return Value integer(kind=C_INT) interface public function fio_get_available_fields(isrc, n, f) bind(C, NAME='fio_get_available_fields') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc integer(kind=C_INT), intent(out) :: n integer(kind=C_INT), intent(out), DIMENSION(:) :: f Return Value integer(kind=C_INT) interface public function fio_open_source(itype, filename, handle) bind(C, NAME='fio_open_source') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: itype character(kind=C_CHAR,len=1), intent(in) :: filename integer(kind=C_INT), intent(out) :: handle Return Value integer(kind=C_INT) interface public function fio_get_field(isrc, type, handle) bind(C, NAME='fio_get_field') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: isrc integer(kind=C_INT), intent(in), VALUE :: type integer(kind=C_INT), intent(inout) :: handle Return Value integer(kind=C_INT) interface public function fio_set_int_option(iopt, v) bind(C, NAME='fio_set_int_option') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), intent(in), VALUE :: iopt integer(kind=C_INT), intent(in), VALUE :: v Return Value integer(kind=C_INT) Subroutines public subroutine initialize_m3d_c1 (params, F, P, spp) Arguments Type Intent Optional Attributes Name type(KORC_PARAMS), intent(inout) :: params type(FIELDS), intent(inout) :: F type(PROFILES), intent(inout) :: P type(SPECIES), intent(inout), DIMENSION(:) :: spp","tags":"","loc":"module/korc_m3d_c1.html"},{"title":"main – KORC-Full Orbit","text":"Uses korc_types korc_units korc_hpc korc_HDF5 korc_fields korc_ppusher korc_interp korc_collisions korc_initialize korc_finalize korc_profiles korc_input Note Main function of KORC. The main program contains the calls to the main functions and subroutines. \n Also, it contains the variables that control\n the behavior of the core of KORC and all other external/optional modules. Order of KORC operations Communication and Timing 1. Parallel Communications Subroutine initialize_communications in korc_hpc that \n initializes MPI and OpenMP communications. 2. Timers Subroutine timing_KORC in korc_hpc that times the \n execution of any parallel sections of KORC. Initialization 1. HDF5 Subroutine initialize_HDF5 in korc_HDF5 that initializes\n HDF5 library. 2. Initialize korc parameters Subroutine initialize_korc_parameters in korc_initialize that \n initializes paths and KORC parameters through load_korc_params on MPI processes. 3. Initialize fields Subroutine initialize_fields in korc_fields that initializes \n parameters of the EM fields, either analytically or from an external HDF5\n file. Reads in &analytical_fields_params and \n &externalPlasmaModel namelists from input file. 4. Initialize Profiles Subroutine initialize_profiles in korc_profiles that initializes \n parameters of the plasma profiles, either analytically or from an\n external HDF5\n file. Reads in &plasmaProfiles namelist from input file.\n Only initialized if collisions (params%collisions==T) are 5. Initialize Particle Velocity Phase Space Subroutine initialize_particles in korc_initialize that \n initializes particle parameters from &amplasma_species namelist, \n allocates arrays for individual particles, including location, velocity, \n local EM fields and plasma profiles, etc., and \n calls initial_energy_pitch_dist to assign particles' energy and pitch\n angle according to the chosen distribution. 9. Compute Characteristic Plasma Parameters Subroutine compute_charcs_plasma_params in korc_units calculates\n the characteristic plasma parameters params%cpp that are used for normalizations.\n Also finds the maximum non-relativistic and relativistic cyclotron frequencies\n to be used for setting the timstep for the time-evolution algorithms. 6. Initialize Collision Parameters Subroutine initialize_collision_params in korc_collisions that\n initializes collision parameters for the SS (single-species) and MS\n (multiple-species) data types, reading in namefiles from the KORC input file.\n MS reads in namelist &CollisionParamsMultipleSpecies while SS reads in\n namelist &CollisionParamsSingleSpecies. 10. Define Time Step Subroutine define_time_step in korc_initialize either loads\n time-stepping parameters for a restart, or defines new parameters based\n on a maximum timestep\n set by the inverse of the relativistic cyclotron frequency. 11. Initialize Particle Pusher 12. Normalize Variables Subroutine normalize_variables in korc_units normalizes \n variables consistent with characteristic plasma parameters \n calculated in compute_charcs_plasma_params . 13. Normalize Collision Parameters Subroutine normalize_collisions_params in korc_collisions that\n normalizes collision parameters for the SS (single-species) and MS\n (multiple-species) data types. 14. Define Collision Time Step Subroutine define_collisions_time_step in korc_collisions that\n sets subcycling iteration number for collisions based off of the collision\n frequency model used. 15. Initialize Fields Interpolant Subroutine initialize_fields_interpolant in korc_interp calls\n EZspline\n subroutines EZspline_init for memory allocation and boundary condition\n setup\n and EZspline_setup to compute the necessary cubic coefficients needed\n for subsequent\n field interpolations. The magnetic field can be defined in terms of an\n axisymmetric\n scalar flux function, axisymmetric field, or 3D field, while the\n electric field\n can be defined as an axisymmetric or 3D field. 16. Initialize Profiles Interpolant Subroutine initialize_profiles_interpolant in korc_interp calls EZspline\n subroutines EZlinear_init for axisymmetric (flux-surface quantities) or\n EZspline_init for 3D profiles for memory allocation and boundary\n condition setup\n and EZspline_setup to compute the necessary cubic coefficients needed\n for subsequent\n field interpolations. \n Only initialized if collisions (params%collisions==T) are present for\n ne, Te, Zeff 17. Set Particle Initial Conditions Subroutine set_up_particles_ic in korc_initialize calls\n subroutines to prescribe initial conditions or load them \n from file for a restart. Initial spatial values are prescribed with intitial_spatial_distribution in korc_spatial_distribution and \n initial velocity values are prescribed with initial_gyro_distribution in korc_velocity_distribution . 18. Save Simulation and Collision Parameters Subroutines save_simulation_parameters in korc_HDF5 and save_collision_params in korc_collisions call\n subroutines to save simulation and collision parameters. Contents Variables params spp F P it mpierr Source Code main Variables Type Attributes Name Initial type(KORC_PARAMS) :: params Contains the parameters that control the core of KORC: \n time steping, output list, etc. type(SPECIES), DIMENSION(:), ALLOCATABLE :: spp Contains the initial parameters of each species, which \n can be different electrons with different\n distribution functions. type(FIELDS) :: F and electric fields, or in the case of using \n external fields it contains the data used in the interpolations. \nSee korc_fields for details. type(PROFILES) :: P or in the case of using external \n fields it contains the data used in the interpolations. \n See korc_profiles for details. integer(kind=ip) :: it Time iteration integer :: mpierr Source Code program main !! @note  Main function of KORC. @endnote !! The main program contains the calls to the main functions and subroutines. !! Also, it contains the variables that control !! the behavior of the core of KORC and all other external/optional modules. use korc_types use korc_units use korc_hpc use korc_HDF5 use korc_fields use korc_ppusher use korc_interp use korc_collisions use korc_initialize use korc_finalize use korc_profiles use korc_input implicit none TYPE ( KORC_PARAMS ) :: params !! Contains the parameters that control the core of KORC: !! time steping, output list, etc. TYPE ( SPECIES ), DIMENSION (:), ALLOCATABLE :: spp !! Contains the initial parameters of each species, which !! can be different electrons with different !! distribution functions. TYPE ( FIELDS ) :: F !! F: Contains the parameters of the analytical magnetic !! and electric fields, or in the case of using !! external fields it contains the data used in the interpolations. !!See [[korc_fields(module)]] for details. TYPE ( PROFILES ) :: P !! P: Contains the parameters of the analytical plasma profiles, !! or in the case of using external !! fields it contains the data used in the interpolations. !! See [[korc_profiles(module)]] for details. INTEGER ( ip ) :: it !! Time iteration INTEGER :: mpierr call initialize_communications ( params ) !!<h2>Order of KORC operations</h2> !! !!<h3>Communication and Timing</h3> !! <h4>1\\. Parallel Communications</h4> !! !! Subroutine [[initialize_communications]] in [[korc_hpc]] that !! initializes MPI and OpenMP communications. call timing_KORC ( params ) !! <h4>2\\. Timers</h4> !! !! Subroutine [[timing_KORC]] in [[korc_hpc]] that times the !! execution of any parallel sections of KORC. ! * * * INITIALIZATION STAGE * * *! call initialize_HDF5 () !!<h3>Initialization</h3> !! !! <h4>1\\. HDF5</h4> !! !! Subroutine [[initialize_HDF5]] in [[korc_HDF5]] that initializes !! HDF5 library. call initialize_korc_parameters ( params ) !! <h4>2\\. Initialize korc parameters</h4> !! !! Subroutine [[initialize_korc_parameters]] in [[korc_initialize]] that !! initializes paths and KORC parameters through [[load_korc_params]] !! on MPI processes. call initialize_fields ( params , F ) !! <h4>3\\. Initialize fields</h4> !! !! Subroutine [[initialize_fields]] in [[korc_fields]] that initializes !! parameters of the EM fields, either analytically or from an external HDF5 !! file. Reads in &amp;analytical_fields_params and !! &amp;externalPlasmaModel namelists from input file. call initialize_profiles ( params , P , F ) !! <h4>4\\. Initialize Profiles</h4> !! !! Subroutine [[initialize_profiles]] in [[korc_profiles]] that initializes !! parameters of the plasma profiles, either analytically or from an !! external HDF5 !! file. Reads in &amp;plasmaProfiles namelist from input file. !! Only initialized if collisions (params%collisions==T) are call initialize_particles ( params , F , P , spp ) ! Initialize particles !! <h4>5\\. Initialize Particle Velocity Phase Space</h4> !! !! Subroutine [[initialize_particles]] in [[korc_initialize]] that !! initializes particle parameters from &amplasma_species namelist, !! allocates arrays for individual particles, including location, velocity, !! local EM fields and plasma profiles, etc., and !! calls [[initial_energy_pitch_dist]] to assign particles' energy and pitch !! angle according to the chosen distribution. !  write(output_unit_write,'(\"init eta: \",E17.10)') spp(1)%vars%eta #ifdef M3D_C1 if ( TRIM ( params % field_model ) . eq . 'M3D_C1' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) \"* * * * INITIALIZING M3D-C1 INTERFACE * * * *\" endif call initialize_m3d_c1 ( params , F , P , spp ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) \"* * * * * * * * * * * * * * * * * * * * * * *\" endif endif #endif call compute_charcs_plasma_params ( params , spp , F ) !! <h4>9\\. Compute Characteristic Plasma Parameters</h4> !! !! Subroutine [[compute_charcs_plasma_params]] in [[korc_units]] calculates !! the characteristic plasma parameters params%cpp that are used for normalizations. !! Also finds the maximum non-relativistic and relativistic cyclotron frequencies !! to be used for setting the timstep for the time-evolution algorithms. call initialize_collision_params ( params ) !! <h4>6\\. Initialize Collision Parameters</h4> !! !! Subroutine [[initialize_collision_params]] in [[korc_collisions]] that !! initializes collision parameters for the SS (single-species) and MS !! (multiple-species) data types, reading in namefiles from the KORC input file. !! MS reads in namelist &CollisionParamsMultipleSpecies while SS reads in !! namelist &CollisionParamsSingleSpecies. call define_time_step ( params ) !! <h4>10\\. Define Time Step</h4> !! !! Subroutine [[define_time_step]] in [[korc_initialize]] either loads !! time-stepping parameters for a restart, or defines new parameters based !! on a maximum timestep !! set by the inverse of the relativistic cyclotron frequency. call initialize_particle_pusher ( params ) !! <h4>11\\. Initialize Particle Pusher</h4> if ( params % SC_E ) then call define_SC_time_step ( params , F ) end if call normalize_variables ( params , spp , F , P ) !! <h4>12\\. Normalize Variables</h4> !! !! Subroutine [[normalize_variables]] in [[korc_units]] normalizes !! variables consistent with characteristic plasma parameters !! calculated in [[compute_charcs_plasma_params]]. call normalize_collisions_params ( params ) !! <h4>13\\. Normalize Collision Parameters </h4> !! !! Subroutine [[normalize_collisions_params]] in [[korc_collisions]] that !! normalizes collision parameters for the SS (single-species) and MS !! (multiple-species) data types. call define_collisions_time_step ( params ) !! <h4>14\\. Define Collision Time Step</h4> !! !! Subroutine [[define_collisions_time_step]] in [[korc_collisions]] that !! sets subcycling iteration number for collisions based off of the collision !! frequency model used. ! *** *** *** *** *** ***   *** *** *** *** *** *** *** ! *** BEYOND THIS POINT VARIABLES ARE DIMENSIONLESS *** ! *** *** *** *** *** ***   *** *** *** *** *** *** *** call initialize_fields_interpolant ( params , F ) !! <h4>15\\. Initialize Fields Interpolant</h4> !! !! Subroutine [[initialize_fields_interpolant]] in [[korc_interp]] calls !! EZspline !! subroutines EZspline_init for memory allocation and boundary condition !! setup !! and EZspline_setup to compute the necessary cubic coefficients needed !! for subsequent !! field interpolations. The magnetic field can be defined in terms of an !! axisymmetric !! scalar flux function, axisymmetric field, or 3D field, while the !! electric field !! can be defined as an axisymmetric or 3D field. call initialize_profiles_interpolant ( params , P ) !! <h4>16\\. Initialize Profiles Interpolant</h4> !! !! Subroutine [[initialize_profiles_interpolant]] in [[korc_interp]] !! calls EZspline !! subroutines EZlinear_init for axisymmetric (flux-surface quantities) or !! EZspline_init for 3D profiles for memory allocation and boundary !! condition setup !! and EZspline_setup to compute the necessary cubic coefficients needed !! for subsequent !! field interpolations. !! Only initialized if collisions (params%collisions==T) are present for !! ne, Te, Zeff if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * INITIALIZING INITIAL CONDITIONS * * * *\",/)' ) end if call set_up_particles_ic ( params , F , spp , P ) if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"* * * * * * * * * * * * * * * * * * * * * * * *\",/)' ) end if !  write(output_unit_write,'(\"post ic eta: \",E17.10)') spp(1)%vars%eta !! <h4>17\\. Set Particle Initial Conditions</h4> !! !! Subroutine [[set_up_particles_ic]] in [[korc_initialize]] calls !! subroutines to prescribe initial conditions or load them !! from file for a restart. Initial spatial values are prescribed with !! [[intitial_spatial_distribution]] in [[korc_spatial_distribution]] and !! initial velocity values are prescribed with [[initial_gyro_distribution]] !! in [[korc_velocity_distribution]]. !  if (minval(spp(1)%vars%Y(:,1)).lt.1._rp/params%cpp%length) stop 'error with init' ! * * * INITIALIZATION STAGE * * * !  write(output_unit_write,'(\"GC init eta: \",E17.10)') spp(1)%vars%eta if (. NOT .( params % restart . OR . params % proceed . or . params % reinit )) then if ( params % orbit_model ( 1 : 2 ). eq . 'FO' ) then call FO_init ( params , F , spp ,. true .,. false .) else if ( params % orbit_model ( 1 : 2 ). eq . 'GC' ) then call GC_init ( params , F , spp ) end if if ( params % SC_E ) then if ( params % field_model ( 1 : 1 ). eq . 'A' ) then call init_SC_E1D ( params , F , spp ( 1 )) else if ( params % field_model ( 1 : 1 ). eq . 'E' ) then call init_SC_E1D_FS ( params , F , spp ( 1 )) end if end if else call get_fields ( params , spp ( 1 )% vars , F ) if ( params % SC_E ) then if ( params % field_model ( 1 : 1 ). eq . 'A' ) then call reinit_SC_E1D ( params , F ) else if ( params % field_model ( 1 : 1 ). eq . 'E' ) then call reinit_SC_E1D_FS ( params , F ) end if end if end if ! * * * SAVING INITIAL CONDITION AND VARIOUS SIMULATION PARAMETERS * * * ! call save_simulation_parameters ( params , spp , F , P ) call save_collision_params ( params ) !! <h4>18\\. Save Simulation and Collision Parameters</h4> !! !! Subroutines [[save_simulation_parameters]] in [[korc_HDF5]] and !! [[save_collision_params]] in [[korc_collisions]] call !! subroutines to save simulation and collision parameters. if (. NOT .( params % restart . OR . params % proceed )) then call save_simulation_outputs ( params , spp , F ) ! Save initial condition end if ! * * * SAVING INITIAL CONDITION AND VARIOUS SIMULATION PARAMETERS * * * ! !  write(output_unit_write,'(\"pre ppusher loop eta: \",E17.10)') spp(1)%vars%eta call timing_KORC ( params ) if ( params % orbit_model ( 1 : 2 ). eq . 'FO' . and . params % field_model ( 1 : 3 ). eq . 'ANA' ) then call FO_init ( params , F , spp ,. false .,. true .) ! Initial half-time particle push do it = params % ito , params % t_steps , params % t_skip call adv_FOeqn_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'FO' . and . params % field_model ( 1 : 3 ). eq . 'EXT' ) then call FO_init ( params , F , spp ,. false .,. true .) ! Initial half-time particle push do it = params % ito , params % t_steps , params % t_skip call adv_FOinterp_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'FO' . and . params % field_model . eq . 'M3D_C1' ) then call FO_init ( params , F , spp ,. false .,. true .) ! Initial half-time particle push do it = params % ito , params % t_steps , params % t_skip call adv_FOm3dc1_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'eqn' . and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip * params % t_it_SC call adv_GCeqn_top ( params , F , P , spp ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip * params % t_it_SC , rp ) * params % dt params % it = it - 1_ip + params % t_skip * params % t_it_SC call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and . params % field_model ( 10 : 12 ). eq . 'PSI' . and . & params % SC_E . and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psi_top_FS ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . 'PSI' . OR . & params % field_model ( 12 : 14 ). eq . 'PSI' ). and . & (. not . params % SC_E ). and .(. not . F % Dim2x1t ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psi_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . 'PSI' . OR . & params % field_model ( 12 : 14 ). eq . 'PSI' ). and . & (. not . params % SC_E ). and . F % Dim2x1t . and .(. not . F % ReInterp_2x1t ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psi2x1t_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . 'PSI' . OR . & params % field_model ( 12 : 14 ). eq . 'PSI' ). and . & (. not . params % SC_E ). and . F % Dim2x1t . and . F % ReInterp_2x1t . and .. not . params % field_model . eq . 'M3D_C1' ) then if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) 'time' , F % X % PHI ( F % ind_2x1t ) * params % cpp % time end if do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_psiwE_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) F % ind_2x1t = F % ind_2x1t + 1_ip if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , * ) 'time' , F % X % PHI ( F % ind_2x1t ) * params % cpp % time end if call initialize_fields_interpolant ( params , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and . F % dBfield . and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_2DBdB_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & F % axisymmetric_fields . and .( params % field_model ( 10 : 12 ). eq . '2DB' . or . & params % field_model ( 12 : 13 ). eq . '2D' ). and .. not .( F % dBfield ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_B2D_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & . not .( F % axisymmetric_fields ). and .( F % dBfield ). and . & ( params % field_model ( 10 : 14 ). eq . '3DBdB' ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_3DBdB_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & . not .( F % axisymmetric_fields ). and .( F % dBfield ). and . & . not .( params % field_model ( 10 : 14 ). eq . '3DBdB' ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_3DBdB1_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_eval . eq . 'interp' . and . & . not .( F % axisymmetric_fields ). and .. not .( F % dBfield ). and .. not . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_B_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip , rp ) * params % dt params % it = it - 1_ip + params % t_skip call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if if ( params % orbit_model ( 1 : 2 ). eq . 'GC' . and . params % field_model . eq . 'M3D_C1' ) then do it = params % ito , params % t_steps , params % t_skip call adv_GCinterp_m3dc1_top ( params , spp , P , F ) params % time = params % init_time & + REAL ( it - 1_ip + params % t_skip * params % t_it_SC , rp ) * params % dt params % it = it - 1_ip + params % t_skip * params % t_it_SC call save_simulation_outputs ( params , spp , F ) call save_restart_variables ( params , spp , F ) end do end if call timing_KORC ( params ) ! * * * FINALIZING SIMULATION * * * call finalize_HDF5 () call finalize_interpolants ( params ) ! DEALLOCATION OF VARIABLES call deallocate_variables ( params , F , spp ) call deallocate_collisions_params ( params ) call finalize_communications ( params ) ! * * * FINALIZING SIMULATION * * * if ( params % mpi_params % rank . EQ . 0 ) then write ( output_unit_write , '(\"KORC ran successfully!\")' ) close ( output_unit_write ) end if end program main","tags":"","loc":"program/main.html"},{"title":"README – KORC-Full Orbit","text":"Welcome! Here you will find doumentation for the use of KORC. Please refer to the \npages within for more information on specific aspect of running the code.","tags":"","loc":"page//index.html"},{"title":"Leopoldo's KORC documentation – KORC-Full Orbit","text":"Note KORC and its documentation are in constant evolution. This makes it possible that there are issues that need to be solved.\nIf you find an issue please report it immediatly through the \"issues\" section of the github repository. Introduction The Kinetic Orbit Runaway electrons Code (KORC) is a full-orbit particle tracer that evolves relativistic electrons in both\nanalytical and grid-based pre-computed electric and magnetic fields. KORC includes the effects of: the acceleration of the\nelectrons due to the electric field, synchrotron radiation energy losses, and collisions with the background plasma containing\nhigh-Z impurities. For details about the equations of motion of the relativistic electrons followed by KORC we refer the user to Carbajal et al. Phys. Plasmas 24 , 042512 (2017) and Carbajal and del-Castillo-Negrete, Nuclear Fusion,\nsubmitted (2018) . Also, for details about the KORC's synchrotron radiation synthetic diagnostic we refer the user to Carbajal and del-Castillo-Negrete, Plasma Phys. Controll. Fusion 59 , 124001 (2017) . KORC is a modular Fortran 95 code that uses a hybrid MPI + open MP parallelization paradigm to exploit multi-core nodes systems,\nsuch as Cori and Edison NERSC systems ( www.nersc.gov ). Installation Warning KORC has been installed and tested in systems with OS 10.6 and higher, Ubuntu 14.04, and SuSe 12. Though we have paid\nspecial attention to portability when developing KORC, there is no guarantee that KORC can be compiled, ran, and is accurate in\nother systems not listed above. As a rule of thumb, we recommend to perform any convenient benchmark tests when compiling and\nrunning KORC in a new system, this to make sure that the external libraries and compilers do not modify the simulation results. Getting started To compile and run KORC you will need the following: The HDF5 library for I/O. The PSPLINES library for interpolating the pre-computed electric and magnetic\nfields as well as the plasma profiles. The GNU compilers suite, or The INTEL compilers suite. The corresponding open MP library The MPI or open MPI library Git, for obtaining the latest version of KORC. The HDF5 and PSPLINES libraries need to be installed BEFORE compiling KORC, or if these are already present in the system, they\nneed to be loaded to your environment and their installation paths need to be added to the Makefile accordingly. We refer the\nuser to the documentation of HDF5 and PSPLINES for the specifics about their installation. If you are installing the HDF5 and PSPLINES libraries in your system, we recommend to perform a local installation. Then enter\nthe absolute path of the folder containing the \"lib\" and \"bin\" folders of each library to the PSPLINE_INSTALL\nand HDF5_INSTALL variables of the Makefile. Note PSPLINES is known for having precision issues sometimes when compiled using the INTEL compilers suite in Linux systems.\nPlease, double-check that the interpolations are giving the correct numbers. Cloning and compiling KORC To obtain the latest version of KORC you will need to clone the Github repository to the system where you want to run KORC.\nThis can be done as follows: Make sure you have all the needed external libraries and compilers in place. Using the terminal of your system, cd to the directory where you want to save KORC. Type the following in the terminal \"git https://github.com/ORNL-Fusion/KORC.git\" . This will copy all the KORC files\nfrom the Github repository to your local system. cd to the KORC-FO folder. In the terminal type: \"./compile.sh GNU\" if you are using GNU compilers, or \"./compile.sh INTEL\" if you are\nusing INTEL compilers. Running KORC","tags":"","loc":"page/./Leo_Doc.html"}]}